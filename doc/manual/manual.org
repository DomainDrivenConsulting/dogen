#+title: Domain Driven Development with Dogen
#+options: author:nil

Copyright (c) 2012, 2013 Marco Craveiro

Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, version 1.3; with no Invariant
Sections, no Front-Cover Texts and no Back-Cover Texts.

Revision *DRAFT*, May 2013

This revision of the manual describes Dogen *master* and is available
in the following formats: HTML and PDF.

#+toc: headlines 2
#+toc: listings
#+toc: tables

* Preface

** About This Document

This document is the official manual for Dogen. Dogen - the domain
generator - is a code generation tool designed specifically to target
domain models. Dogen was created to make the modeling process simpler:
the user creates a domain model using a UML tool and Dogen uses it to
generate its source code representation. The generated code contains
most of the services required from a typical C++ domain object such as
serialisation, hashing, streaming and so on.

** More Information

You can find the latest source code for Dogen at the official
repository in GitHub:

- https://github.com/kitanda/dogen

There is also a mirror in BitBucket:

- FIXME

* PART I - BASIC CONCEPTS

** Introduction

Dogen is the union of two core ideas:

- Code generation
- Domain Driven Design

We'll introduce each in turn, and then explain why we decided to marry
the two. But before we get into the details, a word on models in
general.

*** Models

FIXME: do we need a section on what models are?

Programming is a refined art of abstraction. In general, the
programmer's job is to create a set of abstractions that represent
entities in some problem domain or other; and to get those entities to
cooperate successfully in producing work that is defined as useful by
someone. These entities put together form a model.

*** Code generation and meta-models

The concept of programs that generate programs is probably as old as
computer science itself: it certainly was a common feature in the days
of machine code and assembler code programming. These ideas were
incorporated in early languages such as LISP, where there was a
blurring of the lines between hand crafted source code and machine
generated source code. Sadly, these progressive thoughts faded into
the foreground as the C family of languages took front stage.

It's not as if code generation disappeared - it just went into
hiding. In fact, there are many widely used tools in the Open Source
ecosystem that generate code: FIXME: add links

- Google Protocol Buffers
- ODB
- eXSD tool
- COM IDL compiler
- ...

These tools are designed to do a specific task and to do it well,
hiding as much as possible of the code generation details from the end
user. We call these are special-purpose code generators - although, as
we shall see, in a sense /all/ code generators are special
purpose. The code generated by these tools contains both the data
structures they require as well as hard-coded behaviour associated
with them: how to read and write them from raw storage (in the case of
Protocol Buffers), how to read and write them from the database (ODB),
and so on.

All code generators have an internal set of data structures that
represent the entities to generate - explicitly or implicitly. These
data structures are known as the /meta-model/. Meta-models are a class
of models that focus on describing models themselves. They allow code
to introspect and to think about code; to reflect. In this form, code
generation is simply the transformation of a model, described in one
such representation, into another representation - source code -
following the rules laid out by the grammar of a programming
language. The more complete the meta-model, the more expressive the
generated code can be - and vice-versa. It is in this light that we
call certain classes of code generators /special purpose/, because
they have meta-models that are very focused, designed only for the
task at hand.

However, meta-models can be useful in a more general form when
designing software applications. One of the most common meta-models in
existence is UML. UML is used widely in the industry and there are
many tools that can be used to generate source code from UML
diagrams. UML is simultaneously ubiquitous - that is, available
everywhere - and complete - that is, as a meta-model it defines a
extensive list of concepts for pretty much any aspect of
programming. Thus it is common for tools to take a UML representation
and use it to generate source code.


 At present there are a few Open Source tools that can
generate source code from a UML diagram:

FIXME: add links

- dia2code
- Umbrello (FIXME: does it code generate?)

In a sense one may think of these as general purpose code generators
because they output code that is not tied up with a specific
purpose. However, what has been lost is the addition of any behaviour
associated with the code; it is rather difficult to /model/ behaviour,
short of writing the code itself. So we prefer to think of these code
generators as special-purpose: their aim in life is to generate a
source code representation of a data model - e.g. sans behaviour.

The astute reader would have already devised a simple solution to the
behaviour conundrum: nothing stops us from modeling the signatures of
methods in the meta-model - after all UML provides us with all the
required machinery - and then hand-craft and implementation for these
methods. Indeed there are code generators which permit such workflows;
they are known as /merging code generators/. The merging aspect comes
from the fact that the code generator must be able to distinguish
between the hand-crafted code and the machine generated code in order
to handle meta-model updates. Say you've renamed an attribute of a
class in your UML diagram; the last thing you need is for all the
hand-crafted methods to disappear or for

the code generator does not delete all of
the hand-crafted code, but at the same time, it does not leave
remnants of code that was previously machine generated

*** Domain Driven Design

One of the main problems facing software engineers working on large
systems is the need to clearly separate business rules from
scaffolding code. In many ways, this need originates from the long
forgotten days when the word /Application/ was coined: the use of
computer science /applied/ to a specific problem to provide an
automated solution to the set of people with the problem - the
/users/. During the process of development, users will provide all
sorts of insights into what it is they want solved, and these are
ultimately captured in code. Code will also be made up of reading and
writing records to a database, socket communication, reading and
writing to file and so on; the challenge then is to avoid obscuring
the former while dealing with the latter.

Many people have thought deeply about this dichotomy. Arguably, the
most significant advance was made by Eric Evans with his seminal book
"Domain-Driven Design: Tackling Complexity in the Heart of
Software". Domain Driven Design (DDD) is a software engineering
methodology that places great emphasis on understanding the /problem
domain/, and coupled with Agile it provides a great platform for
iterative improvements both to the understanding and to its expression
in code. DDD places great emphasis in defining a clear and concise
domain model - a set of classes and relationships that model the
insights provided by the users and domain experts in general. It also
explains the difference between the conceptual domain model and myriad
of representations: UML diagrams, specification documents, oral
conversations and, most importantly, source code.

*** Adding the two together
** Hello World Example

* PART II - ADVANCED CONCEPTS
