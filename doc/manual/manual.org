#+title: Domain Driven Development with Dogen
#+options: author:nil

Copyright (c) 2013 Marco Craveiro

Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, version 1.3; with no Invariant
Sections, no Front-Cover Texts and no Back-Cover Texts.

Revision *DRAFT*, May 2013

This revision of the manual describes Dogen *TRUNK* and is available
in the following formats: HTML and PDF.

#+toc: headlines 2
#+toc: listings
#+toc: tables

* Preface

** About This Document

This document is the official manual for Dogen. Dogen - the domain
generator - is a code generation tool designed specifically to target
domain models. Dogen was created to make the modeling process simpler:
the user creates a domain model using a UML tool and Dogen uses it to
generate its source code representation. The generated code contains
most of the services required from a typical C++ domain object such as
serialisation, hashing, streaming and so on.

** More Information

You can find the latest source code for Dogen at the official
repository in GitHub:

- https://github.com/kitanda/dogen

There is also a mirror in BitBucket:

- FIXME

* PART I - BASIC CONCEPTS

** Introduction

Dogen is the union of two core ideas:

- Code generation
- Domain Driven Design

We'll introduce each in turn, and then explain why we decided to marry
the two.

*** Code generation

The creation of programs that generate programs is probably as old as
computer science itself. These ideas where even incorporated in some
languages such as LISP, where there was a blurring of the lines
between hand crafted source code and machine generated source
code. Sadly, these progressive thoughts faded into the foreground as
the C family of languages took front stage. Code generation became the
mainstay in some domains such parsing, but a lot of power and
intelligence was lost.

In its more LISP-like form, code generation is intimately linking with
meta-modeling. Meta-models are a class of domain models that focus on
describing /domain models/ themselves. They allow code to introspect
and to think about code; to reflect. Code generation in this sense can
simply be thought of as the translation of one such representation
into a text file, following the rules laid out by the grammar of a
programming language. The more complete the meta-model, the more
expressive the generated code can be - and vice-versa.

*** Domain Driven Design

One of the main problems facing software engineers working on large
systems is the need to clearly separate business rules from
scaffolding code. In many ways, this need originates from the long
forgotten days when the word /Application/ was coined: the use of
computer science /applied/ to a specific problem to provide an
automated solution to the set of people with the problem - the
/users/. During the process of development, users will provide all
sorts of insights into what it is they want solved, and these are
ultimately captured in code. Code will also be made up of reading and
writing records to a database, socket communication, reading and
writing to file and so on; the challenge then is to avoid obscuring
the former while dealing with the latter.

Many people have thought deeply about this dichotomy. Arguably, the
most significant advance was made by Eric Evans with his seminal book
"Domain-Driven Design: Tackling Complexity in the Heart of
Software". Domain Driven Design (DDD) is a software engineering
methodology that places great emphasis on understanding the /problem
domain/, and coupled with Agile it provides a great platform for
iterative improvements both to the understanding and to its expression
in code. DDD places great emphasis in defining a clear and concise
domain model - a set of classes and relationships that model the
insights provided by the users and domain experts in general. It also
explains the difference between the conceptual domain model and myriad
of representations: UML diagrams, specification documents, oral
conversations and, most importantly, source code.

*** Adding the two together

One of the most common meta-models in existence is UML. It is used
widely in the industry and there are many tools that can be used to
generate source code from UML diagrams. UML is simultaneously
ubiquitous - that is, available everywhere - and complete - that is,
as a meta-model it defines a extensive list of concepts for pretty
much any aspect of programming. However, after sped


** Hello World Example

* PART II - ADVANCED CONCEPTS
