#+title: Backlog
#+options: date:nil toc:nil author:nil num:nil
#+tags: story(s) epic(e) task(t) note(n) spike(p)

* Backlog

This file contains all stories that haven't been assigned to a sprint.

** Development Stories

Stories that we intend to look at, at some point.

*** Unordered map of user type in package fails

We seem to have a strange bug whereby creating a
=std::unordered_map<E1,E2>= fails sanity checks if E1 is in a
package. This appears to be some misunderstanding in namespacing
rules.

*** Architecture refactoring                                           :epic:

Each of these tasks is really a story, but we need to make sure the
entire architecture hangs together before we start refactoring; this
is the purpose of this story. Some of the stories here already have
been captured in the backlog.

- create "modes" of operation: relational, object-oriented and
  procedural. they limit the types available in SML. relational only
  allows primitives plus relational commands (FK and PK; FK is when
  using a model type, PK is a marker on a property). procedural only
  allows primitives plus model types. we will need pointer support for
  this. object oriented is the current mode. the modes are validated
  in the middle end.
- create a backend project that defines the back end interface and
  provides a factory that takes an enum (c, c++, COM, etc) and returns
  a backend. it also provides a mock backend.
- split c++ backend from generator into backend. make it
  implement the backend interface. fix all the naming issues. we need
  to rename this backend as c-like or something of the kind because it
  can be extended to generate C, COM, GObject, etc.
- remove the cpp prefix on c++ files.
- create model wrappers for std and primitives includes
- make the c++ view model a dogen model.
- implement formatters as part of the view model. leave them as
  formatters, not as IO, so we can still IO the view model.
- formatters are now c++ formatters.
- create interfaces for the location and inclusion managers.
- create a dogen model settings at top level, shared by all the dogen
  components (driver, backend, etc).
- create a front end component that defines the front end inteface,
  has a factory that returns a front end based on an enum.
- create the dia front end which contains the dia to SML code from
  modeling.
- create a middle-end component with the rest of the code in
  modeling. create a factory based on an enum that returns the middle
  end instance. create a mock.
- middle end component will eventually be responsible for the
  intermediate model.
- generator is now a shell that interconnects front, middle and back
  end based on configuration options.
- code generate dia model
- code generate SML model
- use inheritance in SML model
- refactor middle end to take advantage of inheritance

*** System models set meta-type to invalid

Something is not quite right on the resolution logic

*** Adding new modeling spec tests is hard

In order to test models at the modeling level one needs to first
generate the dia input. This can be done as follows:

: ./dogen_driver-0.0.507 --save-dia-model xml
: --stop-after-merging -t ../../../../dogen/test_data/dia_sml/input/boost_model.dia

From the bin directory. We need to make these steps a bit more obvious.

*** Naming of saved SML/Dia files is incorrect

For some random reason when we use dogen to save SML/Dia files the
names look like this:

: test_data/dia_sml/expected/boost_model.xmldia
: test_data/dia_sml/expected/std_model.xmldia

but our tests expect:

: test_data/dia_sml/expected/boost_model.diaxml
: test_data/dia_sml/expected/std_model.diaxml

This must be part of a refactoring that wasn't completed properly.

*** Move system model factories into SML

We do not have any generator dependencies in the system model
factories so they can safely be moved into SML.

*** Reduce size of doxygen packages

We need to investigate our doxygen configuration to figure out why our
doxygen packages are so large - weighing at 350MB at the moment, they
are too large to be uploaded to github. We need to find other
project's doxygen configuration to figure out what we are doing wrong.

The main problem must be related to PNG generation.

*** Consider renaming specs to tests

We started using the terminology specs to mean specifications because
our unit tests follow the ideas outlined by Kevlin Henney. However, we
could easily use tests and still carry most of the meaning without
confusing every other developer. This would require:

- rename top-level =spec= folder to =tests=
- rename targets to =_tests=, e.g. =run_sml_tests=
- rename all test suites to =_tests=
- update the automatic detection of boost tests to use the new
  post-fix.
- we should also use =_tests= on the test suite name so we can do
  =using XYZ= without name clashes.

*** Support for components and groups

We recently added support for creating multiple packages from a single
source tree. We need generated models to have a new top-level cmake file:

#+begin_example
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/src)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/spec)

install(
    DIRECTORY include/
    DESTINATION include
    COMPONENT headers
    FILES_MATCHING PATTERN "*.hpp")
#+end_example

And the =src= cmake file:

#+begin_example
install(TARGETS dia ARCHIVE DESTINATION lib COMPONENT libraries)
#+end_example

*** Option to diff generated code

It would be useful to have an option that would do everything except
writing the files to disk; instead, it would diff them with the
existing files and report if there are any differences. This would be
useful to make sure the source code matches the latest version of the
diagram.

*** Option to validate diagram

It would be nice if one could just check if a dia diagram is valid for
code generation, e.g. =--validate= or something along those lines.

*** Shared pointers to primitive types

At present we do not support shared pointers to primitive types. This
is because they require special handling in serialisation. See:

http://boost.2283326.n4.nabble.com/Serialization-of-boost-shared-ptr-lt-int-gt-td2554242.html

We probably need to iterate through all the nested types and find out
if there is a shared pointer to primitive; if there is, put in:

#+begin_example
// defined a "special kind of integer"
BOOST_STRONG_TYPEDEF(int, tracked_int)

// define serialization for a tracked int
template<class Archive>
void serialize(Archive &ar, tracked_int & ti, const unsigned int version){
    // serialize the underlying int
    ar & static_cast<int &>(ti);
}
#+end_example

*** Create helpers for primitive and std model

We are using literals and ad-hoc constants to describe types from the
special models (boost, std and primitives). The boost model has been
factored out into a boost_model_helper, we need to do the same with
the others and go across the code base and remove all these direct
references.

*** Add PFH libraries to packages

At present our packages on windows and OSX don't run because we are
missing all of the boost, etc dependencies which are not present on
the OS. On linux is luck of the draw, it may or may nor run. We should
just add the dependencies to our packages.

We can do this by simply reading the =PFH_LOCATION= from the
environment and then doing an =install= command with files pointing to
the PFH.

http://www.cmake.org/pipermail/cmake/2009-July/030770.html

For windows we need (according to dependency walker):

- LIBBOOST_PROGRAM_OPTIONS-MGW47-MT-1_49.DLL
- LIBBOOST_FILESYSTEM-MGW47-MT-1_49.DLL
- LIBBOOST_THREAD-MGW47-MT-1_49.DLL
- LIBBOOST_SERIALIZATION-MGW47-MT-1_49.DLL
- LIBBOOST_SYSTEM-MGW47-MT-1_49.DLL
- e:\gtkmm\bin\LIBXML2-2.DLL
- LIBGCC_S_DW2-1.DLL
- LIBSTDC++-6.DLL

*** Full constructor parameter comments

We could use the comments in properties to populate the comments for
the full constructor for each parameter. This would require taking the
first line of the documentation of each property and then stitching
them together for the full constructor.

*** Serialisation support for C++-11 specific containers

We can't add =std::array= or =std::forward_list= because there is no
serialisation support in boost 1.49. A mail was sent to the list to
see if this has changed in latter versions:

http://lists.boost.org/boost-users/2012/11/76458.php

*** Support for ordered containers

In order to provide support for ordered containers such as maps and
sets we need to define =operator<=. However, it makes no sense to code
generate this operator as its unlikely we'll get it right. We could
assume the user wants to always sort by key, but that seems like a bad
assumption. The alternatives are:

- to expect a user-defined =entity_name_less_than.hpp= in domain. we'd
  automatically ignore any files matching this patter so the user can
  create them and not lose it. The problem with this approach is that
  we may have different sort criteria. This is a good YAGNI start.
- to provide the =Compare= parameter in the template and then expect a
  user-defined =entity_name_Compare.hpp=. The same ignore
  applies. This would allow users to provide any number of comparison
  operations.

Either approach requires [[Ignore%20files%20and%20folders%20based%20on%20regex][Ignore files and folders based on regex]].

*** Rename =cpp_inserter_implementation=

We used =cpp_inserter_implementation= to provide all sorts of utility
methods for IO. This class should really be named IO utility or
something of the sort.

*** JSON =__type__= should be fully qualified

At present the JSON =__type__= is only the class name. It should
really be fully qualified.

*** Add support for _manual_ types

Sometimes one requires data structures which are just too complicated
for code generation, such as =boost::multi_index=. In this cases one
should add these domain types manually, together with their
serialisation, etc. However, if one then wants to make use of these
types from trivial types, the code generator will fail to resolve. We
need a stereotype of _manual_ (or some such name) which allows the
type to be declared to the type system but no further processing
(including generation) will occur.

*** Add support for boost variant

In order to be able to code generate the dia model we need support for
boost variant. One possible implementation:

- create a new stereotype: variant. works very much like enumeration,
  except attributes in class are a list of types
- create a formatter etc for variants
- add support for default variant visitor. this could be fairly
  generic so we could also use it as part of the visitor patter for
  class hierarchies

*** Throw if user supplies type arguments

We don't support generic types (see [[Supporting%20user%20defined%20generic%20types][Supporting user defined generic
types]]) so we should throw if a user attempts to use them.

*** Consider adding a fluent option

It would be fairly trivial to allow generation of model types with
setters that are fluent (e.g. return =this=).

See: http://en.wikipedia.org/wiki/Fluent_interface

This could also be a stereotype so that a model could have both fluent
and non-fluent classes.

*** Formatters are actually just view model IO

In reality, the formatters are nothing but glorified inserters. When
we start generating the view model, we should not generate the
traditional =io= and re-implement the formatters as inserters so that
one can simply take a file view model and stream it and it should
result in a compilable file. The end result will be a domain model
with:

- domain: code generated view model
- io: formatters refactored as inserters
- utility: view model transformer

*** Cross model referencing tests

At present we do not have any tests were a pod in one model makes use
of types defined in another model.

After some experimentation by JS we found out that this is not going
to work for non-trivial cases. This is because we do not have model
dependency management. We need to create a dag of dependencies between
models in the merger to ensure we process the models in the correct
order. When we initially read up a model it could declare what models
it depends on, this is then used to build the DAG.

*** Typedef keys for each type

We should really have different names for each key. Ideally even
different types, if its easy. We need to consult modern c++ for
this. If its not possible for each key to be a different type, we
should at least provide a typedef on each class.

*** Cross package referencing tests

Scenarios:

- object in root refers to object in package: A => pkg1::B;
- object in root refers to object in package inside of package: A =>
  pkg1::pkg2::B;
- object inside of package refers to object inside of the same
  package: pkg1::A => pkg1::B (must be qualified);
- object in package refers to root object: pkg1::A => B;
- object in package refers to object in other package: pkg1::A =>
  pkg2::B;
- object in package refers to object in package in package: pkg1::A =>
  pkg1::pkg2::B;
- object in package refers to object in other package in package: pkg1::A =>
  pkg2::pkg3::B;
- object in package in package refers to object in package in package:
  pkg1::pkg2::A => pkg3::pkg4::B.

*** Empty directories should be deleted

When housekeeper finishes deleting all extra files, it should check
all of the processed directories to see if they are empty. If they
are, it should delete the directory.

*** Header only models shall not generate projects

A project with just exceptions does not need a make file, and fails to
compile if a makefile is generated. We need a way to not generate a
makefile if there are no implementation files generated.

*** Empty features should not show up

If there are no files for a feature, we should not generate includers
and folders for that feature.

*** Test relationships between pods and other meta types

We should validate that pods are only related to other pods -
e.g. they cannot inherit from exception or enumeration or
vice-versa. Add tests for this.

*** Add support for configurable enumerations types

At present our enumerations always use unsigned int as the underlying
type. It should be possible to override that from dia.

*** Create interfaces to help with mocking

We should be doing a bit more IoC, particularly with inclusion
manager, location manager etc. In order to do so we could define
interfaces for these classes and provide mocks for the tests. This
would make the tests considerably smaller.

*** Add test model with versioning disabled

We don't seem to have a test model for the versioning disabled
scenario.

*** Add test for disabling XML

At present we are not testing model generation with XML disabled.

*** IO header could depend on domain forward decl

At present we are depending on the domain header but it seems we could
depend only on the forward declarations.

*** Format doubles, floats and bools properly

At present we are using IO state savers but not actually setting the
formatting on the stream depending on the primitive type.

*** Add support for protected attributes

We need to distinguish between public and protected attributes when in
the presence of inheritance. If not, issue a warning.

*** Add tests for invalid types

- type name is blank (or variable name)
- type name does not exist on any model

*** Add tests for disconnected connections

We should throw if a diagram has a disconnected inheritance or
composition relationship.

*** Add tests for duplicate identifiers in Dia

Detect if a diagram defines the same class or package multiple
times. Should throw an exception.

*** Create a class with file information

In C++ backend we use four parameters that get passed all over the
place: facet, aspect, file type and category. We should:

- rename file type to file kind (interface, implementation)
- create a class containing the four bits of information called file
  type
- replace all the API calls with file type
- change the view model to take a file type

The class could be called =context= or something of the like.

*** Remove manager post-fix

We should rename location manager to locator and inclusion manager to
includer. The word manager does not add any more meaning to their
responsibilities. We need to find a clearer word to describe what we
call includer at the moment; a header that includes a set of other
headers - for example all headers for facet X or all headers for
domain model Y. Header aggregator, etc.

*** Test model sanity checks fail for enable facet serialisation

For some reason we are unable to compile the serialisation test for
the test model which focuses only on the serialisation facet. Test is
ignored for the moment.

*** Handle unnamed models properly

The option disable model name was meant to allow the generation of
flat models, without any folders or namespaces for the model
name. However, as a side-effect, this also means the artefacts being
generated do not have any names. This resulted in the creation of a
libSTATIC, purely because the next command in the cmake add_library is
STATIC (e.g. static library). As a quick hack, when an empty model
name is detected, a model named "unnamed_model" is created.

The correct solution for this is to have a flag (or flags) at the SML
level which state whether to use the model name for folders, packages,
etc. The view model generation will then take this into account.

*** Update prototype model to reflect latest database API              :epic:
**** Add versioned and unversioned key to prototype model             :story:
**** Refactor setup of SQL from load/erase methods                    :story:
**** Create new range based SQL methods                               :story:
**** Remove transaction setup from exchanger                          :story:
**** Modify tables and stored procedures to match the new API structure :story:
**** Modify test data generator and test procs to match the new API structure :story:
**** Deploy new SQL on all environments                               :story:
***** Newton                                                            :task:
***** Pascal                                                            :task:
***** iMac                                                              :task:
***** Lorenz                                                            :task:
***** Euler                                                             :task:
***** Ronin                                                             :task:
***** Oppenheimer                                                       :task:
***** Erdos                                                             :task:
*** Update C++ code generator to latest database API                  :story:
**** Update data exchanger header                                      :task:
**** Update data exchanger implementation                              :task:
*** Use explicit casting for versioned to unversioned conversions     :story:

At present we have to_versioned; in reality this would be dealt much
better using explicit casts:

#+begin_example
explicit operator std::string() { return "explicit"; }
#+end_example

*** Add SQL support to Dogen                                           :epic:
**** Note on formatters                                                :note:

- Use an attribute with the type to determine if we want only the ID of
  the foreign key in C++ code or if we want a whole type.

Formatters:

- File names are: FQN_ENTITY, e.g. kitanda_prototype_currency_table
- create: table, load, save, erase, test data generators, test
- drop: table, load, save, erase, test data generators, test
- domains
- create schema formatter
- create all tables
- create all procs
- drop all tables
- drop all procs
- drop all
- create all

**** Create SQL backend                                               :story:
***** Create new backend                                               :task:
***** Create new location manager                                      :task:
***** Create aspect and facet types                                    :task:
***** Create a view model for table and stored procedure               :task:
***** Create a transformer from SML to view model                      :task:
***** Add SQL command line options                                     :task:
**** Add table support                                                :story:
***** Create table formatter                                           :task:
***** Drop table formatter                                             :task:
***** Test formatters                                                  :task:

**** Add load support                                                 :story:
***** Create load formatter                                            :task:
***** Drop load formatter                                              :task:
***** Test formatters                                                  :task:

**** Add save support                                                 :story:
***** Create save formatter                                            :task:
***** Drop save formatter                                              :task:
***** Test formatters                                                  :task:

**** Add delete support                                               :story:
***** Create delete formatter                                          :task:
***** Drop delete formatter                                            :task:
***** Test formatters                                                  :task:

**** Add test support                                                 :story:
***** Create test formatter                                            :task:
***** Drop test formatter                                              :task:
***** Test formatters                                                  :task:

**** Analyse deployment support on CMake                              :story:

Ideally, get a state of affairs that resebles something like this:

- make deploy_database
- make undeploy_database

***** Review and fix existing targets                                  :task:

- Rename all =currency= targets to =prototype= targets
- Ensure the targets have correct dependencies

***** Add support for multiple databases                               :task:

*** Add database tests for generated code                             :story:
*** Missing =enable_facet_XYZ= tests                                  :story:

- database
- test data

*** Log should use path for file names                                :story:

At present we are passing the log file name as a string and
concatenating using "/". This is not very good for Windows. We should
use =boost::filesystem::path= throughout and do a =.string= at the
very end if boost log does not support boost filesystem (or use the
path directly if it does).

*** Before throwing write exception to log file                       :story:

We have cases were an exception is thrown and its impossible to figure
out where. If we logged before throw we'd have all the context.

*** Investigate generation of setters using const ref                 :story:

It seems its possible to overload setters with both by value and by
const ref. We need to figure out how this works.

http://www.codesynthesis.com/~boris/blog/2012/06/19/efficient-argument-passing-cxx11-part1/

***** Update class template                                            :task:
***** Update tests                                                     :task:

*** Create model with invalid primitive type                          :story:

At present we are validating that all primitive types work but we
don't check that an invalid type doesn't work.

*** Private properties should be ignored                              :story:

At present we treat private properties as if they were public; we
should ignore them. We need to go through all the models and change
the private ones to public before we do this.

*** Sanity check packages automatically

This work is also covered by tasks in the PFH backlog so update
accordingly. This task only refers to the dogen specific parts of the
task.

- sanity check that package installed correctly, e.g. check for a few
  key files.
- run sanity tests, e.g. create a dogen model and validate the results
- run uninstaller and sanity check that files are gone
  - this should actually be a build agent so we can see that deployment
    is green. We should create a deployment CMake script that does this.
- build package and drop them on a well known location;
- Create a batch script that polls this location for new packages;
  when one is found run package installer.
- we should create a set of VMs that are specific for testing - the
  test environments. One per OS. These are clean builds with nothing
  on them. To start off with they may contain postgres so we can
  connect locally.

*** Check if we've replaced =assert_object= with =assert_file=        :story:

Assert file is now able to do intelligent comparisons based on the
extension of the file. From a cursory look, all the usages we have of
assert object can be replaced by assert file. If that's the case we
can also remove this function.

*** Exception classes should allow inheritance

We need to have a form of inheriting from a base exception for a given
model. We also need to be able to inherit from other exceptions in a
model. At present exceptions are not pods so the dependency graph
support is not there.

*** Investigate GDB visualisers for generated models

It would be great if the code generator created GDB visualisers for
the types in a generated models such that one could inspect values of
STL containers with types of that model.

- [[http://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html][Pretty printing]]
- [[https://github.com/ruediger/Boost-Pretty-Printer][Boost pretty printer]]
- [[https://groups.google.com/group/boost-list/browse_thread/thread/ff232ac626bf41cf/18fbf516ceb091da?pli%3D1][Example for multi-index]]

*** Replace manual exception checks with =BOOST_CHECK_EXCEPTION=

In the past we were testing for exceptions by doing a try and catch:

#+begin_example
    try {
        std::generate_n(std::back_inserter(terms), beyond_end, sequence);
        BOOST_FAIL("Expected sequence_exhausted exception to be thrown.");
    } catch (const kitanda::utility::test_data::sequence_exhausted& e) {
        BOOST_TEST_MESSAGE("Exception thrown as expected: " << e.what());
        BOOST_CHECK(true);
    }
#+end_example

We have now found out about =BOOST_CHECK_EXCEPTION=, so we should
replace the manual checks on all specs that have them. Example usage:

#+begin_example
    BOOST_CHECK_EXCEPTION(
        reader.get_attribute_as_string(label_non_existent_attribute),
        exception,
        std::bind(check_exception, _1, message_error_get_attribute)
        );
#+end_example

*** Licence year is hard-coded to 2012

At present the licence formatter has an hard-coded year of 2012. It
should really be a parameter passed in.

*** Add multiple database support to makefiles

Our makefiles don't cope very well with the test/development database
separation. There is a massive hack required to populate both
databases (changing makefile manually and then reverting the change).

There should be a way of passing in the database name as an
environment variable into the makefile (not into the cmake as we want
to be able to change databases without having to rebuild makefiles).

*** Organise the valgrind suppressions a bit better

In Sprint 9 we fixed a whole bunch of strange valgrind memory leak
warnings that were coming from the guts of boost threading and boost
log. We did it by using the generate suppression from valgrind. We
should be able to summarise all of those suppressions to only one or
two (there are some twenty at the moment). We also need to
double-check with boost if these are real problems.

*** Generator usage in template tests needs to be cleaned

At present some template tests in =utility/test= ask for a
generator, other for instances. We should only have one way of doing
this. We should probably always ask for generators as this means less
boiler plate code in tests. It does mean a fixed dependency on
generators.

*** Replace old style for iterations in IO

At present we are still doing C++-03 iterations in the STL IO files
such as =vector_io=, =list_io=, etc. We should be using the new =for=
syntax for C++-11.

*** Dogen should generate stand alone CMake                           :story:

There should be an option to generate a stand alone =CMakeLists.txt= -
the domain should compile in total isolation from kitanda. This is
useful for demos, etc.

*** Rename qualified_name to qname                                    :story:

QName is well known. It also allows for better method names such as
=type_qname= instead of =type_name= where its not obvious that its a
qualified name rather than a string.

This task is waiting for SML to be code generated.

*** Using boost macro to throw exception

There were some advantages to using =BOOST_THROW_EXCEPTION=, can't quite
remember why. We need to figure out if we should replace our usages of
=throw= with this macro.

*** Rename pod in SML

We mistakingly called complex types =pod= because of a lack of
understanding of what a C++ pod type is. They should really be called
=complex_type=. This would be a good time to clean up the inheritance
tree:

- type: parent; has a name
- simple_type: primitives; child of type.
- complex_type: pods; child of type.
- enumeration: child of type.
- ...

This story is waiting for SML to be code generated.

*** Add an includer for all includers

It would be nice to totally include a model. For that we need an
includer that includes all other includers.

*** Add new equivalence operator to domain types

We should have an operator that compares the state of two objects
ignoring the version.

*** Property types are always fully qualified

When we code generate non-primitive properties we always fully qualify
them even if they are on the same namespace as the containing type.

*** Support "cross-facet interference"

In a few cases its useful to disable bits of a facet when another
facet is switched off because those bits do not belong to the main
facet the formatter is working on. At present this happens in the
following cases:

- Forward declaration of serialisation in domain when serialisation is
  off
- Friend of serialisation in domain when serialisation is
  off
- declaration and implementation of to_stream when IO is off
- declaration and implementation of inserter when IO is off and
  integrated IO is on.

We need a way of accessing the on/off state of all facets from any
formatter so that they can make cross facet decisions. A quick hack
was to add yet another flag: =disable_io= which is disabled when the
IO facet is not present and passed on to the relevant formatters. This
needs to be replaced by a more general approach.

*** Add run spec targets for each test

We could piggy back on the ctest functionality and add a target for
each test so one could =make enable_facet_domain= and =make
run_enable_facet_domain=. The targets need to be prefixed with module
name and test suite.

*** Clean up WinSock definition in CMakeLists

We did a crud implementation of finding WinSock just to get windows to
build. There should be a FindWinSock somewhere. If not create one.

*** Modeling director does not support all archive types

At present the modeling director always outputs in XML. it should
respect the archive type requested by the user.

*** Test database deployment

We need to setup a build that deploys all the SQL (tables, procs, etc)
to a clean database, runs all SQL tests and un-deploys all the SQL.

*** Setup a postgres url in cmake file                                :story:

The database password is set to trust. We should really have user
passwords. To make things more secure we should also pass in the
database credentials to the unit tests. One potential approach is to
do so in cmake. Example from VTK:

#+begin_src cmake
IF ( BUILD_TESTING )
   SET ( VTK_PSQL_TEST_URL "" CACHE STRING "A URL for a PostgreSQL server
         of the form psql://[[username[:password]@]hostname[:port]]/[dbname]" )
ENDIF ( BUILD_TESTING )
#+end_src

Suggestion: maybe there's a possibility of using an environment
variable for all the used parameters (username, hostname, etc)

*** Add unit test benchmarking

[[https://svn.boost.org/trac/boost/ticket/7082][Raised ticket]]

- nightly builds should run all unit tests in "benchmarking mode";
- for each test we should find the sweet spot for N repetitions;
- when plugged into ctest, make sure the benchmark tests have
  different names from the main tests otherwise the timing history
  will be nonsense.
- [[http://lists.boost.org/boost-users/2011/01/65790.php][sent]] email to boost users mailing list asking for benchmarking
  support.

** Won't fix

Stories which we do not think we are going to work on.

*** Tests for error conditions in libxml

We do not have any errors that check for error conditions directly in
libxml. This is why the coverage of these functions is red.

*** Check that custom targets in CMake have correct dependencies

At present we have a number of custom targets, which create a new Make
target. These are good because they do not require re-running CMake to
manage the files in the output directory; however, we do not have the
correct dependencies between the targets and the target
dependencies. For example, create_scripts should check to see if any
script has changed before re-generating the tarball; it seems to have
no dependencies so it will always regenerate the tarball. We need to:

- check all custom targets and see what their current behaviour is:
  a) change a dependency and rebuild the target and see if the
  change is picked up or not; b) change no dependencies and re-run the
  target and ensure that nothing happens.
- add dependencies as required.

*** Enable doxygen warnings for all undocumented code

At present doxygen only warns about undocumented parameters when a
function already has documented parameters. We should consider
enabling warnings for all undocumented code. We also need to figure
out how to mark code as ignored (for example serialisation helpers,
etc won't require documentation).

*** Add specification comments to tests

We started off by adding a technical specification as a doxygen
comment for a test but forgot to keep on doing it. Example:

#+begin_example
/**
 * @brief It shall not be possible to create more terms than those
 * supported by a finite sequence, using std::generate_n.
 */
#+end_example

This helps make the purpose of the test clearer when the name is not
sufficient.
*** Supporting user defined generic types

At present we have a bit of a hack to support templates. However, all
that is required to allow users to create their own template types is:

- parse dia information for type arguments
- change pod to have type arguments
- change merger to allow variables of the type of the type argument
- change view model to propagate type arguments
- change formatter to create template class if type arguments are
  present

However this would then mean that IO and serialisation would fail
since they are implemented on the cpp. As there is no need for
template types, this seems like an ok limitation.
*** Shared pointers as keys in associative containers

This is not supported; it would require generating the
hashing/comparison infrastructure for shared pointers. Further, as it
has been pointed out, keys should be immutable; having pointers as
keys opens the doors to all sorts of problems. We need to throw an
error at model building time if an user tries to do this.
*** Package names should follow a well-known convention

We need to make sure our package names are consistent with the
platform conventions.

- [[http://pastebin.com/TR17TUy9][Example of platform IFs]]
- [[http://libdivsufsort.googlecode.com/svn-history/r6/trunk/CMakeModules/ProjectCPack.cmake][Example CPack]]
- [[http://cmake.3232098.n2.nabble.com/Automatically-add-a-revision-number-to-the-CPack-installer-name-td7356239.htmlhttp://cmake.3232098.n2.nabble.com/Automatically-add-a-revision-number-to-the-CPack-installer-name-td7356239.html][Automatically add a revision number to the CPack installer name]]
- [[http://www.cmake.org/Wiki/CMake:CPackConfiguration][CPack Configuration]]

There are some known limitations in package naming:

- http://public.kitware.com/Bug/view.php?id=12997
