#+title: Scratch Pad
#+options: date:nil toc:nil author:nil num:nil

This document contains snippets of code that we want to preserve, most
likely to avoid having to trek down git history to find it.

** Root enricher
*** Header

#+begin_src c++
namespace dogen {
namespace formatters {
namespace meta_data {

/**
 * @brief Responsible for enriching the meta-data with the core
 * formatter tags.
 */
class root_enricher : public sml::meta_data::enricher_interface {
private:
    /**
     * @brief Returns true if its the first stage enrichment, false
     * otherwise.
     */
    bool is_first_stage_enrichment(
        const sml::meta_data::enrichment_types et) const;

    /**
     * @brief Populates all of the traits of the formatter module,
     * setting it to default values - if they do not yet exist.
     */
    void setup_defaults(boost::property_tree::ptree& target) const;

    /**
     * @brief Performs the first stage enrichment in the target, using
     * the parent module.
     */
    void perform_first_stage_enrichment(
        const boost::property_tree::ptree& parent_module,
        boost::property_tree::ptree& target) const;

public:
    virtual std::string id() const override;

    virtual std::list<std::string> dependencies() const override;

    virtual void enrich(const sml::model& model,
        const sml::meta_data::enrichment_types enrichment_type,
        sml::concept& target) override;

    virtual void enrich(const sml::model& model,
        const sml::meta_data::enrichment_types enrichment_type,
        sml::module& target) override;

    virtual void enrich(const sml::model& model,
        const sml::meta_data::enrichment_types enrichment_type,
        sml::type& target) override;
};

} } }

#endif
#+end_src

*** Implementation

#+begin_src c++
#include <boost/throw_exception.hpp>
#include "dogen/utility/log/logger.hpp"
#include "dogen/sml/io/qname_io.hpp"
#include "dogen/sml/types/meta_data/workflow.hpp"
#include "dogen/sml/types/meta_data/read_write_error.hpp"
#include "dogen/sml/types/meta_data/reader.hpp"
#include "dogen/sml/types/meta_data/writer.hpp"
#include "dogen/formatters/types/meta_data/traits.hpp"
#include "dogen/sml/types/meta_data/enrichment_error.hpp"
#include "dogen/formatters/types/meta_data/root_enricher.hpp"

namespace {

std::string root_id("formatters.root_enricher");
std::list<std::string> empty_dependencies;

using namespace dogen::utility::log;
static logger lg(logger_factory(root_id));

const std::string message("This code was generated by Dogen.");
const std::string could_not_find_module("Could not find module: ");
const std::string no_containing_module_supplied(
    "Expected containing module for type: ");

}

namespace dogen {
namespace formatters {
namespace meta_data {

/**
 * @brief Obtains the containing module.
 *
 * @pre Must have a containing module.
 */
template<typename IdentifiableContainable>
sml::module containing_module(const sml::model& m,
    const IdentifiableContainable& ic) {

    if (!ic.containing_module()) {
        const auto sn(ic.name().simple_name());
        BOOST_LOG_SEV(lg, error) << no_containing_module_supplied << sn;
        BOOST_THROW_EXCEPTION(sml::meta_data::enrichment_error(
                no_containing_module_supplied + sn));
    }

    const auto qn(*ic.containing_module());
    const auto i(m.modules().find(qn));
    if (i == m.modules().end()) {
        const auto sn(qn.simple_name());
        BOOST_LOG_SEV(lg, error) << could_not_find_module << sn;
        BOOST_THROW_EXCEPTION(sml::meta_data::enrichment_error(
                could_not_find_module + sn));
    }
    return i->second;
}

bool root_enricher::is_first_stage_enrichment(
    const sml::meta_data::enrichment_types et) const {
    if (et != sml::meta_data::enrichment_types::first_stage) {
        BOOST_LOG_SEV(lg, debug) << "Only first stage enrichment supported.";
        return false;
    }
    return true;
}

void root_enricher::setup_defaults(boost::property_tree::ptree& target) const {
    sml::meta_data::writer writer(target);

    writer.add_if_key_not_found(traits::generate_preamble, traits::bool_true);
    writer.add_if_key_not_found(traits::code_generation_marker::message,
        message);

    writer.add_if_key_not_found(traits::code_generation_marker::add_warning,
        traits::bool_true);

    writer.add_if_key_not_found(traits::code_generation_marker::add_date_time,
        traits::bool_true);
}

void root_enricher::
perform_first_stage_enrichment(
    const boost::property_tree::ptree& containing_module,
    boost::property_tree::ptree& target) const {
    sml::meta_data::writer writer(target);
    sml::meta_data::reader reader(containing_module);

    writer.add_if_key_not_found(traits::generate_preamble,
        reader.get(traits::generate_preamble));

    if (reader.has_key(traits::licence_name)) {
        writer.add_if_key_not_found(traits::licence_name,
            reader.get(traits::licence_name));
    }

    if (reader.has_key(traits::modeline_group_name)) {
        writer.add_if_key_not_found(traits::modeline_group_name,
            reader.get(traits::modeline_group_name));
    }

    if (reader.has_key(traits::code_generation_marker::message)) {
        writer.add_if_key_not_found(
            traits::code_generation_marker::message,
            reader.get(traits::code_generation_marker::message));
    }

    writer.add_if_key_not_found(
        traits::code_generation_marker::add_warning,
        reader.get(traits::code_generation_marker::add_warning));

    writer.add_if_key_not_found(
        traits::code_generation_marker::add_date_time,
        reader.get(traits::code_generation_marker::add_date_time));
}

std::string root_enricher::id() const { return root_id; }

std::list<std::string> root_enricher::dependencies() const {
    return empty_dependencies;
}

void root_enricher::
enrich(const sml::model& model,
    const sml::meta_data::enrichment_types enrichment_type,
    sml::concept& target) {
    BOOST_LOG_SEV(lg, debug) << "Enriching concept: " << target.name();
    if (!is_first_stage_enrichment(enrichment_type))
        return;

    const auto cm(containing_module(model, target));
    perform_first_stage_enrichment(cm.meta_data(), target.meta_data());
}

void root_enricher::
enrich(const sml::model& model,
    const sml::meta_data::enrichment_types enrichment_type,
    sml::module& target) {
    BOOST_LOG_SEV(lg, debug) << "Enriching module: " << target.name();
    if (!is_first_stage_enrichment(enrichment_type))
        return;

    if (!target.containing_module()) {
        const auto sn(target.name().simple_name());
        BOOST_LOG_SEV(lg, debug) << "No containing module supplied for '" << sn
                                 << "'. Setting up defaults instead.";
        setup_defaults(target.meta_data());
        return;
    }

    const auto cm(containing_module(model, target));
    perform_first_stage_enrichment(cm.meta_data(), target.meta_data());
}

void root_enricher::
enrich(const sml::model& model,
    const sml::meta_data::enrichment_types enrichment_type,
    sml::type& target) {
    BOOST_LOG_SEV(lg, debug) << "Enriching type: " << target.name();
    if (!is_first_stage_enrichment(enrichment_type))
        return;

    const auto cm(containing_module(model, target));
    perform_first_stage_enrichment(cm.meta_data(), target.meta_data());
}

} } }
#+end_src

** Graph populator

#+begin_src c++
class graph_populator {
public:
    graph_populator(module_containment_grapher& grapher) : grapher_(grapher) { }

public:
    void operator()(dogen::sml::type& t) const {
        grapher_.add(t.name(), t.containing_module());
    }

    void operator()(dogen::sml::module& m) const {
        grapher_.add(m.name(), m.containing_module());
    }

    void operator()(dogen::sml::concept& c) const {
        grapher_.add(c.name(), c.containing_module());
    }

private:
    module_containment_grapher& grapher_;
};
#+end_src

** Backend enricher

*** Header

#+begin_src c++
namespace dogen {
namespace cpp {
namespace meta_data {

/**
 * @brief Responsible for enriching the meta-data with the backend
 * specific tags.
 */
class backend_enricher : public sml::meta_data::enricher_interface {
private:
    /**
     * @brief Returns true if its the first stage enrichment, false
     * otherwise.
     */
    bool is_first_stage_enrichment(
        const sml::meta_data::enrichment_types et) const;

    /**
     * @brief Populates all of the traits of the formatter module,
     * setting it to default values - if they do not yet exist.
     */
    void setup_defaults(boost::property_tree::ptree& target) const;

    /**
     * @brief Performs the first stage enrichment in the target, using
     * the parent module.
     */
    void perform_first_stage_enrichment(
        const boost::property_tree::ptree& parent_module,
        boost::property_tree::ptree& target) const;

public:
    virtual std::string id() const override;

    virtual std::list<std::string> dependencies() const override;

    virtual void enrich(const sml::model& model,
        const sml::meta_data::enrichment_types enrichment_type,
        sml::concept& target) override;

    virtual void enrich(const sml::model& model,
        const sml::meta_data::enrichment_types enrichment_type,
        sml::module& target) override;

    virtual void enrich(const sml::model& model,
        const sml::meta_data::enrichment_types enrichment_type,
        sml::type& target) override;
};

} } }

#endif
#+end_src c++

*** Implementation

#+begin_src c++
#include "dogen/utility/log/logger.hpp"
#include "dogen/sml/io/qname_io.hpp"
#include "dogen/sml/types/meta_data/reader.hpp"
#include "dogen/sml/types/meta_data/writer.hpp"
#include "dogen/sml/types/meta_data/enrichment_error.hpp"
#include "dogen/cpp/types/meta_data/traits.hpp"
#include "dogen/cpp/types/meta_data/backend_enricher.hpp"

namespace {

std::string id("cpp.backend_enricher");
std::string source_directory("src");
std::string include_directory("include");
std::string header_file_extension("hpp");
std::string implementation_file_extension("cpp");
const std::string could_not_find_module("Could not find module: ");
const std::string no_containing_module_supplied(
    "Expected containing module for type: ");

std::list<std::string> empty_dependencies;

using namespace dogen::utility::log;
static logger lg(logger_factory(id));

}

namespace dogen {
namespace cpp {
namespace meta_data {

/**
 * @brief Obtains the containing module.
 *
 * @pre Must have a containing module.
 */
template<typename IdentifiableContainable>
sml::module containing_module(const sml::model& m,
    const IdentifiableContainable& ic) {

    if (!ic.containing_module()) {
        const auto sn(ic.name().simple_name());
        BOOST_LOG_SEV(lg, error) << no_containing_module_supplied << sn;
        BOOST_THROW_EXCEPTION(sml::meta_data::enrichment_error(
                no_containing_module_supplied + sn));
    }

    const auto qn(*ic.containing_module());
    const auto i(m.modules().find(qn));
    if (i == m.modules().end()) {
        const auto sn(qn.simple_name());
        BOOST_LOG_SEV(lg, error) << could_not_find_module << sn;
        BOOST_THROW_EXCEPTION(sml::meta_data::enrichment_error(
                could_not_find_module + sn));
    }
    return i->second;
}

std::string backend_enricher::id() const {
    return ::id;
}

std::list<std::string> backend_enricher::dependencies() const {
    return empty_dependencies;
}

bool backend_enricher::is_first_stage_enrichment(
    const sml::meta_data::enrichment_types et) const {
    if (et != sml::meta_data::enrichment_types::first_stage) {
        BOOST_LOG_SEV(lg, debug) << "Only first stage enrichment supported.";
        return false;
    }
    return true;
}

void backend_enricher::
setup_defaults(boost::property_tree::ptree& target) const {
    sml::meta_data::writer writer(target);

    writer.add_if_key_not_found(traits::enabled, traits::bool_true);
    writer.add_if_key_not_found(traits::split_project, traits::bool_false);
    writer.add_if_key_not_found(traits::source_directory, source_directory);
    writer.add_if_key_not_found(traits::include_directory, include_directory);
    writer.add_if_key_not_found(traits::header_file_extension,
        header_file_extension);
    writer.add_if_key_not_found(traits::implementation_file_extension,
        implementation_file_extension);
    writer.add_if_key_not_found(traits::enable_facet_folders,
        traits::bool_true);
    writer.add_if_key_not_found(traits::enable_unique_file_names,
        traits::bool_true);
}

void backend_enricher::
perform_first_stage_enrichment(
    const boost::property_tree::ptree& containing_module,
    boost::property_tree::ptree& target) const {
    sml::meta_data::writer writer(target);
    sml::meta_data::reader reader(containing_module);

    writer.add_if_key_not_found(traits::enabled, reader.get(traits::enabled));
    writer.add_if_key_not_found(traits::split_project,
        reader.get(traits::split_project));
    writer.add_if_key_not_found(traits::source_directory,
        reader.get(traits::source_directory));
    writer.add_if_key_not_found(traits::include_directory,
        reader.get(traits::include_directory));
    writer.add_if_key_not_found(traits::header_file_extension,
        reader.get(traits::header_file_extension));
    writer.add_if_key_not_found(traits::implementation_file_extension,
        reader.get(traits::implementation_file_extension));
    writer.add_if_key_not_found(traits::enable_facet_folders,
        reader.get(traits::enable_facet_folders));
    writer.add_if_key_not_found(traits::enable_unique_file_names,
        reader.get(traits::enable_unique_file_names));
}

void backend_enricher::enrich(const sml::model& model,
    const sml::meta_data::enrichment_types enrichment_type,
    sml::concept& target) {
    BOOST_LOG_SEV(lg, debug) << "Enriching concept: " << target.name();
    if (!is_first_stage_enrichment(enrichment_type))
        return;

    const auto cm(containing_module(model, target));
    perform_first_stage_enrichment(cm.meta_data(), target.meta_data());
}

void backend_enricher::enrich(const sml::model& model,
    const sml::meta_data::enrichment_types enrichment_type,
    sml::module& target) {
    BOOST_LOG_SEV(lg, debug) << "Enriching module: " << target.name();
    if (!is_first_stage_enrichment(enrichment_type))
        return;

    if (!target.containing_module()) {
        const auto sn(target.name().simple_name());
        BOOST_LOG_SEV(lg, debug) << "No containing module supplied for '" << sn
                                 << "'. Setting up defaults instead.";
        setup_defaults(target.meta_data());
        return;
    }

    const auto cm(containing_module(model, target));
    perform_first_stage_enrichment(cm.meta_data(), target.meta_data());
}

void backend_enricher::enrich(const sml::model& model,
    const sml::meta_data::enrichment_types enrichment_type,
    sml::type& target) {
    BOOST_LOG_SEV(lg, debug) << "Enriching type: " << target.name();
    if (!is_first_stage_enrichment(enrichment_type))
        return;

    const auto cm(containing_module(model, target));
    perform_first_stage_enrichment(cm.meta_data(), target.meta_data());
}

} } }
#+end_src c++
** General settings handler

*** Header
#+begin_src
namespace dogen {
namespace formatters {

/**
 * @brief Generates a map of general settings for qnames, taking into
 * account the general settings heuristics.
 */
class general_settings_handler : public sml::consumer_interface {
private:
    typedef std::unordered_map<sml::qname, general_settings>
    general_settings_by_qname_type;

public:
    /**
     * @brief Initialise a new handler.
     *
     * @param data_files_directories where to look for reference data.
     */
    explicit general_settings_handler(
        const std::list<boost::filesystem::path>& data_files_directories);

public:
    std::string id() const override;
    unsigned int required_passes() const override;
    bool consume_last() const override;
    void consume(const sml::model& model, const unsigned int pass,
        const sml::concept& target) const override;
    void consume(const sml::model& model, const unsigned int pass,
        const sml::module& target) const override;
    void consume(const sml::model& model, const unsigned int pass,
        const sml::enumeration& target) const override;
    void consume(const sml::model& model, const unsigned int pass,
        const sml::primitive& target) const override;
    void consume(const sml::model& model, const unsigned int pass,
        const sml::object& target) const override;

public:
    /**
     * @brief Returns the general settings by qname container, built
     * from an SML model.
     */
    const std::unordered_map<sml::qname, general_settings>&
    general_settings_by_qname() const;

private:
    mutable general_settings_by_qname_type general_settings_by_qname_;
    const meta_data::general_settings_factory factory_;
};

} }
#+end_src

*** Implementation

#+begin_src
#include <boost/lexical_cast.hpp>
#include <boost/throw_exception.hpp>
#include "dogen/utility/log/logger.hpp"
#include "dogen/sml/io/qname_io.hpp"
#include "dogen/sml/io/module_types_io.hpp"
#include "dogen/formatters/types/handling_error.hpp"
#include "dogen/formatters/types/general_settings_handler.hpp"

namespace {

const std::string id("formatters.general_settings_handler");
using namespace dogen::utility::log;
auto lg(logger_factory(id));
const std::string unexpected_module_type("Unexpected module type: ");
const std::string qname_not_found("Could not find settings for qname: ");
const std::string uncontained_element(
    "Element does not have a containing module: ");

}
namespace dogen {
namespace formatters {

general_settings_handler::general_settings_handler(
    const std::list<boost::filesystem::path>& data_files_directories)
    : factory_(data_files_directories) { }

std::string general_settings_handler::id() const {
    return ::id;
}

unsigned int general_settings_handler::required_passes() const {
    return 1;
}

bool general_settings_handler::consume_last() const {
    return false;
}

void general_settings_handler::
consume(const sml::model& /*model*/, const unsigned int /*pass*/,
    const sml::concept& target) const {

    if (target.generation_type() == sml::generation_types::no_generation)
        return;
}

void general_settings_handler::
consume(const sml::model& /*model*/, const unsigned int /*pass*/,
    const sml::module& target) const {

    if (target.generation_type() == sml::generation_types::no_generation)
        return;

    if (target.type() != sml::module_types::model &&
        target.type() != sml::module_types::regular) {
        const auto t(boost::lexical_cast<std::string>(target.type()));
        BOOST_LOG_SEV(lg, error) << unexpected_module_type << t;
        BOOST_THROW_EXCEPTION(handling_error(unexpected_module_type + t));
    }

    if (target.type() == sml::module_types::model) {
        const auto gs(factory_.build(target.meta_data()));
        general_settings_by_qname_.insert(std::make_pair(target.name(), gs));
    }

    if (!target.containing_module()) {
        const auto sn(target.name().simple_name());
        BOOST_LOG_SEV(lg, error) << uncontained_element << sn;
        BOOST_THROW_EXCEPTION(handling_error(uncontained_element + sn));
    }

    const auto cm(*target.containing_module());
    const auto i(general_settings_by_qname_.find(cm));
    if (i == general_settings_by_qname_.end()) {
        BOOST_LOG_SEV(lg, error) << qname_not_found << target.name();
        const auto sn(target.name().simple_name());
        BOOST_THROW_EXCEPTION(handling_error(qname_not_found + sn));
    }
}

void general_settings_handler::
consume(const sml::model& /*model*/, const unsigned int /*pass*/,
    const sml::enumeration& target) const {

    if (target.generation_type() == sml::generation_types::no_generation)
        return;
}

void general_settings_handler::
consume(const sml::model& /*model*/, const unsigned int /*pass*/,
    const sml::primitive& target) const {

    if (target.generation_type() == sml::generation_types::no_generation)
        return;
}

void general_settings_handler::
consume(const sml::model& /*model*/, const unsigned int /*pass*/,
    const sml::object& target) const {

    if (target.generation_type() == sml::generation_types::no_generation)
        return;
}

} }
#+end_src
** All formatters support

#+begin_src
diff --git a/projects/cpp/include/dogen/cpp/types/registrar.hpp b/projects/cpp/include/dogen/cpp/types/registrar.hpp
index d198af8..36ba8ba 100644
--- a/projects/cpp/include/dogen/cpp/types/registrar.hpp
+++ b/projects/cpp/include/dogen/cpp/types/registrar.hpp
@@ -29,6 +29,7 @@
 #include <forward_list>
 #include <unordered_map>
 #include "dogen/cpp/types/facet_settings.hpp"
+#include "dogen/cpp/types/formatters/formatter_interface.hpp"
 #include "dogen/cpp/types/formatters/class_formatter_interface.hpp"
 
 namespace dogen {
@@ -40,6 +41,10 @@ public:
         std::shared_ptr<formatters::class_formatter_interface>
     > class_formatters_type;
 
+    typedef std::forward_list<
+        std::shared_ptr<formatters::formatter_interface>
+        > formatters_type;
+
 public:
     /**
      * @brief Ensures the registrar is ready to be used.
@@ -64,6 +69,11 @@ public:
     const class_formatters_type& class_formatters() const;
 
     /**
+     * @brief Returns all available formatters.
+     */
+    const formatters_type& all_formatters() const;
+
+    /**
      * @brief Returns all default settings for all facets.
      */
     const std::unordered_map<std::string, facet_settings>&
@@ -73,6 +83,7 @@ private:
     class_formatters_type class_formatters_;
     std::unordered_map<std::string, facet_settings>
     default_facet_settings_by_facet_id_;
+    formatters_type all_formatters_;
 };
 
 } }
#+end_src

#+begin_src
	Modified   projects/cpp/src/types/registrar.cpp
diff --git a/projects/cpp/src/types/registrar.cpp b/projects/cpp/src/types/registrar.cpp
index 923686d..5216597 100644
--- a/projects/cpp/src/types/registrar.cpp
+++ b/projects/cpp/src/types/registrar.cpp
@@ -63,12 +63,17 @@ void registrar::register_formatter(
         BOOST_THROW_EXCEPTION(registrar_error(null_formatter));
 
     class_formatters_.push_front(f);
+    all_formatters_.push_front(f);
 }
 
 const registrar::class_formatters_type& registrar::class_formatters() const {
     return class_formatters_;
 }
 
+const registrar::formatters_type& registrar::all_formatters() const {
+    return all_formatters_;
+}
#+end_src
