#+title: Scratch Pad
#+options: date:nil toc:nil author:nil num:nil

This document contains snippets of code that we want to preserve, most
likely to avoid having to trek down git history to find it.

** Meta-data tagger

Header:

#+begin_src c++
#include <set>
#include <memory>
#include "dogen/config/types/cpp_settings.hpp"
#include "dogen/config/types/cpp_facet_types.hpp"
#include "dogen/sml/types/type_visitor.hpp"
#include "dogen/sml/types/meta_data_writer.hpp"
#include "dogen/sml/types/flat_name_builder.hpp"
#include "dogen/sml/types/qname.hpp"
#include "dogen/sml/types/model.hpp"
#include "dogen/sml/types/type.hpp"
#include "dogen/sml/types/tags.hpp"

namespace dogen {
namespace sml {

/**
 * @brief Generate all meta data tags across the model.
 */
class meta_data_tagger : private sml::type_visitor {
public:
    meta_data_tagger() = default;
    meta_data_tagger(const meta_data_tagger&) = default;
    meta_data_tagger(meta_data_tagger&&) = default;

public:
    virtual ~meta_data_tagger() noexcept { }

private:
    class context;

private:
    /**
     * @brief Tag the model with all the options chosen in the
     * application settings.
     *
     * This ensures backwards compatibility until we remove these
     * options from the configuration model.
     *
     * @deprecated Needed whilst settings contain options that should
     * really be in the meta-data.
     */
    void from_settings(const config::cpp_settings& s, model& m) const;

    /**
     * @brief Returns true if the facet is enabled in the settings,
     * false otherwise.
     *
     * @deprecated Needed whilst settings contain options that should
     * really be in the meta-data.
     */
    bool is_facet_enabled(
        const std::set<config::cpp_facet_types>& enabled_facets,
        const config::cpp_facet_types facet) const;

private:
    /**
     * @brief Copies across all tags from the model into the taggable
     * using the writer.
     */
    void copy_model_tags(meta_data_writer& writer) const;

    /**
     * @brief Returns true if an explicit move constructor is
     * required, false otherwise.
     */
    bool generate_explicit_move_constructor(const nested_qname& nqn) const;

private:
    using sml::type_visitor::visit;
    void visit(sml::primitive& p) const override;
    void visit(sml::enumeration& e) const override;
    void visit(sml::object& vo) const override;

public:
    /**
     * @brief Adds meta-data to the type supplied.
     */
    void operator()(type& t) const;

    /**
     * @brief Adds meta-data to the module supplied.
     */
    void operator()(module& m) const;

    /**
     * @brief Adds meta-data to the concept supplied.
     */
    void operator()(concept& c) const;

public:
    /**
     * @brief Adds meta-data to the property supplied.
     */
    void tag(property& p) const;

    /**
     * @brief Adds meta-data to the object supplied.
     */
    void tag(object& o) const;

    /**
     * @brief Adds meta-data to the model supplied.
     */
    void tag(model& m) const;

    /**
     * @brief Adds meta-data to the model supplied.
     *
     * @deprecated This method is only made available for backwards
     * compatibility.
     */
    void tag(const config::cpp_settings& s, model& m) const;

private:
    mutable std::shared_ptr<context> context_;
    flat_name_builder builder_;
};

} }
#+end_src

Implementation:

#+begin_src c++
#include <sstream>
#include <boost/throw_exception.hpp>
#include "dogen/utility/log/logger.hpp"
#include "dogen/sml/types/meta_data_error.hpp"
#include "dogen/sml/types/meta_data_reader.hpp"
#include "dogen/sml/types/all_model_items_traversal.hpp"
#include "dogen/sml/types/tags.hpp"
#include "dogen/sml/types/enumeration.hpp"
#include "dogen/sml/types/object.hpp"
#include "dogen/sml/io/qname_io.hpp"
#include "dogen/sml/types/meta_data_tagger.hpp"

using namespace dogen::utility::log;

namespace {

auto lg(logger_factory("sml.meta_data_tagger"));
const std::string empty;
const std::string original_parent_not_found(
    "Failed to find original parent for type: ");
const std::string too_many_original_parents(
    "Type has too many original parents, expected one: ");

const std::string cpp_header_extension(".hpp");
const std::string cpp_implementation_extension(".cpp");
const std::string cpp_includer_file_name("all");

const std::string empty_postfix;
const std::string types_postfix;
const std::string forward_decls_postfix("_fwd");
const std::string io_postfix("_io");
const std::string hash_postfix("_hash");
const std::string serialization_postfix("_ser");
const std::string test_data_postfix("_td");
const std::string odb_postfix("_pragmas");

const std::string source_directory("src");
const std::string include_directory("include");
const std::string types_directory("types");
const std::string io_directory("io");
const std::string hash_directory("hash");
const std::string serialization_directory("serialization");
const std::string test_data_directory("test_data");
const std::string odb_directory("odb");

const bool is_header_file(true);

}

namespace dogen {
namespace sml {

class meta_data_tagger::context {
public:
    context(sml::model& m) : model_(m) { }

public:
    sml::model& model() { return model_; }

private:
    sml::model& model_;
};

void meta_data_tagger::
from_settings(const config::cpp_settings& s, model& m) const {
    meta_data_writer writer(m.meta_data());

    writer.add_if_key_not_found(tags::cpp::split_project,
        s.split_project() ? tags::bool_false : tags::bool_true);

    writer.add_if_key_not_found(tags::cpp::header_file_extension,
        s.header_extension());

    writer.add_if_key_not_found(tags::cpp::implementation_file_extension,
        s.source_extension());

    writer.add_if_key_not_found(tags::cpp::enable_facet_folders,
        s.disable_facet_folders() ? tags::bool_false : tags::bool_true);

    writer.add_if_key_not_found(tags::cpp::enable_unique_file_names,
        s.disable_unique_file_names() ?
        tags::bool_false : tags::bool_true);

    using config::cpp_facet_types;
    if (is_facet_enabled(s.enabled_facets(), cpp_facet_types::types)) {
        writer.add_if_key_not_found(tags::cpp::types::enabled, tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::types::generate_complete_constructor,
            s.disable_complete_constructor() ?
            tags::bool_false : tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::types::includers_file::generate,
            s.disable_facet_includers() ?
            tags::bool_false : tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::types::directory_name,
            s.domain_facet_folder());
    } else {
        writer.add_if_key_not_found(tags::cpp::types::enabled,
            tags::bool_false);
    }

    if (is_facet_enabled(s.enabled_facets(), cpp_facet_types::hash)) {
        writer.add_if_key_not_found(tags::cpp::hash::standard::enabled,
            tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::hash::standard::includers_file::generate,
            s.disable_facet_includers() ?
            tags::bool_false : tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::hash::standard::directory_name,
            s.hash_facet_folder());
    } else {
        writer.add_if_key_not_found(tags::cpp::hash::standard::enabled,
            tags::bool_false);
    }

    if (is_facet_enabled(s.enabled_facets(), cpp_facet_types::io)) {
        writer.add_if_key_not_found(tags::cpp::io::enabled, tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::io::enable_integrated_io,
            s.use_integrated_io() ?
            tags::bool_true : tags::bool_false);

        writer.add_if_key_not_found(
            tags::cpp::io::includers_file::generate,
            s.disable_facet_includers() ?
            tags::bool_false : tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::io::directory_name,
            s.io_facet_folder());
    } else {
        writer.add_if_key_not_found(tags::cpp::io::enabled,
            tags::bool_false);
    }

    if (is_facet_enabled(s.enabled_facets(), cpp_facet_types::serialization)) {
        writer.add_if_key_not_found(tags::cpp::serialization::boost::enabled,
            tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::enable_xml_serialization,
            s.disable_xml_serialization() ?
            tags::bool_false : tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::includers_file::generate,
            s.disable_facet_includers() ?
            tags::bool_false : tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::directory_name,
            s.serialization_facet_folder());
    } else {
        writer.add_if_key_not_found(tags::cpp::serialization::boost::enabled,
            tags::bool_false);
    }

    if (is_facet_enabled(s.enabled_facets(), cpp_facet_types::test_data)) {
        writer.add_if_key_not_found(tags::cpp::test_data::enabled,
            tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::test_data::includers_file::generate,
            s.disable_facet_includers() ?
            tags::bool_false : tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::test_data::directory_name,
            s.test_data_facet_folder());
    } else {
        writer.add_if_key_not_found(tags::cpp::test_data::enabled,
            tags::bool_false);
    }

    if (is_facet_enabled(s.enabled_facets(), cpp_facet_types::odb)) {
        writer.add_if_key_not_found(tags::cpp::odb::enabled, tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::odb::includers_file::generate,
            s.disable_facet_includers() ?
            tags::bool_false : tags::bool_true);

        writer.add_if_key_not_found(
            tags::cpp::odb::directory_name,
            s.odb_facet_folder());
    } else {
        writer.add_if_key_not_found(tags::cpp::odb::enabled, tags::bool_false);
    }
}

bool meta_data_tagger::is_facet_enabled(
    const std::set<config::cpp_facet_types>& enabled_facets,
    const config::cpp_facet_types facet) const {
    const auto i(enabled_facets.find(facet));
    return i != enabled_facets.end();
}

void meta_data_tagger::copy_model_tags(meta_data_writer& writer) const {
    meta_data_reader reader(context_->model().meta_data());

    if (reader.has_key(tags::copyright_holder)) {
        writer.add_if_key_not_found(tags::copyright_holder,
            reader.get(tags::copyright_holder));
    }

    writer.add_if_key_not_found(tags::generate_preamble,
        reader.get(tags::generate_preamble));

    if (reader.has_key(sml::tags::licence_name)) {
        writer.add_if_key_not_found(sml::tags::licence_name,
            reader.get(sml::tags::licence_name));
    }

    if (reader.has_key(sml::tags::modeline_group_name)) {
        writer.add_if_key_not_found(sml::tags::modeline_group_name,
            reader.get(sml::tags::modeline_group_name));
    }

    if (reader.has_key(sml::tags::code_generation_marker::message)) {
        writer.add_if_key_not_found(
            sml::tags::code_generation_marker::message,
            reader.get(sml::tags::code_generation_marker::message));
    }

    writer.add_if_key_not_found(
        sml::tags::code_generation_marker::add_warning,
        reader.get(sml::tags::code_generation_marker::add_warning));

    writer.add_if_key_not_found(
        sml::tags::code_generation_marker::add_date_time,
        reader.get(sml::tags::code_generation_marker::add_date_time));

    writer.add_if_key_not_found(tags::cpp::header_file_extension,
        reader.get(tags::cpp::header_file_extension));

    writer.add_if_key_not_found(tags::cpp::implementation_file_extension,
        reader.get(tags::cpp::implementation_file_extension));

    writer.add_if_key_not_found(tags::cpp::enable_facet_folders,
        reader.get(tags::cpp::enable_facet_folders));

    writer.add_if_key_not_found(tags::cpp::enable_unique_file_names,
        reader.get(tags::cpp::enable_unique_file_names));

    writer.add_if_key_not_found(tags::cpp::forward_declaration_postfix,
        reader.get(tags::cpp::forward_declaration_postfix));

    writer.add_if_key_not_found(tags::cpp::types::enabled,
        reader.get(tags::cpp::types::enabled));

    writer.add_if_key_not_found(tags::cpp::hash::standard::enabled,
        reader.get(tags::cpp::hash::standard::enabled));

    writer.add_if_key_not_found(tags::cpp::serialization::boost::enabled,
        reader.get(tags::cpp::serialization::boost::enabled));

    writer.add_if_key_not_found(tags::cpp::io::enabled,
        reader.get(tags::cpp::io::enabled));

    writer.add_if_key_not_found(tags::cpp::test_data::enabled,
        reader.get(tags::cpp::test_data::enabled));

    writer.add_if_key_not_found(tags::cpp::odb::enabled,
        reader.get(tags::cpp::odb::enabled));


    if (reader.is_true(tags::cpp::types::enabled)) {
        writer.add_if_key_not_found(tags::cpp::types::directory_name,
            reader.get(tags::cpp::types::directory_name));

        writer.add_if_key_not_found(tags::cpp::types::postfix,
            reader.get(tags::cpp::types::postfix));
    }

    if (reader.is_true(tags::cpp::hash::standard::enabled)) {
        writer.add_if_key_not_found(tags::cpp::hash::standard::directory_name,
            reader.get(tags::cpp::hash::standard::directory_name));

        writer.add_if_key_not_found(tags::cpp::hash::standard::postfix,
            reader.get(tags::cpp::hash::standard::postfix));
    }

    if (reader.is_true(tags::cpp::serialization::boost::enabled)) {
        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::directory_name,
            reader.get(tags::cpp::serialization::boost::directory_name));

        writer.add_if_key_not_found(tags::cpp::serialization::boost::postfix,
            reader.get(tags::cpp::serialization::boost::postfix));
    }

    if (reader.is_true(tags::cpp::io::enabled)) {
        writer.add_if_key_not_found(tags::cpp::io::directory_name,
            reader.get(tags::cpp::io::directory_name));

        writer.add_if_key_not_found(tags::cpp::io::postfix,
            reader.get(tags::cpp::io::postfix));

        writer.add_if_key_not_found(
            tags::cpp::io::enable_integrated_io,
            reader.get(tags::cpp::io::enable_integrated_io));
    }

    if (reader.is_true(tags::cpp::test_data::enabled)) {
        writer.add_if_key_not_found(tags::cpp::test_data::directory_name,
            reader.get(tags::cpp::test_data::directory_name));

        writer.add_if_key_not_found(tags::cpp::test_data::postfix,
            reader.get(tags::cpp::test_data::postfix));
    }

    if (reader.is_true(tags::cpp::odb::enabled)) {
        writer.add_if_key_not_found(tags::cpp::odb::directory_name,
            reader.get(tags::cpp::odb::directory_name));

        writer.add_if_key_not_found(tags::cpp::odb::postfix,
            reader.get(tags::cpp::odb::postfix));
    }
}

bool meta_data_tagger::
generate_explicit_move_constructor(const nested_qname& nqn) const {
    const auto type_name(nqn.type().simple_name());
    if (type_name == "optional" || type_name == "path" ||
        type_name == "variant" || type_name == "time_duration" ||
        type_name == "ptree")
        return true;

    for (const auto c : nqn.children()) {
        if (generate_explicit_move_constructor(c))
            return true;
    }
    return false;
}

void meta_data_tagger::visit(sml::primitive& p) const {
    meta_data_writer writer(p.meta_data());
    writer.add_if_key_not_found(tags::cpp::types::is_simple_type,
        tags::bool_true);
}

void meta_data_tagger::visit(sml::enumeration& e) const {
    meta_data_writer writer(e.meta_data());
    writer.add_if_key_not_found(tags::cpp::types::is_simple_type,
        tags::bool_true);
}

void meta_data_tagger::visit(sml::object& o) const {
    tag(o);
}

void meta_data_tagger::operator()(type& t) const {
    meta_data_writer writer(t.meta_data());
    copy_model_tags(writer);

    meta_data_reader reader(t.meta_data());
    writer.add_if_key_not_found(tags::cpp::types::qualified_name,
        builder_.cpp_qualified_name(context_->model(), t.name()));

    using gt = generation_types;
    if (reader.is_true(tags::cpp::types::enabled)) {
        const auto header_fn(builder_.cpp_filename_for_qname(
                t.meta_data(),
                is_header_file, t.name(),
                reader.get(tags::cpp::types::directory_name),
                reader.get(tags::cpp::types::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::types::header_file::file_name, header_fn);

        writer.add_if_key_not_found(
            tags::cpp::types::header_file::is_system, tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::types::header_file::generate, tags::bool_true);
            writer.add_if_key_not_found(
                tags::cpp::types::header_file::generate_header_guards,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::types::header_file::overwrite, tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::types::header_file::generate, tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::types::header_file::generate_header_guards,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::types::header_file::overwrite, tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::types::header_file::generate, tags::bool_false);
        }

        const auto impl_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                !is_header_file, t.name(),
                reader.get(tags::cpp::types::directory_name),
                reader.get(tags::cpp::types::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::types::implementation_file::file_name, impl_fn);

        writer.add_if_key_not_found(
            tags::cpp::types::implementation_file::is_system, tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::types::implementation_file::generate,
                tags::bool_true);
            writer.add_if_key_not_found(
                tags::cpp::types::implementation_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::types::implementation_file::generate,
                tags::bool_true);
            writer.add_if_key_not_found(
                tags::cpp::types::implementation_file::overwrite,
                tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::types::implementation_file::generate,
                tags::bool_false);
        }

        const auto fwd_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                is_header_file, t.name(),
                reader.get(tags::cpp::types::directory_name),
                reader.get(tags::cpp::types::postfix),
                reader.get(tags::cpp::forward_declaration_postfix)));

        writer.add_if_key_not_found(
            tags::cpp::types::forward_declarations_file::file_name, fwd_fn);

        writer.add_if_key_not_found(
            tags::cpp::types::forward_declarations_file::is_system,
            tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::types::forward_declarations_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::types::forward_declarations_file::
                generate_header_guards, tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::types::forward_declarations_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::types::forward_declarations_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::types::forward_declarations_file::
                generate_header_guards, tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::types::forward_declarations_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::types::forward_declarations_file::generate,
                tags::bool_false);
        }
    }

    if (reader.is_true(tags::cpp::hash::standard::enabled)) {
        const auto header_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                is_header_file, t.name(),
                reader.get(tags::cpp::hash::standard::directory_name),
                reader.get(tags::cpp::hash::standard::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::hash::standard::header_file::file_name, header_fn);

        writer.add_if_key_not_found(
            tags::cpp::hash::standard::header_file::is_system,
            tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::hash::standard::header_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::hash::standard::header_file::generate_header_guards,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::hash::standard::header_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::hash::standard::header_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::hash::standard::header_file::generate_header_guards,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::hash::standard::header_file::overwrite,
                tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::hash::standard::header_file::generate,
                tags::bool_false);
        }

        const auto impl_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                !is_header_file, t.name(),
                reader.get(tags::cpp::hash::standard::directory_name),
                reader.get(tags::cpp::hash::standard::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::hash::standard::implementation_file::file_name, impl_fn);

        writer.add_if_key_not_found(
            tags::cpp::hash::standard::implementation_file::is_system,
            tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::hash::standard::implementation_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::hash::standard::implementation_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::hash::standard::implementation_file::generate,
                tags::bool_true);
            writer.add_if_key_not_found(
                tags::cpp::hash::standard::implementation_file::overwrite,
                tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::hash::standard::implementation_file::generate,
                tags::bool_false);
        }
    }

    if (reader.is_true(tags::cpp::serialization::boost::enabled)) {
        const auto header_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                is_header_file, t.name(),
                reader.get(tags::cpp::serialization::boost::directory_name),
                reader.get(tags::cpp::serialization::boost::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::header_file::file_name, header_fn);

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::header_file::is_system,
            tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::header_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::header_file::
                generate_header_guards, tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::header_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::header_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::header_file::
                generate_header_guards, tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::header_file::overwrite,
                tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::header_file::generate,
                tags::bool_false);
        }

        const auto impl_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                !is_header_file, t.name(),
                reader.get(tags::cpp::serialization::boost::directory_name),
                reader.get(tags::cpp::serialization::boost::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::implementation_file::file_name,
            impl_fn);

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::implementation_file::is_system,
            tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::implementation_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::implementation_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::implementation_file::generate,
                tags::bool_true);
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::implementation_file::overwrite,
                tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::implementation_file::generate,
                tags::bool_false);
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::implementation_file::overwrite,
                tags::bool_false);
        }

        const auto fwd_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                is_header_file, t.name(),
                reader.get(tags::cpp::serialization::boost::directory_name),
                reader.get(tags::cpp::serialization::boost::postfix),
                reader.get(tags::cpp::forward_declaration_postfix)));

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::forward_declarations_file::
            file_name, fwd_fn);

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::forward_declarations_file::
            is_system, tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::forward_declarations_file::
                generate, tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::forward_declarations_file::
                generate_header_guards, tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::forward_declarations_file::
                overwrite, tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::forward_declarations_file::
                generate, tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::forward_declarations_file::
                generate_header_guards, tags::bool_false);

            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::forward_declarations_file::
                overwrite, tags::bool_true);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::serialization::boost::forward_declarations_file::
                generate, tags::bool_false);
        }
    }

    if (reader.is_true(tags::cpp::io::enabled)) {
        const auto header_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                is_header_file, t.name(),
                reader.get(tags::cpp::io::directory_name),
                reader.get(tags::cpp::io::postfix),
                empty_postfix));

        writer.add_if_key_not_found(tags::cpp::io::header_file::file_name,
            header_fn);

        writer.add_if_key_not_found(tags::cpp::io::header_file::is_system,
            tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::io::header_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::io::header_file::generate_header_guards,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::io::header_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::io::header_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::io::header_file::generate_header_guards,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::io::header_file::overwrite,
                tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::io::header_file::generate,
                tags::bool_false);
        }

        const auto impl_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                !is_header_file, t.name(),
                reader.get(tags::cpp::io::directory_name),
                reader.get(tags::cpp::io::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::io::implementation_file::file_name,
            impl_fn);

        writer.add_if_key_not_found(
            tags::cpp::io::implementation_file::is_system,
            tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::io::implementation_file::generate,
                tags::bool_true);
            writer.add_if_key_not_found(
                tags::cpp::io::implementation_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::io::implementation_file::generate,
                tags::bool_true);
            writer.add_if_key_not_found(
                tags::cpp::io::implementation_file::overwrite,
                tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::io::implementation_file::generate,
                tags::bool_false);
            writer.add_if_key_not_found(
                tags::cpp::io::implementation_file::overwrite,
                tags::bool_false);
        }
    }

    if (reader.is_true(tags::cpp::test_data::enabled)) {
        const auto header_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                is_header_file, t.name(),
                reader.get(tags::cpp::test_data::directory_name),
                reader.get(tags::cpp::test_data::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::test_data::header_file::file_name,
            header_fn);

        writer.add_if_key_not_found(
            tags::cpp::test_data::header_file::is_system,
            tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::test_data::header_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::test_data::header_file::generate_header_guards,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::test_data::header_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::test_data::header_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::test_data::header_file::generate_header_guards,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::test_data::header_file::overwrite,
                tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::test_data::header_file::generate,
                tags::bool_false);
        }

        const auto impl_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                !is_header_file,
                t.name(), reader.get(tags::cpp::test_data::directory_name),
                reader.get(tags::cpp::test_data::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::test_data::implementation_file::file_name,
            impl_fn);

        writer.add_if_key_not_found(
            tags::cpp::test_data::implementation_file::is_system,
            tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::test_data::implementation_file::generate,
                tags::bool_true);
            writer.add_if_key_not_found(
                tags::cpp::test_data::implementation_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::test_data::implementation_file::generate,
                tags::bool_true);
            writer.add_if_key_not_found(
                tags::cpp::test_data::implementation_file::overwrite,
                tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::test_data::implementation_file::generate,
                tags::bool_false);
            writer.add_if_key_not_found(
                tags::cpp::test_data::implementation_file::overwrite,
                tags::bool_false);
        }
    }

    if (reader.is_true(tags::cpp::odb::enabled)) {
        const auto header_fn(builder_.cpp_filename_for_qname(t.meta_data(),
                is_header_file, t.name(),
                reader.get(tags::cpp::odb::directory_name),
                reader.get(tags::cpp::odb::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::odb::header_file::file_name,
            header_fn);

        writer.add_if_key_not_found(
            tags::cpp::odb::header_file::is_system,
            tags::bool_false);

        if (t.generation_type() == gt::full_generation) {
            writer.add_if_key_not_found(
                tags::cpp::odb::header_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::odb::header_file::generate_header_guards,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::odb::header_file::overwrite,
                tags::bool_true);
        } else if (t.generation_type() == gt::partial_generation) {
            writer.add_if_key_not_found(
                tags::cpp::odb::header_file::generate,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::odb::header_file::generate_header_guards,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::odb::header_file::overwrite,
                tags::bool_false);
        } else if (t.generation_type() == gt::no_generation) {
            writer.add_if_key_not_found(
                tags::cpp::odb::header_file::generate,
                tags::bool_false);
        }
    }

    t.accept(*this);
}

void meta_data_tagger::operator()(module& m) const {
    meta_data_writer writer(m.meta_data());
    copy_model_tags(writer);

    // only generate a types file for models when there is
    // documentation for the model.
    if (m.documentation().empty()) {
        writer.add_if_key_not_found(
            tags::cpp::types::header_file::generate, tags::bool_false);

        return;
    }

    writer.add_if_key_not_found(
        tags::cpp::types::header_file::generate, tags::bool_true);

    writer.add_if_key_not_found(
        tags::cpp::types::header_file::generate_header_guards, tags::bool_true);

    // must massage the model name in order to generate the
    // correct file name for the model.
    qname qn(m.name());
    qn.simple_name(m.name().model_name());

    meta_data_reader reader(m.meta_data());
    const auto fn(builder_.cpp_filename_for_qname(m.meta_data(), is_header_file,
            qn, reader.get(tags::cpp::types::directory_name),
            reader.get(tags::cpp::types::postfix),
            empty_postfix));

    writer.add_if_key_not_found(
        tags::cpp::types::header_file::file_name, fn);

    writer.add_if_key_not_found(
        tags::cpp::types::header_file::is_system, tags::bool_false);
}

void meta_data_tagger::operator()(concept& /*c*/) const {
    // nothing to do for concepts
}

void meta_data_tagger::tag(property& p) const {
    meta_data_writer w(p.meta_data());
    std::string cn;
    builder_.cpp_complete_name(context_->model(), p.type(), cn);
    w.add_if_key_not_found(tags::cpp::types::complete_name, cn);

    const auto i(context_->model().primitives().find(p.type().type()));
    const bool is_primitive(i != context_->model().primitives().end());
    const auto j(context_->model().enumerations().find(p.type().type()));
    const bool is_enumeration(j != context_->model().enumerations().end());
    const bool is_simple_type(is_primitive || is_enumeration);

    w.add_if_key_not_found(tags::cpp::types::is_simple_type,
        is_simple_type ? tags::bool_true : tags::bool_false);
}

void meta_data_tagger::tag(object& o) const {
    meta_data_writer writer(o.meta_data());
    meta_data_reader reader(o.meta_data());

    writer.add_if_key_not_found(tags::cpp::types::is_simple_type,
        tags::bool_false);

    bool generate_explicit_move_constructor(false);
    bool generate_explicit_default_constructor(false);
    for (auto& p : o.local_properties()) {
        if (!generate_explicit_move_constructor)
            generate_explicit_move_constructor =
                this->generate_explicit_move_constructor(p.type());

        tag(p);
        meta_data_reader reader(p.meta_data());
        if (!generate_explicit_default_constructor)
            generate_explicit_default_constructor =
                reader.is_true(tags::cpp::types::is_simple_type);
    }

    writer.add_if_key_not_found(
        tags::cpp::types::generate_explicit_move_constructor,
        generate_explicit_move_constructor ?
        tags::bool_true : tags::bool_false);

    writer.add_if_key_not_found(
        tags::cpp::types::generate_explicit_default_constructor,
        generate_explicit_default_constructor ?
        tags::bool_true : tags::bool_false);

    for (auto& p : o.all_properties())
        tag(p);

    for (auto& pair : o.inherited_properties()) {
        for (auto& p : pair.second)
            tag(p);
    }

    const auto i(o.relationships().find(relationship_types::original_parents));
    if (i != o.relationships().end() && !i->second.empty()) {
        if (i->second.size() > 1) {
            const auto sn(o.name().simple_name());
            BOOST_LOG_SEV(lg, error) << too_many_original_parents << sn;
            BOOST_THROW_EXCEPTION(meta_data_error(too_many_original_parents +
                    sn));
        }

        const auto& opn(i->second.front());
        writer.add_if_key_not_found(tags::original_parent_name,
            opn.simple_name());

        const auto i(context_->model().objects().find(opn));
        if (i == context_->model().objects().end()) {
            BOOST_LOG_SEV(lg, error) << original_parent_not_found << opn;
            BOOST_THROW_EXCEPTION(meta_data_error(original_parent_not_found +
                    opn.simple_name()));
        }

        writer.add_if_key_not_found(tags::is_original_parent_visitable,
            i->second.is_visitable() ? tags::bool_true : tags::bool_false);

        /*
         * If your original parent is visitable and you are a leaf,
         * you must generate a concrete accept method.
         */
        if (i->second.is_visitable() && !o.is_parent()) {
            writer.add_if_key_not_found(tags::cpp::types::generate_accept,
                tags::bool_true);
        }

        writer.add_if_key_not_found(
            tags::cpp::types::qualified_original_parent_name,
            builder_.cpp_qualified_name(context_->model(), opn));
    }

    /*
     * If your are visitable, you must generate an accept method.
     */
    if (o.is_visitable()) {
        writer.add_if_key_not_found(tags::cpp::types::generate_accept,
            tags::bool_true);

        /*
         * If you are not a leaf, the accept method must be
         * virtual. Since is visitable is only set for the base class
         * of a hierarchy, you should always be a parent, really. But
         * we check, just in case.
         */
        if (o.is_parent()) {
            writer.add_if_key_not_found(
                tags::cpp::types::accept_is_pure_virtual,
                tags::bool_true);
        }
    }

    writer.add_if_key_not_found(
        tags::cpp::types::generate_defaulted_functions, tags::bool_true);

    writer.add_if_key_not_found(
        tags::cpp::types::generate_explicit_default_constructor,
        tags::bool_false);

    writer.add_if_key_not_found(
        tags::cpp::types::generate_explicit_move_constructor, tags::bool_false);

    /*
     * Types which are part of an inheritance relationship require
     * manually generated destructors.
     */
    if (o.is_parent() || o.is_child()) {
        writer.add_if_key_not_found(
            tags::cpp::types::generate_explicit_destructor, tags::bool_true);

        /*
         * according to MEC++, item 33, base classes should always be
         * abstract. this avoids all sorts of tricky problems with
         * assignment and swap.
         *
         * incidentally, this also fixes some strange clang errors:
         * undefined reference to `vtable.
         */
        if (o.is_parent()) {
            writer.add_if_key_not_found(
                tags::cpp::types::destructor_is_pure_virtual, tags::bool_true);
        }
    }

    /*
     * Types which are not immutable, have no properties or are not
     * parents in an inheritance relationship do not require swap
     * support or explicit assignment operators.
     */
    if (!o.is_immutable() && (!o.all_properties().empty() || o.is_parent())) {

        /*
         * All types which require swap support must have an internal
         * swap method since the external swap method uses it. In
         * addition, parents must supply it so that their children can
         * use it to swap the parent's state.
         */
        writer.add_if_key_not_found(
            tags::cpp::types::generate_internal_swap,
            tags::bool_true);

        /*
         * Classes that are parents in an inheritance relationship
         * should not overload the standard swap function. This is
         * because they are abstract classes (MEC++-33). For the same
         * reason, they should not have their own assignment
         * operators.
         */
        if (!o.is_parent()) {
            writer.add_if_key_not_found(
                tags::cpp::types::generate_external_swap,
                tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::types::generate_explicit_assignment_operator,
                tags::bool_false);
        }
    }

    writer.add_if_key_not_found(
        tags::cpp::types::generate_complete_constructor,
        tags::bool_true);

    writer.add_if_key_not_found(tags::cpp::types::generate_equality,
        tags::bool_true);

    writer.add_if_key_not_found(tags::cpp::types::generate_friends,
        tags::bool_true);

    if (reader.is_true(tags::cpp::io::enabled)) {
        /*
         * Types which are involved in an inheritance relationship must
         * have an internal to stream method to allow for delegation
         * between parents and children.
         */
        if (o.is_parent() || o.is_child()) {
            writer.add_if_key_not_found(
                tags::cpp::types::generate_to_stream,
                tags::bool_true);
        }

        /*
         * If integrated IO is enabled we need to generate an
         * external inserter with the class.
         */
        if (reader.is_true(tags::cpp::io::enable_integrated_io)) {
            writer.add_if_key_not_found(
                tags::cpp::types::generate_external_inserter,
                tags::bool_true);
        }
    }
}

void meta_data_tagger::tag(model& m) const {
    context_ = std::unique_ptr<context>(new context(m));

    meta_data_writer writer(m.meta_data());

    writer.add_if_key_not_found(tags::cpp::source_directory, source_directory);
    writer.add_if_key_not_found(tags::cpp::include_directory,
        include_directory);

    writer.add_if_key_not_found(
        sml::tags::code_generation_marker::message, empty);

    writer.add_if_key_not_found(
        sml::tags::code_generation_marker::add_warning,
        tags::bool_false);

    writer.add_if_key_not_found(
        sml::tags::code_generation_marker::add_date_time,
        tags::bool_false);

    writer.add_if_key_not_found(tags::generate_preamble, tags::bool_true);

    writer.add_if_key_not_found(tags::cpp::header_file_extension,
        cpp_header_extension);

    writer.add_if_key_not_found(tags::cpp::implementation_file_extension,
        cpp_implementation_extension);

    writer.add_if_key_not_found(tags::cpp::enable_facet_folders,
        tags::bool_true);

    writer.add_if_key_not_found(tags::cpp::enable_unique_file_names,
        tags::bool_true);

    writer.add_if_key_not_found(tags::cpp::forward_declaration_postfix,
        forward_decls_postfix);

    writer.add_if_key_not_found(tags::cpp::types::enabled, tags::bool_true);
    writer.add_if_key_not_found(tags::cpp::hash::standard::enabled,
        tags::bool_true);
    writer.add_if_key_not_found(tags::cpp::serialization::boost::enabled,
        tags::bool_true);
    writer.add_if_key_not_found(tags::cpp::io::enabled, tags::bool_true);
    writer.add_if_key_not_found(tags::cpp::test_data::enabled, tags::bool_true);
    writer.add_if_key_not_found(tags::cpp::odb::enabled, tags::bool_true);

    meta_data_reader reader(m.meta_data());
    if (reader.is_true(tags::cpp::types::enabled)) {
        writer.add_if_key_not_found(tags::cpp::types::directory_name,
            types_directory);

        writer.add_if_key_not_found(tags::cpp::types::postfix,
            types_postfix);

        // only generate a types file for models when there is
        // documentation for the model.
        if (!m.documentation().empty()) {
            writer.add_if_key_not_found(
                tags::cpp::types::header_file::generate, tags::bool_true);

            writer.add_if_key_not_found(
                tags::cpp::types::header_file::overwrite, tags::bool_true);

            // must massage the model name in order to generate the
            // correct file name for the model.
            qname qn(m.name());
            qn.simple_name(m.name().model_name());
            const auto fn(builder_.cpp_filename_for_qname(m.meta_data(),
                    is_header_file, qn,
                    reader.get(tags::cpp::types::directory_name),
                    reader.get(tags::cpp::types::postfix),
                    empty_postfix));

            writer.add_if_key_not_found(
                tags::cpp::types::header_file::file_name, fn);

            writer.add_if_key_not_found(
                tags::cpp::types::header_file::is_system, tags::bool_false);
        }

        qname qn;
        qn.simple_name(cpp_includer_file_name);
        qn.model_name(m.name().model_name());
        qn.external_module_path(m.name().external_module_path());
        const auto includers_fn(builder_.cpp_filename_for_qname(m.meta_data(),
                is_header_file, qn,
                reader.get(tags::cpp::types::directory_name),
                reader.get(tags::cpp::types::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::types::includers_file::file_name, includers_fn);

        writer.add_if_key_not_found(
            tags::cpp::types::includers_file::is_system, tags::bool_false);
    }

    if (reader.is_true(tags::cpp::hash::standard::enabled)) {
        writer.add_if_key_not_found(tags::cpp::hash::standard::directory_name,
            hash_directory);

        writer.add_if_key_not_found(tags::cpp::hash::standard::postfix,
            hash_postfix);

        qname qn;
        qn.simple_name(cpp_includer_file_name);
        qn.model_name(m.name().model_name());
        qn.external_module_path(m.name().external_module_path());
        const auto includers_fn(builder_.cpp_filename_for_qname(m.meta_data(),
                is_header_file, qn,
                reader.get(tags::cpp::hash::standard::directory_name),
                reader.get(tags::cpp::hash::standard::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::hash::standard::includers_file::file_name, includers_fn);

        writer.add_if_key_not_found(
            tags::cpp::hash::standard::includers_file::is_system,
            tags::bool_false);
    }

    if (reader.is_true(tags::cpp::serialization::boost::enabled)) {
        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::directory_name,
            serialization_directory);

        writer.add_if_key_not_found(tags::cpp::serialization::boost::postfix,
            serialization_postfix);

        qname qn;
        qn.simple_name(cpp_includer_file_name);
        qn.model_name(m.name().model_name());
        qn.external_module_path(m.name().external_module_path());
        const auto includers_fn(builder_.cpp_filename_for_qname(m.meta_data(),
                is_header_file, qn,
                reader.get(tags::cpp::serialization::boost::directory_name),
                reader.get(tags::cpp::serialization::boost::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::includers_file::file_name,
            includers_fn);

        writer.add_if_key_not_found(
            tags::cpp::serialization::boost::includers_file::is_system,
            tags::bool_false);
    }

    if (reader.is_true(tags::cpp::io::enabled)) {
        writer.add_if_key_not_found(tags::cpp::io::directory_name,
            serialization_directory);

        writer.add_if_key_not_found(tags::cpp::io::postfix,
            serialization_postfix);

        qname qn;
        qn.simple_name(cpp_includer_file_name);
        qn.model_name(m.name().model_name());
        qn.external_module_path(m.name().external_module_path());
        const auto includers_fn(builder_.cpp_filename_for_qname(m.meta_data(),
                is_header_file, qn, reader.get(tags::cpp::io::directory_name),
                reader.get(tags::cpp::io::postfix),
                empty_postfix));

        writer.add_if_key_not_found(tags::cpp::io::includers_file::file_name,
            includers_fn);

        writer.add_if_key_not_found(tags::cpp::io::includers_file::is_system,
            tags::bool_false);
    }

    if (reader.is_true(tags::cpp::test_data::enabled)) {
        writer.add_if_key_not_found(tags::cpp::test_data::directory_name,
            test_data_directory);

        writer.add_if_key_not_found(tags::cpp::test_data::postfix,
            test_data_postfix);

        qname qn;
        qn.simple_name(cpp_includer_file_name);
        qn.model_name(m.name().model_name());
        qn.external_module_path(m.name().external_module_path());
        const auto includers_fn(builder_.cpp_filename_for_qname(m.meta_data(),
                is_header_file, qn,
                reader.get(tags::cpp::test_data::directory_name),
                reader.get(tags::cpp::test_data::postfix),
                empty_postfix));

        writer.add_if_key_not_found(
            tags::cpp::test_data::includers_file::file_name,
            includers_fn);

        writer.add_if_key_not_found(
            tags::cpp::test_data::includers_file::is_system,
            tags::bool_false);
    }

    if (reader.is_true(tags::cpp::odb::enabled)) {
        writer.add_if_key_not_found(tags::cpp::odb::directory_name,
            odb_directory);

        writer.add_if_key_not_found(tags::cpp::odb::postfix, odb_postfix);

        qname qn;
        qn.simple_name(cpp_includer_file_name);
        qn.model_name(m.name().model_name());
        qn.external_module_path(m.name().external_module_path());
        const auto includers_fn(builder_.cpp_filename_for_qname(m.meta_data(),
                is_header_file, qn, reader.get(tags::cpp::odb::directory_name),
                reader.get(tags::cpp::odb::postfix),
                empty_postfix));

        writer.add_if_key_not_found(tags::cpp::odb::includers_file::file_name,
            includers_fn);

        writer.add_if_key_not_found(tags::cpp::odb::includers_file::is_system,
            tags::bool_false);
    }

    all_model_items_traversal(m, *this);
    context_ = std::unique_ptr<context>();
}

void meta_data_tagger::tag(const config::cpp_settings& s, model& m) const {
    from_settings(s, m);
    tag(m);
}

} }
#+end_src

Spec:

#+begin_src
#include <array>
#include <boost/throw_exception.hpp>
#include <boost/test/unit_test.hpp>
#include <boost/filesystem/path.hpp>
#include <boost/algorithm/string/predicate.hpp>
#include "dogen/config/test/mock_settings_factory.hpp"
#include "dogen/config/io/cpp_settings_io.hpp"
#include "dogen/utility/test/asserter.hpp"
#include "dogen/utility/test/logging.hpp"
#include "dogen/sml/types/tags.hpp"
#include "dogen/sml/types/model.hpp"
#include "dogen/sml/types/meta_data_error.hpp"
#include "dogen/sml/types/object.hpp"
#include "dogen/sml/io/model_io.hpp"
#include "dogen/sml/io/qname_io.hpp"
#include "dogen/sml/io/object_io.hpp"
#include "dogen/utility/test/exception_checkers.hpp"
#include "dogen/sml/test/mock_model_factory.hpp"
#include "dogen/sml/types/meta_data_tagger.hpp"

using dogen::config::test::mock_settings_factory;
using dogen::sml::meta_data_error;

namespace {

const std::string test_module("sml");
const std::string test_suite("meta_data_tagger_spec");

using dogen::sml::test::mock_model_factory;
const mock_model_factory::flags flags(false/*tagged*/, false/*resolved*/,
    false/*merged*/, false/*concepts_indexed*/, false/*properties_indexed*/);
const mock_model_factory model_factory(flags);

const std::string default_cpp_forward_declaration_postfix("_fwd");
const std::string default_cpp_implementation_file_extension(".cpp");
const std::string default_cpp_header_file_extension(".hpp");
const std::string default_cpp_types_directory("types");

bool has(const boost::property_tree::ptree& tags, const std::string& key) {
    const auto node(tags.get_optional<std::string>(key));
    return node;
}

std::string
get(const boost::property_tree::ptree& tags, const std::string& key) {
    const auto node(tags.get_optional<std::string>(key));
    if (!node)
        BOOST_THROW_EXCEPTION(meta_data_error("could not find key: " + key));

    return node->data();
}

bool is_true(const boost::property_tree::ptree& tags, const std::string& key) {
    const auto value(get(tags, key));
    return value == dogen::sml::tags::bool_true;
}

}

using dogen::utility::test::contains_checker;
using dogen::utility::test::asserter;

BOOST_AUTO_TEST_SUITE(meta_data_tagger)

BOOST_AUTO_TEST_CASE(tagging_empty_model_without_any_configuration_options_results_in_expected_tags) {
    SETUP_TEST_LOG_SOURCE("tagging_empty_model_without_any_configuration_options_results_in_expected_tags");

    auto m(model_factory.build_empty_model());
    dogen::sml::meta_data_tagger t;
    t.tag(m);
    BOOST_LOG_SEV(lg, debug) << "m: " << m;

    BOOST_CHECK(!m.meta_data().empty());
    using dogen::sml::tags;
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::types::enabled));

    boost::filesystem::path fn;
    fn /= m.name().model_name();
    fn /= default_cpp_types_directory;
    fn /= m.name().model_name() + default_cpp_header_file_extension;
    BOOST_CHECK(get(m.meta_data(), tags::cpp::types::header_file::file_name) ==
        fn.generic_string());

    BOOST_CHECK(get(m.meta_data(), tags::cpp::types::directory_name) ==
        default_cpp_types_directory);

    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::enable_unique_file_names));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::enable_facet_folders));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::enable_facet_folders));
    BOOST_CHECK(is_true(m.meta_data(), tags::generate_preamble));
    BOOST_CHECK(get(m.meta_data(), tags::cpp::forward_declaration_postfix) ==
        default_cpp_forward_declaration_postfix);
    BOOST_CHECK(get(m.meta_data(), tags::cpp::implementation_file_extension) ==
        default_cpp_implementation_file_extension);
    BOOST_CHECK(get(m.meta_data(), tags::cpp::header_file_extension) ==
        default_cpp_header_file_extension);
}

BOOST_AUTO_TEST_CASE(tagging_empty_model_with_all_facets_enabled_results_in_expected_tags) {
    SETUP_TEST_LOG_SOURCE("tagging_empty_model_with_all_facets_enabled_results_in_expected_tags");

    auto m(model_factory.build_empty_model());
    const auto s(mock_settings_factory::build_cpp_settings());
    BOOST_LOG_SEV(lg, debug) << "s: " << s;

    dogen::sml::meta_data_tagger t;
    t.tag(s, m);
    BOOST_LOG_SEV(lg, debug) << "m: " << m;

    BOOST_CHECK(!m.meta_data().empty());
    using dogen::sml::tags;
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::types::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::types::directory_name));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::hash::standard::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::hash::standard::directory_name));
    BOOST_CHECK(is_true(m.meta_data(),
            tags::cpp::serialization::boost::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::serialization::boost::directory_name));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::io::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::io::directory_name));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::test_data::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::test_data::directory_name));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::odb::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::odb::directory_name));
}

BOOST_AUTO_TEST_CASE(tagging_empty_model_with_a_few_facets_enabled_results_in_expected_tags) {
    SETUP_TEST_LOG_SOURCE("tagging_empty_model_with_a_few_facets_enabled_results_in_expected_tags");

    auto m(model_factory.build_empty_model());
    auto s(mock_settings_factory::build_cpp_settings());
    s.enabled_facets().clear();
    s.enabled_facets().insert(dogen::config::cpp_facet_types::types);
    s.enabled_facets().insert(dogen::config::cpp_facet_types::odb);
    s.enabled_facets().insert(dogen::config::cpp_facet_types::test_data);

    dogen::sml::meta_data_tagger t;
    t.tag(s, m);
    BOOST_LOG_SEV(lg, debug) << "m: " << m;

    BOOST_CHECK(!m.meta_data().empty());
    using dogen::sml::tags;
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::types::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::types::directory_name));
    BOOST_CHECK(!is_true(m.meta_data(), tags::cpp::hash::standard::enabled));
    BOOST_CHECK(!has(m.meta_data(), tags::cpp::hash::standard::directory_name));
    BOOST_CHECK(!is_true(m.meta_data(),
            tags::cpp::serialization::boost::enabled));
    BOOST_CHECK(!has(m.meta_data(),
            tags::cpp::serialization::boost::directory_name));
    BOOST_CHECK(!is_true(m.meta_data(), tags::cpp::io::enabled));
    BOOST_CHECK(!has(m.meta_data(), tags::cpp::io::directory_name));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::test_data::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::test_data::directory_name));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::odb::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::odb::directory_name));
}

BOOST_AUTO_TEST_CASE(tagging_single_type_model_with_all_facets_enabled_results_in_expected_tags) {
    SETUP_TEST_LOG_SOURCE("tagging_single_type_model_with_all_facets_enabled_results_in_expected_tags");

    auto m(model_factory.build_single_type_model());
    auto s(mock_settings_factory::build_cpp_settings());

    dogen::sml::meta_data_tagger t;
    t.tag(s, m);
    BOOST_LOG_SEV(lg, debug) << "m: " << m;

    BOOST_CHECK(!m.meta_data().empty());
    using dogen::sml::tags;
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::types::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::types::directory_name));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::hash::standard::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::hash::standard::directory_name));
    BOOST_CHECK(is_true(m.meta_data(),
            tags::cpp::serialization::boost::enabled));
    BOOST_CHECK(has(m.meta_data(),
            tags::cpp::serialization::boost::directory_name));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::io::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::io::directory_name));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::test_data::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::test_data::directory_name));
    BOOST_CHECK(is_true(m.meta_data(), tags::cpp::odb::enabled));
    BOOST_CHECK(has(m.meta_data(), tags::cpp::odb::directory_name));
}

BOOST_AUTO_TEST_SUITE_END()
#+end_src

