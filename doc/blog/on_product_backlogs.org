#+title: Nerd Food: On Product Backlog
#+options: date:nil toc:nil author:nil num:nil title:nil

#+begin_html
<table border="0">
<tr>
<td width="50%"></td>
<td width="50%"><p class="verse" style="text-align:left">
<small>
Would be be good to have a better bug-tracking setup? Yes.
But I think it takes man-power, and it would take something
*fundamentally* better than bugzilla. <i>-- Linus</i>
</small>
</p></td>
</tr>
</table>
#+end_html

Many developers in large companies tend to be exposed to a strange
variation of agile which I like to call "Enterprise Grade Agile", but
I've also heard it called "Fragile" and, most aptly, "Cargo-Cult
Agile". However you decide to name the phenomena, the gist of it is
that these setups contain nearly all of the ceremony of agile -
including stand-ups, sprint planning, retrospectives and so on - but
none of its spirit. Tweets such as this are great at capturing the
essence of the problem:

#+begin_html
<blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">Top
tip: if you need to bring a notepad to the daily stand up to tell us
what you did yesterday that&#39;s too many details</p>&mdash; Fran
Buontempo (@fbuontempo) <a
href="https://twitter.com/fbuontempo/status/686856528696086528">January
12, 2016</a></blockquote> <script async
src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
#+end_html

Once you start having that nagging feeling of doing things "because
you are told to", and once your stand-ups become more of a status
report to the "project manager" and/or "delivery manager" - the
existence of which, in itself, is rather worrying - your Cargo Cult
Agile alarm bells should start ringing. As I see it, agile is a
toolbox with a number of tools, and they only start to add value once
you've adapted them to your personal circumstances. The fitness
function that determines if a tool should be used is how much value it
adds to all (or at least most) of its users. If it does not, the tool
must be further adapted or removed altogether. And, crucially, you
learn about agile tools by using them and by reflecting on the lessons
learned. There is no other way.

This post is one such exercise and the tool I'd like to reflect on is
the /Product Backlog/. Now, before you read through the whole rant,
its probably worth saying that this post takes a slightly narrow and
somewhat "advanced" view of agile, with a target audience of those
already using it. If you require a more introductory approach, you are
probably better off looking at other online resources such as [[http://zerodollarbill.blogspot.co.uk/2012/06/how-to-learn-scrum-in-10-minutes-and.html][How to
learn Scrum in 10 minutes and clean your house in the process]]. Having
said that, I'll try to define terms best I can to make sure we are all
on the same page.

* Working Definition

Once your company has grokked the basics of agile and starts to move
away from those lengthy specification documents - those that no one
reads properly until implementation and those that never specified
anything the customer wanted, but everything we thought the customer
wanted and then some - you will start to use the product backlog in
anger. And that's when you will realise that it is not quite as simple
as memorising text books.

So what do the "text books" say? Let's take a fairly typical
definition - this one from [[https://en.wikipedia.org/wiki/Scrum_(software_development)][Scrum]]:

#+begin_quote
The agile product backlog in Scrum is a prioritized features list,
containing short descriptions of all functionality desired in the
product. When applying Scrum, it's not necessary to start a project
with a lengthy, upfront effort to document all
requirements. Typically, a Scrum team and its product owner begin by
writing down everything they can think of for agile backlog
prioritization. This agile product backlog is almost always more than
enough for a first sprint. The Scrum product backlog is then allowed
to grow and change as more is learned about the product and its
customers.[fn:definition]
#+end_quote

This is a good working definition, which will suffice for the purposes
of this post. It is deceptively simple. However, as always, one must
remember Yogi Berra: "In theory, there is no difference between theory
and practice. But in practice, there is."

* The "Potmenkin Product Backlog"

Many teams finish reading one such definition, find it amazingly
inspiring, install the "agile plug-in" on their bug-tracking software
of choice and then furiously start typing in those tickets. But if you
look closely, you'd be hard-pressed to find any difference between the
bug tickets of old versus the "user stories" in the new and improved
"product backlog" that apparently you are now using.

This is a classic management disconnect, whereby a renaming exercise
is applied and suddenly, [[https://en.wikipedia.org/wiki/Potemkin_village][Potemkin village-style]], we are now in with
the kool kids and our company suddenly becomes a modern and desirable
place to work. But much like Potemkin villages were not designed for
real people to live in, so "Potmenkin Product Backlogs" are not
designed to help you manage the lifecycle of a real product; they are
there to give you the /appearance/ of doing said management, for the
purposes of reporting to the higher eschelons and so that you can tell
stakeholders that "their story has been added to the product backlog
for prioritisation".

Alas, very soon you will find that the bulk of the "user stories" are
nothing but glorified one-liners that no one seems to recall what
exactly they're supposed to mean, and those few elaborately detailed
tickets end up rotting because they keep being deprioritised and now
describe a world long gone. Soon enough you will find that your sprint
planning meetings will cover less and less of the product backlog -
after all, who is able to prioritise this mess?  Some stories don't
even make any sense! The final act is when all stories worked on are
stories raised directly on the sprint backlog, and the product backlog
is nothing but the dumping ground for the stories that didn't make it
on a given sprint. At this stage, the product backlog is in such a
terrible mess that no one looks at it, other than for the occasional
historic search for valuable details of how a bug was
fixed. Eventually the product backlog is zeroed - maybe a dozen or so
of the most recent stories make it through the cull - and the entire
process begins anew, but enlightenment is never achieved.

As expected, the Potmenkin Product Backlog adds very little value - in
fact it can be argued that it detracts value - but it must be kept
because "agile requires a product backlog".

* Bug-Trackers: Lessons From History

In order to understand the difficulties with a product backlog we
should turn to their logical predecessors: bug-tracking systems such
as [[https://www.bugzilla.org/][Bugzilla]] or [[https://www.atlassian.com/software/jira][Jira]]. This post starts with a quote from the kernel's
Benevolent Dictator that illustrates the problem with these. Linus has
long taken the approach that there is no need for a bug-tracker in
kernel development, although he does not object if someone wants to
use one for a subsystem. You may think this is a very primitive
approach but in some ways it is also a /very/ modern approach, very
much in line with agile; if you have a bug-tracking system which is
taking time away from developers without providing any value, you
should /remove/ the bug-tracking system. In kernel development, there
simply is no space for ceremony - or, for that matter, for anything
which slows things down[fn:evolution].

All of which begs the question: what makes bug-tracking systems so
useless? From experience, there are a few factors:

- they are a "fire and forget" capture system. Most users only care
  about entering new data, rather than worrying about the lifecycle of
  a ticket. Very few places have some kind of "ticket quality control"
  which ensures that the content of the ticket is vaguely sensible,
  and those who do suffer from another problem:
- they require dedicated teams. By this I don't just mean running the
  bug-tracking software - which you will most likely have to do in a
  proprietary shop; I also mean the entire notion of Q&A and Testing
  as separate from development, with reams of people dedicated to
  setting "environments" up (and keeping them up!), organising
  database restores and other practices that are not compatible with
  current practices in software development.
- they are temples of ceremony: a glance at the myriad of fields you
  need to fill in - and the rules and permutations required to get
  them exactly right - should be sufficient to put off even the most
  ardent believer in process. Most developers end up memorising some
  safe incantation that allows them to get on with life, without
  understanding the majority of the data they are entering.
- as the underlying product ages, you will be faced with [[http://tinyletter.com/programming-beyond-practices/letters/the-sad-graph-of-software-death][the sad graph
  of software death]]. The main problem is that resources get taken away
  from systems as they get older, a phenomena that manifests itself as
  a growth in the delta between the number of open tickets against the
  number of closed tickets. This is actually a /really/ useful metric
  but one that is often ignored.[fn:maintenance].

And what of the newest iterations on this venerable concept such as
[[https://guides.github.com/features/issues/][GitHub Issues]]? Well, clearly they solve a number of the problems
above - such as lowering the complexity and cost barriers - and
certainly they do serve a very useful purpose: they allow the
efficient management of user interactions. Every time I create an
issue - such as this [[https://github.com/flycheck/flycheck/issues/852][one]] - it never ceases to amaze me how easily the
information flows within GitHub projects; one can initiate comms with
the author(s) or other users with /zero setup/ - something that
previously required mailinglist membership, opening an account on a
bug-tracker and so forth. We now take all of this for granted, of
course, but it is important to bear in mind that many open source
projects would probably not even have any form of user interaction
support were it not for GitHub. After all, most of them are a
one-person shop with very little disposable time, and it makes no
sense to spend part of that time maintaining infrastructure for the
odd person or two who may drop by to chat.

However, for all of its glory, it is also important to bear in mind
that GitHub Issues is *not* a product backlog solution. What I mean by
this is that the product backlog must be owned by the team that owns
the product and, as we shall see, it must be carefully groomed if it
is to be continually useful. This is at loggerheads with allowing free
flow of information from users. Your Issues will eventually be filled
up with user requests and questions which you may not want to address,
or general discussions which may or may not have a user story behind
it. They are simply different tools for different jobs, albeit with an
overlap of functionality.

So, history tells us what does not work. But what do we want from a
product backlog?

* Voyaging Through Strange Seas of Thought

One of the great things about agile is how much it reflects on itself;
a strange loop of sorts. Presentations such as Kevlin Henney's [[http://www.infoq.com/presentations/architecture-uncertainty][The
Architecture of Uncertainty]] are part of this continual process of
discovery and understanding, and provide great insights about the
fundamental nature of the development process. The product backlog
plays - or should play - a crucial role exactly because of this
uncertain nature of software development. We can explain this by way
of a device.

Imagine that you start off by admitting that you know very little
about what it is that you are intending to do and that the problem
domain you are about to explore is vast and complex. In this scenario,
the product backlog is the sum of the knowledge gained whilst
exploring this space, like explorer's maps were in the
fifteen-hundreds. In those days, "users" knew that much of it was
incorrect and a great part was sketchy and ill-defined, but it was all
you had. Given that the odds of success were stacked against you,
you'd hold that map pretty tightly while the storms were raging about
you. Those that made it back would provide corrections and amendments
and, over time, the maps eventually converged with the real geography.

The product backlog does something similar, but of course, the space
you are exploring does not have a fixed geometry or topography and
your knowledge of the problem domain can actively /change/ the domain
itself too - an unavoidable consequence of dealing with pure thought
stuff. But the general principle applies. Thus, in the same way [[http://www.joelonsoftware.com/articles/fog0000000069.html][a code
base is precious]] because it embodies the sum total knowledge of a
domain - heck, in many ways it /is/ the sum total knowledge of a
domain! - so the product backlog is precious because it captures all
the known knowledge of these yet-to-be-explored areas. In this light,
you can understand statements such as this:

#+begin_html
<blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">
When your product backlog is empty, your product is dead -
<a href="https://twitter.com/KevlinHenney">@KevlinHenney</a>
<a href="https://twitter.com/hashtag/agileotb?src=hash">#agileotb</a>
</p>&mdash; Marc Johnson (@marcjohnson)
<a href="https://twitter.com/marcjohnson/status/507522331900915712">
September 4, 2014</a>
</blockquote>
<script async src="//platform.twitter.com/widgets.js"
charset="utf-8"></script>
#+end_html

So, if the backlog is this important, how should one manage it?

* Back To Basics

There are three things to consider: how stories get into the product
backlog, how they are managed once they are there and how they exit
the product backlog. All of these are of extreme importance.

You


One of the most enlightening things I learned with Dogen was how
useful it is to use plain text files to manage most of my agile


[fn:definition] [[https://www.mountaingoatsoftware.com/agile/scrum/product-backlog][Scrum Product Backlog]], from Mountain Goat Software.

[fn:evolution] A topic which I covered some time ago here: [[http://mcraveiro.blogspot.co.uk/2008/06/nerd-food-on-evolutionary-methodology.html][On
Evolutionary Methodology]]. It is also interesting to see how the kernel
processes are organised for speed: [[http://lwn.net/Articles/670209/][How 4.4's patches got to the
mainline]].

[fn:maintenance] Another topic which I also covered here some time
ago: [[http://mcraveiro.blogspot.co.uk/2007/05/nerd-food-on-maintenance.html][On Maintenance]].

[fn:github]
was reminded of this usefuln
