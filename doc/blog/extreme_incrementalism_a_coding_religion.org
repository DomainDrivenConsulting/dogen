#+title: Nerd Food: Extreme Incrementalism: A Coding Religion
#+options: date:nil toc:nil author:nil num:nil title:nil

A lot of interesting lessons have been learned during the development
of Dogen and I'm rather afraid many more are still in store. As it is
typical with the agile process, I'm constantly reviewing what went
right and what went wrong. I thought I'd put pen to paper with some of
these, In the vain hope of them being of general interest.

One of the major wins in terms of development process was to think
incrementally. Of course, agile already gives you a mental framework
for that, and we had a perfectly functioning agile process during our
start up days - the time of the inception of Dogen. However, with the
tearing down of the start up and the return to gainful employment,
agile soon revealed itself to be far too coarse grained.

When I decided to continue developing Dogen on my spare time, I had
two conflicting requirements: very little development resources and
very ambitious ideas that required lots of work. The development
resource was, well, just me. With a family and a full time job there
isn't a lot of spare cycles left. In fact, after some analysis, I
realised I was in a conundrum. Whilst there is was a lot of
"dead-time" in the average week, it was mostly "low-quality grade
time": lots of discontinued segments of varying and unpredictable
lengths. Summed together in a naive way it seemed like a lot, but - as
every programmer knows - six blocks of ten minutes do not one solid
hour make.

Nevertheless, one has to play the game with the cards that were dealt.
Soon I realised that the correct question to ask was: "what kind of
development environment would be required such that one can be
productive given these conditions?"

As it turns out, the answer is multi-part - just like MIME.

* DVCS is at the core

We had already started to use git during the start-up days, and it had
proved to be a major win at the time. After all, one never quite knows
where one will be coding from - and whether internet access is
available or not - so its important to have a self-contained
environment. In the end we found out it brought many, many more
advantages such as great collaborative flows, good managed web
interfaces/hosting providers ([[http://www.github.com][GitHub]] and, to some extent, [[http://www.bitbucket.com][BitBucket]]),
amazing raw speed even on low-powered machines, and many other
wins. Since most of it is covered elsewhere, I won't bore you with it.

However, one decision that turned out to be a major win is still not
the done thing. Ever the trailblazers, we decided to put everything
related to the project in version control. And by "everything" I do
mean *everything*: documentation, bug reports, agile process, blog
posts, the whole lot. It did seem a bit silly not to use GitHub's Wiki
and Issues at the time, but, on hindsight, having everything in one
versioned controlled place proved to be a major win:

- searching is never further than a couple of greps away, and its not
  sensitive to connectivity;
- updates by other people come in as commits and can be easily
  reviewed as part of the normal push/pull process;
- changes can easily be diffed;
- history can be checked using the familiar version control interface,
  which is available wherever you go.

When you have little time, these little advantages are life-savers.

The second and very important lesson learned was to commit early and
commit often. Its rather obvious in hindsight, really. After all, if
you have very small blocks of time to do work, you want to make sure
you don't break anything; last thing you need is to spend a week
debugging a tricky problem, with no idea of where you're going or how
far you still have to travel. So its important to make your commits
/very small/ and /very focused/ such that a bisection would almost
immediately reveal a problem - or at least provide you with an obvious
rollback strategy. This has proved itself to be invaluable, far too
many times to count. The gist of this approach it is to split changes
in an almost OCD sort of way, to the point that anyone can look at the
commit comment and the commit diff and make a judgement as to whether
the change was correct or not. To be fair, its not quite always that
straightforward, but that has been the overall aim.

* Continuously Integrated

After the commit comes the build, and the proof is in the pudding, as
they say. When it comes to code, that largely means CI; granted, it
may not be a very reliable proof, but nevertheless it is the best
proof we've got. One of the major wins from the start up days was to
setup CI, and to give it as wide a coverage as we could muster. We
setup multiple build agents across compilers and platforms, added
dynamic analysis, code coverage, packaging and basic sanity tests on
those packages.

The packaging idea was a good one - after all, most users will
probably rely on those - but providing packages turned out to be
harder than first thought. This is because GitHub decommissioned their
downloads section.





I even gave it a name: /Extreme Incrementalism/ or EI for
short. As you can see, the name fits well with the spirit of
"overreaching naming conventions", typically used for development
methodologies. Opportunistic coding.
