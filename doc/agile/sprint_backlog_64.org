#+title: Sprint Backlog 64
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission

Finish implementing stitch and stitcher and create the first
formatters using it.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2015-04-21 Tue 16:08]

| Headline                                                | Time    |       |      |
|---------------------------------------------------------+---------+-------+------|
| *Total time*                                            | *21:11* |       |      |
|---------------------------------------------------------+---------+-------+------|
| Active                                                  |         | 21:11 |      |
| STARTED Sprint and product backlog grooming             |         |       | 1:07 |
| COMPLETED Create a formatting utilities class           |         |       | 1:17 |
| COMPLETED Implement a basic formatter in stitch         |         |       | 3:02 |
| COMPLETED Fix build errors in Windows and Linux 32-bit  |         |       | 0:28 |
| COMPLETED Create a stitch workflow                      |         |       | 2:22 |
| COMPLETED Add expander that computes output path        |         |       | 1:04 |
| COMPLETED Add support for dynamic extensions in stitch  |         |       | 3:44 |
| COMPLETED Refactor =knit= workflows                     |         |       | 2:10 |
| COMPLETED Use =formatters::file= in legacy formatters   |         |       | 2:28 |
| COMPLETED Move outputters from knit to formatters model |         |       | 1:22 |
| COMPLETED Implement file writing in stitch              |         |       | 1:38 |
| COMPLETED Add test coverage to stitch's workflow        |         |       | 0:29 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-04-21 Tue 15:26]--[2015-04-21 Tue 15:39] =>  0:13
    CLOCK: [2015-04-20 Mon 22:53]--[2015-04-20 Mon 23:01] =>  0:08
    CLOCK: [2015-04-18 Sat 06:41]--[2015-04-18 Sat 07:15] =>  0:34
    CLOCK: [2015-04-15 Wed 16:10]--[2015-04-15 Wed 16:15] =>  0:05
    CLOCK: [2015-04-13 Mon 07:04]--[2015-04-13 Mon 07:11] =>  0:07

Updates to sprint and product backlog.

*** STARTED Updates to the manual and readme files                    :story:

Use downtime to update the manual and / or readme file.

*** COMPLETED Create a formatting utilities class                     :spike:
    CLOSED: [2015-04-13 Mon 19:05]
    CLOCK: [2015-04-13 Mon 17:04]--[2015-04-13 Mon 18:05] =>  1:01
    CLOCK: [2015-04-13 Mon 16:48]--[2015-04-13 Mon 17:04] =>  0:16

The stitch formatter needs to make use of basic features such as
quoting etc. This is a good time to tidy-up the old utilities
formatter.

*** COMPLETED Implement a basic formatter in stitch                   :story:
    CLOSED: [2015-04-14 Tue 19:44]
    CLOCK: [2015-04-14 Tue 19:29]--[2015-04-14 Tue 19:44] =>  0:15
    CLOCK: [2015-04-14 Tue 19:12]--[2015-04-14 Tue 19:28] =>  0:16
    CLOCK: [2015-04-14 Tue 17:40]--[2015-04-14 Tue 19:11] =>  1:31
    CLOCK: [2015-04-13 Mon 18:05]--[2015-04-13 Mon 19:05] =>  1:00

We need to create a formatter in stitch that can implement the trivial
use cases we have covered with the parser. We must also start creating
a stitch template for the formatter and perhaps implement the stitch
output manually just to give stitch a target.

Actually, a stitch template does not make a lot of sense. This is
because stitch has nothing to add to the output other than what it
reads from its object model. So the template would contain nothing but
c++ code, with very little text.

*** COMPLETED Fix build errors in Windows and Linux 32-bit            :story:
    CLOSED: [2015-04-18 Sat 07:14]
    CLOCK: [2015-04-13 Mon 15:50]--[2015-04-13 Mon 16:18] =>  0:28

It seems a number of test models are failing in the knitting tests for
both Windows and Linux 32-bit. Looking at the diffs it seems the
problems are in the includers. This is likely to be due to the new
sorting algorithm, that does not take into account cases where the
sorting criteria is identical all the way to the size of the
string. This then means its the luck of the draw for these strings.

We need to add further criteria to disambiguate strings.

*** COMPLETED Create a stitch workflow                                :story:
    CLOSED: [2015-04-18 Sat 07:15]
    CLOCK: [2015-04-16 Thu 22:10]--[2015-04-16 Thu 22:32] =>  0:22
    CLOCK: [2015-04-15 Wed 22:25]--[2015-04-15 Wed 22:41] =>  0:16
    CLOCK: [2015-04-15 Wed 20:13]--[2015-04-15 Wed 21:23] =>  1:10
    CLOCK: [2015-04-15 Wed 17:26]--[2015-04-15 Wed 18:00] =>  0:34

We need to implement a workflow that reads in the fields, parses the
template, formats it and writes it to file.

*** COMPLETED Add expander that computes output path                  :story:
    CLOSED: [2015-04-18 Sat 07:15]
    CLOCK: [2015-04-17 Fri 21:20]--[2015-04-17 Fri 21:38] =>  0:18
    CLOCK: [2015-04-16 Thu 07:36]--[2015-04-16 Thu 08:22] =>  0:46

We need to compute the output path and populate it in the file
generated by the formatter.

*** COMPLETED Add support for dynamic extensions in stitch            :story:
    CLOSED: [2015-04-18 Sat 07:15]
    CLOCK: [2015-04-15 Wed 16:00]--[2015-04-15 Wed 16:10] =>  0:10
    CLOCK: [2015-04-15 Wed 14:42]--[2015-04-15 Wed 15:59] =>  1:17
    CLOCK: [2015-04-15 Wed 14:26]--[2015-04-15 Wed 14:42] =>  0:16
    CLOCK: [2015-04-15 Wed 13:29]--[2015-04-15 Wed 14:26] =>  0:57
    CLOCK: [2015-04-14 Tue 20:33]--[2015-04-14 Tue 20:49] =>  0:16
    CLOCK: [2015-04-14 Tue 19:44]--[2015-04-14 Tue 20:32] =>  0:48

There are a number of things that would be useful in stitch:

- boilerplate formatters: we could do with licence etc. We need to
  move this code into =formatters=, into a =cpp= namespace. This
  includes inclusion.
- we need a file path field that is computed if the user has passed in
  the template file path. The expansion performs this computation (so
  we need expansion).
- we need include dependencies support. Users add includes and we
  extract them and pass them over to boilerplate.

*** COMPLETED Refactor =knit= workflows                               :story:
    CLOSED: [2015-04-19 Sun 22:45]
    CLOCK: [2015-04-19 Sun 21:52]--[2015-04-19 Sun 22:44] =>  0:52
    CLOCK: [2015-04-19 Sun 21:02]--[2015-04-19 Sun 21:51] =>  0:49
    CLOCK: [2015-04-18 Sat 20:58]--[2015-04-18 Sat 21:25] =>  0:27
    CLOCK: [2015-04-18 Sat 07:16]--[2015-04-18 Sat 07:18] =>  0:02

Create a backend workflow that has activities for each
backend. Actually create two sub-workflows: sml model workflow and
backend workflow. Then create a top-level workflow that calls both.

*** COMPLETED Use =formatters::file= in legacy formatters             :story:
    CLOSED: [2015-04-20 Mon 18:56]
    CLOCK: [2015-04-20 Mon 17:31]--[2015-04-20 Mon 18:56] =>  1:25
    CLOCK: [2015-04-20 Mon 15:35]--[2015-04-20 Mon 16:38] =>  1:03

We should make use of formatters file in preparation for using the new
world formatters.

- remove all of the typedefs in outputters, cpp_formatters, etc.
- cpp formatters to start creating formatters::file
- housekeeper to create a map of files if required; actually, add
  activity that generates the set.

*** COMPLETED Minor refactor to legacy =backend=                      :story:
    CLOSED: [2015-04-20 Mon 18:57]

We should take this opportunity to make the legacy backend a bit more
manageable.

- cpp_backend to be split into activities: transform, legacy generate,
  new world overwrite.
- rename backend to backend interface
- pass the model into the generate method of the backend

*** COMPLETED Move outputters from knit to formatters model           :story:
    CLOSED: [2015-04-20 Mon 22:53]
    CLOCK: [2015-04-20 Mon 21:55]--[2015-04-20 Mon 22:53] =>  0:58
    CLOCK: [2015-04-18 Sat 06:22]--[2015-04-18 Sat 06:40] =>  0:45
    CLOCK: [2015-04-17 Fri 21:38]--[2015-04-17 Fri 21:44] =>  0:06

We need to move outputting to formatters so that it can be reused in
stitch.

- create and implement the writers in formatters.
- replace knit::outputters with formatters::writer

*** COMPLETED Implement file writing in stitch                        :story:
    CLOSED: [2015-04-21 Tue 15:32]
    CLOCK: [2015-04-21 Tue 14:02]--[2015-04-21 Tue 15:26] =>  1:24
    CLOCK: [2015-04-20 Mon 23:01]--[2015-04-20 Mon 23:15] =>  0:14

We need to start writing files in stitch by making use of formatter's
file writers. As part of this we need to get the workflow tests to
pass.

- we should remember the "last known indentation level" for a
  scriptlet line and use that for non-scriptlet lines. Actually, this
  does not work at all as we may not have the last indentation
  level. Lets leave indentation for later.
- we need to add diff/rebase support to the stitch test data set.

*** COMPLETED Add test coverage to stitch's workflow                  :story:
    CLOSED: [2015-04-21 Tue 16:07]
    CLOCK: [2015-04-21 Tue 15:38]--[2015-04-21 Tue 16:07] =>  0:29

*Final Understanding*

Instead of adding lots of test coverage, we will rely on the fact that
stitch (and stitcher) will be heavily used within dogen on all use
cases that we require it to cover. We just need a couple of basic
tests to prove that it is vaguely working.

*Previous Understanding*

We must make sure we don't start adding lots of pointless workflow
tests. Tests that are validating the formatter/parser behaviour
already exist so we don't have to worry about that. Objectives of
workflow tests are to answer these questions:

- do we write files in to the expected locations?
- do the files produce valid c++?
- does the c++ produce the expected template output?
- does the workflow itself work? i.e. the integration between parser,
  formatter, etc.

This means we probably just need a single positive test with a
template that makes use of all available features. We could also add a
few negative tests:

- template not found.
- invalid relative directory: tricky one to test as we are supposed to
  create one.
- invalid template: no need for lots of variations, just one.
- empty template: should generate an error. This is because we would
  not write to the correct directory (due to a lack of relative output
  path). Also we do not have any use cases for this.

A positive test that is required is running stitch against a directory
of templates.

*** STARTED Create a "supported" expander                             :story:

This needs a bit more analysis. The gist of it is that not all types
support all formatters. We need a way to determine if a formatter is
not supported. This probably should be inferred by a "is dogen model"
property (see backlog); e.g. non-dogen models need their types to have
an inclusion setup in order to be "supported", otherwise they should
default to "not-supported". However the "supported" flag is populated,
we then need to take into account relationships and propagate this
flag across the model such that, if a type =A= in a dogen model has a
property of a type =B= from a non-dogen model which does not support a
given formatter =f=, then =A= must also not support =f=.

In order to implement this feature we need to:

- update the SML grapher to take into account relationships
  (properties that the class has) as well as inheritance.
- we must only visit related types if we ourselves do not have values
  for all supported fields.
- we also need a visitor that detects cycles; when a cycle is found we
  simply assume that the status of the revisited class is true (or
  whatever the default value of "supported" is) and we write a warning
  to the log file. We should output the complete path of the cycle.
- users can override this by setting supported for all formatters
  where there are cycles.
- we could perhaps have a bitmask by qname; we could start by
  generating all bitmasks for all qnames and setting them to default
  value. We could then find all qnames that have supported set to
  false and update the corresponding bitmasks. Then we could use the
  graph to loop through the qnames and "and" the bitmasks of each
  qname with the bitmasks of their related qnames. The position of
  each field is allocated by the algorithm (e.g. the first "supported"
  field is at position 0 and so on). Actually the first position of
  the bitmask could be used to indicate if the bitmask has already
  been processed or not. In the presence of a cycle force it to true.
- we need a class that takes the SML model and computes the supported
  bitmasks for each qname; the supported expander then simply takes
  this (perhaps as part of the expansion context), looks up for the
  current qname and uses the field list to set the flags
  appropriately.
- we should remove all traces of supported from a settings
  perspective; supported and multi-level enabled are just artefacts of
  the meta-data. From a settings perspective, there is just a
  formatter level (common formatter settings) enabled which determines
  whether the formatter is on or off. How that flag came to be
  computed is not relevant outside the expansion process. This also
  means we can have simpler or more complex policies as time allows us
  improve on this story; provided we can at least set all flags to
  enabled we can move forward.

Solution for cycles:

- detect the cycle and then remember the pair (a, b) where b is the
  start of the cycle and a is the last vertex before the cycle. We
  should assume that a is (true, true) for the edge (a, b) and compute
  all other edges. Finally, once the graph has been processed we
  should check all of the pairs in a cycle; for these we should simply
  look at the values of b, and update a accordingly.

*** Get a trivial stitcher to work                                    :story:

Now that we have implemented most of stitch, we should get stitcher up
and running. All we need is a few command line options, maybe even
just one - the directory to process or the template to process.

We probably also need version and help.

*** Add support for inline code in stitch                             :story:

At present we do not support the =<#=xyz#>= and =<#+xyz#>= forms in
stitch. We need to support these.

*** Handling of managed directories is incorrect                      :story:

At present we are querying the dia to sml transformer to figure out
what the managed directories are. These are basically the top-level
directories from where we want the housekeeper to operate. In reality
this is (or can be placed) in the meta-data. We should be able to
extract the managed directories from the meta-data as a step in one of
the workflows.

This can be done by the backend. It does mean that we should be
returning a composite type from generation:

- list of files;
- list of managed directories.

Alternatively we could have a =managed_directories= method that takes
in an SML model and then internally reads in the meta-data for a given
model to produce the list.

*Merged with previous story*

Compute managed directories from knitting options

At present the backend is returning empty managed directories. This
means housekeeping will fail in the new world. We need to change the
interface of this method to take in the knitting options and return
the managed directories.

This is not entirely trivial. At present the managed directories are
computed in the locator. It takes into account split project, etc to
come up with all the directories used by the backend. We need to make
these decisions during path expansion, expect we only need manged
directories for the root object. However we do not know which object
is the root object at present, during the expansion. We could identify
it via the QName and the SML model in context thought. We could then
populate the managed directories as a text collection. We then need
some settings and a factory to pull out the managed directories from
the root object. This could be done in =managed_directories=, by
having an SML model as input.

*** Consider removing the overwrite flag in =formatters::file=        :story:

Investigate if the overwrite flag makes sense in file; it seems we
only use it in two scenarios: force overwrite requested by user or
file contents have changed, both of which can be done in the
file_writer.

Actually this flag is needed. It is required to handle the case where
we do not code-generate files, unless they do not exist. For example,
for service headers and implementation we should create the files, but
then subsequently not touch them. The overwrite flag should be set to
false. We need to figure out how to implement this and remove the
hacks around file writing.

*** Split knitting from stitching settings                            :story:

At present we only have a single common directory with all of the
available fields. Not all fields apply to both stitching and
knitting - but some do. We need a way to filter these. One possibility
is to use an approach similar to the formatter groups in the ownership
hierarchy. For now we simply have fields that have no meaning in
stitching but can be supplied by users.

*** Create a forward declarations formatter using stitch              :story:

We need to start making use of stitch in dogen. To start off with, we
will manually run the stitch command against a template to generate
the =cpp= file and include the header file from the formatter. We also
need to inject the stitch file name to the list of ignores, probably
by ignoring =*_stitch.cpp=, =*_stitch.hpp= and =*.stitch=. This should
avoid clashes with the source code of stitch itself.

** Deprecated
