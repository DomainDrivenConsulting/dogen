#+title: Sprint Backlog 64
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission

Finish implementing stitch and stitcher and create the first
formatters using it.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2015-04-19 Sun 22:46]

| Headline                                               | Time    |       |      |
|--------------------------------------------------------+---------+-------+------|
| *Total time*                                           | *15:17* |       |      |
|--------------------------------------------------------+---------+-------+------|
| Active                                                 |         | 15:17 |      |
| STARTED Sprint and product backlog grooming            |         |       | 0:46 |
| COMPLETED Create a formatting utilities class          |         |       | 1:17 |
| COMPLETED Implement a basic formatter in stitch        |         |       | 3:02 |
| COMPLETED Fix build errors in Windows and Linux 32-bit |         |       | 0:28 |
| COMPLETED Create a stitch workflow                     |         |       | 2:22 |
| COMPLETED Add expander that computes output path       |         |       | 1:04 |
| COMPLETED Add support for dynamic extensions in stitch |         |       | 3:44 |
| COMPLETED Refactor =knit= workflows                    |         |       | 2:10 |
| STARTED Move outputters from knit to formatters model  |         |       | 0:24 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-04-18 Sat 06:41]--[2015-04-18 Sat 07:15] =>  0:34
    CLOCK: [2015-04-15 Wed 16:10]--[2015-04-15 Wed 16:15] =>  0:05
    CLOCK: [2015-04-13 Mon 07:04]--[2015-04-13 Mon 07:11] =>  0:07

Updates to sprint and product backlog.

*** STARTED Updates to the manual and readme files                    :story:

Use downtime to update the manual and / or readme file.

*** COMPLETED Create a formatting utilities class                     :spike:
    CLOSED: [2015-04-13 Mon 19:05]
    CLOCK: [2015-04-13 Mon 17:04]--[2015-04-13 Mon 18:05] =>  1:01
    CLOCK: [2015-04-13 Mon 16:48]--[2015-04-13 Mon 17:04] =>  0:16

The stitch formatter needs to make use of basic features such as
quoting etc. This is a good time to tidy-up the old utilities
formatter.

*** COMPLETED Implement a basic formatter in stitch                   :story:
    CLOSED: [2015-04-14 Tue 19:44]
    CLOCK: [2015-04-14 Tue 19:29]--[2015-04-14 Tue 19:44] =>  0:15
    CLOCK: [2015-04-14 Tue 19:12]--[2015-04-14 Tue 19:28] =>  0:16
    CLOCK: [2015-04-14 Tue 17:40]--[2015-04-14 Tue 19:11] =>  1:31
    CLOCK: [2015-04-13 Mon 18:05]--[2015-04-13 Mon 19:05] =>  1:00

We need to create a formatter in stitch that can implement the trivial
use cases we have covered with the parser. We must also start creating
a stitch template for the formatter and perhaps implement the stitch
output manually just to give stitch a target.

Actually, a stitch template does not make a lot of sense. This is
because stitch has nothing to add to the output other than what it
reads from its object model. So the template would contain nothing but
c++ code, with very little text.

*** COMPLETED Fix build errors in Windows and Linux 32-bit            :story:
    CLOSED: [2015-04-18 Sat 07:14]
    CLOCK: [2015-04-13 Mon 15:50]--[2015-04-13 Mon 16:18] =>  0:28

It seems a number of test models are failing in the knitting tests for
both Windows and Linux 32-bit. Looking at the diffs it seems the
problems are in the includers. This is likely to be due to the new
sorting algorithm, that does not take into account cases where the
sorting criteria is identical all the way to the size of the
string. This then means its the luck of the draw for these strings.

We need to add further criteria to disambiguate strings.

*** COMPLETED Create a stitch workflow                                :story:
    CLOSED: [2015-04-18 Sat 07:15]
    CLOCK: [2015-04-16 Thu 22:10]--[2015-04-16 Thu 22:32] =>  0:22
    CLOCK: [2015-04-15 Wed 22:25]--[2015-04-15 Wed 22:41] =>  0:16
    CLOCK: [2015-04-15 Wed 20:13]--[2015-04-15 Wed 21:23] =>  1:10
    CLOCK: [2015-04-15 Wed 17:26]--[2015-04-15 Wed 18:00] =>  0:34

We need to implement a workflow that reads in the fields, parses the
template, formats it and writes it to file.

*** COMPLETED Add expander that computes output path                  :story:
    CLOSED: [2015-04-18 Sat 07:15]
    CLOCK: [2015-04-17 Fri 21:20]--[2015-04-17 Fri 21:38] =>  0:18
    CLOCK: [2015-04-16 Thu 07:36]--[2015-04-16 Thu 08:22] =>  0:46

We need to compute the output path and populate it in the file
generated by the formatter.

*** COMPLETED Add support for dynamic extensions in stitch            :story:
    CLOSED: [2015-04-18 Sat 07:15]
    CLOCK: [2015-04-15 Wed 16:00]--[2015-04-15 Wed 16:10] =>  0:10
    CLOCK: [2015-04-15 Wed 14:42]--[2015-04-15 Wed 15:59] =>  1:17
    CLOCK: [2015-04-15 Wed 14:26]--[2015-04-15 Wed 14:42] =>  0:16
    CLOCK: [2015-04-15 Wed 13:29]--[2015-04-15 Wed 14:26] =>  0:57
    CLOCK: [2015-04-14 Tue 20:33]--[2015-04-14 Tue 20:49] =>  0:16
    CLOCK: [2015-04-14 Tue 19:44]--[2015-04-14 Tue 20:32] =>  0:48

There are a number of things that would be useful in stitch:

- boilerplate formatters: we could do with licence etc. We need to
  move this code into =formatters=, into a =cpp= namespace. This
  includes inclusion.
- we need a file path field that is computed if the user has passed in
  the template file path. The expansion performs this computation (so
  we need expansion).
- we need include dependencies support. Users add includes and we
  extract them and pass them over to boilerplate.

*** COMPLETED Refactor =knit= workflows                               :story:
    CLOSED: [2015-04-19 Sun 22:45]
    CLOCK: [2015-04-19 Sun 21:52]--[2015-04-19 Sun 22:44] =>  0:52
    CLOCK: [2015-04-19 Sun 21:02]--[2015-04-19 Sun 21:51] =>  0:49
    CLOCK: [2015-04-18 Sat 20:58]--[2015-04-18 Sat 21:25] =>  0:27
    CLOCK: [2015-04-18 Sat 07:16]--[2015-04-18 Sat 07:18] =>  0:02

Create a backend workflow that has activities for each
backend. Actually create two sub-workflows: sml model workflow and
backend workflow. Then create a top-level workflow that calls both.

*** STARTED Create a "supported" expander                             :story:

This needs a bit more analysis. The gist of it is that not all types
support all formatters. We need a way to determine if a formatter is
not supported. This probably should be inferred by a "is dogen model"
property (see backlog); e.g. non-dogen models need their types to have
an inclusion setup in order to be "supported", otherwise they should
default to "not-supported". However the "supported" flag is populated,
we then need to take into account relationships and propagate this
flag across the model such that, if a type =A= in a dogen model has a
property of a type =B= from a non-dogen model which does not support a
given formatter =f=, then =A= must also not support =f=.

In order to implement this feature we need to:

- update the SML grapher to take into account relationships
  (properties that the class has) as well as inheritance.
- we must only visit related types if we ourselves do not have values
  for all supported fields.
- we also need a visitor that detects cycles; when a cycle is found we
  simply assume that the status of the revisited class is true (or
  whatever the default value of "supported" is) and we write a warning
  to the log file. We should output the complete path of the cycle.
- users can override this by setting supported for all formatters
  where there are cycles.
- we could perhaps have a bitmask by qname; we could start by
  generating all bitmasks for all qnames and setting them to default
  value. We could then find all qnames that have supported set to
  false and update the corresponding bitmasks. Then we could use the
  graph to loop through the qnames and "and" the bitmasks of each
  qname with the bitmasks of their related qnames. The position of
  each field is allocated by the algorithm (e.g. the first "supported"
  field is at position 0 and so on). Actually the first position of
  the bitmask could be used to indicate if the bitmask has already
  been processed or not. In the presence of a cycle force it to true.
- we need a class that takes the SML model and computes the supported
  bitmasks for each qname; the supported expander then simply takes
  this (perhaps as part of the expansion context), looks up for the
  current qname and uses the field list to set the flags
  appropriately.
- we should remove all traces of supported from a settings
  perspective; supported and multi-level enabled are just artefacts of
  the meta-data. From a settings perspective, there is just a
  formatter level (common formatter settings) enabled which determines
  whether the formatter is on or off. How that flag came to be
  computed is not relevant outside the expansion process. This also
  means we can have simpler or more complex policies as time allows us
  improve on this story; provided we can at least set all flags to
  enabled we can move forward.

Solution for cycles:

- detect the cycle and then remember the pair (a, b) where b is the
  start of the cycle and a is the last vertex before the cycle. We
  should assume that a is (true, true) for the edge (a, b) and compute
  all other edges. Finally, once the graph has been processed we
  should check all of the pairs in a cycle; for these we should simply
  look at the values of b, and update a accordingly.

*** STARTED Compute managed directories from knitting options         :story:

At present the backend is returning empty managed directories. This
means housekeeping will fail in the new world. We need to change the
interface of this method to take in the knitting options and return
the managed directories.

This is not entirely trivial. At present the managed directories are
computed in the locator. It takes into account split project, etc to
come up with all the directories used by the backend. We need to make
these decisions during path expansion, expect we only need manged
directories for the root object. However we do not know which object
is the root object at present, during the expansion. We could identify
it via the QName and the SML model in context thought. We could then
populate the managed directories as a text collection. We then need
some settings and a factory to pull out the managed directories from
the root object. This could be done in =managed_directories=, by
having an SML model as input.

*** STARTED Move outputters from knit to formatters model             :story:
    CLOCK: [2015-04-18 Sat 06:22]--[2015-04-18 Sat 06:40] =>  0:45
    CLOCK: [2015-04-17 Fri 21:38]--[2015-04-17 Fri 21:44] =>  0:06

We need to move outputting to formatters so that it can be reused in
stitch.

- create and implement the writers in formatters.
- replace knit::outputters with formatters::writer

*** Use =formatters::file= in legacy formatters                       :story:

We should make use of formatters file in preparation for using the new
world formatters.

- remove all of the typedefs in outputters, cpp_formatters, etc.
- cpp formatters to start creating formatters::file
- housekeeper to create a map of files if required; actually, add
  activity that generates the set.

*** Minor refactor to legacy =backend=                                :story:

We should take this opportunity to make the legacy backend a bit more
manageable.

- cpp_backend to be split into activities: transform, legacy generate,
  new world overwrite.
- rename backend to backend interface
- pass the model into the generate method of the backend

*** Remove the overwrite flag in =formatters::file=                   :story:

Investigate if the overwrite flag makes sense in file; it seems we
only use it in two scenarios: force overwrite requested by user or
file contents have changed, both of which can be done in the
file_writer.

*** Split knitting from stitching settings                            :story:

At present we only have a single common directory with all of the
available fields. Not all fields apply to both stitching and
knitting - but some do. We need a way to filter these. One possibility
is to use an approach similar to the formatter groups in the ownership
hierarchy. For now we simply have fields that have no meaning in
stitching but can be supplied by users.

*** Create a forward declarations formatter using stitch              :story:

We need to start making use of stitch in dogen. To start off with, we
will manually run the stitch command against a template to generate
the =cpp= file and include the header file from the formatter. We also
need to inject the stitch file name to the list of ignores, probably
by ignoring =*_stitch.cpp=, =*_stitch.hpp= and =*.stitch=. This should
avoid clashes with the source code of stitch itself.

** Deprecated
