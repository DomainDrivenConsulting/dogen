#+title: Sprint Backlog 66
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission

Implement as many formatters as possible using the new cpp
architecture.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2015-05-11 Mon 19:32]

| Headline                                                          | Time   |      |      |
|-------------------------------------------------------------------+--------+------+------|
| *Total time*                                                      | *5:15* |      |      |
|-------------------------------------------------------------------+--------+------+------|
| Active                                                            |        | 5:15 |      |
| STARTED Sprint and product backlog grooming                       |        |      | 0:44 |
| COMPLETED Add a validate JSON target                              |        |      | 0:41 |
| COMPLETED Add support for =inclusion_required= at formatter level |        |      | 1:09 |
| COMPLETED Remove duplicate includes                               |        |      | 0:18 |
| COMPLETED Ensure keys have =is_final= set in sml                  |        |      | 0:03 |
| STARTED Implement types class header formatter using stitch       |        |      | 2:20 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-05-11 Mon 18:57]--[2015-05-11 Mon 19:28] =>  0:31
    CLOCK: [2015-05-10 Sun 23:01]--[2015-05-10 Sun 23:14] =>  0:13

Updates to sprint and product backlog.

*** STARTED Updates to the manual and readme files                    :story:

Use downtime to update the manual and / or readme file.

*** COMPLETED Add a validate JSON target                              :story:
    CLOSED: [2015-05-11 Mon 14:54]
    CLOCK: [2015-05-11 Mon 14:12]--[2015-05-11 Mon 14:53] =>  0:41

It would be nice to be able to validate all of the JSON we have in the
library by running a single target. We could detect [[http://stedolan.github.io/jq/][jq]] and then use it
to validate.

*** COMPLETED Add support for =inclusion_required= at formatter level :story:
    CLOSED: [2015-05-11 Mon 17:41]
    CLOCK: [2015-05-11 Mon 16:29]--[2015-05-11 Mon 17:38] =>  1:09

In order to support hashing properly we need to be able to exclude
some includes. The inclusion required was implemented at the facet
level, so its not fine grained enough for this. Add it at formatter
level too.

*** COMPLETED Remove duplicate includes                               :story:
    CLOSED: [2015-05-11 Mon 17:56]
    CLOCK: [2015-05-11 Mon 17:38]--[2015-05-11 Mon 17:56] =>  0:18

At present we seem to have duplicate qnames in the relationships
containers. There isn't any good reason for this so we need to remove
them during SML workflow. This is not a problem at present because we
copy the relationships into a set before we start creating includes
for them.

Actually the problem is not the qnames themselves, but the include
files. Multiple qnames are pointing to the same include file. We need
to remove duplicates on the includes container.

*** COMPLETED Ensure keys have =is_final= set in sml                  :story:
    CLOSED: [2015-05-11 Mon 18:01]
    CLOCK: [2015-05-11 Mon 17:58]--[2015-05-11 Mon 18:01] =>  0:03

At present we are not marking keys as final in the new world
formatters. This is likely because we are not setting =is_final= for
keys when we generate them.

*** COMPLETED Populate property =is_original_parent_visitable= in SML :story:
    CLOSED: [2015-05-11 Mon 19:06]

*Rationale*: Story implemented in previous sprint.

To make life easier in C++ model, we've added a new SML property:
=is_original_parent_visitable=. We need to look at the SML
transformation and ensure this property is populated correctly.

*** COMPLETED Consider creating constants for common fields           :story:
    CLOSED: [2015-05-11 Mon 19:30]

*Rationale*: we are doing this already.

Fields such as =enabled=, =postfix= etc are common to all formatters
and facets. It may make more sense to define some string constants for
them, perhaps in =traits=?

*** STARTED Implement types class header formatter using stitch       :story:
    CLOCK: [2015-05-11 Mon 18:46]--[2015-05-11 Mon 18:57] =>  0:11
    CLOCK: [2015-05-11 Mon 18:01]--[2015-05-11 Mon 18:18] =>  0:17
    CLOCK: [2015-05-11 Mon 15:44]--[2015-05-11 Mon 15:59] =>  0:15
    CLOCK: [2015-05-11 Mon 14:55]--[2015-05-11 Mon 15:43] =>  0:48
    CLOCK: [2015-05-11 Mon 14:53]--[2015-05-11 Mon 14:55] =>  0:02
    CLOCK: [2015-05-11 Mon 13:25]--[2015-05-11 Mon 14:12] =>  0:47

We need to implement a stitch template for the class header formatter
in types, plug it in and start working through the diffs.

To test diff:

: head -n50 /home/marco/Development/DomainDrivenConsulting/dogen/projects/test_models/all_primitives/include/dogen/test_models/all_primitives/types/a_class.hpp > expected.txt && grep -B20 -A25 -e "\#ifndef DOGEN_TEST_MODELS_ALL_PRIMITIVES_TYPES_A_CLASS_HPP" /home/marco/Development/DomainDrivenConsulting/output/dogen/clang-3.5/stage/bin/log/knit/workflow_spec/all_primitives_model_generates_expected_code.log > actual.txt && diff -u expected.txt actual.txt 

Notes:

- we can't access disable complete constructor option. Figure out how
  to.

Remaining problems with trivial inheritance:

- primitive types have includes; not honouring "requires include?"
  flag.
- leaf types do not have visitor methods. This is because
  =is_original_parent_visitable= is not being populated.
- too much space after end of namespaces and before end if.
- no support for comments on classes and methods.
- visitor includes in descendants.
- class marked as service is being generated.

Trivial inheritance is now green.

Problems with std model:

- dependencies on hashes are not included
- duplicate includes. after sort we need some kind of distinct. Or
  perhaps the SML indexer should only add distinct qnames.
- keys are not final.

Problems with stereotypes:

- whitespace handling of immutability causes diffs.
- we generate assignment operator even though immutability is on.
- non-generatable stereotype is not being honoured.

Problems with models that disable facets and disable full constructor
model:

- not honouring flags set in command line options.

*** Create settings expander and switcher                             :story:

*New Understanding*

The expansion process now takes on this work. We need to refactor this
story into an expander.

*Previous Understanding*

We need a class responsible for copying over all settings that exist
both locally and globally. The idea is that, for those settings, the
selector should be able to just query by formatter name locally and
get the right values. This could be the expander.

We also need a more intelligent class that determines what formatters
are enabled and disabled. This is due to:

- lack of support for a given formatter/facet by a type in the graph;
  it must be propagated to all dependent types. We must be careful
  with recursion (for example in the composite pattern).
- a facet has been switched off. This must be propagated to all
  formatters in that facet.
- user has switched off a formatter. As with lack of support, this
  must be propagated through the graph.

This could be done by the switcher. We should first expand the
settings then switch them.

In some ways we can think of the switcher as a dependency
manager. This may inform the naming of this class.

One thing to take into account is the different kinds of behaviours
regarding enabling facets and formatters:

- for serialisation we want it to be on and if its on, all types
  should be serialisable.
- for hashing we want it to be off (most likely) and if the user makes
  use of a hashing container we want the type that is the key of the
  container to have hashing on; no other types should have it on. We
  also may want the user to manually switch hashing on for a type.
- for forward declarations: if another formatter requires it for a
  type, we want it on; if no one requires it we want it off. The user
  may want to manually switch it on for a type.

*** Expand fields from command line options into dynamic              :story:

We need to ensure the following fields are populated, from the command
line options:

- integrated facets
- enabled

*** Improve references management                                     :story:

At present, we compute model references as follows:

- in dia to sml we first loop through all types and figure out the
  distinct model names. This is done by creating a "shallow" qname
  with just the model name and setting its origin type to unknown.
- when we merge, we take the references of target - the only ones we
  care about - and then we check that against the list of the models
  we are about to merge. If there are any missing models we complain
  (see comments below). We then loop through the list of references
  and "resolve" the origin type of the model.

Note: We could actually also complain if there are too many models, or
more cleverly avoid merging those models which are not required. Or
even more cleverly, we could avoid loading them in the first place, if
only we could load target first.

A slightly better way of doing this would be:

- in SML create a references updater that takes a model and computes
  its reference requirements. It could also receive a list of "other"
  models from which to get their origin types to avoid using =unknown=
  at all, and checks that all reference requirements have been met.
- the current step =update_references= is just a call to the
  references updater, prior to merging, with the target model.

*** Assignment operator seems to pass types by value                  :story:

The code for the operator is as follows:

:         stream_ << indenter_ << ci.name() << "& operator=(" << ci.name()
:                << " other);" << std::endl;

If this is the case we need to fix it and regenerate all models.

Actually we have implemented assignment in terms of swap, so that is
why we copy. We need to figure out if this was a good idea. Raise
story in backlog.

: diff --git a/projects/cpp/src/types/formatters/types/class_header_formatter.stitch b/projects/cpp/src/types/formatters/types/class_header_formatter.stitch
: index f9f91af..663f0ac 100644
: --- a/projects/cpp/src/types/formatters/types/class_header_formatter.stitch
: +++ b/projects/cpp/src/types/formatters/types/class_header_formatter.stitch
: @@ -253,7 +253,7 @@ public:
:  <#+
:                  if (!c.is_parent()) {
:  #>
: -    <#= c.name() #>& operator=(<#= c.name() #> other);
: +    <#= c.name() #>& operator=(<#= c.name() #>& other);
:  <#+
:                  }
:              }
: diff --git a/projects/cpp_formatters/src/types/class_declaration.cpp b/projects/cpp_formatters/src/types/class_declaration.cpp
: index c2eeb3c..534ab69 100644
: --- a/projects/cpp_formatters/src/types/class_declaration.cpp
: +++ b/projects/cpp_formatters/src/types/class_declaration.cpp
: @@ -457,8 +457,8 @@ void class_declaration::swap_and_assignment(
:  
:      // assignment is only available in leaf classes - MEC++-33
:      if (!ci.is_parent()) {
: -        stream_ << indenter_ << ci.name() << "& operator=(" << ci.name()
: -                << " other);" << std::endl;
: +        stream_ << indenter_ << ci.name() << "& operator=(const " << ci.name()
: +                << "& other);" << std::endl;
:      }
:  
:      utility_.blank_line();
: diff --git a/projects/cpp_formatters/src/types/class_implementation.cpp b/projects/cpp_formatters/src/types/class_implementation.cpp
: index 5c9fe50..9276701 100644
: --- a/projects/cpp_formatters/src/types/class_implementation.cpp
: +++ b/projects/cpp_formatters/src/types/class_implementation.cpp
: @@ -456,8 +456,8 @@ assignment_operator(const cpp::formattables::class_info& ci) {
:          return;
:  
:      stream_ << indenter_ << ci.name() << "& "
: -            << ci.name() << "::operator=(" << ci.name()
: -            << " other) ";
: +            << ci.name() << "::operator=(const " << ci.name()
: +            << "& other) ";
:  
:      utility_.open_scope();
:      {

*** Implement options copier and remove options from context          :story:

At present the path derivatives expander is getting access to the C++
options via the expansion context. This was obviously a temporary hack
to get things moving. The right thing must surely be to add the root
object to the context, and to read the options from the root
object. These for now must be populated via the options copier; in the
future one can imagine that users define them in diagrams.

Actually, the directories supplied to dogen do need to be command line
options. This is because they tend to be created by CMake on the fly
as absolute paths and as such cannot be hard-coded into the
diagram. This being the case, perhaps we should just supply the
knitting options to the expansion context. This does mean that now
expansion is a knitting thing - it could have been used by
stitch. Needs a bit more thinking.

*Tasks to read options from root object*

Not yet clear this is the right solution, but if it is, this is what
needs to be done.

- check that we have all the required fields in JSON for all of the
  c++ options we require for now.
- update options copier to copy these options. In many cases we will
  have to "redirect" the option. For example, =domain_facet_folder=
  becomes the types directory and so forth. Having said that we
  probably won't need these for now.
- remove options from context, and add root object instead. We may
  need to do the usual "locate root object" routine.
- update the path settings factory to read these from the root object.
- add options to type settings where it makes sense (e.g. disable
  complete constructor) and implement the type settings factory.

*** Consider dropping the prefix inclusion in expansion               :story:

*New Understanding*

The problem with this is that "directive" does not have any
meaning. We could get away with dependencies, but directive is very
open ended. We cannot start changing meta-data keys (e.g. =directive=
instead of =inclusion_directive=) because that would confuse users; so
we would end up with two names in two different places, probably even
more confusing.

*Previous Understanding*

At present we have really long class names because they all need
"inclusion" on the name. In reality, we have two concepts:

- directives
- dependencies

We don't need the prefix "inclusion" to make these understandable. We
can probably get away with removing it from all of the expansion
classes without significant loss of meaning.

*** Add new c++ warnings to compilation                               :story:

- =-Wunused-private-field=: Seems like this warning is not part of
  =-Wall=
- =-Winconsistent-missing-override=: new clang warning, probably 3.6.

** Deprecated
*** CANCELLED Handling missing default facet settings                 :story:
    CLOSED: [2015-05-11 Mon 19:08]

*Rationale*: We don't have facet settings any more and we are checking
this properly for the formatter settings.

At present we are just logging a warning when the user supplies
dynamic extensions for a facet that we do not have defaults
for. However, it may make more sense to just throw if someone is
assuming support for something which we do not support. We need to
think about this use case properly.
