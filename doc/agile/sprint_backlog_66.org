#+title: Sprint Backlog 66
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission

Implement the bulk of the new world formatters and start fleshing out
the move to needle.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2015-05-12 Tue 13:17]

| Headline                                                          | Time   |      |      |
|-------------------------------------------------------------------+--------+------+------|
| *Total time*                                                      | *7:08* |      |      |
|-------------------------------------------------------------------+--------+------+------|
| Active                                                            |        | 7:08 |      |
| STARTED Sprint and product backlog grooming                       |        |      | 0:54 |
| COMPLETED Add a validate JSON target                              |        |      | 0:41 |
| COMPLETED Add support for =inclusion_required= at formatter level |        |      | 1:09 |
| COMPLETED Remove duplicate includes                               |        |      | 0:18 |
| COMPLETED Ensure keys have =is_final= set in sml                  |        |      | 0:03 |
| STARTED Implement types class header formatter using stitch       |        |      | 2:28 |
| STARTED Create a trivial "enabled" expander                       |        |      | 1:35 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-05-11 Mon 22:25]--[2015-05-11 Mon 22:35] =>  0:10
    CLOCK: [2015-05-11 Mon 18:57]--[2015-05-11 Mon 19:28] =>  0:31
    CLOCK: [2015-05-10 Sun 23:01]--[2015-05-10 Sun 23:14] =>  0:13

Updates to sprint and product backlog.

*** STARTED Updates to the manual and readme files                    :story:

Use downtime to update the manual and / or readme file.

*** COMPLETED Add a validate JSON target                              :story:
    CLOSED: [2015-05-11 Mon 14:54]
    CLOCK: [2015-05-11 Mon 14:12]--[2015-05-11 Mon 14:53] =>  0:41

It would be nice to be able to validate all of the JSON we have in the
library by running a single target. We could detect [[http://stedolan.github.io/jq/][jq]] and then use it
to validate.

*** COMPLETED Add support for =inclusion_required= at formatter level :story:
    CLOSED: [2015-05-11 Mon 17:41]
    CLOCK: [2015-05-11 Mon 16:29]--[2015-05-11 Mon 17:38] =>  1:09

In order to support hashing properly we need to be able to exclude
some includes. The inclusion required was implemented at the facet
level, so its not fine grained enough for this. Add it at formatter
level too.

*** COMPLETED Remove duplicate includes                               :story:
    CLOSED: [2015-05-11 Mon 17:56]
    CLOCK: [2015-05-11 Mon 17:38]--[2015-05-11 Mon 17:56] =>  0:18

At present we seem to have duplicate qnames in the relationships
containers. There isn't any good reason for this so we need to remove
them during SML workflow. This is not a problem at present because we
copy the relationships into a set before we start creating includes
for them.

Actually the problem is not the qnames themselves, but the include
files. Multiple qnames are pointing to the same include file. We need
to remove duplicates on the includes container.

*** COMPLETED Ensure keys have =is_final= set in sml                  :story:
    CLOSED: [2015-05-11 Mon 18:01]
    CLOCK: [2015-05-11 Mon 17:58]--[2015-05-11 Mon 18:01] =>  0:03

At present we are not marking keys as final in the new world
formatters. This is likely because we are not setting =is_final= for
keys when we generate them.

*** COMPLETED Populate property =is_original_parent_visitable= in SML :story:
    CLOSED: [2015-05-11 Mon 19:06]

*Rationale*: Story implemented in previous sprint.

To make life easier in C++ model, we've added a new SML property:
=is_original_parent_visitable=. We need to look at the SML
transformation and ensure this property is populated correctly.

*** COMPLETED Consider creating constants for common fields           :story:
    CLOSED: [2015-05-11 Mon 19:30]

*Rationale*: we are doing this already.

Fields such as =enabled=, =postfix= etc are common to all formatters
and facets. It may make more sense to define some string constants for
them, perhaps in =traits=?

*** STARTED Implement types class header formatter using stitch       :story:
    CLOCK: [2015-05-11 Mon 21:29]--[2015-05-11 Mon 21:37] =>  0:08
    CLOCK: [2015-05-11 Mon 18:46]--[2015-05-11 Mon 18:57] =>  0:11
    CLOCK: [2015-05-11 Mon 18:01]--[2015-05-11 Mon 18:18] =>  0:17
    CLOCK: [2015-05-11 Mon 15:44]--[2015-05-11 Mon 15:59] =>  0:15
    CLOCK: [2015-05-11 Mon 14:55]--[2015-05-11 Mon 15:43] =>  0:48
    CLOCK: [2015-05-11 Mon 14:53]--[2015-05-11 Mon 14:55] =>  0:02
    CLOCK: [2015-05-11 Mon 13:25]--[2015-05-11 Mon 14:12] =>  0:47

We need to implement a stitch template for the class header formatter
in types, plug it in and start working through the diffs.

To test diff:

: head -n50 /home/marco/Development/DomainDrivenConsulting/dogen/projects/test_models/all_primitives/include/dogen/test_models/all_primitives/types/a_class.hpp > expected.txt && grep -B20 -A25 -e "\#ifndef DOGEN_TEST_MODELS_ALL_PRIMITIVES_TYPES_A_CLASS_HPP" /home/marco/Development/DomainDrivenConsulting/output/dogen/clang-3.5/stage/bin/log/knit/workflow_spec/all_primitives_model_generates_expected_code.log > actual.txt && diff -u expected.txt actual.txt 

Notes:

- we can't access disable complete constructor option. Figure out how
  to.

Remaining problems with trivial inheritance:

- primitive types have includes; not honouring "requires include?"
  flag.
- leaf types do not have visitor methods. This is because
  =is_original_parent_visitable= is not being populated.
- too much space after end of namespaces and before end if.
- no support for comments on classes and methods.
- visitor includes in descendants.
- class marked as service is being generated.

Trivial inheritance is now green.

Problems with std model:

- dependencies on hashes are not included
- duplicate includes. after sort we need some kind of distinct. Or
  perhaps the SML indexer should only add distinct qnames.
- keys are not final.

Problems with stereotypes:

- whitespace handling of immutability causes diffs.
- we generate assignment operator even though immutability is on.
- non-generatable stereotype is not being honoured.

Problems with models that disable facets and disable full constructor
model:

- not honouring flags set in command line options.

*** STARTED Create a trivial "enabled" expander                       :story:
    CLOCK: [2015-05-12 Tue 12:21]--[2015-05-12 Tue 13:17] =>  0:56
    CLOCK: [2015-05-11 Mon 21:38]--[2015-05-11 Mon 22:17] =>  0:39

For now we just need a very simple expander that looks into the root
object and switches the formatter's "enabled" flag at the entity level
on/off. Implement this to allow us to get the disable facet knit tests
to pass.

- why do we loop through the field definitions to find a field? Surely
  it makes more sense to supply the desired field name plus the
  ownership hierarchy to the selector and ask for the field directly?
  We would have to tell it if its the model, facet or formatter's
  version we are looking for but the method name could imply that -
  "for facet", etc. This would clean up all the "found_" flags and
  associated madness.

*** Create a "supported" expander                                     :story:

This needs a bit more analysis. The gist of it is that not all types
support all formatters. We need a way to determine if a formatter is
not supported. This probably should be inferred by a "is dogen model"
property (see backlog); e.g. non-dogen models need their types to have
an inclusion setup in order to be "supported", otherwise they should
default to "not-supported". However the "supported" flag is populated,
we then need to take into account relationships and propagate this
flag across the model such that, if a type =A= in a dogen model has a
property of a type =B= from a non-dogen model which does not support a
given formatter =f=, then =A= must also not support =f=.

In order to implement this feature we need to:

- update the SML grapher to take into account relationships
  (properties that the class has) as well as inheritance.
- we must only visit related types if we ourselves do not have values
  for all supported fields.
- we also need a visitor that detects cycles; when a cycle is found we
  simply assume that the status of the revisited class is true (or
  whatever the default value of "supported" is) and we write a warning
  to the log file. We should output the complete path of the cycle.
- users can override this by setting supported for all formatters
  where there are cycles.
- we could perhaps have a bitmask by qname; we could start by
  generating all bitmasks for all qnames and setting them to default
  value. We could then find all qnames that have supported set to
  false and update the corresponding bitmasks. Then we could use the
  graph to loop through the qnames and "and" the bitmasks of each
  qname with the bitmasks of their related qnames. The position of
  each field is allocated by the algorithm (e.g. the first "supported"
  field is at position 0 and so on). Actually the first position of
  the bitmask could be used to indicate if the bitmask has already
  been processed or not. In the presence of a cycle force it to true.
- we need a class that takes the SML model and computes the supported
  bitmasks for each qname; the supported expander then simply takes
  this (perhaps as part of the expansion context), looks up for the
  current qname and uses the field list to set the flags
  appropriately.
- we should remove all traces of supported from a settings
  perspective; supported and multi-level enabled are just artefacts of
  the meta-data. From a settings perspective, there is just a
  formatter level (common formatter settings) enabled which determines
  whether the formatter is on or off. How that flag came to be
  computed is not relevant outside the expansion process. This also
  means we can have simpler or more complex policies as time allows us
  improve on this story; provided we can at least set all flags to
  enabled we can move forward.

Solution for cycles:

- detect the cycle and then remember the pair (a, b) where b is the
  start of the cycle and a is the last vertex before the cycle. We
  should assume that a is (true, true) for the edge (a, b) and compute
  all other edges. Finally, once the graph has been processed we
  should check all of the pairs in a cycle; for these we should simply
  look at the values of b, and update a accordingly.

*Other notes*

- we need some validation to ensure that some types will be generated
  at all. The existing "generatable types" logic will have to be
  removed or perhaps updated; we should take the opportunity to make
  it reflect whether a type belongs to the target model or not. This
  has no bearing on generatability (other that non-target types are
  always not generated). So at the middle-end level we need to check
  if there are any target types at all, and if not, just want the user
  and exit. Then, a second layer is required at the model group /
  language level to determine if there are any types to generate. It
  is entirely possible that we end up not generating anything at all
  because once we went through the graph everything got
  disabled. Users will have to somehow debug this when things go
  wrong.
- following on from this, we probably need a "dump info" option that
  explains the enabled/supported decisions for a given model, for all
  target types; possibly, users could then supply regexes to filter
  this info (e.g. why did you not generate =hash= for type =xyz=? can
  I see all types for formatter =abc=?). It may be useful to have an
  option to toggle between "target only types" and "all types",
  because the system types may be the ones causing the problem.
- the enabled supported logic applies to all formatters across all
  model groups. We need a way

*** Create settings expander and switcher                             :story:

*New Understanding*

The expansion process now takes on this work. We need to refactor this
story into an expander.

*Previous Understanding*

We need a class responsible for copying over all settings that exist
both locally and globally. The idea is that, for those settings, the
selector should be able to just query by formatter name locally and
get the right values. This could be the expander.

We also need a more intelligent class that determines what formatters
are enabled and disabled. This is due to:

- lack of support for a given formatter/facet by a type in the graph;
  it must be propagated to all dependent types. We must be careful
  with recursion (for example in the composite pattern).
- a facet has been switched off. This must be propagated to all
  formatters in that facet.
- user has switched off a formatter. As with lack of support, this
  must be propagated through the graph.

This could be done by the switcher. We should first expand the
settings then switch them.

In some ways we can think of the switcher as a dependency
manager. This may inform the naming of this class.

One thing to take into account is the different kinds of behaviours
regarding enabling facets and formatters:

- for serialisation we want it to be on and if its on, all types
  should be serialisable.
- for hashing we want it to be off (most likely) and if the user makes
  use of a hashing container we want the type that is the key of the
  container to have hashing on; no other types should have it on. We
  also may want the user to manually switch hashing on for a type.
- for forward declarations: if another formatter requires it for a
  type, we want it on; if no one requires it we want it off. The user
  may want to manually switch it on for a type.

*** Expand fields from command line options into dynamic              :story:

We need to ensure the following fields are populated, from the command
line options:

- integrated facets
- enabled

*** Improve references management                                     :story:

At present, we compute model references as follows:

- in dia to sml we first loop through all types and figure out the
  distinct model names. This is done by creating a "shallow" qname
  with just the model name and setting its origin type to unknown.
- when we merge, we take the references of target - the only ones we
  care about - and then we check that against the list of the models
  we are about to merge. If there are any missing models we complain
  (see comments below). We then loop through the list of references
  and "resolve" the origin type of the model.

Note: We could actually also complain if there are too many models, or
more cleverly avoid merging those models which are not required. Or
even more cleverly, we could avoid loading them in the first place, if
only we could load target first.

A slightly better way of doing this would be:

- in SML create a references updater that takes a model and computes
  its reference requirements. It could also receive a list of "other"
  models from which to get their origin types to avoid using =unknown=
  at all, and checks that all reference requirements have been met.
- the current step =update_references= is just a call to the
  references updater, prior to merging, with the target model.

*** Assignment operator seems to pass types by value                  :story:

The code for the operator is as follows:

:         stream_ << indenter_ << ci.name() << "& operator=(" << ci.name()
:                << " other);" << std::endl;

If this is the case we need to fix it and regenerate all models.

Actually we have implemented assignment in terms of swap, so that is
why we copy. We need to figure out if this was a good idea. Raise
story in backlog.

: diff --git a/projects/cpp/src/types/formatters/types/class_header_formatter.stitch b/projects/cpp/src/types/formatters/types/class_header_formatter.stitch
: index f9f91af..663f0ac 100644
: --- a/projects/cpp/src/types/formatters/types/class_header_formatter.stitch
: +++ b/projects/cpp/src/types/formatters/types/class_header_formatter.stitch
: @@ -253,7 +253,7 @@ public:
:  <#+
:                  if (!c.is_parent()) {
:  #>
: -    <#= c.name() #>& operator=(<#= c.name() #> other);
: +    <#= c.name() #>& operator=(<#= c.name() #>& other);
:  <#+
:                  }
:              }
: diff --git a/projects/cpp_formatters/src/types/class_declaration.cpp b/projects/cpp_formatters/src/types/class_declaration.cpp
: index c2eeb3c..534ab69 100644
: --- a/projects/cpp_formatters/src/types/class_declaration.cpp
: +++ b/projects/cpp_formatters/src/types/class_declaration.cpp
: @@ -457,8 +457,8 @@ void class_declaration::swap_and_assignment(
:  
:      // assignment is only available in leaf classes - MEC++-33
:      if (!ci.is_parent()) {
: -        stream_ << indenter_ << ci.name() << "& operator=(" << ci.name()
: -                << " other);" << std::endl;
: +        stream_ << indenter_ << ci.name() << "& operator=(const " << ci.name()
: +                << "& other);" << std::endl;
:      }
:  
:      utility_.blank_line();
: diff --git a/projects/cpp_formatters/src/types/class_implementation.cpp b/projects/cpp_formatters/src/types/class_implementation.cpp
: index 5c9fe50..9276701 100644
: --- a/projects/cpp_formatters/src/types/class_implementation.cpp
: +++ b/projects/cpp_formatters/src/types/class_implementation.cpp
: @@ -456,8 +456,8 @@ assignment_operator(const cpp::formattables::class_info& ci) {
:          return;
:  
:      stream_ << indenter_ << ci.name() << "& "
: -            << ci.name() << "::operator=(" << ci.name()
: -            << " other) ";
: +            << ci.name() << "::operator=(const " << ci.name()
: +            << "& other) ";
:  
:      utility_.open_scope();
:      {

*** Implement options copier and remove options from context          :story:

At present the path derivatives expander is getting access to the C++
options via the expansion context. This was obviously a temporary hack
to get things moving. The right thing must surely be to add the root
object to the context, and to read the options from the root
object. These for now must be populated via the options copier; in the
future one can imagine that users define them in diagrams.

Actually, the directories supplied to dogen do need to be command line
options. This is because they tend to be created by CMake on the fly
as absolute paths and as such cannot be hard-coded into the
diagram. This being the case, perhaps we should just supply the
knitting options to the expansion context. This does mean that now
expansion is a knitting thing - it could have been used by
stitch. Needs a bit more thinking.

*Tasks to read options from root object*

Not yet clear this is the right solution, but if it is, this is what
needs to be done.

- check that we have all the required fields in JSON for all of the
  c++ options we require for now.
- update options copier to copy these options. In many cases we will
  have to "redirect" the option. For example, =domain_facet_folder=
  becomes the types directory and so forth. Having said that we
  probably won't need these for now.
- remove options from context, and add root object instead. We may
  need to do the usual "locate root object" routine.
- update the path settings factory to read these from the root object.
- add options to type settings where it makes sense (e.g. disable
  complete constructor) and implement the type settings factory.

*** Consider dropping the prefix inclusion in expansion               :story:

*New Understanding*

The problem with this is that "directive" does not have any
meaning. We could get away with dependencies, but directive is very
open ended. We cannot start changing meta-data keys (e.g. =directive=
instead of =inclusion_directive=) because that would confuse users; so
we would end up with two names in two different places, probably even
more confusing.

*Previous Understanding*

At present we have really long class names because they all need
"inclusion" on the name. In reality, we have two concepts:

- directives
- dependencies

We don't need the prefix "inclusion" to make these understandable. We
can probably get away with removing it from all of the expansion
classes without significant loss of meaning.

*** Add new c++ warnings to compilation                               :story:

- =-Wunused-private-field=: Seems like this warning is not part of
  =-Wall=
- =-Winconsistent-missing-override=: new clang warning, probably 3.6.

** Deprecated
*** CANCELLED Handling missing default facet settings                 :story:
    CLOSED: [2015-05-11 Mon 19:08]

*Rationale*: We don't have facet settings any more and we are checking
this properly for the formatter settings.

At present we are just logging a warning when the user supplies
dynamic extensions for a facet that we do not have defaults
for. However, it may make more sense to just throw if someone is
assuming support for something which we do not support. We need to
think about this use case properly.
