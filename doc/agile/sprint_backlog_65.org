#+title: Sprint Backlog 65
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission

Implement as many formatters as possible using the new cpp
architecture.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2015-04-30 Thu 08:21]

| Headline                                                                 | Time    |       |      |
|--------------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                             | *15:26* |       |      |
|--------------------------------------------------------------------------+---------+-------+------|
| Active                                                                   |         | 15:26 |      |
| STARTED Sprint and product backlog grooming                              |         |       | 2:01 |
| COMPLETED Fix borked gcc build                                           |         |       | 0:35 |
| COMPLETED Output new world forward declarations                          |         |       | 2:36 |
| COMPLETED Fix missing new line in enumeration forward declarations       |         |       | 0:32 |
| COMPLETED Text of GPL V2 licence is the same as V3                       |         |       | 0:10 |
| COMPLETED Inclusion provision needs to cater for optional case           |         |       | 0:21 |
| COMPLETED Consider adding a ownership hierarchy method in registrar      |         |       | 0:15 |
| COMPLETED Improve streaming of empty lines in stitch                     |         |       | 0:16 |
| COMPLETED Implement serialization forward declarations formatter         |         |       | 0:17 |
| COMPLETED Create a formatter helper                                      |         |       | 1:24 |
| COMPLETED Add =is_final= in SML                                          |         |       | 0:17 |
| COMPLETED Simplify logic around move construction                        |         |       | 0:06 |
| STARTED Implement types class header formatter using stitch              |         |       | 4:40 |
| STARTED Add support for =disable_complete_constructor= in options copier |         |       | 1:06 |
| STARTED Implement options copier and remove options from context         |         |       | 0:50 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-04-28 Tue 11:15]--[2015-04-28 Tue 12:14] =>  0:59
    CLOCK: [2015-04-27 Mon 14:15]--[2015-04-27 Mon 15:07] =>  0:52
    CLOCK: [2015-04-27 Mon 14:05]--[2015-04-27 Mon 14:15] =>  0:10

Updates to sprint and product backlog.

*** STARTED Updates to the manual and readme files                    :story:

Use downtime to update the manual and / or readme file.

*** COMPLETED Fix borked gcc build                                    :story:
    CLOSED: [2015-04-27 Mon 14:15]
    CLOCK: [2015-04-27 Mon 13:00]--[2015-04-27 Mon 13:35] =>  0:35

The last few builds on travis have failed. Figure out why and fix it.

*** COMPLETED Output new world forward declarations                   :story:
    CLOSED: [2015-04-27 Mon 17:01]
    CLOCK: [2015-04-27 Mon 17:55]--[2015-04-27 Mon 18:06] =>  0:11
    CLOCK: [2015-04-27 Mon 17:02]--[2015-04-27 Mon 17:35] =>  0:33
    CLOCK: [2015-04-27 Mon 15:09]--[2015-04-27 Mon 17:01] =>  1:52

We need to find a way to suppress class header formatter and enable
forward declarations formatter; we want to start using new code from
now on.

We will also have to deal with all the breaks that this generates.

*** COMPLETED Fix missing new line in enumeration forward declarations :story:
    CLOSED: [2015-04-27 Mon 18:50]
    CLOCK: [2015-04-27 Mon 18:48]--[2015-04-27 Mon 18:50] =>  0:02
    CLOCK: [2015-04-27 Mon 18:08]--[2015-04-27 Mon 18:38] =>  0:30

For now we put in a hack in the stitch template not to output
those.

*Tasks*

- fix legacy formatters;
- rebase the world
- fix template.

*** COMPLETED Text of GPL V2 licence is the same as V3                :story:
    CLOSED: [2015-04-27 Mon 18:56]
    CLOCK: [2015-04-27 Mon 18:55]--[2015-04-27 Mon 19:05] =>  0:10

We seem to have copied and pasted the licence across.

*** COMPLETED Inclusion provision needs to cater for optional case    :story:
    CLOSED: [2015-04-27 Mon 19:51]
    CLOCK: [2015-04-27 Mon 19:30]--[2015-04-27 Mon 19:51] =>  0:21

While implementing forward declarations we hit a problem: Exceptions
require includes for forward declarations but no other type requires
this. In order for this to work, we need to refactor inclusion
provision to allow for optional inclusion dependencies. For now we put
in a massive hack that allows empty formatter names to be returned
from provider.

*Tasks*

- add a class to represent the inclusion dependency rather than use a
  pair of a list etc.
- make the return type of the interface optional.
- do the appropriate actions in inclusion dependency factory when
  provider returns null for optional.

*** COMPLETED Consider adding a ownership hierarchy method in registrar :story:
    CLOSED: [2015-04-27 Mon 21:46]
    CLOCK: [2015-04-27 Mon 21:31]--[2015-04-27 Mon 21:46] =>  0:15

In a few cases we seem to need the ownership hierarchy for all
formatters. We should move this logic to formatter registrar.

*** COMPLETED Refactor boost and std helpers and enums                :story:
    CLOSED: [2015-04-28 Tue 11:50]

*Rationale*: Will be done as part of architecture refactor.

We shouldn't really have std and boost enums. These are just a repeat
of the SML models. We should have a find object by name in a model which
returns the appropriate qname given a type name. Then the helpers bind
to those qnames; given a qname, they return the include information,
etc. In the current implementation, the enums are basically a
duplication of the static models.

In reality we should really load up these models from a file, such
that users can add their own bindings without having to change C++
code. This could be done with a config file using boost property
tree. However, one would need some kind of way of mapping types into
primitives, sequence containers etc - some kind of "concepts".

*** COMPLETED Implement include generation for class header formatter :story:
    CLOSED: [2015-04-28 Tue 11:51]

*Rationale*: this has been implemented and will be completed with the
 current stitch template work.

Now that we have finished generating the path spec details, we need to
make sure includes generation works as expected. Add both formatter
level includes as well as model level includes.

We also need to deal with:

- exposing formatter id as a static property so we can create
  dependencies between formatters;
- includes overrides via dynamic extensions, so we can start using
  STL, Boost etc classes.
- includes of STL, Boost etc that are formatter level dependencies -
  this needs to be handled via traits.

Notes:

- rename header file to file name override or something else quite
  distinct. We need to ensure it is obvious that this property is only
  used for non-dogen models. Actually we can now just call it include
  path.
- however we still have a problem: when we compute the include path we
  do not know if it is a system or user path. We need to change file
  properties to take this into account. We need a include path class
  with a include type: user or system. we could then use this.
- add field definition =no_inclusion_required= and populate all
  relevant primitives.

We need to add the notion of aspects. This is because a lot of things
we have dealt with individually are really all related to aspects. An
aspect is a part of a formatter that can be enabled or disabled. For
example:

- manual move constructor
- manual default constructor
- inserter operator
- swap function
- etc.

We could simply create aspect settings; local and global formatters
would have a map of =aspect_settings= against an =aspect_name=. We
need to remove the integrated facet approach and implement it in terms
of this. We should go through the types formatter and figure out which
aspects it has. For now we shall ignore relationships between aspects
and facets (and any other kind of switching logic). For example, it is
the responsibility of the user to ensure that if integrated io is
used, the io facet is switched off. This is because it is very
complicated to build in the generic logic of such dependencies. We
have a story to handle this properly in the backlog, but it will
require a lot of work.

*** COMPLETED Includer generation should be done from dynamic extensions :story:
    CLOSED: [2015-04-28 Tue 11:52]

*Rationale*: Will be done as part of architecture refactor.

*New Understanding*

The true use case of this story is not to allow users to add includes
at random; it is actually only useful in one scenario:

- *merging code generation*: users add code which requires additional
  includes. Without support for this, merging code generation would
  have limited usefulness.

*Previous Understanding*

It would be nice if we could determine which includer files to create
by looking at the dynamic extensions. For this we need a notion of an
inclusion group, defined at the model level:

- =cpp.types.includers.general=
- =cpp.types.includers.value_objects=
- ...

Under each of these one would configure the aspect:

- =cpp.types.includers.general.generate=: =true=
- =cpp.types.includers.general.file_name=: =a/b/c=
- =cpp.types.includers.general.is_system=: =false=

Then, each type, module etc would declare its membership (as a list):

- =cpp.includers.member=: =cpp.types.includers.general=
- =cpp.includers.member=: =cpp.types.includers.value_objects=
- ...

*Previous understanding*

We should simply go through all the types in the SML model and for
each type and each facet create the corresponding inclusion
path. locator can be used to generate standard paths, and a model
specific mapping is required for other models such as std.

Include then takes the relationships extracted by extractor, the
mappings generated by this mapper and simply appends to the inclusion
list the file names. it also appends the implementation specific
headers.

*** COMPLETED Handling of modelines is incorrect in general settings  :story:
    CLOSED: [2015-04-28 Tue 11:53]

*Rationale*: Will be done as part of architecture refactor.

At present the general settings are hard-coded to look for a C++
modeline. This will not work for CMake files, etc. We need to think
how multiple modelines will be supported. See general settings factory
in formatters.

*** COMPLETED Add include files at the formatter level                :story:
    CLOSED: [2015-04-28 Tue 11:54]

*Rationale*: Will be done as part of architecture refactor.

We need to remove all the include files from =includer= which are
related to formatter specific code. We need to inject these
dependencies inside of the formatters.

- implement includer in terms of json files
- get includer to work off of object relationships
- remove relationships from transformer
- remove helper models boost and std

*** COMPLETED Delete content types                                    :story:
    CLOSED: [2015-04-28 Tue 11:54]

*Rationale*: Will be done as part of architecture refactor.

Now we have the type system representing the content, we can delete
this enumeration.

*** COMPLETED Delete aspect types                                     :story:
    CLOSED: [2015-04-28 Tue 11:54]

*Rationale*: Will be done as part of architecture refactor.

Now we have the type system representing the aspects, we can delete
this enumeration.

*** COMPLETED Rename =codgen= targets                                 :story:
    CLOSED: [2015-04-28 Tue 11:55]

*Rationale*: fixed in previous sprint.

These are really the =knitting= or =knitter= targets because we are
calling =knitter=.

*** COMPLETED Add support for spaces in template types                :story:
    CLOSED: [2015-04-28 Tue 12:00]

*Rationale*: Fixed in previous sprint.

At present we do not allow any spaces when declaring a type that has
template parameters:

: std::exception::what: Failed to parse string: std::unordered_map<std::string, facet_settings>

We need to look into how to add this to the spirit parsing rules as it
causes a lot of pain.

*** COMPLETED Formatters should cache qname formatting                :story:
    CLOSED: [2015-04-28 Tue 12:02]

*Rationale*: Will be done as part of architecture refactor.

We seem to re-format the same qname lots of times. We should just use
a =std::ostringstream= to format once and reuse the resulting
string. Probably worth doing this change after the performance tests
are in.

*** COMPLETED Improve streaming of empty lines in stitch              :spike:
    CLOSED: [2015-04-28 Tue 14:22]
    CLOCK: [2015-04-28 Tue 14:06]--[2015-04-28 Tue 14:22] =>  0:16

At present we stream empty lines as follows:

: s << "" << std::endl;

We should really be doing:

: s << std::endl;

*** COMPLETED Implement serialization forward declarations formatter  :story:
    CLOSED: [2015-04-28 Tue 16:28]
    CLOCK: [2015-04-28 Tue 16:10]--[2015-04-28 Tue 16:27] =>  0:17

We didn't implement the serialization forward declarations
formatter. It is totally separate from the types one so that's why it
got missed. We need it for the class header formatter to work.

*** COMPLETED Create a formatter helper                               :story:
    CLOSED: [2015-04-29 Wed 17:24]
    CLOCK: [2015-04-29 Wed 16:00]--[2015-04-29 Wed 17:24] =>  1:24

We could implement most of the formatter interface in a common base
class and then only have the descendants override what they need.

In reality we need probably more than one base formatter: one for c++
types, etc. We could handle all of the path and include generation
here. Name: =cpp_base_formatter=?

Actually maybe we just need a helper class. Prefer the name
=assistant= to helper.

Responsibilities:

- obtain the formatter settings from a given entity;
- validate the formatter settings (maybe needs a validate header,
  validate implementation versions);
- given string, generate file;
- create the scoped boiler plate;
- create the scoped namespace formatter;
- it could own a =stringstream= too, making our life even easier.

This way the stitch template can call the assistant and the format
method does very little..

*** COMPLETED Add =is_final= in SML                                   :story:
    CLOSED: [2015-04-29 Wed 17:42]
    CLOCK: [2015-04-29 Wed 17:25]--[2015-04-29 Wed 17:42] =>  0:17

Finality should be an SML level concept. We could infer it using the
same logic as =cpp= uses at present. Add it to SML, then cpp and then
make use of it in the formatter.

*** COMPLETED Simplify logic around move construction                 :story:
    CLOSED: [2015-04-29 Wed 17:48]
    CLOCK: [2015-04-29 Wed 17:42]--[2015-04-29 Wed 17:48] =>  0:06

We are doing some computations in the template that should be done
during transformation.

*** STARTED Implement types class header formatter using stitch       :story:
    CLOCK: [2015-04-30 Thu 08:00]--[2015-04-30 Thu 08:21] =>  0:21
    CLOCK: [2015-04-30 Thu 07:39]--[2015-04-30 Thu 08:00] =>  0:21
    CLOCK: [2015-04-29 Wed 22:09]--[2015-04-29 Wed 22:27] =>  0:18
    CLOCK: [2015-04-29 Wed 21:58]--[2015-04-29 Wed 22:08] =>  0:10
    CLOCK: [2015-04-29 Wed 21:42]--[2015-04-29 Wed 21:57] =>  0:15
    CLOCK: [2015-04-29 Wed 21:20]--[2015-04-29 Wed 21:41] =>  0:21
    CLOCK: [2015-04-29 Wed 17:49]--[2015-04-29 Wed 18:39] =>  0:50
    CLOCK: [2015-04-28 Tue 17:21]--[2015-04-28 Tue 17:47] =>  0:26
    CLOCK: [2015-04-28 Tue 14:27]--[2015-04-28 Tue 15:47] =>  1:20
    CLOCK: [2015-04-28 Tue 14:22]--[2015-04-28 Tue 14:27] =>  0:05
    CLOCK: [2015-04-28 Tue 13:53]--[2015-04-28 Tue 14:06] =>  0:13

We need to implement a stitch template for the class header formatter
in types, plug it in and start working through the diffs.

To test diff:

: head -n50 /home/marco/Development/DomainDrivenConsulting/dogen/projects/test_models/all_primitives/include/dogen/test_models/all_primitives/types/a_class.hpp > expected.txt && grep -B20 -A25 -e "\#ifndef DOGEN_TEST_MODELS_ALL_PRIMITIVES_TYPES_A_CLASS_HPP" /home/marco/Development/DomainDrivenConsulting/output/dogen/clang-3.5/stage/bin/log/knit/workflow_spec/all_primitives_model_generates_expected_code.log > actual.txt && diff -u expected.txt actual.txt 

Notes:

- we can't access disable complete constructor option. Figure out how to.

*** STARTED Add support for =disable_complete_constructor= in options copier
    CLOCK: [2015-04-29 Wed 15:39]--[2015-04-29 Wed 15:59] =>  0:20
    CLOCK: [2015-04-29 Wed 14:50]--[2015-04-29 Wed 15:07] =>  0:17
    CLOCK: [2015-04-28 Tue 23:25]--[2015-04-28 Tue 23:54] =>  0:29

Class header requires =disable_complete_constructor=.

- add field to JSON.
- update options copier to copy from options
- implement reading in the type settings factory.
- type settings cannot be optional as we need to know whether to
  disable complete constructor.
- stop passing in settings that can be derived.
- bump up log file to reveal rest of class.

*** STARTED Implement options copier and remove options from context  :story:
    CLOCK: [2015-04-28 Tue 19:34]--[2015-04-28 Tue 19:43] =>  0:09
    CLOCK: [2015-04-28 Tue 18:52]--[2015-04-28 Tue 19:33] =>  0:41

At present the path derivatives expander is getting access to the C++
options via the expansion context. This was obviously a temporary hack
to get things moving. The right thing must surely be to add the root
object to the context, and to read the options from the root
object. These for now must be populated via the options copier; in the
future one can imagine that users define them in diagrams.

Actually, the directories supplied to dogen do need to be command line
options. This is because they tend to be created by CMake on the fly
as absolute paths and as such cannot be hard-coded into the
diagram. This being the case, perhaps we should just supply the
knitting options to the expansion context. This does mean that now
expansion is a knitting thing - it could have been used by
stitch. Needs a bit more thinking.

*Tasks to read options from root object*

Not yet clear this is the right solution, but if it is, this is what
needs to be done.

- check that we have all the required fields in JSON for all of the
  c++ options we require for now.
- update options copier to copy these options. In many cases we will
  have to "redirect" the option. For example, =domain_facet_folder=
  becomes the types directory and so forth. Having said that we
  probably won't need these for now.
- remove options from context, and add root object instead. We may
  need to do the usual "locate root object" routine.
- update the path settings factory to read these from the root object.
- add options to type settings where it makes sense (e.g. disable
  complete constructor) and implement the type settings factory.

*** Improve streaming of empty expressions in stitch                  :spike:

We have a problem with empty expressions:

: <#= #>

Results in:

: s << <<

We need to ignore empty expressions.

*** Do we use =formatter_types=?                                      :story:

We need to figure out if we need this enumeration in =cpp::formatters=
and if not remove it.

*** Tidy-up sml consumer interface                                    :story:

After implementing the includes for the class header formatter we
should figure out if we need the multiple passes machinery. Most
likely all of that should be scraped.

*** Remove =cpp_formatters::formatting_error=                         :story:

Use the =formatters::formating_error= instead.

*** Contents change check is done twice                               :story:

We seem to check twice if a file has changed:

: 2015-04-26 12:37:28.451464 [DEBUG] [formatters.filesystem_writer] File contents have not changed, and force write is false so not writing.
: 2015-04-26 12:37:28.451486 [DEBUG] [formatters.filesystem_writer] File contents have not changed, and force write is false so not writing.

This is in stitch but it should be the same for knit.

*** Stitch does not handle directories very well                      :story:

At present we seem to generate log files called =.= when we use stitch
against a directory. This should only happen if we use =.= on the
target parameter, e.g.:

: --target .

Not sure why it is happening when we call stitch from CMake since it
should use the full path to the =cpp= directory.

*** Update dynamic section in manual                                  :story:

We need to talk about the new fields, field templates, etc.

*** Add stitch section in manual                                      :story:

We need to document stitch:

- formal definition of the language and its limitations;
- command line usage of the tool.

*** Add kvp support to =identifier_parser=                            :story:

We have code to split kvps all over the place. We should do this in a
single pace, and use boost spirit or tokenizer. For one such
implementation with spirit see:

[[http://boost-spirit.com/home/2010/02/24/parsing-skippers-and-skipping-parsers/][Parsing Skippers and Skipping Parsers]]

*** Investigate adding polymode support for stitch                    :story:

We need a way to visualise stitch templates that is a bit more
readable than fundamental mode. One option is [[https://github.com/vspinu/polymode/tree/master/modes][polymode]].

** Deprecated
*** CANCELLED Add tests for main header file formatter with optionality :story:
    CLOSED: [2015-04-28 Tue 11:50]

*Rationale*: we already have tests for optionality at the boilerplate level.

We should add a couple of tests that exercise the annotation
factory. As it will have its own tests, we just need to make sure it
works in general. For example, pass in an empty annotation.

*** CANCELLED Strange logging behaviour in tests                      :story:
    CLOSED: [2015-04-28 Tue 11:48]

*Rationale*: can't reproduce.

As reported by JS for some reason if a test has a null pointer
de-reference, the next test will log to both files. This means the
logger is not being switched off properly in the presence of exceptions.

*** CANCELLED Rename =inserter_implementation=                        :story:
    CLOSED: [2015-04-28 Tue 11:50]

*Rationale*: won't be a problem after architecture refactor.

We used =inserter_implementation= to provide all sorts of utility
methods for IO. This class should really be named IO utility or
something of the sort.
