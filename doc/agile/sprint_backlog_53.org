#+title: Sprint Backlog 53
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) task(t) note(n) spike(p) }
#+tags: { refactor(r) bug(b) feature(f) vision(v) }
#+tags: { meta_data(m) tests(a) packaging(q) media(h) build(u) validation(x) diagrams(w) frontend(c) backend(g) }
#+tags: dia(y) sml(l) cpp(k) config(o) formatters(d)

* Stories

This file contains all stories that were closed during sprint 53.

The *Mission Statement* for this sprint is to implement the backend
model, hook it up to the C++ model and implement at least one
formatter in the C++ model.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2014-10-17 Fri 22:32]

| Headline                                                            | Time   |      |      |
|---------------------------------------------------------------------+--------+------+------|
| *Total time*                                                        | *6:55* |      |      |
|---------------------------------------------------------------------+--------+------+------|
| Development Stories Implemented                                     |        | 6:55 |      |
| IMPLEMENTATION Sprint and product backlog grooming                  |        |      | 1:26 |
| COMPLETED Fix CMake 3.0 warnings                                    |        |      | 0:14 |
| COMPLETED Rename =model_provider_interface= to =frontend_interface= |        |      | 0:18 |
| COMPLETED Implement the =backend= model                             |        |      | 1:31 |
| COMPLETED Implement general settings handling                       |        |      | 2:44 |
| COMPLETED Update =knit= to use the =backend= model                  |        |      | 0:42 |
#+end:

*** IMPLEMENTATION Sprint and product backlog grooming                 :task:
    CLOCK: [2014-10-17 Fri 22:22]--[2014-10-17 Fri 22:32] =>  0:10
    CLOCK: [2014-10-15 Wed 21:51]--[2014-10-15 Wed 22:03] =>  0:12
    CLOCK: [2014-10-14 Tue 22:41]--[2014-10-14 Tue 22:53] =>  0:12
    CLOCK: [2014-10-13 Mon 21:41]--[2014-10-13 Mon 22:06] =>  0:25
    CLOCK: [2014-10-06 Mon 08:10]--[2014-10-06 Mon 08:18] =>  0:08
    CLOCK: [2014-10-06 Mon 07:51]--[2014-10-06 Mon 08:10] =>  0:19

Updates to sprint and product backlog.

*** Updates to the manual and readme files                       :task:media:

Use downtime to update the manual and / or readme file.

*** Manually generate packages for previous sprint          :story:packaging:

#+begin_quote
*Story*: As a dogen user, I want to install dogen so that I don't have
to compile it.
#+end_quote

We should manually generate packages for the previous sprint and
upload them to Google drive. To do this we should log in to each build
agent, git clone the repo from scratch, =git checkout= the tag and
then do a full build. We should also upload the docs too. Ideally we
should do this for all platforms.

*** COMPLETED Fix CMake 3.0 warnings                                  :spike:
    CLOSED: [2014-10-06 Mon 19:16]
    CLOCK: [2014-10-06 Mon 19:02]--[2014-10-06 Mon 19:16] =>  0:14

After the latest CMake update we started to see a lot of warnings. We
need to fix these.

*** COMPLETED Rename =model_provider_interface= to =frontend_interface= :task:refactor:
    CLOSED: [2014-10-07 Tue 22:04]
    CLOCK: [2014-10-07 Tue 21:46]--[2014-10-07 Tue 22:04] =>  0:18

Since we called =backend_interface= to the =backend= model interface
for all the backend instances, it only seems logical to call
=frontend_interface= to its equivalent in the =frontend= model. This
may be a case of "over-symmetry" but seems to make sense.

*** COMPLETED Implement the =backend= model                   :task:refactor:
    CLOSED: [2014-10-07 Tue 22:08]

Create the interface, workflow and registrar for the backend
model. Workflow returns list of consumers. Implement it in formatters
and C++ models. Formatters are consumers too (or provide a consumer).

We may need to use some kind of adaptor for now to convert the output
of the =cpp_formatters= model into a =formatters::file=.

**** COMPLETED Code generate the =backend= model
     CLOSED: [2014-10-06 Mon 19:26]
     CLOCK: [2014-10-06 Mon 19:16]--[2014-10-06 Mon 19:26] =>  0:10
     CLOCK: [2014-10-06 Mon 08:20]--[2014-10-06 Mon 08:46] =>  0:26

Add model to CMake, fix all code generation errors, etc.

**** COMPLETED Implement the main classes
     CLOSED: [2014-10-07 Tue 22:07]
     CLOCK: [2014-10-07 Tue 22:05]--[2014-10-07 Tue 22:07] =>  0:02
     CLOCK: [2014-10-07 Tue 21:04]--[2014-10-07 Tue 21:44] =>  0:40
     CLOCK: [2014-10-06 Mon 19:26]--[2014-10-06 Mon 19:39] =>  0:13

Add code for interface, registrar and workflow.

*** COMPLETED Log should use path for file names              :task:refactor:
    CLOSED: [2014-10-13 Mon 21:50]

At present we are passing the log file name as a string and
concatenating using "/". This is not very good for Windows. We should
use =boost::filesystem::path= throughout and do a =.string= at the
very end if boost log does not support boost filesystem (or use the
path directly if it does).

*** COMPLETED Empty features should not show up                    :task:bug:
    CLOSED: [2014-10-13 Mon 21:54]

If there are no files for a feature, we should not generate includers
and folders for that feature.

*** COMPLETED Create front-end interfaces                     :task:refactor:
    CLOSED: [2014-10-13 Mon 21:56]

- create a front end component that defines the front end inteface,
  has a factory that returns a front end based on an enum.
- create the dia front end which contains the dia to SML code from
  modeling.
- create the JSON front end.
- engine should rely on the front-end factory.

*** COMPLETED Implement general settings handling             :task:refactor:
    CLOSED: [2014-10-16 Thu 22:55]
    CLOCK: [2014-10-16 Thu 22:01]--[2014-10-16 Thu 22:13] =>  0:12
    CLOCK: [2014-10-16 Thu 21:35]--[2014-10-16 Thu 22:00] =>  0:25
    CLOCK: [2014-10-10 Fri 23:40]--[2014-10-10 Fri 23:42] =>  0:02
    CLOCK: [2014-10-08 Wed 23:05]--[2014-10-09 Thu 00:07] =>  1:02
    CLOCK: [2014-10-08 Wed 22:45]--[2014-10-08 Wed 23:04] =>  0:19
    CLOCK: [2014-10-08 Wed 22:24]--[2014-10-08 Wed 22:31] =>  0:07
    CLOCK: [2014-10-07 Tue 22:09]--[2014-10-07 Tue 22:46] =>  0:37

*New understanding:*

Actually, we are making this much complicated
than what it needs to be. Lets just fulfil the simplest use case which
is to support general settings at the model module level.

*Old  understanding:*

We need to implement the model consumer interface, perform the
override heuristics, and return the general settings container to its
owner. We should also plug it in to the backend workflow.

*** COMPLETED Update =knit= to use the =backend= model        :task:refactor:
    CLOSED: [2014-10-16 Thu 22:56]
    CLOCK: [2014-10-18 Sat 23:20]--[2014-10-18 Sat 23:24] =>  0:04
    CLOCK: [2014-10-16 Thu 22:13]--[2014-10-16 Thu 22:55] =>  0:42

Hook up =knit= to use the new =backend= model.

*** Refactor types header formatter            :task:refactor:formatters:cpp:

Make the main types header formatters look like the =om= types
formatter. This model was deleted around commit 10157ad.

This is still not quite right. We need to drive the formatting from
two things:

- user options
- available formatters

**** Tidy-up =types_main_header_file_formatter=                        :task:

Clean up internal functions in file and add documentation.

**** Make use of boilerplate                                           :task:

Generate the licence, etc using boilerplate formatter.

**** Copy across documentation from =om=                               :task:

We did a lot of doxygen comments that are readily applicable, copy
them across.

**** Make use of indenting stream                                      :task:

Remove uses of old indenter.

**** Copy across =om= types formatter tests                            :task:

Not sure how applicable this would be, but we may be able to scavenge
some tests.

*** Add include files at the formatter level    :task:refactor:meta_data:cpp:

We need to remove all the include files from =includer= which are
related to formatter specific code. We need to inject these
dependencies inside of the formatters.

- implement includer in terms of json files
- get includer to work off of object relationships
- remove relationships from transformer
- remove helper models boost and std

*** Includer generation should be done from meta-data         :task:refactor:

It would be nice if we could determine which includer files to create
by looking at the meta-data. For this we need a notion of an inclusion
group, defined at the model level:

- =cpp.types.includers.general=
- =cpp.types.includers.value_objects=
- ...

Under each of these one would configure the aspect:

- =cpp.types.includers.general.generate=: =true=
- =cpp.types.includers.general.file_name=: =a/b/c=
- =cpp.types.includers.general.is_system=: =false=

Then, each type, module etc would declare its membership (as a list):

- =cpp.includers.member=: =cpp.types.includers.general=
- =cpp.includers.member=: =cpp.types.includers.value_objects=
- ...

*Previous understanding*

We should simply go through all the types in the SML model and for
each type and each facet create the corresponding inclusion
path. locator can be used to generate standard paths, and a model
specific mapping is required for other models such as std.

Include then takes the relationships extracted by extractor, the
mappings generated by this mapper and simply appends to the inclusion
list the file names. it also appends the implementation specific
headers.

*** Support "cross-facet interference"                         :task:feature:

In a few cases its useful to disable bits of a facet when another
facet is switched off because those bits do not belong to the main
facet the formatter is working on. At present this happens in the
following cases:

- Forward declaration of serialisation in domain when serialisation is
  off
- Friend of serialisation in domain when serialisation is
  off
- declaration and implementation of to_stream when IO is off
- declaration and implementation of inserter when IO is off and
  integrated IO is on.

We need a way of accessing the on/off state of all facets from any
formatter so that they can make cross facet decisions. A quick hack
was to add yet another flag: =disable_io= which is disabled when the
IO facet is not present and passed on to the relevant formatters. This
needs to be replaced by a more general approach.

*** Add frontends and backends to =info= command line option  :story:feature:

#+begin_quote
*Story*: As a dogen user, I want to know what frontends and backends
are available in my dogen version so that I don't try to use features
that are not present.
#+end_quote

With the static registration of frontends and backends, we should add
some kind of mechanism to display whats on offer in the command line,
via the =--info= option. This is slightly tricky because the
=frontend= and =backend= models do not know of the command line. We
need a method in the frontends that returns a description and a method
in the workflow that returns all descriptions. These must be
static. The knitter can then call these methods and build the info
text.

*** Rename the include tags and add them to CPP model          :task:bug:sml:

Update all the JSON files with names in the form
=cpp.include.types.header_file=. Add properties in =cpp= to capture
these.

While we're at it, add support for =family= too.

** Deprecated Development Stories

Stories that do not make sense any longer.

*** CANCELLED Implement the types enricher in cpp      :task:feature:sml:cpp:
    CLOSED: [2014-10-01 Wed 15:44]

*Rationale*: superseded by new stories.

Create the first and second stage enrichment for types. This is a good
test to see if the overall logic is sound.

*** CANCELLED Move SML graph visiting code from meta-data into main namespace :task:refactor:
    CLOSED: [2014-10-01 Wed 15:43]

*Rationale*: superseded by new stories.

We also need to rename enrichers and delete the graph of dependencies
between enrichers.

*** CANCELLED Create a librarian to manage library models     :task:refactor:
    CLOSED: [2014-09-29 Mon 01:25]

*Rationale*: Actually, the library models are not an SML artefact; in
fact SML handles these models in exactly the same way as any other
model. Knit is the right place for this.

As part of the frontend refactor we moved the loading of library
models away from the SML workflow. However, SML should at least
provide a simple way to manage the library models or else we will have
to duplicate this code wherever these models need to be loaded.
