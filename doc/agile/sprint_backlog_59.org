#+title: Sprint Backlog 59
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Commentary

** Mission

Implement dynamic and start making use of it in SML.

** Retrospective

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2015-01-13 Tue 00:23]

| Headline                                                       | Time   |      |      |
|----------------------------------------------------------------+--------+------+------|
| *Total time*                                                   | *8:16* |      |      |
|----------------------------------------------------------------+--------+------+------|
| Active                                                         |        | 8:16 |      |
| STARTED Sprint and product backlog grooming                    |        |      | 0:43 |
| COMPLETED Refactor comments processing code in dia to sml      |        |      | 4:01 |
| COMPLETED Create a class to store the field definitions        |        |      | 0:36 |
| COMPLETED Inject dia fields =comment= and =identity_attribute= |        |      | 2:47 |
| COMPLETED Determine what fields need to be injected            |        |      | 0:09 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-01-13 Tue 00:13]--[2015-01-13 Tue 00:22] =>  0:09
    CLOCK: [2015-01-12 Mon 23:00]--[2015-01-12 Mon 23:10] =>  0:10
    CLOCK: [2015-01-11 Sun 23:22]--[2015-01-11 Sun 23:34] =>  0:12
    CLOCK: [2015-01-05 Mon 23:28]--[2015-01-05 Mon 23:32] =>  0:04
    CLOCK: [2015-01-05 Mon 23:10]--[2015-01-05 Mon 23:18] =>  0:08

Updates to sprint and product backlog.

*** COMPLETED Refactor comments processing code in dia to sml         :story:
    CLOSED: [2015-01-09 Fri 23:46]
    CLOCK: [2015-01-08 Thu 22:40]--[2015-01-08 Thu 23:44] =>  1:04
    CLOCK: [2015-01-08 Thu 22:29]--[2015-01-08 Thu 22:40] =>  0:11
    CLOCK: [2015-01-08 Thu 21:34]--[2015-01-08 Thu 22:29] =>  0:55
    CLOCK: [2015-01-07 Wed 21:52]--[2015-01-07 Wed 23:29] =>  1:37
    CLOCK: [2015-01-06 Tue 22:14]--[2015-01-06 Tue 22:21] =>  0:07
    CLOCK: [2015-01-05 Mon 23:32]--[2015-01-05 Mon 23:39] =>  0:07

*New Understanding*

- the comments parser job should be to convert the comments section
  into the value of the =dia.comment= key, as well as parse any other
  kvps.
- use processed comment in processed object

*Previous Understanding*

In dia to sml; At present we are returning:

: std::pair<std::string,
:    std::list<
:       std::pair<std::string, std::string>
:    >
: >

Where the first string is the comments (sans kvps) and the second are
the kvps. This is a bit confusing. We should probably have a class
with fields that reflect this, e.g.:

- =original_comments=
- =key_value_pair=

We need to reflect on these names.

*** COMPLETED Create a class to store the field definitions           :story:
    CLOSED: [2015-01-12 Mon 23:46]
    CLOCK: [2015-01-12 Mon 23:39]--[2015-01-12 Mon 23:46] =>  0:07
    CLOCK: [2015-01-12 Mon 23:10]--[2015-01-12 Mon 23:39] =>  0:29

When querying for a field we need to have it's complete name. Instead
of duplicating the complete name, we should probably have a central
location for the field definitions. This is in effect a new take on
the =tags= theme but this time with the field definitions. We can then
use them like so:

#+begin_example
const auto s(o[field_definitions::identity_attribute().name().complete_name()]);
#+end_example

Its a tad verbose. A static variable is used in each of the static
methods. Initialiser also uses this code to populate the
registrar. Each model that defines fields has one of these classes (a
la =tags=).

To help with the verbosity we need a utility class in dynamic that
takes a field definition and queries the object with it.

*** COMPLETED Inject dia fields =comment= and =identity_attribute=    :story:
    CLOSED: [2015-01-12 Mon 23:47]
    CLOCK: [2015-01-10 Sat 00:48]--[2015-01-10 Sat 00:52] =>  0:04
    CLOCK: [2015-01-09 Fri 23:42]--[2015-01-10 Sat 00:48] =>  1:06
    CLOCK: [2015-01-09 Fri 23:22]--[2015-01-09 Fri 23:40] =>  0:18
    CLOCK: [2015-01-09 Fri 23:18]--[2015-01-09 Fri 23:22] =>  0:04
    CLOCK: [2015-01-06 Tue 22:21]--[2015-01-06 Tue 23:36] =>  1:15

We need to implement dia.comment in terms of the dynamic object. We
need to add the field definition and make sure we can replace the
transformer processing with the new approach.

Perhaps throwing whenever we find field that has no field definition
is a bit excessive, at least for now. This means we need to add all
the field definitions in one go rather than a few at a time. As a
quick fix we can skip over undefined fields and re-evaluate this
later.

*** COMPLETED Add a dynamic workflow to dia to sml transformer        :story:
    CLOSED: [2015-01-12 Mon 23:50]

*New Understanding*

With processed comments, we no longer require this. Having said that,
we did add the dynamic workflow to transformer so considering this as
a closed story.

*Previous Understanding*

We need to process the output of the comments parser using the dynamic
workflow.

*** COMPLETED Determine what fields need to be injected               :story:
    CLOSED: [2015-01-13 Tue 00:20]
    CLOCK: [2015-01-12 Mon 23:52]--[2015-01-13 Tue 00:01] =>  0:09

Log whenever we are skipping a field because there is no associated
field definition.

From main models:

#+begin_example
$ cd ../output/dogen/clang-3.5/log
$ grep -nH -e "Field definition not found" * | gawk '{print $NF}' | sort | uniq
ODB_PRAGMA
copyright
licence
modeline_group
#+end_example

And for unit tests:

#+begin_example
find . -iname '*log' -exec grep -nH -e "Field definition not found" {} \; | gawk '{print $NF}' | sort | uniq
COPYRIGHT
LICENCE
MODELINE_GROUP
key
#+end_example

Seems like we have a mix of cases on annotation fields.

*** Add annotation fields and remove meta-data usage in formatters    :story:

Add all required field definitions for the formatters field; rename
meta-data namespace to dynamic and re-implement factory using dynamic
fields instead of =ptree=.

We need to inject:

- copyright
- licence
- modeline_group

We also need to sort out the upper case/lower case naming of these
fields in various diagrams.

*** Remove optionality from =obtain_field_definition=                 :story:

In order to progress in stages we made fields optional in dynamic
workflow; if a definition is not found we skip it. We need to remove
this once all field definitions have been added.

*** Rename =dia.comment=                                              :story:

This field hasn't got a sensible name. We need to continue thinking
about the right name for this - as we have already started doing with
processed comment; =applicable_to_parent_object= is not quite the
right name but it is moving on the right direction. Once we settle on
a good name we need to rename all usages of =dia.comment=.

*** Replace uses of meta-data with dynamic object                     :story:

Find all places where we are using ptree and use the dynamic object
instead. This should be mainly in meta-data factories.

*** Rename namespace =meta-data= to =dynamic=                         :story:

We have created a number of "meta-data extension" namespaces, which is
where we transform the ptree into a strongly typed object. These
should be renamed to =dynamic= to make it consistent.

*** Remove all references to =ptree=                                  :story:

Delete reader and writer classes and remove meta-data from
=Extensible=.

*** Add merger to dynamic                                             :story:

We need a class that takes two objects and merges them. For example
the root module meta-data object and any type. Could be called
merger. Should have a lhs and a rhs and produce a result.

*Note*: we still need to prove the use case; it may be that we do not
need merging at all.

*** Add dynamic merging to SML workflow                               :story:

We need an extra activity in the SML workflow that makes use of the
=dynamic::merger= to produce the final dynamic object.

*Note*: we still need to prove the use case; it may be that we do not
need merging at all.

*** Remove dependency of writer on tags                               :story:

We seem to be using the tags to detect containers. We need to get rid
of this dependency.

*** Delete tags class in SML                                          :story:

This class does not make sense any more as each model will be
responsible for their own tags.

Can only be done once we delete writer and reader.

*** Protect against double-initialisation                             :story:

We need to look into static initialisation and make sure the code can
cope with it being called several times.

*** Create a top-level initialiser for knit                           :story:

At present we are duplicating the initialisation dependencies
everywhere where knit is being used. We should just declare a knit
initialiser that does the job and call that from the outside world.

*** Update meta-data section in manual                                :story:

Once we are done with all of the meta-data refactoring, we need to
update the manual.

** Deprecated
