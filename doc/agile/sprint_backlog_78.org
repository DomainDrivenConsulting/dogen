#+title: Sprint Backlog 78
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- continue work on the cpp/quilt refactor.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75
#+CAPTION: Clock summary at [2016-01-10 Sun 10:33]
| <75>                                                                        |         |       |      |
| Headline                                                                    | Time    |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                                | *14:56* |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| Stories                                                                     | 14:56   |       |      |
| Active                                                                      |         | 14:56 |      |
| STARTED Sprint and product backlog grooming                                 |         |       | 1:09 |
| COMPLETED Supply formatter properties and settings directly to formatter    |         |       | 4:12 |
| COMPLETED Rename =backend= to =quilt=                                       |         |       | 0:41 |
| COMPLETED Rename =cpp= to =quilt.cpp=                                       |         |       | 7:24 |
| STARTED Create a separate flow for yarn based types                         |         |       | 0:57 |
| STARTED Create a blog post on product backlogs                              |         |       | 0:33 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-01-07 Thu 20:20]--[2016-01-07 Thu 20:35] =>  0:15
    CLOCK: [2016-01-07 Thu 19:55]--[2016-01-07 Thu 20:20] =>  0:25
    CLOCK: [2016-01-07 Thu 06:10]--[2016-01-07 Thu 06:24] =>  0:20
    CLOCK: [2016-01-06 Wed 23:28]--[2016-01-06 Wed 23:31] =>  0:03
    CLOCK: [2016-01-04 Mon 21:28]--[2016-01-04 Mon 21:40] =>  0:12

Updates to sprint and product backlog.

*** STARTED Update manual                                             :story:

Updates to manual.

*** COMPLETED Supply formatter properties and settings directly to formatter :story:
    CLOSED: [2016-01-06 Wed 22:29]
    CLOCK: [2016-01-06 Wed 21:32]--[2016-01-06 Wed 22:29] =>  0:57
    CLOCK: [2016-01-05 Tue 21:15]--[2016-01-05 Tue 23:11] =>  1:56
    CLOCK: [2016-01-04 Mon 21:41]--[2016-01-04 Mon 23:00] =>  1:19

In preparation for removing the cpp formattables, we need to supply
the formatter properties and settings in the format method, rather
than via the cpp type.

Notes:

- we must pass in the whole map into the formatter not just the
  formatter properties for a given formatter.
- we need to do some hackery around the formattables factory and pass
  in the repositories as non-const references to populate them for the
  hacked types. This will all be handled properly once we move to yarn
  types.

*** COMPLETED Rename =backend= to =quilt=                             :story:
    CLOSED: [2016-01-07 Thu 23:33]
    CLOCK: [2016-01-07 Thu 22:52]--[2016-01-07 Thu 23:33] =>  0:41

As part of the quilt refactor, we need to rename =backend= to =quilt=.

*** COMPLETED Rename =cpp= to =quilt.cpp=                             :story:
    CLOSED: [2016-01-10 Sun 10:33]
    CLOCK: [2016-01-10 Sun 09:55]--[2016-01-10 Sun 10:32] =>  0:37
    CLOCK: [2016-01-09 Sat 22:41]--[2016-01-10 Sun 00:27] =>  1:46
    CLOCK: [2016-01-08 Fri 23:20]--[2016-01-09 Sat 02:52] =>  3:32
    CLOCK: [2016-01-08 Fri 21:11]--[2016-01-08 Fri 22:40] =>  1:29

As part of the quilt refactor we need to rename =cpp= to =quilt.cpp=.

Notes:

- namespace documentation file is not part of master includer
- not generating services

*** Rename test data folder for yarn.dia files                        :story:

Test data folder is still called =yarn_dia= rather than =yarn.dia=.

*** STARTED Create a separate flow for yarn based types               :story:
    CLOCK: [2016-01-06 Wed 22:30]--[2016-01-06 Wed 23:27] =>  0:57

We won't be able to replace all cpp types in one go, so the best way
to go about this is to incrementally update the formatters. This could
be done by having two sets of elements to format, one formattable
based and the other yarn based. We can update the interfaces, one type
a time and have them share the same registrars etc.

*** STARTED Create a blog post on product backlogs                    :story:
    CLOCK: [2016-01-07 Thu 06:25]--[2016-01-07 Thu 06:58] =>  0:33

- linus quote on bug trackers
- how the management of the backlog is not the same as the management
  of stories/tasks. A task management system is still useful.
- jira as a fire and forget capture system.
- issues in github are not a replacement for a backlog, but useful in
  managing user interactions; the kind of stories that go into the
  backlog are different.
- on product backlog grooming.
- graph of features: a) all features in the world b) all features in
  your product that are compatible with your vision c) all features in
  the backlog d) all features in the sprint log.
- find Kevlin Henney's graph on the relationship between product and
  sprint backlog (had some arrows in a cycle). Also find some of his
  quotes.
- the importance of vision as the function that determines if a story
  should go in the backlog or not; and how stories refine the
  vision. It starts hazy but then coalesces over time and comes to
  define what the product means.
- define strategy has the set of steps required to implement the
  vision.
- the importance of mission for a sprint as a function that determines
  what to get out of the backlog. Tactics go along with missions.
- how a good product backlog could have a story that evolves over the
  years only to become exactly the thing you need at a given sprint
  and then you benefit from the knowledge and insight gained over that
  period of time.
- Stories mature in the backlog. They are at different stages:
  occasional one-liner/todo style story, which gets filled in over
  time until it has enough information to become implementable; it
  then waits until there is a sprint with a consistent mission. Or it
  could be that the story has to mature within the sprint
  itself. Mature stories get refined: trimmed in scope, re-targeted,
  or even cancelled because they no longer fit with the
  vision. Cancelled stories are important because we may came back to
  them - its just very unlikely that we do.
- if your product backlog is empty your product is dead - find the
  quote, probably Henney.
- backlog becomes stale so its important to do deep grooming very
  frequently. This is an expensive activity as time goes by because
  a good backlog increases in size with time. As the number of
  developers will not grow in line with the size of the backlog, this
  becomes more of a problem over time. However, its still very
  important to avoid from letting it go stale.
- managing a backlog in org mode is very advantageous: one big flat
  file, renderable in HTML; easy to fold and create structure as
  required.
- finding the right level of structure in the backlog is difficult; we
  tried lots of structure but then it became expensive to maintain. At
  the same time, stories become harder to find without structure so
  there is less value. For example it would be nice to find all bugs
  on a given component, or all visionary tasks, etc.
- FIXME: we should not use the word "vision" as a label or category in
  the backlog as it makes it confusing since its not the product
  vision.
- provide a definition of product and backlog (e.g. dictionary) and
  then of product backlog using an agile definition.
- before writing a story try very hard to find prior art. You need to
  find all stories in the backlog that have any vague relation to this
  new story and either modify those or extract the commonalities from
  those into this new story.
- if a product is the exploration of an unknown space, the backlog is
  the sum total knowledge of that exploration, akin to a map of that
  space. The backlog is akin to an historical map: it gives you the
  thoughts of the person that last was in that area, in a given state
  of mind. It is not a very accurate map, but then like those maps its
  better than nothing.
- FIXME: find the Henney quote on how even if you write the same code
  twice you would not write it the same way because you are not the
  same.
- stories in backlog should have age/recency: time they were last
  groomed. Devs must take a certain percentage of backlog stories
  every sprint and groom them. The percentage is determined by the
  rate at which stories are going in and out of backlog (some kind of
  backlog growth rate).
- find story on dead project that was on hacker news because the
  number of open stories was too large.
- talk about how useless and counter productive backlogs are in
  professional places with large teams because the signal to noise
  ratio is too high. People first start that sprint planning by going
  through the backlog, then a subset of the backlog and then
  eventually just ignore it all together because they spent the whole
  sprint planning meet looking through the backlog.
- post: on product backlogs
- [[http://tinyletter.com/programming-beyond-practices/letters/the-sad-graph-of-software-death][The sad graph of software death]]

*** Attach helper methods to types dynamically                        :story:

In order to cope with the removal of nested type info, we need a way
to determine what helper methods are required for a given yarn type.

For this we need a way to allow helper methods to bind dynamically to
types. This can be done by using meta-data. The helper method
registers a name and the type uses that name it its key for helper
method. Where possible the helper method should use the name of the
STL concept it is binding to. We need settings support for reading
this field, and registration support for helper methods (registrar,
etc).

We should also find a nicer way to package helper methods, maybe
aligned to a model and type or concept.

Once this is done we need to remove the =object_types= that exist in
yarn just to figure out what helper methods to use.

*** Implement formattables in terms of yarn types                     :story:

At present formattables are just a shadow copy of yarn types plus
additional =cpp= specific types. In practice:

- for the types that are shadow copies, we could have helper utilities
  that do the translation on the fly (e.g. for names).
- for additional information which cannot be translated, we could have
  containers indexed by qualified name and query those just before we
  call the transformer. This is the case with formatter properties. We
  need something similar to house "type properties" such as
  =requires_stream_manipulators=. These could be moved into aspect
  settings.
- for types that do not exist in yarn, we could inherit from element;
  this is the case for registrar, forward declarations, cmakelists and
  odb options. Note that with this we are now saying that element
  space contains anything which can be modeled, regardless of if they
  are part of the programming language type system, or build system,
  etc. This is not ideal, but its not a problem just yet. We could
  update the factory to generate these types and then take a copy of
  the model and inject them in it.

*** Create a settings class for the "requires" settings               :story:

We need to populate these in a settings workflow of some kind.

*** Move all properties in =cpp= to a properties namespace            :story:

Once all formattables are gone, we should have only properties left in
the formattables namespace. We should then rename it to
properties. Thus we have two kinds of things: settings, which are a
direct translation of meta-data without any further processing and
properties which require processing.

Merged stories:

*Split formatter properties and associated classes from formattables*

We have two kinds of data: the formattables themselves (mapped from
yarn) and associated data (formatter properties). The latter is
totally independent. We should create a namespace for all of these
classes and a workflow that produces the data ready for consumption. A
tentative name is =manifest=.

*** Investigate slow down                                             :story:

With commit 7e89ddb we introduced a set of hacks to inject settings
and formatter properties into the repositories. This seems to have had
a very negative impact in performance. We need to ensure performance
goes back to normal after the hacks have been removed.

*** Tidy-up master include generation                                 :story:

At present we have one humongous hack in the factory to generate the
master includers. How to do this properly:

- wait until we start using yarn types.
- loop through the yarn model instead of the path derivatives.
- use a visitor to dispatch the types.
- do not filter out services?
- filter registrars etc based on type dispatching.

*** Create a UML profile to formalise yarn concepts                   :story:

Profile should include the hashable, etc changes.

*** Create a map between UML/MOF terminology and yarn                 :story:

It would be helpful to know what a yarn type means in terms of
UML/MOF, and perhaps even explain why we have chosen certain names
instead of the UML ones. We should also cover the modeling of
relationships and the relation between yarn concepts and UML/MOF
classes. This will form a chapter in the manual.

The UML specification is available [[http://www.omg.org/spec/UML/2.5/][here]] and MOF specification is
available [[http://www.omg.org/spec/MOF/2.5][here]].

We need a way to uniquely identify a property. This could be done by
appending the containing type's qualified name to the property name.

See also [[http://www.uml-diagrams.org/][The Unified Modeling Language]] for a more accessible treatment.

*** Remove =service= stereotype                                       :story:

This really just means non-generatable, or do not generate. We already
have a stereotype for this. Remove =service= and any other stereotype
which is not being used such as =value_object= etc.

Actually, non-generatable is not a stereotype really. We should
instead have some meta-data that can affect generation:

- do not generate: do nothing at all. For references only. If a file
  exists with this file name, it will be deleted as part of
  housekeeping.
- generate blank file if it doesn't exist: we don't even want a
  template.
- generate with content if it doesn't exist, do not touch otherwise:
  what we call services at the moment. Generate a "template" that then
  gets filled in manually.
- generate and merge: merge the contents of the generated file with
  the current contents in the file system. When we support merging.
- generate and overwrite: generate the file and overwrite whatever
  exists in the file system.

This could be called "generation policy".

The second behaviour we get for free with services is that we disable
all facets except for types. A few points:

- we may want to have io, serialisation, etc. This is not possible at
  present. If a state of a service is made up of supported types, we
  could even use existing code generation.
- in order for this to be implemented correctly we need to hook in to
  the enablement management somehow. In addition, it seems each facet
  can have its own generation policy. For example we may want to
  manually create types but automatically generate io.
- the best way to handle this may be to setup "enablement profiles"
  that the user can hook up to. For example we could have a "default"
  profile that enables all facets (or uses facet defaults), a second
  "service" profile that enables types with partial generation and io
  with full generation and so on. We probably also need "generation
  profiles" to go with "enablement profiles".

** Deprecated
*** CANCELLED Consider renaming nested name                           :story:
    CLOSED: [2016-01-07 Thu 20:18]

*Rationale*: the final conclusion on this was that nested name is the
best of a bad bunch. See Sprint 77 stories on renames for details.

*New understanding*:

This story requires further analysis. Blindly following the composite
pattern was tried but it resulted in a lot of inconsistencies because
we then had to follow MEC-33 and create =abstract_qname=; however, the
nested qname does not really behave like a composite qname; its more
like the difference between a type in isolation and a type
instantiated as an argument of a function. For example, whilst the
type in isolation may have unknown template parameters, presumably, as
an argument of a function these have been instantiated with real
types.

One way to solve this is just to make the type name a bit more
explicit rather than try to imply the composite pattern
(e.g. "nested"). We need a name that signifies "instantiated
type". Look at the C++ standard for the difference between defining a
generic type and instantiating a generic type.

No good names yet (type reference, type instantiation, instantiated
name). What are we trying to represent: an identifier which points to
a complete definition of a name such that the name can be instantiated
as a type in the underlying language. By "instantiated" we mean used
to define variables of this type. In this light: instantiable name,
definable name? If we choose instantiable name, we could then rename
"children" to type arguments.

Other notes:

- there is such a thing as a element instance identifier. We call it
  nested name at present. The element instance identifier identifies
  instantiations of types. It models two cases: for the case where the
  type has no type parameters, the instance identifier is equal to the
  element identifier; for all other cases, it is a hierarchical
  collection of element identifiers, modeling the type parameter
  structure.

*Previous understanding*:

We should just follow the composite pattern in the naming.
