#+title: Sprint Backlog 84
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- complete the properties refactoring across all models;
- finish implementing IO helpers.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-07-15 Fri 21:35]
| <75>                                                                        |         |       |      |       |
| Headline                                                                    | Time    |       |      |     % |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| *Total time*                                                                | *30:03* |       |      | 100.0 |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| Stories                                                                     | 30:03   |       |      | 100.0 |
| Active                                                                      |         | 30:03 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |         |       | 2:26 |   8.1 |
| STARTED Manual updates and blog posts                                       |         |       | 1:21 |   4.5 |
| COMPLETED Try to fix tag build issues                                       |         |       | 1:28 |   4.9 |
| COMPLETED Enable =BUILD_TYPE= on travis                                     |         |       | 1:17 |   4.3 |
| COMPLETED Add initial support for coveralls                                 |         |       | 0:29 |   1.6 |
| COMPLETED Simplify local builds on emacs                                    |         |       | 0:20 |   1.1 |
| COMPLETED Create a debug build for clang in travis                          |         |       | 0:10 |   0.6 |
| COMPLETED Rename element settings back to aspect settings                   |         |       | 0:50 |   2.8 |
| COMPLETED Rename bundle to element settings                                 |         |       | 0:27 |   1.5 |
| COMPLETED Rename bundle in stitch to properties                             |         |       | 0:16 |   0.9 |
| COMPLETED Refactor general settings                                         |         |       | 5:50 |  19.4 |
| COMPLETED Rename specs to tests                                             |         |       | 1:24 |   4.7 |
| COMPLETED Create a IO settings class                                        |         |       | 1:15 |   4.2 |
| COMPLETED Implement streaming for type in terms of IO settings              |         |       | 1:24 |   4.7 |
| COMPLETED Usage of rev-list in version causes problems                      |         |       | 0:03 |   0.2 |
| CANCELLED Consider not running initialisers in a static context             |         |       | 0:10 |   0.6 |
| COMPLETED Refactor formatter interfaces                                     |         |       | 0:36 |   2.0 |
| COMPLETED Move formatter helpers into formatter container                   |         |       | 0:13 |   0.7 |
| COMPLETED Add aliases for commonly used targets                             |         |       | 0:02 |   0.1 |
| CANCELLED Add a pretty printer for ownership hierarchy                      |         |       | 0:13 |   0.7 |
| COMPLETED Add formatter id to file and helper formatters                    |         |       | 1:20 |   4.4 |
| COMPLETED Add IO to formatter container                                     |         |       | 1:19 |   4.4 |
| COMPLETED Includers formatter id is incorrect                               |         |       | 0:07 |   0.4 |
| COMPLETED Enable IO helpers for types                                       |         |       | 5:51 |  19.5 |
| COMPLETED Implement IO helper methods with new helper infrastructure        |         |       | 1:03 |   3.5 |
| STARTED Implement hashing using dynamic helpers                             |         |       | 0:09 |   0.5 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-07-12 Tue 17:47]--[2016-07-12 Tue 18:37] =>  0:50
    CLOCK: [2016-07-12 Tue 17:25]--[2016-07-12 Tue 17:46] =>  0:21
    CLOCK: [2016-07-12 Tue 15:50]--[2016-07-12 Tue 16:10] =>  0:20
    CLOCK: [2016-07-06 Wed 18:31]--[2016-07-06 Wed 18:35] =>  0:04
    CLOCK: [2016-07-05 Tue 21:27]--[2016-07-05 Tue 21:47] =>  0:20
    CLOCK: [2016-07-05 Tue 21:22]--[2016-07-05 Tue 21:26] =>  0:04
    CLOCK: [2016-07-05 Tue 21:11]--[2016-07-05 Tue 21:21] =>  0:10
    CLOCK: [2016-07-04 Mon 20:05]--[2016-07-04 Mon 20:22] =>  0:17

Updates to sprint and product backlog.

*** STARTED Manual updates and blog posts                             :story:
    CLOCK: [2016-07-09 Sat 23:43]--[2016-07-09 Sat 23:56] =>  0:13
    CLOCK: [2016-07-09 Sat 23:21]--[2016-07-09 Sat 23:40] =>  0:19
    CLOCK: [2016-07-09 Sat 18:53]--[2016-07-09 Sat 19:05] =>  0:12
    CLOCK: [2016-07-05 Tue 21:48]--[2016-07-05 Tue 22:25] =>  0:37

Time taken with blog posts and updates to the manual.

*** COMPLETED Try to fix tag build issues                             :story:
    CLOSED: [2016-07-04 Mon 21:03]
    CLOCK: [2016-07-04 Mon 21:39]--[2016-07-04 Mon 22:12] =>  0:33
    CLOCK: [2016-07-04 Mon 21:15]--[2016-07-04 Mon 21:38] =>  0:23
    CLOCK: [2016-07-04 Mon 20:30]--[2016-07-04 Mon 21:02] =>  0:32

For some reason we are getting failures when building the tag:

: CMake Error at CMakeLists.txt:203 (string):
:  string sub-command STRIP requires two arguments.

For some reason the git commit count command is failing on a tag. At
any rate, we do not seem to need the strip, so the easy fix for now is
to remove it.

Actually, reproducing the commands locally, the error is:

: fatal: ambiguous argument 'master': unknown revision or path not in the working tree.
: Use '--' to separate paths from revisions, like this:
: 'git <command> [<revision>...] -- [<file>...]'

This is probably related to checking out the branch but requesting
rev-list from master. We can ask for the current branch's rev-list
instead:

: git rev-list --count HEAD

We were already doing this for the hash of the top-commit.

*** COMPLETED Enable =BUILD_TYPE= on travis                           :story:
    CLOSED: [2016-07-05 Tue 21:10]
    CLOCK: [2016-07-05 Tue 20:17]--[2016-07-05 Tue 20:22] =>  0:05
    CLOCK: [2016-07-05 Tue 19:04]--[2016-07-05 Tue 20:16] =>  1:12

Using =BUILD_TYPE= seems to disable the stage folder in travis -
though it works locally. We probably shouldn't use the stage folder
since its not a CMake idiom.

The other thing to notice is that we do not have a =make_directory=
for these folders anywhere in the code base. Its not clear how it has
been working so far.

- generate the folders if they do not exist;
- remove =WITH_DEBUG=.

*** COMPLETED Add initial support for coveralls                       :story:
    CLOSED: [2016-07-06 Wed 18:01]
    CLOCK: [2016-07-06 Wed 18:01]--[2016-07-06 Wed 18:30] =>  0:29

Seems like all we need to do to have code coverage from travis is to
enable it in the YML file.

Try just copying the code from [[https://github.com/JoakimSoderberg/coveralls-cmake][coveralls-cmake]]

- we are generating far too much output. We need to keep it quieter or
  we will break travis.
- we are not filtering out non-project files from initial
  processing. There must be a gcov option to ignore files.

: Process: /home/marco/Development/DomainDrivenConsulting/dogen/build/output/gcc-5/Debug/projects/quilt/spec/CMakeFiles/quilt.spec.dir/main.cpp.gcda
: ------------------------------------------------------------------------------
: File '../../../../projects/quilt/spec/main.cpp'
: Lines executed:62.50% of 8
: Creating '^#^#^#^#projects#quilt#spec#main.cpp.gcov'
:
: File '/usr/local/personal/include/boost/smart_ptr/detail/sp_counted_impl.hpp'
: Lines executed:60.00% of 20
: Creating '#usr#local#personal#include#boost#smart_ptr#detail#sp_counted_impl.hpp.gcov'

See also:

- [[https://github.com/JoakimSoderberg/coveralls-cmake-example/blob/master/CMakeLists.txt][example use of coveralls-cmake]]
- [[https://github.com/SpinWaveGenie/SpinWaveGenie/blob/master/libSpinWaveGenie/CMakeLists.txt][SpinWaveGenie's support for Coveralls]]

**** Direct use of Coveralls failed

We had to remove coveralls:

: - coveralls --gcov "$GCOV" --gcov-options '\-lp' -e /usr

This was generating over 10 MB of logging so the build got terminated.

We also add to remove debug builds:

: -DWITH_DEBUG=on -DWITH_PROFILING=on

We were getting a lot of internal compiler errors:

: FAILED: /usr/bin/g++-4.9   -DBOOST_ALL_DYN_LINK -g -O0 -Wall -Wextra -pedantic -Werror -Wno-system-headers -Woverloaded-virtual -Wwrite-strings -fprofile-arcs -ftest-coverage -std=c++11 -frtti -fvisibility-inlines-hidden -fvisibility=default -isystem /usr/include/libxml2 -Istage/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/dia/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/dia_to_sml/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/frontend/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/backend/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/sml/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/config/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/cpp/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/cpp_formatters/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/sml_to_cpp/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/formatters/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/utility/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/knit/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/knitter/include -MMD -MT projects/sml_to_cpp/src/CMakeFiles/sml_to_cpp.dir/types/transformer.cpp.o -MF "projects/sml_to_cpp/src/CMakeFiles/sml_to_cpp.dir/types/transformer.cpp.o.d" -o projects/sml_to_cpp/src/CMakeFiles/sml_to_cpp.dir/types/transformer.cpp.o -c /home/travis/build/DomainDrivenConsulting/dogen/projects/sml_to_cpp/src/types/transformer.cpp
: g++-4.9: internal compiler error: Killed (program cc1plus)
: Please submit a full bug report,
: with preprocessed source if appropriate.
: See <file:///usr/share/doc/gcc-4.9/README.Bugs> for instructions.

Finally note also that we must add coverage _after_ the script
executes or else we risk doing coverage whilst the build is taking
place. Hopefully this is the reason for these errors:

: /home/travis/build/DomainDrivenConsulting/output/projects/test_models/class_without_attributes/src/CMakeFiles/class_without_attributes.dir/io/package_1/class_1_io.cpp.gcda:cannot open data file, assuming not executed
: File '/usr/include/c++/4.9/bits/basic_ios.h'
: No executable lines

We should read up on the [[http://docs.travis-ci.com/user/build-lifecycle/][life-cycle]] properly.

**** Travis Examples

Seems like all we need to do to have code coverage from travis is to
enable it in the YML file. We should look into copying it from the
[[https://github.com/apolukhin/Boost.DLL][Boost.DLL]] [[https://raw.githubusercontent.com/apolukhin/Boost.DLL/master/.travis.yml][example]]. We also need to enable coverage on all builds,
separately from nightlies. The key parts appear to be these:

:  - ../../../b2 cxxflags="--coverage -std=$CXX_STANDARD" linkflags="--coverage"

and

: after_success:
:    - find ../../../bin.v2/ -name "*.gcda" -exec cp "{}" ./ \;
:    - find ../../../bin.v2/ -name "*.gcno" -exec cp "{}" ./ \;
:    - sudo apt-get install -qq python-yaml lcov
:    - lcov --directory ./ --base-directory ./ --capture --output-file coverage.info
:    - lcov --remove coverage.info '/usr*' '*/filesystem*' '*/container*' '*/core/*' '*/exception/*' '*/intrusive/*' '*/smart_ptr/*' '*/move/*' '*/fusion/*' '*/io/*' '*/function/*' '*/iterator/*' '*/preprocessor/*' '*/system/*' '*/boost/test/*' '*/boost/detail/*' '*/utility/*' '*/dll/example/*' '*/dll/test/*' '*/pe_info.hpp' '*/macho_info.hpp' -o coverage.info
:    - gem install coveralls-lcov
:    - cd .. && coveralls-lcov test/coverage.info

Another way seems to be using gcov, as per [[https://github.com/fabianschuiki/Maxwell][Maxwell]] [[https://raw.githubusercontent.com/fabianschuiki/Maxwell/master/.travis.yml][travis.yml]]:

: - if [ "$CXX" = "g++" ]; then sudo apt-get install -qq g++-4.8; export CXX="g++-4.8" CC="gcc-4.8" GCOV="gcov-4.8"; fi
:  - sudo pip install cpp-coveralls

and

: script:
:  - export CTEST_OUTPUT_ON_FAILURE=1
:  - cmake -DCMAKE_BUILD_TYPE=gcov . && make && make test
: after_success:
:  - coveralls --gcov "$GCOV" --gcov-options '\-lp' -e CMakeFiles -E ".*/test/.*" -E ".*/mock/.*" -e maxwell/gen -e language -e thirdparty -e maxwell/ast/nodes -e maxwell/driver/gramdiag.c -e maxwell/driver/Parser.cpp -e maxwell/driver/Parser.hpp -e maxwell/driver/Scanner.cpp -e maxwell/driver/position.hh -e maxwell/driver/stack.hh -e maxwell/driver/location.hh

Yet another way seems to be creating a script to do coverage, as per
[[https://github.com/BoostGSoC13/boost.afio][boost.afio]] [[https://raw.githubusercontent.com/BoostGSoC13/boost.afio/master/.travis.yml][travis.yml]]. The script is available [[https://raw.githubusercontent.com/BoostGSoC13/boost.afio/master/test/update_coveralls.sh][here]].

Another example from [[https://github.com/boostorg/dll/blob/develop/.travis.yml][Boost.Dll]].

*** COMPLETED Simplify local builds on emacs                          :story:
    CLOSED: [2016-07-06 Wed 18:32]
    CLOCK: [2016-07-06 Wed 00:20]--[2016-07-06 Wed 00:40] =>  0:20

With the move to build type, local builds on emacs are getting more
and more complicated. We need some kind of script. The command line at
present is rather monstrous:

: export PROJ=~/Development/DomainDrivenConsulting/dogen/ &&
: export BUILD=Release &&
: cd ${PROJ}/build/output/gcc-5/${BUILD} &&
: CMAKE_INCLUDE_PATH=/usr/local/personal/include
: CMAKE_LIBRARY_PATH=/usr/local/personal/lib
: CC=gcc-5 CXX=g++-5
: cmake ${PROJ} -G Ninja -DCMAKE_BUILD_TYPE=${BUILD}
: -DCMAKE_EXPORT_COMPILE_COMMANDS=TRUE -DWITH_LATEX=FALSE &&
: ninja -j5

Create a simple bash script with a couple of parameters:

- clang or gcc
- debug or release
- cmake dir

Usage:

: COVERALLS=1
: /home/marco/Development/DomainDrivenConsulting/dogen/build/scripts/build.linux.sh
: Debug gcc /usr/local/personal

*** COMPLETED Create a debug build for clang in travis                :story:
    CLOSED: [2016-07-06 Wed 18:59]
    CLOCK: [2016-07-05 Tue 21:00]--[2016-07-05 Tue 21:10] =>  0:10

In order to enable code coverage we need to have a debug build. For
this we need to setup travis with a build matrix, with two build types
for clang (debug and release).

Example YML: [[https://github.com/Microsoft/GSL/blob/master/.travis.yml][GSL]]
*** COMPLETED Rename element settings back to aspect settings         :story:
    CLOSED: [2016-07-06 Wed 19:24]
    CLOCK: [2016-07-06 Wed 19:07]--[2016-07-06 Wed 19:24] =>  0:17
    CLOCK: [2016-07-06 Wed 18:33]--[2016-07-06 Wed 19:06] =>  0:33

As per design story, we incorrectly added non-aspect attributes to
this class. Remove them and rename the class.

*** COMPLETED Rename bundle to element settings                       :story:
    CLOSED: [2016-07-06 Wed 19:48]
    CLOCK: [2016-07-06 Wed 19:24]--[2016-07-06 Wed 19:51] =>  0:27

As per design story, these are really the settings that belong to the
element. Rename and deal with the fallout.

*** COMPLETED Rename bundle in stitch to properties                   :story:
    CLOSED: [2016-07-06 Wed 23:01]
    CLOCK: [2016-07-06 Wed 22:45]--[2016-07-06 Wed 23:01] =>  0:16

In keeping with the properties/settings refactor, ensure stitch is
using these terms with the same meanings as everyone else.

*** COMPLETED Refactor general settings                               :story:
    CLOSED: [2016-07-08 Fri 22:57]
    CLOCK: [2016-07-08 Fri 21:45]--[2016-07-08 Fri 22:57] =>  1:12
    CLOCK: [2016-07-07 Thu 20:18]--[2016-07-07 Thu 21:02] =>  0:44
    CLOCK: [2016-07-07 Thu 07:53]--[2016-07-07 Thu 08:40] =>  0:47
    CLOCK: [2016-07-06 Wed 00:13]--[2016-07-06 Wed 00:20] =>  0:07
    CLOCK: [2016-07-06 Wed 00:06]--[2016-07-06 Wed 00:12] =>  0:06
    CLOCK: [2016-07-05 Tue 23:16]--[2016-07-06 Wed 00:05] =>  0:49
    CLOCK: [2016-07-05 Tue 22:26]--[2016-07-05 Tue 23:15] =>  0:49
    CLOCK: [2016-07-04 Mon 22:54]--[2016-07-04 Mon 23:30] =>  0:36
    CLOCK: [2016-07-04 Mon 22:13]--[2016-07-04 Mon 22:53] =>  0:40

Tasks:

- create a file settings class that reflects dynamic (and nothing
  more). Create an associated factory, repository etc.
- rename the existing general settings to file properties. Make the
  factory use the file settings to produce the properties.
- move general settings from the bundle into element properties.

*Previous Understanding*

A while ago we came up with this name for the settings of the generic
formatter model. This is the model with basic infrastructure to be
reused by the more specialised formatters. However, now that we have
many (many) settings classes, general settings may not be the most
appropriate name. We need to look a bit more deeply into the role of
this class and see if a better name is not available.

We could call it preamble settings because all settings are related to
the file preamble; annoyingly, we also generate a post-amble from
it. There doesn't seem to be any good names for the pair (preamble,
post-amble). In networking this would be called frame markers perhaps.

Now that we are not using =meta_data= any more, perhaps we could
re-purpose it for this (=meta_data_settings=). In a way, preambles and
post-ambles are meta-data, as opposed to the real file
contents. Having said that, one could say the same about any kind of
comments.

We could also use [[http://www1.appstate.edu/~yaleread/typographichierarchy.pdf][typography terminology]]: headers and footers.

Now that we have subsidiary settings and principal settings do we need
the rename? We should consider "universal settings" maybe.

In addition, the convention is now that "settings" mean a strongly
typed representation of =dynamic= data; general "settings" are not
settings in this sense. However, we do need a class to model settings
properly (i.e. to mirror dynamic exactly, without any
transformations).

In truth, =annotation= is probably sufficient - or perhaps
=annotation_properties=. It could then have an =enabled= property to
replace =generate_preamble=. This is more accurate due to the
preamble/postamble setup explained above. In this setup, we'd have
=annotation_settings= to map to dynamic data, with an annotation
settings factory which reads these off of dynamic object; then, an
annotation factory to generate annotations. Finally, we can introduce
the annotation formatter to generate the portion of boilerplate
related to just the annotation. Boilerplate formatter collaborates
with annotation formatter.

More ideas on this: are these not just "file settings"? After all the
meta-data it contains relates to file-level properties. As =file= is
an entity defined in =formatters= this fits the bill nicely. We still
have to deal with the dilemma described above (these "settings" are
not all directly read out of meta-data). We should then call these
"file properties". We need to then refactor the code so that there is
a file settings class that is an exact match of what is read out of
dynamic and is then used as input to generate the file properties.
*

*** COMPLETED Rename specs to tests                                   :story:
    CLOSED: [2016-07-09 Sat 00:09]
    CLOCK: [2016-07-09 Sat 00:10]--[2016-07-09 Sat 00:23] =>  0:13
    CLOCK: [2016-07-08 Fri 22:58]--[2016-07-09 Sat 00:09] =>  1:11

We started using the terminology specs to mean specifications because
our unit tests follow the ideas outlined by Kevlin Henney. However, we
could easily use tests and still carry most of the meaning without
confusing every other developer. This would require:

- rename top-level =spec= folder to =tests=
- rename targets to =_tests=, e.g. =run_sml_tests=
- rename all test suites to =_tests=
- update the automatic detection of boost tests to use the new
  post-fix.
- we should also use =_tests= on the test suite name so we can do
  =using XYZ= without name clashes.

*** COMPLETED Create a IO settings class                              :story:
    CLOSED: [2016-07-11 Mon 22:21]
    CLOCK: [2016-07-11 Mon 21:22]--[2016-07-11 Mon 21:46] =>  0:24
    CLOCK: [2016-07-11 Mon 21:14]--[2016-07-11 Mon 21:21] =>  0:07
    CLOCK: [2016-07-11 Mon 20:45]--[2016-07-11 Mon 21:01] =>  0:16
    CLOCK: [2016-07-09 Sat 18:51]--[2016-07-09 Sat 18:52] =>  0:01
    CLOCK: [2016-07-09 Sat 18:13]--[2016-07-09 Sat 18:40] =>  0:27

Add a class to model all of the settings required to produce the io
invocation, create a repository for it and associated factory and
finally add the repository to the context.

*** COMPLETED Implement streaming for type in terms of IO settings    :story:
    CLOSED: [2016-07-11 Mon 23:16]
    CLOCK: [2016-07-11 Mon 23:10]--[2016-07-11 Mon 23:16] =>  0:06
    CLOCK: [2016-07-11 Mon 22:22]--[2016-07-11 Mon 23:09] =>  0:47
    CLOCK: [2016-07-11 Mon 22:16]--[2016-07-11 Mon 22:21] =>  0:05
    CLOCK: [2016-07-11 Mon 22:00]--[2016-07-11 Mon 22:14] =>  0:14
    CLOCK: [2016-07-11 Mon 21:47]--[2016-07-11 Mon 21:59] =>  0:12

- rename it o "IO invocation for type". Actually lets use IO for the
  facet and streaming for the aspect.
- call it with an ID; look up the corresponding IO settings in the global
  IO settings container from context.
- remove all other streaming for type implementations and use the new
  one in the legacy formatters.

*** COMPLETED Consider adding issues emblem                           :story:
    CLOSED: [2016-07-12 Tue 17:42]

*Rationale*: Done a few sprints ago.

Boost.DI seems to have a new emblem for issues:

https://github.com/krzysztof-jusiak/di

In the future, this may be useful if users submit issues.

*** COMPLETED Compile dogen in Windows using Visual Studio 2015       :story:
    CLOSED: [2016-07-12 Tue 18:11]

*Rationale*: Completed in the previous sprint.

*New Understanding*

We now have an [[https://ci.appveyor.com/project/mcraveiro/dogen/history][AppVeyor build for windows]] with Conan support. We just
need to work through the errors.

*Previous Understanding*

Using our "SoC" resources, we need to setup a Dogen development
environment on Windows using VS 2015. We need to also create a blog
post about it.

Issues:

- is polymorphic in instrinsics for microsoft, remove comment. see
  patch in github.
- update find boost with MSVC version
- add string to enum io
- update exception classes: remove default in base constructor, and
  add explicit to base and derived as well as by ref.

File with instructions:

0. cd c:\DEVELOPEMENT\output
1. (only once - as admin) update version of msvc in cmake C:\Program
  Files (x86)\CMake\share\cmake-3.3\Modules\FindBoost.cmake
  look for msvc-140 and update it to msvc-150
2. set CMAKE_INCLUDE_PATH=C:\boost\include;C:\DEVELOPEMENT\libxml2-2.7.8.win32\include
   set CMAKE_LIBRARY_PATH=C:\boost\lib;C:\DEVELOPEMENT\libxml2-2.7.8.win32\lib
3. cmake ..\dogen -G "Visual Studio 14 2015" -Wno-dev (CONFIGURATION COMMAND)

if you need to re-run: delete the cache:

del CMakeCache.txt

4. msbuild dogen.sln /t:config

5.msbuild dogen.sln /t:dia /fileLogger   => used to create log for
  errors- called msbuild.log in output directory

Links:

- [[http://dominoc925.blogspot.co.uk/2013/04/how-i-build-boost-for-64-bit-windows.html][How I build Boost for 64 bit Windows]]
- [[https://svn.boost.org/trac/boost/ticket/11449][C++11 - is_polymorphic doesn't work with final-ed class in MSVC.]]
- [[https://github.com/boostorg/type_traits/blob/04a8a9ecc2b02b7334a4b3f0459a5f62b855cc68/include/boost/type_traits/intrinsics.hpp][type_traits/include/boost/type_traits/intrinsics.hpp]]
- [[http://stackoverflow.com/questions/20800166/cmake-compile-with-mt-instead-of-md][CMake - compile with /MT instead of /MD]]
- [[http://www.cmake.org/cmake/help/v3.1/manual/cmake-generators.7.html][CMake Generators]]
- [[http://choorucode.com/2014/06/06/how-to-build-boost-for-visual-studio-2013/][How to build Boost for Visual Studio 2013]]

*** COMPLETED Emblems for appveyor and for version                    :story:
    CLOSED: [2016-07-12 Tue 18:12]

*Rationale*: We've implemented this already.

The [[https://github.com/no1msd/mstch][mstch]] project seems to have great emblems for appveyor - you can
actually distinguish it from travis - and also an emblem for the
current project version. See if we can apply it to Dogen.

*** COMPLETED Create a debug build for clang in travis                :story:
    CLOSED: [2016-07-12 Tue 18:16]

*Rationale*: Implemented in the previous sprint.

In order to enable code coverage we need to have a debug build. For
this we need to setup travis with a build matrix, with two build types
for clang (debug and release).

Example YML: [[https://github.com/Microsoft/GSL/blob/master/.travis.yml][GSL]]

We almost made this work, but now we have a problem: using BUILD_TYPE
seems to disable the stage folder in travis (though it works
locally). We probably shouldn't use the stage folder since its not a
CMake idiom.

This is a requirement for code coverage.

*** COMPLETED Usage of rev-list in version causes problems            :story:
    CLOSED: [2016-07-12 Tue 23:25]
    CLOCK: [2016-07-12 Tue 23:22]--[2016-07-12 Tue 23:25] =>  0:03

We have bumped into a number of problems with the versioning scheme
that keeps track of the current commit in master (see below). Remove
this scheme.

*Previous Understanding*

Now we are using travis, we have found problems with the way we are
using the number of git commits to assign versions. The problem stems
from the git clone command:

:  git clone --depth=50 --branch=master git://github.com/DomainDrivenConsulting/dogen.git DomainDrivenConsulting/dogen

This means we are always at version 50/51:

: -- Product version: 0.56.51

This is in addition to the problems we had with tagging (where we have
to manually stamp the version) and branching (where we are using the
number of commits in master rather than the branch). We need a better
solution than using rev-list for this.

Perhaps we should just abandon the approach of putting the commit
number in the version; we haven't found a single case where this makes
life easier. We could only have the major version, then sprint (which
is reset back to zero for every major version) and then patch-level
which is used only in cases where we release patches. The key
requirement here is that, given a build, we should be able to identify
which commit it comes from. We probably don't want to add it to the
version / help / etc because this forces spurious rebuilds for no
reason every time one commits. We could add it to some package file.

Merged Stories:

*Consider tagging the git branch in version*

At present we make use of rev-list to determine the minor
version. However, this is always off of master, which means that if
you have a few more commits on your integration branch you will end up
with a build that lies. We should consider:

- adding the git commit SHA to the build, perhaps comments.
- adding the branch to the build, perhaps comments.
- rev-listing the current branch rather than always master.

*Version number relies on latest commit in master*

When trying to build off of a tag, we noticed that the version number
is always of the latest commit in master. This means that trying to
generate packages for tag =v0.50.2410= results in packages with a
version after that like say =v0.50.2415=. We should look at the
current commit in master rather than the latest one.

The current workaround is to manually sett the minor version just
before closing the sprint and then reset it back.

*** CANCELLED Consider not running initialisers in a static context   :story:
    CLOSED: [2016-07-13 Wed 22:35]
    CLOCK: [2016-07-13 Wed 22:25]--[2016-07-13 Wed 22:35] =>  0:10

*Rationale*: Since the objective of this exercise is just to log
registered types, we can just implement some IO for this.

There is no particular reason to trigger initialisation in a static
context. See what happens if we move it to normal execution. This
means we can log registrations.

Actually we are initialising in a regular function, but we are doing
it before logging is available. Try reordering this.

This is not so easy for the tests: each test has its own log file and
so the log initialisation is done on a test by test basis; however,
static state can only be initialised once. We could have a flag ("do
not log"?) and pass that through to the initialisers, but then things
start to get a bit too messy.

*** COMPLETED Refactor formatter interfaces                           :story:
    CLOSED: [2016-07-13 Wed 23:19]
    CLOCK: [2016-07-13 Wed 22:43]--[2016-07-13 Wed 23:19] =>  0:36

There are two kinds of formatters:

- file formatters: generate a whole file.
- helper formatters: generate the helper aspect.

Rename the interfaces accordingly and update diagram.

*** COMPLETED Move formatter helpers into formatter container         :story:
    CLOSED: [2016-07-13 Wed 23:29]
    CLOCK: [2016-07-13 Wed 23:20]--[2016-07-13 Wed 23:29] =>  0:09
    CLOCK: [2016-07-13 Wed 22:37]--[2016-07-13 Wed 22:41] =>  0:04

For some reason we placed them directly under the registrar. Move them
to the container.

*** COMPLETED Add aliases for commonly used targets                   :story:
    CLOSED: [2016-07-14 Thu 20:51]
    CLOCK: [2016-07-14 Thu 20:49]--[2016-07-14 Thu 20:51] =>  0:02

We could probably do with aliases such as:

- run_all_tests: rat
- knit_and_stitch: kas
- knit_all: ka
- stitch_all: sa

*** CANCELLED Add a pretty printer for ownership hierarchy            :story:
    CLOSED: [2016-07-14 Thu 21:05]
    CLOCK: [2016-07-14 Thu 20:52]--[2016-07-14 Thu 21:05] =>  0:13

*Rationale*: Brown-paper-bag revert, forgot formatter name is already
fully qualified.

We need a standard way of converting the ownership hierarchy into a
string representation. Add a simple pretty printer for it.

*** COMPLETED Add formatter id to file and helper formatters          :story:
    CLOSED: [2016-07-14 Thu 22:27]
    CLOCK: [2016-07-14 Thu 21:51]--[2016-07-14 Thu 22:27] =>  0:36
    CLOCK: [2016-07-14 Thu 21:06]--[2016-07-14 Thu 21:50] =>  0:44

We need to be able to identify formatters for logging purposes.

*** COMPLETED Add IO to formatter container                           :story:
    CLOSED: [2016-07-14 Thu 23:07]
    CLOCK: [2016-07-14 Thu 22:46]--[2016-07-14 Thu 23:12] =>  0:26
    CLOCK: [2016-07-14 Thu 22:27]--[2016-07-14 Thu 22:45] =>  0:18
    CLOCK: [2016-07-14 Thu 20:32]--[2016-07-14 Thu 20:49] =>  0:17
    CLOCK: [2016-07-13 Wed 23:31]--[2016-07-13 Wed 23:49] =>  0:18

We need some kind of JSON dump of the formatter container telling us
what types have been registered.

- create a utility method to generate a formatter name from ownership
  hierarchy.
- same for helper formatters, but taking owners into account.
- add method in file formatter / helper formatter for name, generated
  using utility.
- use these methods in new container IO code.

*** COMPLETED Includers formatter id is incorrect                     :story:
    CLOSED: [2016-07-15 Fri 20:33]
    CLOCK: [2016-07-15 Fri 19:33]--[2016-07-15 Fri 19:40] =>  0:07

At present the id of the includers formatter is:

:  "includers_formatters": [
:    "quilt.cpp.serialization.includers_formatter",
:    "quilt.cpp.serialization.includers_formatter",
:    "quilt.cpp.serialization.includers_formatter",
:    "quilt.cpp.serialization.includers_formatter",
:    "quilt.cpp.serialization.includers_formatter",
:    "quilt.cpp.serialization.includers_formatter"
:  ],

We need somehow know what facet it was registered again. Also, why is
the default facet hard-coded to =serialization=.

Id was using a static string incorrectly.

*** COMPLETED Enable IO helpers for types                             :story:
    CLOSED: [2016-07-15 Fri 20:35]
    CLOCK: [2016-07-15 Fri 19:41]--[2016-07-15 Fri 20:35] =>  0:54
    CLOCK: [2016-07-14 Thu 23:13]--[2016-07-14 Thu 23:16] =>  0:03
    CLOCK: [2016-07-13 Wed 22:11]--[2016-07-13 Wed 22:24] =>  0:13
    CLOCK: [2016-07-13 Wed 21:43]--[2016-07-13 Wed 22:11] =>  0:28
    CLOCK: [2016-07-13 Wed 18:46]--[2016-07-13 Wed 19:15] =>  0:29
    CLOCK: [2016-07-13 Wed 18:25]--[2016-07-13 Wed 18:45] =>  0:17
    CLOCK: [2016-07-13 Wed 07:51]--[2016-07-13 Wed 08:39] =>  0:48
    CLOCK: [2016-07-12 Tue 22:23]--[2016-07-12 Tue 23:21] =>  0:58
    CLOCK: [2016-07-12 Tue 22:04]--[2016-07-12 Tue 22:22] =>  0:18
    CLOCK: [2016-07-12 Tue 20:58]--[2016-07-12 Tue 21:40] =>  0:42
    CLOCK: [2016-07-12 Tue 13:14]--[2016-07-12 Tue 13:30] =>  0:16
    CLOCK: [2016-07-12 Tue 07:53]--[2016-07-12 Tue 08:05] =>  0:12
    CLOCK: [2016-07-12 Tue 07:42]--[2016-07-12 Tue 07:52] =>  0:10

Originally we did a quick hack to allow us to wrap things up with
types: we used both the legacy helper methods infrastructure (for IO)
and the new helper methods infrastructure (for types). This was
required to allow us to implement the basic infrastructure in IO. Now
we need to remove the legacy aspect of the IO helper methods usage in
types.

- implement is enabled on all IO formatters
- register all IO formatters against both IO and types
- remove calls to legacy helper methods
- problem: how do we know if we are in inheritance from assistant? In
  the future we can add a flag into the =yarn::object=; when we are
  consuming yarn types in formatters, this flag is passed in to the
  enabled method. For now we can check the class info and compute in
  inheritance. Actually we can add the flag now and propagate it to
  class info so that in future the changes are smaller.
- helpers should not know of their owning formatters - this should be
  done as part of registration.
- helper's id is facet + helper name.

*** COMPLETED Implement IO helper methods with new helper infrastructure :story:
    CLOSED: [2016-07-15 Fri 21:14]
    CLOCK: [2016-07-15 Fri 21:18]--[2016-07-15 Fri 21:24] =>  0:06
    CLOCK: [2016-07-15 Fri 20:35]--[2016-07-15 Fri 21:17] =>  0:42
    CLOCK: [2016-07-12 Tue 07:26]--[2016-07-12 Tue 07:41] =>  0:15

Problems:

- we do not have a "streaming for type" function in assistant. We need
  to figure out how to obtain this data from the helper.
- we do not have a name tree so we do not know what the key and value
  names are for associative containers. We probably need to add the
  name tree to the helper descriptor.
- =string_conversion_method= cannot be implemented as is;we need it
  for all properties, not just in the context of helpers. This seems
  to imply we need a way to access this information directly from the
  property. It will need some thinking.

*** STARTED Implement hashing using dynamic helpers                   :story:
    CLOCK: [2016-07-15 Fri 21:25]--[2016-07-15 Fri 21:34] =>  0:09

Update formatters in hash to use new helpers.

*** Add tests to inheritance test model                               :story:

We should make sure types' use of IO kicks in via the inheritance test
model. For this we need a base class with associative containers, etc
and a derived class.

*** Add new c++ warnings to compilation                               :story:

- =-Wunused-private-field=: Seems like this warning is not part of
  =-Wall=
- =-Winconsistent-missing-override=: new clang warning, probably 3.6.

*** Detect knitter and disable code generation accordingly            :story:

At present you can try to build the codegen knitting targets even
before you built knitter. We should make them conditional on detecting
=knitter=. We just need to make sure this is not cached by CMake.

*** Group the file related fields under a prefix                      :story:

Now we have =element= as a prefix, it probably makes sense to also
group the fields that are related to file names, paths etc. These
could be under =file= or perhaps =paths=? Examples:

- =quilt.cpp.file.include_directory_name=
- =quilt.cpp.source_directory_name=

*** Implement qualified name efficiently                              :story:

We used a =std::map= to store qualified names. In practice, we don't
need something this expensive.

- instead of mapping names to languages, we could map them to
  "styles". There are only a few "styles" across all programming
  languages (e.g. =.= separated, =::= separated and so on).
- we can also create an array of these styles. We know up front how
  many styles there are.
- finally we can create a enumeration to access the array. At present
  this is not possible because we cannot disable invalid, nor is it
  possible to move it to a different position (e.g. last). Also we
  will have to static cast the enum to access the int, which is not
  very pretty.

Once all of this is done we can simply do, at O(1):

: name.qualified[static_cast<unsigned int>(styles::double_colon_separated_style)]

We can prettify it a bit: [[http://stackoverflow.com/questions/8357240/how-to-automatically-convert-strongly-typed-enum-into-int][How to automatically convert strongly typed
enum into int?]]

: template <typename E>
: constexpr typename std::underlying_type<E>::type to_underlying(E e) {
:     return static_cast<typename std::underlying_type<E>::type>(e);
: }
:
: std::cout << foo(to_underlying(b::B2)) << std::endl;

Giving us:

: name.qualified[to_underlying(styles::double_colon_separated_style)]

*** Create utility methods for =__type__= etc                         :story:

At present we've hard-coded the field name for =__type__= and so forth
in each formatter. This is not ideal. Create a simple utility method
that returns it and update all formatters to use it instead. List of
hard-coded things:

- =__type__=
- =<empty>=
- =data=
- =value=
- =memory=
- string helper variables: =<new_line>=, =<quote>=
- =tidy_up_string=

*** Add support for file properties overrides                         :story:

At present we have hard-coded the file properties (old general
settings) to be read from the root object only. In an ideal world, we
should be able to override some of these such as the copyrights. It
may not make sense to be able to override them all though.

*** Why do we need helpers and io for some types?                     :story:

At present we have helper support for maps, sets, pairs etc. We also
seem to have utility support for these. Originally the idea was that
we needed utility so that users could have a map of dogen types and
still have streaming support. This is useful. However, what is
slightly less clear is why we don't just use the utility methods
inside the IO subsystem to output these types, but instead use
helpers. We should try doing that and see what breaks, there may be a
reasons for this.

In theory we just have to remove the helpers in IO for utility
supported types and add the includes to the meta-data; regenerate and
see what breaks. It could be related to the ordering of template
functions or some such problem. If so we need to document this in
manual. We should also do a quick search in backlog for this.

*** Character member variables are not tidied up on io                :story:

At present there is no code to convert non-printable chars into
something acceptable in JSON. We probably never noticed this before
because test data generates printable chars. Code generated is as
follows (all primitives model):

: << "\"char_property\": " << "\"" << v.char_property() << "\"" << ", "

We need a "tidy-up char" function to handle this properly.

For now we've hacked this and set =remove_unprintable_characters= to
false to keep backwards compatibility with legacy.

*** Lists of strings are not properly tidied up on io                 :story:

In the log file, when we dump include dependencies we see invalid
JSON:

: [ "<iosfwd>", ""dogen/sml/types/merger.hpp"" ]

This implies we are not calling =tidy_up_string=. This can be tested
by creating a container of =filesystem::path=.

*** Type-bound helpers and generic helpers                            :story:

Not all helpers are bound to a type. We have the case of inserter
helper in io which is used by main formatters directly. We need to
make this distinction in the manual.

*** Check which properties need to loop through the entire model      :story:

In certain cases such as helpers we probably don't need to go through
all types; only the target types matter. Ensure we are not processing
other types for no reason.

*** Add validation for helper families                                :story:

At present we are checking that the name tree has the expected number
of type arguments:

:    const auto children(t.children());
:    if (children.size() != 1) {
:        BOOST_LOG_SEV(lg, error) << invalid_smart_pointer;
:        BOOST_THROW_EXCEPTION(formatting_error(invalid_smart_pointer));
:    }
:    smart_pointer_helper_stitch(fa, t);

In the future with dynamic helpers we will remove these checks. In
order to implement them we need to declare the type families up front
in a JSON file, with a name and number of type arguments. When
constructing the type helpers, we can check the name tree to make sure
the number of type arguments is correct.

This can be done as a helper setting (number of type arguments?).

*** Update assistant to use new helper information                    :story:

Once all the pieces are in place, the assistant can then use the
element properties to find out which helpers are required for each
type; call those helpers and populate the file with the generate
code. We can remove all previous helper support.

*** Create a settings class for the "requires" settings               :story:

We need to populate these in a settings workflow of some kind.

*** Consider caching "all modules" in location                        :story:

At present we are adding the module lists together to build the
qualified name; location could have a "all modules" list that
concatenates external, model and internal modules. We should look at
performance before doing this change though.

*** Consider reducing the number of qname lookups in cpp model        :story:

At present we are still using =yarn::name= in a lot of repositories in
quilt. We already had one go in moving to id's but there are still
quite a few left. Investigate to see if there are more that can be
moved.

*** Implement formattables in terms of yarn types                     :epic:

At present formattables are just a shadow copy of yarn types plus
additional =cpp= specific types. In practice:

- for the types that are shadow copies, we could have helper utilities
  that do the translation on the fly (e.g. for names).
- for additional information which cannot be translated, we could have
  containers indexed by qualified name and query those just before we
  call the transformer. This is the case with formatter properties. We
  need something similar to house "type properties" such as
  =requires_stream_manipulators=. These could be moved into aspect
  settings.
- for types that do not exist in yarn, we could inherit from element;
  this is the case for registrar, forward declarations, cmakelists and
  odb options. Note that with this we are now saying that element
  space contains anything which can be modeled, regardless of if they
  are part of the programming language type system, or build system,
  etc. This is not ideal, but its not a problem just yet. We could
  update the factory to generate these types and then take a copy of
  the model and inject them in it.

*** Add support for selectively disabling helpers on a family         :story:

At present when a type belongs to a helper family it must provide all
helpers across all facets. This means that we can't support the cases
where a helper is required for one facet for one type but not for
others. For example, we cannot create a family for =Dereferenceable=
including both smart pointers and optionals because optional does not
need a helper for =types=.

One solution for this is to allow disabling the helper for a given
type on a given facet. However, our templating mechanism in dynamic is
not able to cope with this use case. Changes required:

- add a "component" to ownership hierarchy. This would be "helper" in
  our case. We should also set "type" which has been hacked via the
  qualified name.
- create a supported/enabled field with a component of helper and a
  facet template. We could change this to formatter template if
  required in the future.
- merge the families of optional and smart pointer into
  =Dereferenceable=.
- disable the helper for types for optional.
- update the helper settings to read this new field.
- enabled method now checks the helper properties.

*** Remove nested type info                                           :story:

Once all of the infrastructure is in place, we should not need this
class any more. Remove code from transformer and remove object types
and anything else that was used to dispatch based on type.

*** Rename methods parsing name trees                                 :story:

We have a variety of names for the methods parsing name trees
recursively. The best one seems to be =walk_name_tree=. We should use
this name consistently.

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

*** Consider using indices rather than associative containers         :story:

Once we generate the final model the model becomes constant; this
means we can easily assign an [[https://en.wikipedia.org/wiki/Ordinal_number][ordinal number]] to each model
element. These could be arranged so that we always start with
generatable types first; this way we always generate dense
containers - there are some cases where we need both generatable types
and non-generatable types; in other cases we just need generatable
types; we never need just non-generatable types. We also need to know
the position of the first non-generatable type (or alternatively, the
size of the generatable types set).

Once we have this, we can start creating vectors with a fixed size
(either total number of elements or just size of generatable
types). We can also make it so that each name has an id which is the
ordinal (another model post-processing activity). Actually we should
call it "type index" or some other name because its a transient
id. This means both properties and settings require no lookups at all
since all positions are known beforehand (except in cases where the
key of the associative container must be the =yarn::name= because we
use it for processing).

In theory, a similar approach can be done for formatters too. We know
upfront what the ordinal number is for each formatter because they are
all registered before we start processing. If formatters obtained
their ordinal number at registration, wherever we are using a map of
formatter name to a resource, we could use a fixed-size
vector. However, formatters may be sparse in many cases (if not all
cases?). For example, we do not have formatter properties for all
formatters for every =yarn::name= because many (most) formatters don't
make sense for every yarn type. Thus this is less applicable, at least
for formatter properties. We need to look carefully at all use cases
and see if there is any place where this approach is applicable.

*** Handle "special includes" correctly                               :story:

We did a quick hack to handle "special includes": we simply "detected"
them in include builder and then did the appropriate action in each of
the include providers. In order to make this work dynamically, we need
somehow to have "associated includes" on a per type basis. For
example:

- type =x= requires include =y= in formatter =f=.

This can easily be achieved via an "additional inclusion directive"
which is a container. For example:

:        "extensions" : {
:                "quilt.cpp.helper.family" : "Dereferenceable",
:                "quilt.cpp.types.class_header_formatter.inclusion_directive" : "<boost/weak_ptr.hpp>",

Could have:

:                "quilt.cpp.types.class_header_formatter.additional_inclusion_directive" : "<some_include.hpp>",

If multiple are provided then they are all added. This highlights an
important point: we need a way to inject type specific includes from a
formatter. It makes no sense to declare all of these up front in a
library since we do not know what all possible formatters are, nor
what requirements they may have for inclusion. At the same time,
formatters cannot be expected to declare types. The solution is to be
able to "inject" these dependencies from a JSON file associated with
the formatter. We could supply the qualified name and the properties
to inject. This problem can be solved later on - create a separate
story for this.

*** Registrar in serialisation is not stable sorted                   :story:

We seem to have a traffic light diff on =registrar_ser.cpp=:

: -    dogen::config::register_types(ar);
:      dogen::quilt::cpp::register_types(ar);
:      dogen::yarn::register_types(ar);
: +    dogen::config::register_types(ar);

This is probably a lack of a stable sort in model dependencies.

*** Support only specific attributes for certain facets               :story:

Whenever an object has a unique identifier, it may make sense to make
use of it for:

- hashing
- equality
- less than

And so forth. For example, names and name trees don't really require
comparing the entire state of the object. We need a way to mark
properties against each facet in the meta-data.

** Deprecated

*** CANCELLED Write next interesting instalment in blog               :story:
    CLOSED: [2016-07-12 Tue 17:33]

*Rationale*: Not much of a point of having "interesting" related
stories in backlog.

We have a number of links backlogged and we need to offload them in an
"interesting..." post.
*** CANCELLED Create a ebook and dead-tree book for the manual        :story:
    CLOSED: [2016-07-12 Tue 18:07]

*Rationale*: this story does not add any value. We need to write the
manual and then worry about this.

We should probably start by creating a simple ebook first and then
explore the dead-tree options such as [[http://www.lulu.com][Lulu]]. We should also see what
Luigi did for [[https://leanpub.com/implementingquantlib/][QuantLib]].
