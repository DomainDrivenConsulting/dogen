#+title: Sprint Backlog 52
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) task(t) note(n) spike(p) }
#+tags: { refactor(r) bug(b) feature(f) vision(v) }
#+tags: { meta_data(m) tests(a) packaging(q) media(h) build(u) validation(x) diagrams(w) frontend(c) backend(g) }
#+tags: dia(y) sml(l) cpp(k) config(o) formatters(d)

* Stories

This file contains all stories that were closed during sprint 51.

The *Mission Statement* for this sprint is to implement the core of
the meta-data processing, in both SML and the formatters. We also want
to improve the communication with the outside world.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2014-09-24 Wed 22:41]

| Headline                                                               | Time   |      |      |
|------------------------------------------------------------------------+--------+------+------|
| *Total time*                                                           | *3:34* |      |      |
|------------------------------------------------------------------------+--------+------+------|
| Development Stories Implemented                                        |        | 3:34 |      |
| IMPLEMENTATION Sprint and product backlog grooming                     |        |      | 0:21 |
| IMPLEMENTATION Rethink meta-data subsystem in light of latest analysis |        |      | 2:06 |
| Refactor types header formatter                                        |        |      | 1:07 |
#+end:

*** IMPLEMENTATION Sprint and product backlog grooming                 :task:
    CLOCK: [2014-09-25 Thu 10:21]--[2014-09-25 Thu 10:40] =>  0:19
    CLOCK: [2014-09-24 Wed 22:15]--[2014-09-24 Wed 22:36] =>  0:21

Updates to sprint and product backlog.

*** Add a =is_target= flag to model                           :task:refactor:

Ideally we should keep track of the "targetness" of the model with the
model itself instead of passing parameters. This will make the
frontend move easier.

*** Updates to the manual and readme files                       :task:media:

Use downtime to update the manual and / or readme file.

*** IMPLEMENTATION Rethink meta-data subsystem in light of latest analysis :task:
    CLOCK: [2014-09-23 Tue 21:18]--[2014-09-23 Tue 21:27] =>  0:09
    CLOCK: [2014-09-22 Mon 13:10]--[2014-09-22 Mon 13:44] =>  0:34

After the analysis performed in the actual use cases we have for
meta-data, it became apparent that the current architecture is far
more complicated than what is required to fulfil our use cases. We now
aim to design an architecture that fulfils the use cases and nothing
more.

**** COMPLETED Consequences of the use case analysis
     CLOSED: [2014-09-23 Tue 21:50]
     CLOCK: [2014-09-23 Tue 21:37]--[2014-09-23 Tue 21:50] =>  0:13
     CLOCK: [2014-09-23 Tue 21:28]--[2014-09-23 Tue 21:37] =>  0:09

There are several points of worthy of note:

- we do not need meta-data for internal purposes. originally we did
  this because we thought it was easier, but actually it complicates
  things without any obvious benefits. In reality, it makes more sense
  to use strongly-typed data structures for all the data that is
  inferred internally and reserve the meta-data purely for input
  purposes - data supplied by the user. This means we do not need
  "enrichers" as such because we want the meta-data to be
  read-only. However we still need something akin to it.
- we can built the internal data-structures on the fly as we visit the
  SML containment graph. These types were previously called enrichers
  but should be renamed to say "builders" - this is a consequence of
  the previous point whereby the builders use internal types to keep
  state rather than pushing it into the meta-data. Another interesting
  consequence is that the responsibilities of these types may not
  necessarily be the determinant characteristic in naming the
  interface. In reality, the interface is just providing us a way to
  iterate through the SML graph of containment. This is not at all
  related to meta-data, or to enrichment. The implementers of the
  interface are responsible for the building. We still need
  dependencies between the builders and we still need multiple
  passes. Basically we should move all of these classes away from the
  meta-data namespace, into the main SML namespace. We need to read up
  on the right name for this - seems like a variation of visitor, but
  without double-dispatch. Boost graph may be a good source of
  inspiration. Compiler terminology may also be of assistance (the
  iterators of the AST in clang for instance).

**** COMPLETED Static initialisation and a cleaner architecture
     CLOSED: [2014-09-24 Wed 22:37]
     CLOCK: [2014-09-24 Wed 21:45]--[2014-09-24 Wed 21:46] =>  0:01
     CLOCK: [2014-09-24 Wed 21:27]--[2014-09-24 Wed 21:31] =>  0:04
     CLOCK: [2014-09-24 Wed 20:30]--[2014-09-24 Wed 21:26] =>  0:56

As a result of the implementation of the enrichers, we found out the
joys of using static initialisation. It is actually a useful approach
because it means we can minimise coupling; however, we need to be
careful on how we set it up to avoid problems with order of
initialisation, or just plain forgetting to initialise things.

One way of thinking about this is to split =knit= into three:
frontend, backend and the rest.

Frontend contains just the interface for the front end and a
workflow. The workflow allows implementers of the frontend interface
to register. The registration process takes a file extension and a
shared pointer to the interface. The worfklow receives a list of boost
file paths, and against each a flag: is target. For each of these, it
looks for the appropriate frontend in a unordered map, calls the
frontend with the file name and the flag, and receives back an SML
model. The result of the workflow is a set of SML models. The SML
models have a "is target" flag set on them somewhere.

Backend is in some ways similar: It provides a backend interface that
receives an SML model and a map of qname to formatter settings. It
returns a list of files (as per =formatters= model).

Knit makes use of these models, effectively creating the complete
pipeline between frontends and backends. The disabling and enabling of
the backends is done via the meta-data.

The static initialisation is now more straightforward: we need to
register backends and frontends against each workflow. These are the
only two points of static initialisation. The two workflows on
construction validate their state (e.g. we need at least one frontend
and one backend). Dia to SML and SML itself implement the two front
ends; CPP implements the one backend.

The "builders" are as follows:

- one for the formatters model (owned by the backend model, since the
  formatter settings will be common to all backends). This satisfies
  use case *annotation settings*. Owned by the =backend= model; its
  result is provided to the workflow of each individual backend.
- one for each individual backend (the C++ builder will process
  generic C++ settings). This satisfies use case *backend settings*.
- one for each facet (use case *facet settings*). Owned by the
  individual backend. Result supplied to each formatter.
- one for each formatter (use case *formatter settings*). These are
  responsible for naming the files and for determining the inclusion
  lists. The formatter should own the builder and retrieve its product
  just prior to formatting.

This means the builders must implement two interfaces: one for
visiting the SML data structures and one for producing the
settings. We should also abandon any dependency management between
formatters for now as the use cases do not show a need for it yet.

Finally, we pass in all of the settings to the formatters. The
formatters must return =std::optional<formatter:file>= in case the
formatter is disabled in the formatter settings. The =backend= model
will return all the files produced by all formatters on all backend
models. These are then passed to an outputter in =knit=.

**** Find a new name for enrichers
**** Find a new name for the "builders"
*** Move SML graph visiting code from meta-data into main namespace :task:refactor:

We also need to rename enrichers and delete the graph of dependencies
between enrichers.

*** Create the =frontend= model                               :task:refactor:

Create the interface, workflow and registrar for the frontend
model. Implement it in SML and Dia to SML models.

*** Create the =backend= model                                :task:refactor:

Create the interface, workflow and registrar for the backend
model. Implement it in formatters and C++ models.

We may need to use some kind of adaptor for now to convert the output
of the =cpp_formatters= model into a =formatters::file=.

*** Update =knit= to use new models                           :task:refactor:

Remove the internal interfaces and code in workflow that perform the
same role as the new models do.

*** Split library model loading from SML workflow         :task:refactor:sml:

We should really create a library model loader, with tests, instead of
doing all the work directly in the SML workflow.

We can then start thinking about adding features such as loading only
libraries the merged model depends on, etc.

*** Refactor types header formatter            :task:refactor:formatters:cpp:
    CLOCK: [2014-08-25 Mon 12:01]--[2014-08-25 Mon 12:40] =>  0:39
    CLOCK: [2014-08-25 Mon 11:56]--[2014-08-25 Mon 11:57] =>  0:01
    CLOCK: [2014-08-25 Mon 11:35]--[2014-08-25 Mon 11:43] =>  0:08

Make the main types header formatters look like the =om= types
formatter. This model was deleted around commit 10157ad.

This is still not quite right. We need to drive the formatting from
two things:

- user options
- available formatters

**** Tidy-up =types_main_header_file_formatter=                        :task:
     CLOCK: [2014-08-25 Mon 11:57]--[2014-08-25 Mon 12:16] =>  0:19

Clean up internal functions in file and add documentation.

**** Make use of boilerplate                                           :task:

Generate the licence, etc using boilerplate formatter.

**** Copy across documentation from =om=                               :task:

We did a lot of doxygen comments that are readily applicable, copy
them across.

**** Make use of indenting stream                                      :task:

Remove uses of old indenter.

**** Copy across =om= types formatter tests                            :task:

Not sure how applicable this would be, but we may be able to scavenge
some tests.

*** Add include files at the formatter level    :task:refactor:meta_data:cpp:

We need to remove all the include files from =includer= which are
related to formatter specific code. We need to inject these
dependencies inside of the formatters.

- implement includer in terms of json files
- get includer to work off of object relationships
- remove relationships from transformer
- remove helper models boost and std

*** Includer generation should be done from meta-data         :task:refactor:

It would be nice if we could determine which includer files to create
by looking at the meta-data. For this we need a notion of an inclusion
group, defined at the model level:

- =cpp.types.includers.general=
- =cpp.types.includers.value_objects=
- ...

Under each of these one would configure the aspect:

- =cpp.types.includers.general.generate=: =true=
- =cpp.types.includers.general.file_name=: =a/b/c=
- =cpp.types.includers.general.is_system=: =false=

Then, each type, module etc would declare its membership (as a list):

- =cpp.includers.member=: =cpp.types.includers.general=
- =cpp.includers.member=: =cpp.types.includers.value_objects=
- ...

*Previous understanding*

We should simply go through all the types in the SML model and for
each type and each facet create the corresponding inclusion
path. locator can be used to generate standard paths, and a model
specific mapping is required for other models such as std.

Include then takes the relationships extracted by extractor, the
mappings generated by this mapper and simply appends to the inclusion
list the file names. it also appends the implementation specific
headers.

*** Support "cross-facet interference"                         :task:feature:

In a few cases its useful to disable bits of a facet when another
facet is switched off because those bits do not belong to the main
facet the formatter is working on. At present this happens in the
following cases:

- Forward declaration of serialisation in domain when serialisation is
  off
- Friend of serialisation in domain when serialisation is
  off
- declaration and implementation of to_stream when IO is off
- declaration and implementation of inserter when IO is off and
  integrated IO is on.

We need a way of accessing the on/off state of all facets from any
formatter so that they can make cross facet decisions. A quick hack
was to add yet another flag: =disable_io= which is disabled when the
IO facet is not present and passed on to the relevant formatters. This
needs to be replaced by a more general approach.

*** Implement the types enricher in cpp                :task:feature:sml:cpp:

Create the first and second stage enrichment for types. This is a good
test to see if the overall logic is sound.

*** Refactor engine's =persister=                             :task:refactor:

- add documentation
- we put the decision on whether to persist on not based on settings
  inside of persister. It should really be up to the person calling
  the persister to decide. Persister should always persist.
- we should have an argument deciding the file format, perhaps an
  enumeration, instead of passing in the extension. The extension
  should be automatically determined.
- persister should support all archive types. At present it always
  outputs in XML; it should respect the archive type requested by the
  user.

** Deprecated Development Stories

Stories that do not make sense any longer.
