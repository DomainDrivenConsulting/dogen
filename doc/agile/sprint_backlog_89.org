#+title: Sprint Backlog 89
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) }

* Mission Statement

- finish refactoring quilt.cpp.
- introduce wale templates.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-09-28 Wed 22:21]
| <75>                                                                        |         |       |      |       |
| Headline                                                                    | Time    |       |      |     % |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| *Total time*                                                                | *20:56* |       |      | 100.0 |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| Stories                                                                     | 20:56   |       |      | 100.0 |
| Active                                                                      |         | 20:56 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |         |       | 0:49 |   3.9 |
| COMPLETED Edit release notes for previous sprint                            |         |       | 0:07 |   0.6 |
| COMPLETED Generation of formattable is incorrect                            |         |       | 2:30 |  11.9 |
| COMPLETED Visitor includes are incorrect                                    |         |       | 0:20 |   1.6 |
| COMPLETED Add includer to quilt.cpp                                         |         |       | 1:46 |   8.4 |
| COMPLETED Add reducer to quilt.cpp                                          |         |       | 0:22 |   1.8 |
| COMPLETED Add new index to formtter container                               |         |       | 0:19 |   1.5 |
| COMPLETED Add path expander to quilt.cpp                                    |         |       | 0:49 |   3.9 |
| COMPLETED Add guard expander to quilt.cpp                                   |         |       | 0:27 |   2.1 |
| COMPLETED Investigate borked travis build                                   |         |       | 0:37 |   2.9 |
| COMPLETED Add decoration expander to quilt.cpp                              |         |       | 0:23 |   1.8 |
| COMPLETED Add aspect expander to quilt.cpp                                  |         |       | 1:26 |   6.8 |
| COMPLETED Run tests that are passing on windows                             |         |       | 0:10 |   0.8 |
| COMPLETED Add helper expander to quilt.cpp                                  |         |       | 1:26 |   6.8 |
| COMPLETED Merge pre and post workflows                                      |         |       | 0:16 |   1.3 |
| COMPLETED Fix bug in aspect and helper generation                           |         |       | 0:15 |   1.2 |
| COMPLETED Investigate element annotation support                            |         |       | 2:05 |  10.0 |
| CANCELLED Add streaming settings expander                                   |         |       | 0:36 |   2.9 |
| COMPLETED Create the formattables model                                     |         |       | 1:32 |   7.3 |
| COMPLETED Hook formattables into formatters                                 |         |       | 3:58 |  18.9 |
| STARTED Remove include builder legacy api                                   |         |       | 0:43 |   3.4 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-09-27 Tue 10:04]--[2016-09-27 Tue 10:13] =>  0:09
    CLOCK: [2016-09-26 Mon 15:36]--[2016-09-26 Mon 15:39] =>  0:03
    CLOCK: [2016-09-26 Mon 09:49]--[2016-09-26 Mon 10:00] =>  0:11
    CLOCK: [2016-09-26 Mon 09:22]--[2016-09-26 Mon 09:48] =>  0:26

Updates to sprint and product backlog.

*** COMPLETED Edit release notes for previous sprint                  :story:
    CLOSED: [2016-09-26 Mon 10:08]
    CLOCK: [2016-09-26 Mon 10:01]--[2016-09-26 Mon 10:08] =>  0:07

Add github release notes for v88.

Text:

#+begin_src markdown
Overview
=======

We continue our long road of internal refactorings, focusing on the ```quilt.cpp``` model. There are no user visible changes in this release.

For more details see the [sprint log](https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_88.org).
#+end_src

*** COMPLETED Generation of formattable is incorrect                  :story:
    CLOSED: [2016-09-26 Mon 13:03]
    CLOCK: [2016-09-26 Mon 12:50]--[2016-09-26 Mon 13:03] =>  0:13
    CLOCK: [2016-09-26 Mon 12:30]--[2016-09-26 Mon 12:49] =>  0:19
    CLOCK: [2016-09-26 Mon 11:51]--[2016-09-26 Mon 12:16] =>  0:25
    CLOCK: [2016-09-26 Mon 11:42]--[2016-09-26 Mon 11:51] =>  0:09
    CLOCK: [2016-09-26 Mon 10:09]--[2016-09-26 Mon 11:33] =>  1:24

The new formattable type is generating an invalid header file. It is
missing the forward declaration of the yarn element.

Note: to login to postgres from emacs, [[http://emacs.1067599.n8.nabble.com/sql-postgresql-authentication-failure-td71620.html][leave server empty]].

Load relevant data into postgres for querying:

: grep dogen.knitter.quilt.cpp.log -e "Finished inclusion directives repository" > crap.txt
: cut -b142- crap.txt > ~/inclusion.json
: create table inclusion_directives_json (values jsonb);
: \copy inclusion_directives_json from '~/inclusion.json';

Now create a row per entry in the container:

: create table inclusion_directives2_json (values jsonb);
: insert into inclusion_directives2_json
: select jsonb_array_elements(values->'by_name')
: from inclusion_directives_json;

Now find out type:

: select values as val
: from inclusion_directives2_json
: where values::text like '%<dogen><quilt><cpp><formattables><formattable>%';

And dump it to a file:

: \copy (select values as val from inclusion_directives2_json
: where values::text like '%<dogen><quilt><cpp><formattables><formattable>%')
: to 'out.json';

Actually this was for the directives. We need the same but for the dependencies:

: grep dogen.knitter.quilt.cpp.log -e "Finished creating inclusion dependencies: " > crap.txt
: cut -b144- crap.txt > ~/inclusion_deps.json
: create table inclusion_deps2_json (values jsonb);
: \copy inclusion_deps_json from '~/inclusion_deps.json';

Split objects:

: insert into inclusion_deps2_json
: select jsonb_array_elements(values->'by_name')
: from inclusion_deps_json;

Find our object:

: select values from inclusion_deps2_json
: where values::text like '%<dogen><quilt><cpp><formattable>%';

Save it:

: copy (select values from inclusion_deps2_json where values::text
: like '%<dogen><quilt><cpp><formattables><formattable>%')
: to '~/deps.json';

Actually the problem really was with the inclusion directives! It
seems we are not generating the forward declarations for element:

: select values as val
: from inclusion_directives2_json
: where values::text like '%<dogen><yarn><element>%';

No mention of forward declarations. The problem is fabric is only
injecting forward declarations for the target model. we need to relax
this and do it for all models.

When we do this we seem to overwrite the helper configuration for
types such as =boost::filesystem::path=.

*** COMPLETED Visitor includes are incorrect                          :story:
    CLOSED: [2016-09-26 Mon 13:25]
    CLOCK: [2016-09-26 Mon 13:17]--[2016-09-26 Mon 13:25] =>  0:08
    CLOCK: [2016-09-26 Mon 13:04]--[2016-09-26 Mon 13:16] =>  0:12

We are adding an include to the descendants' header for no
reason. Remove it.

*** COMPLETED Add includer to quilt.cpp                               :story:
    CLOSED: [2016-09-26 Mon 15:13]
    CLOCK: [2016-09-26 Mon 14:43]--[2016-09-26 Mon 15:13] =>  0:30
    CLOCK: [2016-09-26 Mon 13:26]--[2016-09-26 Mon 14:42] =>  1:16

Responsible for computing the inclusion dependencies.

- add a flag in builder to choose new or old API. Supply formattables
  container by ID and new directives repository. When using old API,
  these are default initialised. With new API the other parameters are
  default initialised. Actually a better approach is to create two
  builder impls and to decide which one to use based on the
  constructor of the builder.

*** COMPLETED Do not compute inclusion directives for system models   :story:
    CLOSED: [2016-09-26 Mon 15:23]

*Rationale*: Fixed with new inclusion expander. We only compute
directives as a last resort.

It seems we are computing inclusion directives and other path
derivatives for system models:

: {
:   "__type__": "dogen::cpp::expansion::path_derivatives",
:   "file_path": "/home/marco/Development/DomainDrivenConsulting/output/dogen/clang-3.5/stage/bin/../test_data/all_primitives/actual/std/include/std/serialization/unique_ptr_fwd_ser.hpp",
:   "header_guard": "STD_SERIALIZATION_UNIQUE_PTR_FWD_SER_HPP",
:   "inclusion_directive": "<quote>std/serialization/unique_ptr_fwd_ser.hpp<quote>"
: }

This comes out of the workflow, so we possibly are then ignoring it
for the non-target types. So:

- can we avoid computing these altogether?
- are we ignoring it?

Actually this is the usual problem with the "origin" of the type. We
need a way to determine if this type needs computations or not. We
need to create a story to clean up the =origin_type= and
=generation_type= and then we can make use of it to determine if we
need to compute inclusion, path etc or not.

*** COMPLETED Add reducer to quilt.cpp                                :story:
    CLOSED: [2016-09-26 Mon 15:36]
    CLOCK: [2016-09-26 Mon 15:14]--[2016-09-26 Mon 15:36] =>  0:22

Removes all types that are non-generatable.

Merged stories:

*Add filter to quilt.cpp*

Removes the non-target formattables.

*** COMPLETED Add new index to formtter container                     :story:
    CLOSED: [2016-09-26 Mon 17:48]
    CLOCK: [2016-09-26 Mon 16:56]--[2016-09-26 Mon 17:15] =>  0:19

It is actually quite useful to look for a formatter by formatter
name. We should provide this in formatter container and use it from
inclusion expander.

*** COMPLETED Add path expander to quilt.cpp                          :story:
    CLOSED: [2016-09-26 Mon 17:49]
    CLOCK: [2016-09-26 Mon 17:16]--[2016-09-26 Mon 17:49] =>  0:33
    CLOCK: [2016-09-26 Mon 16:39]--[2016-09-26 Mon 16:55] =>  0:16

Generates the full paths.

*** COMPLETED Add guard expander to quilt.cpp                         :story:
    CLOSED: [2016-09-26 Mon 18:17]
    CLOCK: [2016-09-26 Mon 17:50]--[2016-09-26 Mon 18:17] =>  0:27

Generates the header guards. Merged with path generator.

*** COMPLETED Investigate borked travis build                         :story:
    CLOSED: [2016-09-26 Mon 18:38]
    CLOCK: [2016-09-26 Mon 20:43]--[2016-09-26 Mon 21:05] =>  0:22
    CLOCK: [2016-09-26 Mon 18:18]--[2016-09-26 Mon 18:33] =>  0:15

We seem to have borked the build some how:

https://travis-ci.org/DomainDrivenConsulting/dogen/builds/162785692
https://travis-ci.org/DomainDrivenConsulting/dogen/builds/162801645

Hopefully this is just due to not running tests locally. Checkout a
worktree and check.

: git worktree add ../dogen_1fd4399 origin/master
: cd ../dogen_1fd4399/
: mkdir build/output
: build/scripts/build.linux.sh Release gcc /usr/local/personal run_knit.tests

Problem reproduced locally, must have forgotten to run the tests.

: Running 33 test cases...
: ../../../../projects/knit/tests/workflow_tests.cpp(203): error: in "workflow_tests/trivial_inheritance_model_generates_expected_code": check generate_and_diff(target) has failed
: ../../../../projects/knit/tests/workflow_tests.cpp(233): error: in "workflow_tests/std_model_generates_expected_code": check generate_and_diff(target) has failed
: ../../../../projects/knit/tests/workflow_tests.cpp(239): error: in "workflow_tests/boost_model_generates_expected_code": check generate_and_diff(target) has failed
: ../../../../projects/knit/tests/workflow_tests.cpp(245): error: in "workflow_tests/stereotypes_model_generates_expected_code": check generate_and_diff(target) has failed
:
: *** 4 failures are detected in the test module "knit_tests"
: ninja: build stopped: subcommand failed.

Actually, the problem persists. It seems this is related to clean
builds. We seem to have lost service forward declarations.

*** COMPLETED Add decoration expander to quilt.cpp                    :story:
    CLOSED: [2016-09-26 Mon 21:24]
    CLOCK: [2016-09-26 Mon 21:19]--[2016-09-26 Mon 21:24] =>  0:05
    CLOCK: [2016-09-26 Mon 18:34]--[2016-09-26 Mon 18:52] =>  0:18

Generates the decoration.

Merged stories:

*Add file properties generator to to quilt.cpp*

We need to generate the file properties for each formattable. The
formatter must supply the modeline name. At present we have a hack in
element properties to determine the modeline.

*** COMPLETED Add aspect expander to quilt.cpp                        :story:
    CLOSED: [2016-09-26 Mon 22:51]
    CLOCK: [2016-09-26 Mon 21:25]--[2016-09-26 Mon 22:51] =>  1:26

Generates the aspect configuration.

- first generate a container with aspect annotations.
- then use it to compute aspect configurations; populate those
  directly into the formattable.

*** COMPLETED Run tests that are passing on windows                   :story:
    CLOSED: [2016-09-27 Tue 08:19]
    CLOCK: [2016-09-26 Mon 21:06]--[2016-09-26 Mon 21:16] =>  0:10

At present we have a release build on windows but we are not running
any tests. This is because some of the tests are failing at the
moment. We should run all test suites that are green to ensure we
don't regress without noticing.

Look at the stories with errors to determine which tests are passing.

*** COMPLETED Add helper expander to quilt.cpp                        :story:
    CLOSED: [2016-09-27 Tue 09:46]
    CLOCK: [2016-09-27 Tue 08:19]--[2016-09-27 Tue 09:45] =>  1:26

Generates the helper configuration.

*** COMPLETED Merge pre and post workflows                            :story:
    CLOSED: [2016-09-27 Tue 10:03]
    CLOCK: [2016-09-27 Tue 09:47]--[2016-09-27 Tue 10:03] =>  0:16

It seems we don't have much of a post reduction workflow. Merge them.

*** COMPLETED Add formattable element                                 :story:
    CLOSED: [2016-09-27 Tue 10:05]

*Rationale*: we introduced the type in the previous sprint. The
hooking of it is a different story.

Create a top-level formattable type that is an aggregation of the
element and the element configuration. Update workflow to output a
list of formattable and formatters to take in formattable.

Previous understanding:

- create a top-level type that has formatter, element properties and
  element. Must be non-generatable. Add formattable id as the sum of
  element id and formatter id.
- add =formattables::model= as an unordered map of id to
  formattable. Implement formatting workflow in terms of formattables
  model. Add all context properties to model such as
  streaming_settings_repository and helpers_. element_settings should
  be merged with configuration.
- remove formatting context and update formatting workflow to call a
  visitor to resolve the element and then call the formatter.
- add an enablement map for all formatters in the formatter

*** CANCELLED Move name builder into yarn                             :story:
    CLOSED: [2016-09-27 Tue 10:07]

*Rationale*: It was used only during formattables generation for the
helpers. The one method was moved into the expander.

At present we have name builder in quilt.cpp simply to build the
merged namespaces. We should have some kind of utility for this in
yarn.

*** CANCELLED Move registration of providers to initialiser           :story:
    CLOSED: [2016-09-27 Tue 10:07]

*Rationale*: No longer applies since provider refactor.

At present we are iterating through the formatters list in properties
and manually registering all include providers via the interface. This
is not ideal because the formatter interface needs to know of include
providers, meaning we can't move it away from =quilt.cpp=.

When we register a formatter we should also register the include
provider too.

Tasks:

- add provider support directly to the formatters instead of another
  class and remove registration from formatter interface.
- add a static registrar for the include providers in workflow.
- change initialiser to register the include providers from the same
  shared pointer.

*** CANCELLED Implement all formatter interfaces                      :story:
    CLOSED: [2016-09-27 Tue 10:10]

*Rationale*: we implemented primitives. there is no need to do this
for concepts.

We still have a couple of skeleton interfaces:

- primitives
- concepts

We should throw if formatting is required.

*** CANCELLED Remove =optional<list>=                                 :story:
    CLOSED: [2016-09-27 Tue 10:12]

*Rationale*: we've already done a few of these. This story is too much
of an epic to be useful.

We should not really be using optional<list>. The empty list is
sufficient for this.

Uses:

- include provider. Fixed with other story.

*** COMPLETED Formatters with duplicate names result in non-intuitive errors :story:
    CLOSED: [2016-09-27 Tue 10:10]

*Rationale*: completed with the addition of the formatter by formatter
name container. We now get a duplicate formatter id exception.

We added two formatters to io with the same name by mistake and the
resulting error was not particularly enlightening:

: std::exception::what: Qualified name defined more than once: cpp.io.enum_header_formatter.inclusion_required

We should have a very early on validation to ensure formatters have
distinct names.

Merged stories:

*Check for duplicate formatter names in formatter registrar*

At present it is possible to register a formatter name more than
once. Registrar should keep track of the names and throw if the name
is duplicated.

*** COMPLETED Fix bug in aspect and helper generation                 :story:
    CLOSED: [2016-09-27 Tue 10:58]
    CLOCK: [2016-09-27 Tue 10:43]--[2016-09-27 Tue 10:58] =>  0:15

It seems we are updating non-target types for these configurations but
we weren't before. This caused a break in the verification that
somehow was not spotted.

*** COMPLETED Investigate element annotation support                  :story:
    CLOSED: [2016-09-27 Tue 20:39]
    CLOCK: [2016-09-27 Tue 20:17]--[2016-09-27 Tue 20:39] =>  0:22
    CLOCK: [2016-09-27 Tue 10:59]--[2016-09-27 Tue 12:14] =>  1:15
    CLOCK: [2016-09-27 Tue 10:14]--[2016-09-27 Tue 10:42] =>  0:28

The new formattables do not yet support element annotations. Figure
out if we need to. Seems like we did a brutal hack and left the
processing of "element annotations" to the formatters
themselves. Also, now its clearer why we thought of an annotation
expander (which we since removed).

The right thing to do:

- rename element annotations to opaque annotations
- add opaque annotations to element configuration
- add a opaque annotations expander to read them into the element
  configuration.

Actually we should just avoid the element annotations altogether as
they make no sense at all. Create an opaque configuration and add it
at the correct level in formatter configuration.

Tried to add a verification step but its just too hard, what with
shared pointers etc.

*** CANCELLED Add streaming settings expander                         :story:
    CLOSED: [2016-09-28 Wed 09:39]
    CLOCK: [2016-09-27 Tue 20:55]--[2016-09-27 Tue 21:17] =>  0:22
    CLOCK: [2016-09-27 Tue 20:40]--[2016-09-27 Tue 20:54] =>  0:14

Add streaming settings to the element properties and populate them via
a new expander.

Actually we need to revert this change as these settings need to be
across the whole model.

*** COMPLETED Create the formattables model                           :story:
    CLOSED: [2016-09-28 Wed 09:40]
    CLOCK: [2016-09-28 Wed 08:30]--[2016-09-28 Wed 09:31] =>  1:01
    CLOCK: [2016-09-27 Tue 21:43]--[2016-09-27 Tue 21:50] =>  0:07
    CLOCK: [2016-09-27 Tue 21:18]--[2016-09-27 Tue 21:42] =>  0:24

There are a couple of properties that are shared by all
formattables. One way of solving this is to create a top-level
container for all formattables that also has these properties.

- create model class
- update workflow to return model
- update verification code.
- remove streaming settings from element, delete streaming expander.
- update streaming annotations factory to return correct container.
- create a model factory and a formattables factory. Model factory
  simply assembles model. Formattables workflow hooks them together.

*** COMPLETED Hook formattables into formatters                       :story:
    CLOSED: [2016-09-28 Wed 21:38]
    CLOCK: [2016-09-28 Wed 20:20]--[2016-09-28 Wed 21:38] =>  1:18
    CLOCK: [2016-09-28 Wed 11:39]--[2016-09-28 Wed 12:16] =>  0:37
    CLOCK: [2016-09-28 Wed 11:17]--[2016-09-28 Wed 11:38] =>  0:21
    CLOCK: [2016-09-28 Wed 11:01]--[2016-09-28 Wed 11:16] =>  0:15
    CLOCK: [2016-09-28 Wed 10:36]--[2016-09-28 Wed 11:00] =>  0:24
    CLOCK: [2016-09-28 Wed 09:32]--[2016-09-28 Wed 10:35] =>  1:03

Find a way to format out of the formattables container, side-by-side
with the current formatting workflow.

- remove element annotations from context, use element configuration
  instead.
- create a new formatters workflow that uses formattables.

*** COMPLETED Remove empty context                                    :story:
    CLOSED: [2016-09-28 Wed 22:21]

*Rationale*: done as part of refactor.

We were generating empty contexts before in context factory, but this
should not be required any longer.

*** STARTED Remove include builder legacy api                         :story:
    CLOCK: [2016-09-28 Wed 21:38]--[2016-09-28 Wed 22:21] =>  0:43

When implementing inclusion expander we did a number of ugly hacks to
support both the legacy API and the new API. We need to remove all the
impls etc we added, in builder, factory, etc.

*** Move enabled formatters to element configuration                  :story:

At present we have =enabled_formatters= at the formatter level. This
should be at the element level.

*** Consider supplying element configuration as a parameter           :story:

Figure out if element configuration is context or if it is better
expressed as a stand alone formatting parameter.

*** Move facet directory to a better place                            :story:

At present we have this property at the formatter configuration level,
but its not clear why we need to duplicate it. In fact, it may even
make more sense to have it at a higher level since its the same for
all elements.

*** Clean up element segmentation                                     :story:

Originally we added all element segments at the same level. But in
truth:

- there are always two segments;
- one of which is the "master" segment: the one with "is element
  extension" set to false.

We should formalise this and make the configuration model reflect it.

*** Remove formatter id                                               :story:

Not clear why we need this given we have formatter name.

*** Remove all of the legacy infrastructure                           :story:

Includes:

- repositories, repository factories in formattables, annotations.

*** Check which properties need to loop through the entire model      :story:

In certain cases such as helpers we probably don't need to go through
all types; only the target types matter. Ensure we are not processing
other types for no reason.

Merged stories:

*Element properties includes non-target types*

We seem to be generating a lot of element properties and formatter
properties as well. We should only be generating these for the target
model.

*** Introduce the concept of proxy models                             :story:

These are models that exist solely to bring types in, but do not
define those types. Typically one uses a proxy model to expose
non-dogen types into dogen. We could add a flag to models
=is_proxy=. It would replace the notion of system models. We need to
check the stories in the backlog around this.

Interestingly we could have different defaults for formatters in proxy
models. For example, if a model is proxy we can assume that we should
not compute inclusion paths. This could save a lot of time when
specifying the models in JSON.

*** Create the notion of a formatter alias                            :story:

We did a bit of a hack with mapping the facet to the default
formatter. What we really need is the notion of an alias. It still
looks like a formatter name (for example "header_formatter") but it
must be first resolved into an actual formatter. For this we need a
type index.

Other names:

- canonical formatter
- reference formatter

We need to support a strange use case: where the formatter does not
exist for a given element type. For example, we do not have primitive
formatters, but there are directives set in them:

#+begin_src json-mode
        {
            "meta_type" : "primitive",
            "simple_name" : "uint64_t",
            "extensions" : {
                "quilt.cpp.helper.family" : "Number",
                "quilt.cpp.aspect.requires_manual_default_constructor" : true,
                "quilt.cpp.types.class_header_formatter.inclusion_directive" : "<cstdint>",
                "quilt.cpp.hash.class_header_formatter.inclusion_required" : false,
                "quilt.cpp.io.class_header_formatter.inclusion_required" : false,
                "quilt.cpp.test_data.class_header_formatter.inclusion_required" : false,
                "quilt.cpp.serialization.class_header_formatter.inclusion_required" : false,
                "quilt.cpp.odb.class_header_formatter.inclusion_required" : false
            }
        },
#+end_src

The problem with this is that if we do not have a formatter for
primitives, then we will not read the directives. In the past this
worked because we were processing the cross-product of formatters and
element sub-types, so the mistake of
=quilt.cpp.types.class_header_formatter.inclusion_directive= was
actually resulted in the correct result. But of course, we cannot
replace class_header_formatter with the correct formatter name (as we
don't have one). Nor does it sound good to have to hard-code the
formatter name against the type. One way to solve this is with
canonical formatters:

- use the canonical formatter name in the declaration
- ensure we always read directives for the canonical formatter from
  the meta-data.
- when processing, only set the canonical formatter if it was not
  already set by meta-data.

When testing the fix, we need to delete the mock formaters created for
primitives.

As part of this work we need to review the need for
=element_extension=, which seems unused at present. Actually it is
used now in helper annotations repository factory, to ensure we don't
generate annotations for the forward declarations and clobber the main
object with it. This needs reviewing.

*** Tidy-up of inclusion terminology                                  :story:

Random notes:

- imports and exports
- some types support both (headers)
- some support imports only (cpp)
- some support neither (cmakelists, etc).

*** Supply formatter's container to injector                          :story:

At present the injector is calling the formatters' workflow
directly, in order to obtain the formatters' container. It should
receive it as a parameter during initialisation.

*** Refactor path settings factory                                    :story:

Tasks:

- get distinct list of facets across all formatters and generate field
  definitions from this list;
- cache top-level fields and facet fields and copy results instead of
  re-reading them.

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

*** Move odb options file into odb folder                             :story:

There is not particularly good reason for this file to exist at the
src level.

In order to implement this story we need to have a working odb setup
to test it and ensure we didn't break anything.

*** Add more validation to formatter registration                     :story:

We should check to ensure that only one formatter per facet is
declared the canonical formatter.

*** Consider using indices rather than associative containers          :epic:

Once we generate the final model the model becomes constant; this
means we can easily assign an [[https://en.wikipedia.org/wiki/Ordinal_number][ordinal number]] to each model
element. These could be arranged so that we always start with
generatable types first; this way we always generate dense
containers - there are some cases where we need both generatable types
and non-generatable types; in other cases we just need generatable
types; we never need just non-generatable types. We also need to know
the position of the first non-generatable type (or alternatively, the
size of the generatable types set).

Once we have this, we can start creating vectors with a fixed size
(either total number of elements or just size of generatable
types). We can also make it so that each name has an id which is the
ordinal (another model post-processing activity). Actually we should
call it "type index" or some other name because its a transient
id. This means both properties and settings require no lookups at all
since all positions are known beforehand (except in cases where the
key of the associative container must be the =yarn::name= because we
use it for processing).

In theory, a similar approach can be done for formatters too. We know
upfront what the ordinal number is for each formatter because they are
all registered before we start processing. If formatters obtained
their ordinal number at registration, wherever we are using a map of
formatter name to a resource, we could use a fixed-size
vector. However, formatters may be sparse in many cases (if not all
cases?). For example, we do not have formatter properties for all
formatters for every =yarn::name= because many (most) formatters don't
make sense for every yarn type. Thus this is less applicable, at least
for formatter properties. We need to look carefully at all use cases
and see if there is any place where this approach is applicable. It is
probably going to be more useful for formatters than elements.

Tasks:

- in resolver, assign element indices and update property names with
  them.
- change final model to have a vector of size maximum index (a
  property of the intermediate model).
- in the final model generation, for each type, look at its index and
  populate the slot accordingly.
- update quilt to use the indices where possible.

** Deprecated
