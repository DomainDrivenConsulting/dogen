#+title: Sprint Backlog 89
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) }

* Mission Statement

- finish refactoring quilt.cpp.
- introduce wale templates.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-09-26 Mon 22:51]
| <75>                                                                        |        |      |      |       |
| Headline                                                                    | Time   |      |      |     % |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| *Total time*                                                                | *9:56* |      |      | 100.0 |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| Stories                                                                     | 9:56   |      |      | 100.0 |
| Active                                                                      |        | 9:56 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |        |      | 0:40 |   6.7 |
| COMPLETED Edit release notes for previous sprint                            |        |      | 0:07 |   1.2 |
| COMPLETED Generation of formattable is incorrect                            |        |      | 2:30 |  25.2 |
| COMPLETED Visitor includes are incorrect                                    |        |      | 0:20 |   3.4 |
| COMPLETED Add includer to quilt.cpp                                         |        |      | 1:46 |  17.8 |
| COMPLETED Add reducer to quilt.cpp                                          |        |      | 0:22 |   3.7 |
| COMPLETED Add new index to formtter container                               |        |      | 0:19 |   3.2 |
| COMPLETED Add path expander to quilt.cpp                                    |        |      | 0:49 |   8.2 |
| COMPLETED Add guard expander to quilt.cpp                                   |        |      | 0:27 |   4.5 |
| COMPLETED Investigate borked travis build                                   |        |      | 0:37 |   6.2 |
| COMPLETED Add decoration expander to quilt.cpp                              |        |      | 0:23 |   3.9 |
| COMPLETED Add aspect expander to quilt.cpp                                  |        |      | 1:26 |  14.4 |
| STARTED Run tests that are passing on windows                               |        |      | 0:10 |   1.7 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-09-26 Mon 15:36]--[2016-09-26 Mon 15:39] =>  0:03
    CLOCK: [2016-09-26 Mon 09:49]--[2016-09-26 Mon 10:00] =>  0:11
    CLOCK: [2016-09-26 Mon 09:22]--[2016-09-26 Mon 09:48] =>  0:26

Updates to sprint and product backlog.

*** COMPLETED Edit release notes for previous sprint                  :story:
    CLOSED: [2016-09-26 Mon 10:08]
    CLOCK: [2016-09-26 Mon 10:01]--[2016-09-26 Mon 10:08] =>  0:07

Add github release notes for v88.

Text:

#+begin_src markdown
Overview
=======

We continue our long road of internal refactorings, focusing on the ```quilt.cpp``` model. There are no user visible changes in this release.

For more details see the [sprint log](https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_88.org).
#+end_src

*** COMPLETED Generation of formattable is incorrect                  :story:
    CLOSED: [2016-09-26 Mon 13:03]
    CLOCK: [2016-09-26 Mon 12:50]--[2016-09-26 Mon 13:03] =>  0:13
    CLOCK: [2016-09-26 Mon 12:30]--[2016-09-26 Mon 12:49] =>  0:19
    CLOCK: [2016-09-26 Mon 11:51]--[2016-09-26 Mon 12:16] =>  0:25
    CLOCK: [2016-09-26 Mon 11:42]--[2016-09-26 Mon 11:51] =>  0:09
    CLOCK: [2016-09-26 Mon 10:09]--[2016-09-26 Mon 11:33] =>  1:24

The new formattable type is generating an invalid header file. It is
missing the forward declaration of the yarn element.

Note: to login to postgres from emacs, [[http://emacs.1067599.n8.nabble.com/sql-postgresql-authentication-failure-td71620.html][leave server empty]].

Load relevant data into postgres for querying:

: grep dogen.knitter.quilt.cpp.log -e "Finished inclusion directives repository" > crap.txt
: cut -b142- crap.txt > ~/inclusion.json
: create table inclusion_directives_json (values jsonb);
: \copy inclusion_directives_json from '~/inclusion.json';

Now create a row per entry in the container:

: create table inclusion_directives2_json (values jsonb);
: insert into inclusion_directives2_json
: select jsonb_array_elements(values->'by_name')
: from inclusion_directives_json;

Now find out type:

: select values as val
: from inclusion_directives2_json
: where values::text like '%<dogen><quilt><cpp><formattables><formattable>%';

And dump it to a file:

: \copy (select values as val from inclusion_directives2_json
: where values::text like '%<dogen><quilt><cpp><formattables><formattable>%')
: to 'out.json';

Actually this was for the directives. We need the same but for the dependencies:

: grep dogen.knitter.quilt.cpp.log -e "Finished creating inclusion dependencies: " > crap.txt
: cut -b144- crap.txt > ~/inclusion_deps.json
: create table inclusion_deps2_json (values jsonb);
: \copy inclusion_deps_json from '~/inclusion_deps.json';

Split objects:

: insert into inclusion_deps2_json
: select jsonb_array_elements(values->'by_name')
: from inclusion_deps_json;

Find our object:

: select values from inclusion_deps2_json
: where values::text like '%<dogen><quilt><cpp><formattable>%';

Save it:

: copy (select values from inclusion_deps2_json where values::text
: like '%<dogen><quilt><cpp><formattables><formattable>%')
: to '~/deps.json';

Actually the problem really was with the inclusion directives! It
seems we are not generating the forward declarations for element:

: select values as val
: from inclusion_directives2_json
: where values::text like '%<dogen><yarn><element>%';

No mention of forward declarations. The problem is fabric is only
injecting forward declarations for the target model. we need to relax
this and do it for all models.

When we do this we seem to overwrite the helper configuration for
types such as =boost::filesystem::path=.

*** COMPLETED Visitor includes are incorrect                          :story:
    CLOSED: [2016-09-26 Mon 13:25]
    CLOCK: [2016-09-26 Mon 13:17]--[2016-09-26 Mon 13:25] =>  0:08
    CLOCK: [2016-09-26 Mon 13:04]--[2016-09-26 Mon 13:16] =>  0:12

We are adding an include to the descendants' header for no
reason. Remove it.

*** COMPLETED Add includer to quilt.cpp                               :story:
    CLOSED: [2016-09-26 Mon 15:13]
    CLOCK: [2016-09-26 Mon 14:43]--[2016-09-26 Mon 15:13] =>  0:30
    CLOCK: [2016-09-26 Mon 13:26]--[2016-09-26 Mon 14:42] =>  1:16

Responsible for computing the inclusion dependencies.

- add a flag in builder to choose new or old API. Supply formattables
  container by ID and new directives repository. When using old API,
  these are default initialised. With new API the other parameters are
  default initialised. Actually a better approach is to create two
  builder impls and to decide which one to use based on the
  constructor of the builder.

*** COMPLETED Do not compute inclusion directives for system models   :story:
    CLOSED: [2016-09-26 Mon 15:23]

*Rationale*: Fixed with new inclusion expander. We only compute
directives as a last resort.

It seems we are computing inclusion directives and other path
derivatives for system models:

: {
:   "__type__": "dogen::cpp::expansion::path_derivatives",
:   "file_path": "/home/marco/Development/DomainDrivenConsulting/output/dogen/clang-3.5/stage/bin/../test_data/all_primitives/actual/std/include/std/serialization/unique_ptr_fwd_ser.hpp",
:   "header_guard": "STD_SERIALIZATION_UNIQUE_PTR_FWD_SER_HPP",
:   "inclusion_directive": "<quote>std/serialization/unique_ptr_fwd_ser.hpp<quote>"
: }

This comes out of the workflow, so we possibly are then ignoring it
for the non-target types. So:

- can we avoid computing these altogether?
- are we ignoring it?

Actually this is the usual problem with the "origin" of the type. We
need a way to determine if this type needs computations or not. We
need to create a story to clean up the =origin_type= and
=generation_type= and then we can make use of it to determine if we
need to compute inclusion, path etc or not.

*** COMPLETED Add reducer to quilt.cpp                                :story:
    CLOSED: [2016-09-26 Mon 15:36]
    CLOCK: [2016-09-26 Mon 15:14]--[2016-09-26 Mon 15:36] =>  0:22

Removes all types that are non-generatable.

*** COMPLETED Add new index to formtter container                     :story:
    CLOSED: [2016-09-26 Mon 17:48]
    CLOCK: [2016-09-26 Mon 16:56]--[2016-09-26 Mon 17:15] =>  0:19

It is actually quite useful to look for a formatter by formatter
name. We should provide this in formatter container and use it from
inclusion expander.

*** COMPLETED Add path expander to quilt.cpp                          :story:
    CLOSED: [2016-09-26 Mon 17:49]
    CLOCK: [2016-09-26 Mon 17:16]--[2016-09-26 Mon 17:49] =>  0:33
    CLOCK: [2016-09-26 Mon 16:39]--[2016-09-26 Mon 16:55] =>  0:16

Generates the full paths.

*** COMPLETED Add guard expander to quilt.cpp                         :story:
    CLOSED: [2016-09-26 Mon 18:17]
    CLOCK: [2016-09-26 Mon 17:50]--[2016-09-26 Mon 18:17] =>  0:27

Generates the header guards. Merged with path generator.

*** COMPLETED Investigate borked travis build                         :story:
    CLOSED: [2016-09-26 Mon 18:38]
    CLOCK: [2016-09-26 Mon 20:43]--[2016-09-26 Mon 21:05] =>  0:22
    CLOCK: [2016-09-26 Mon 18:18]--[2016-09-26 Mon 18:33] =>  0:15

We seem to have borked the build some how:

https://travis-ci.org/DomainDrivenConsulting/dogen/builds/162785692
https://travis-ci.org/DomainDrivenConsulting/dogen/builds/162801645

Hopefully this is just due to not running tests locally. Checkout a
worktree and check.

: git worktree add ../dogen_1fd4399 origin/master
: cd ../dogen_1fd4399/
: mkdir build/output
: build/scripts/build.linux.sh Release gcc /usr/local/personal run_knit.tests

Problem reproduced locally, must have forgotten to run the tests.

: Running 33 test cases...
: ../../../../projects/knit/tests/workflow_tests.cpp(203): error: in "workflow_tests/trivial_inheritance_model_generates_expected_code": check generate_and_diff(target) has failed
: ../../../../projects/knit/tests/workflow_tests.cpp(233): error: in "workflow_tests/std_model_generates_expected_code": check generate_and_diff(target) has failed
: ../../../../projects/knit/tests/workflow_tests.cpp(239): error: in "workflow_tests/boost_model_generates_expected_code": check generate_and_diff(target) has failed
: ../../../../projects/knit/tests/workflow_tests.cpp(245): error: in "workflow_tests/stereotypes_model_generates_expected_code": check generate_and_diff(target) has failed
:
: *** 4 failures are detected in the test module "knit_tests"
: ninja: build stopped: subcommand failed.

Actually, the problem persists. It seems this is related to clean
builds. We seem to have lost service forward declarations.

*** COMPLETED Add decoration expander to quilt.cpp                    :story:
    CLOSED: [2016-09-26 Mon 21:24]
    CLOCK: [2016-09-26 Mon 21:19]--[2016-09-26 Mon 21:24] =>  0:05
    CLOCK: [2016-09-26 Mon 18:34]--[2016-09-26 Mon 18:52] =>  0:18

Generates the decoration.

*** COMPLETED Add aspect expander to quilt.cpp                        :story:
    CLOSED: [2016-09-26 Mon 22:51]
    CLOCK: [2016-09-26 Mon 21:25]--[2016-09-26 Mon 22:51] =>  1:26

Generates the aspect configuration.

- first generate a container with aspect annotations.
- then use it to compute aspect configurations; populate those
  directly into the formattable.

*** STARTED Run tests that are passing on windows                     :story:
    CLOCK: [2016-09-26 Mon 21:06]--[2016-09-26 Mon 21:16] =>  0:10

At present we have a release build on windows but we are not running
any tests. This is because some of the tests are failing at the
moment. We should run all test suites that are green to ensure we
don't regress without noticing.

Look at the stories with errors to determine which tests are passing.

*** Add helper generator to quilt.cpp                                 :story:

Generates the helper configuration.

*** Hook formattables into formatters                                 :story:

Find a way to format out of the formattables container, side-by-side
with the current formatting workflow.

*** Check which properties need to loop through the entire model      :story:

In certain cases such as helpers we probably don't need to go through
all types; only the target types matter. Ensure we are not processing
other types for no reason.

Merged stories:

*Element properties includes non-target types*

We seem to be generating a lot of element properties and formatter
properties as well. We should only be generating these for the target
model.

*** Remove =optional<list>=                                           :story:

We should not really be using optional<list>. The empty list is
sufficient for this.

Uses:

- include provider. Fixed with other story.

*** Add file properties generator to to quilt.cpp                     :story:

We need to generate the file properties for each formattable. The
formatter must supply the modeline name. At present we have a hack in
element properties to determine the modeline.

*** Introduce the concept of proxy models                             :story:

These are models that exist solely to bring types in, but do not
define those types. Typically one uses a proxy model to expose
non-dogen types into dogen. We could add a flag to models
=is_proxy=. It would replace the notion of system models. We need to
check the stories in the backlog around this.

Interestingly we could have different defaults for formatters in proxy
models. For example, if a model is proxy we can assume that we should
not compute inclusion paths. This could save a lot of time when
specifying the models in JSON.

*** Add formattable element                                           :story:

Create a top-level formattable type that is an aggregation of the
element and the element configuration. Update workflow to output a
list of formattable and formatters to take in formattable.

Previous understanding:

- create a top-level type that has formatter, element properties and
  element. Must be non-generatable. Add formattable id as the sum of
  element id and formatter id.
- add =formattables::model= as an unordered map of id to
  formattable. Implement formatting workflow in terms of formattables
  model. Add all context properties to model such as
  streaming_settings_repository and helpers_. element_settings should
  be merged with configuration.
- remove formatting context and update formatting workflow to call a
  visitor to resolve the element and then call the formatter.
- add an enablement map for all formatters in the formatter

*** Remove formatter id                                               :story:

Not clear why we need this given we have formatter name.

*** Remove include builder legacy api                                 :story:

When implementing inclusion expander we did a number of ugly hacks to
support both the legacy API and the new API. We need to remove all the
impls etc we added, in builder, factory, etc.

*** Create the notion of a formatter alias                            :story:

We did a bit of a hack with mapping the facet to the default
formatter. What we really need is the notion of an alias. It still
looks like a formatter name (for example "header_formatter") but it
must be first resolved into an actual formatter. For this we need a
type index.

Other names:

- canonical formatter
- reference formatter

We need to support a strange use case: where the formatter does not
exist for a given element type. For example, we do not have primitive
formatters, but there are directives set in them:

#+begin_src json-mode
        {
            "meta_type" : "primitive",
            "simple_name" : "uint64_t",
            "extensions" : {
                "quilt.cpp.helper.family" : "Number",
                "quilt.cpp.aspect.requires_manual_default_constructor" : true,
                "quilt.cpp.types.class_header_formatter.inclusion_directive" : "<cstdint>",
                "quilt.cpp.hash.class_header_formatter.inclusion_required" : false,
                "quilt.cpp.io.class_header_formatter.inclusion_required" : false,
                "quilt.cpp.test_data.class_header_formatter.inclusion_required" : false,
                "quilt.cpp.serialization.class_header_formatter.inclusion_required" : false,
                "quilt.cpp.odb.class_header_formatter.inclusion_required" : false
            }
        },
#+end_src

The problem with this is that if we do not have a formatter for
primitives, then we will not read the directives. In the past this
worked because we were processing the cross-product of formatters and
element sub-types, so the mistake of
=quilt.cpp.types.class_header_formatter.inclusion_directive= was
actually resulted in the correct result. But of course, we cannot
replace class_header_formatter with the correct formatter name (as we
don't have one). Nor does it sound good to have to hard-code the
formatter name against the type. One way to solve this is with
canonical formatters:

- use the canonical formatter name in the declaration
- ensure we always read directives for the canonical formatter from
  the meta-data.
- when processing, only set the canonical formatter if it was not
  already set by meta-data.

When testing the fix, we need to delete the mock formaters created for
primitives.

As part of this work we need to review the need for
=element_extension=, which seems unused at present. Actually it is
used now in helper annotations repository factory, to ensure we don't
generate annotations for the forward declarations and clobber the main
object with it. This needs reviewing.

*** Tidy-up of inclusion terminology                                  :story:

Random notes:

- imports and exports
- some types support both (headers)
- some support imports only (cpp)
- some support neither (cmakelists, etc).

*** Supply formatter's container to injector                          :story:

At present the injector is calling the formatters' workflow
directly, in order to obtain the formatters' container. It should
receive it as a parameter during initialisation.

*** Add filter to quilt.cpp                                           :story:

Removes the non-target formattables.

*** Move name builder into yarn                                       :story:

At present we have name builder in quilt.cpp simply to build the
merged namespaces. We should have some kind of utility for this in
yarn.

*** Refactor path settings factory                                    :story:

Tasks:

- get distinct list of facets across all formatters and generate field
  definitions from this list;
- cache top-level fields and facet fields and copy results instead of
  re-reading them.

*** Move registration of providers to initialiser                     :story:

At present we are iterating through the formatters list in properties
and manually registering all include providers via the interface. This
is not ideal because the formatter interface needs to know of include
providers, meaning we can't move it away from =quilt.cpp=.

When we register a formatter we should also register the include
provider too.

Tasks:

- add provider support directly to the formatters instead of another
  class and remove registration from formatter interface.
- add a static registrar for the include providers in workflow.
- change initialiser to register the include providers from the same
  shared pointer.

*** Implement all formatter interfaces                                :story:

We still have a couple of skeleton interfaces:

- primitve
- concepts

We should throw if formatting is required.

*** Formatters with duplicate names result in non-intuitive errors    :story:

We added two formatters to io with the same name by mistake and the
resulting error was not particularly enlightening:

: std::exception::what: Qualified name defined more than once: cpp.io.enum_header_formatter.inclusion_required

We should have a very early on validation to ensure formatters have
distinct names.

Merged stories:

*Check for duplicate formatter names in formatter registrar*

At present it is possible to register a formatter name more than
once. Registrar should keep track of the names and throw if the name
is duplicated.

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

*** Move odb options file into odb folder                             :story:

There is not particularly good reason for this file to exist at the
src level.

In order to implement this story we need to have a working odb setup
to test it and ensure we didn't break anything.

*** Add more validation to formatter registration                     :story:

We should check to ensure that only one formatter per facet is
declared the canonical formatter.

*** Consider using indices rather than associative containers          :epic:

Once we generate the final model the model becomes constant; this
means we can easily assign an [[https://en.wikipedia.org/wiki/Ordinal_number][ordinal number]] to each model
element. These could be arranged so that we always start with
generatable types first; this way we always generate dense
containers - there are some cases where we need both generatable types
and non-generatable types; in other cases we just need generatable
types; we never need just non-generatable types. We also need to know
the position of the first non-generatable type (or alternatively, the
size of the generatable types set).

Once we have this, we can start creating vectors with a fixed size
(either total number of elements or just size of generatable
types). We can also make it so that each name has an id which is the
ordinal (another model post-processing activity). Actually we should
call it "type index" or some other name because its a transient
id. This means both properties and settings require no lookups at all
since all positions are known beforehand (except in cases where the
key of the associative container must be the =yarn::name= because we
use it for processing).

In theory, a similar approach can be done for formatters too. We know
upfront what the ordinal number is for each formatter because they are
all registered before we start processing. If formatters obtained
their ordinal number at registration, wherever we are using a map of
formatter name to a resource, we could use a fixed-size
vector. However, formatters may be sparse in many cases (if not all
cases?). For example, we do not have formatter properties for all
formatters for every =yarn::name= because many (most) formatters don't
make sense for every yarn type. Thus this is less applicable, at least
for formatter properties. We need to look carefully at all use cases
and see if there is any place where this approach is applicable. It is
probably going to be more useful for formatters than elements.

Tasks:

- in resolver, assign element indices and update property names with
  them.
- change final model to have a vector of size maximum index (a
  property of the intermediate model).
- in the final model generation, for each type, look at its index and
  populate the slot accordingly.
- update quilt to use the indices where possible.

** Deprecated
