#+title: Sprint Backlog 21
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) spike(p) }

* Mission Statement

- Continue moving more elements into the assets meta-model.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2020-01-27 Mon 18:29]
| <75>                                                  |         |       |      |       |
| Headline                                              | Time    |       |      |     % |
|-------------------------------------------------------+---------+-------+------+-------|
| *Total time*                                          | *15:21* |       |      | 100.0 |
|-------------------------------------------------------+---------+-------+------+-------|
| Stories                                               | 15:21   |       |      | 100.0 |
| Active                                                |         | 15:21 |      | 100.0 |
| Edit release notes for previous sprint                |         |       | 7:01 |  45.7 |
| Create a demo and presentation for previous sprint    |         |       | 1:49 |  11.8 |
| Sprint and product backlog grooming                   |         |       | 0:22 |   2.4 |
| Create the final video on the relational model series |         |       | 0:30 |   3.3 |
| Move registrar into assets                            |         |       | 5:16 |  34.3 |
| Fix error in asserter tests                           |         |       | 0:08 |   0.9 |
| Fix nightly error in registrar                        |         |       | 0:09 |   1.0 |
| Move visual studio fabric types into assets           |         |       | 0:06 |   0.7 |
#+TBLFM: $5='(org-clock-time%-mod @3$2 $2..$4);%.1f
#+end:

*** COMPLETED Edit release notes for previous sprint                  :story:
    CLOSED: [2020-01-24 Fri 12:58]
    :LOGBOOK:
    CLOCK: [2020-01-24 Fri 16:00]--[2020-01-24 Fri 16:12] =>  0:12
    CLOCK: [2020-01-24 Fri 12:01]--[2020-01-24 Fri 12:58] =>  0:57
    CLOCK: [2020-01-23 Thu 00:43]--[2020-01-23 Thu 00:49] =>  0:06
    CLOCK: [2020-01-23 Thu 00:38]--[2020-01-23 Thu 00:42] =>  0:04
    CLOCK: [2020-01-22 Wed 22:42]--[2020-01-23 Thu 00:37] =>  1:55
    CLOCK: [2020-01-22 Wed 18:30]--[2020-01-22 Wed 19:16] =>  0:46
    CLOCK: [2020-01-22 Wed 08:02]--[2020-01-22 Wed 09:03] =>  1:01
    CLOCK: [2020-01-21 Tue 20:41]--[2020-01-21 Tue 22:09] =>  1:28
    CLOCK: [2020-01-20 Mon 22:55]--[2020-01-20 Mon 23:27] =>  0:32
    :END:

Add github release notes for previous sprint.

Title: Dogen v1.0.20, "Oasis do Arco"

#+BEGIN_SRC markdown
**DRAFT: release notes are still being worked on**

![Oasis do Arco](https://upload.wikimedia.org/wikipedia/commons/thumb/9/91/Mini_oasis_in_the_namibe_desert%2C_Angola.JPG/800px-Mini_oasis_in_the_namibe_desert%2C_Angola.JPG)
_Arco Oasis, Namibe, Moçamedes, Angola. (C) 2011 [Paulo César Santos](https://commons.wikimedia.org/wiki/File:Mini_oasis_in_the_namibe_desert,_Angola.JPG)_

# Introduction

New year, new Dogen sprint! At around two months of elapsed time for 83 hours worth of commitment, this was yet another long, drawn-out affair, and the festive period most certainly did not help matters. Having said that, the sprint was reasonably focused on the mission at hand: making the relational model _just about_ usable. In doing so, it provided its fair share of highs and lows, and taught a great deal of lessons - more than we ever wished for. Ah, the joys, the joys. But, onwards we march!

# User visible changes

This section covers stories that affect end users, with the video providing a quick demonstration of the new features, and the sections below describing them in more detail. There were only a few small features this sprint, and there are no breaking changes.

[![Sprint 1.0.20 Demo](https://img.youtube.com/vi/TkYQTW_jAGk/0.jpg)](https://youtu.be/TkYQTW_jAGk)
_Video 1: Sprint 20 Demo._

## Add ODB type overrides to primitives

ORM type overrides had not been used in anger until the relational model was introduced (see below), and, as a result, we did not notice any problems with its implementation. Because the relational model makes heavy use of JSONB, we quickly spotted an issue when declaring type overrides inline with the column (_i.e._, at the attribute level):

```
#DOGEN masd.orm.type_override=postgresql,JSONB
```

According to the [ODB manual](https://www.codesynthesis.com/products/odb/doc/manual.xhtml#14.8), this incantation is not sufficient to cope with conversion functions and other more complex uses. And so, with this sprint, type mapping was updated to take advantage of ODB's flexibility. You can now define type mappings at the element level:

```
#DOGEN masd.orm.type_override=postgresql,JSONB
#DOGEN masd.orm.type_mapping=postgresql,JSONB,TEXT,to_jsonb((?)::jsonb),from_jsonb((?))
#DOGEN masd.orm.type_mapping=sqlite,JSON_TEXT,TEXT,json((?))
```

You can then make use of it at attribute level, as previously. An even better scenario is to define a ```masd::primitive``` for the type, which takes care of it for you, and generates code like so:

```
#pragma db member(json::value_) column("") pgsql:type("JSONB")
```

For example uses of JSONB, please look at the discussion on the relational model in section _Significant Internal Stories_ below.

## Allow outputting the model's SHA1 hash in decoration

The decoration marker has been expanded to allow recording the SHA1 hash of the target model. This is intended as a simple way to keep track of which model was used to generate the source code. In order to switch it on, simply add ```add_origin_sha1_hash``` to the generation marker:

![Decoration marker](https://github.com/MASD-Project/dogen/raw/master/doc/blog/images/decoration_sha1_hash_example.png)
_Figure 1: Sample decoration marker, obtained from the C++ Reference Model._

The generated code will then contain the SHA1 hash:

```c++
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This is a code-generated file.
 *
 * Model SHA1 hash: be42bdb7f246ad4040f17dbcc953222492e1a3bf
 * WARNING: do not edit this file manually.
 * Generated by MASD Dogen v1.0.21
```

Sadly the SHA1 hash does not match the [git hash](https://stackoverflow.com/questions/5290444/why-does-git-hash-object-return-a-different-hash-than-openssl-sha1); however, one can easily use ```sha1sum``` to compute the hash manually:

```
$ sha1sum cpp_ref_impl.lam_model.dia
be42bdb7f246ad4040f17dbcc953222492e1a3bf  cpp_ref_impl.lam_model.dia
```

Before we move on, there are a couple of points worthy of note with regards to this feature. First and foremost, please heed the following warning:

> :warning: : **Important**: Remember that SHA1 hashes in Dogen **are NOT a security measure**; they exist **only** for informational purposes.

Secondly, as we mentioned in the past, features such as these (_e.g._ date/time, Dogen version, SHA1 hash, _etc._) should be used with caution since they may cause unnecessary changes to generated code and thus trigger expensive rebuilds. As such, we recommend that careful consideration is given before enabling it.

## Improvements in generation timestamps

For the longest time, Dogen has allowed users to stamp each file it generates with a _generation timestamp_. This is enabled via the parameter ```add_date_time```, which is part of the  generation marker meta-element; for an example of this meta-element see [the screenshot above](https://github.com/MASD-Project/dogen/raw/master/doc/blog/images/decoration_sha1_hash_example.png), where it is disabled.

When enabled, a typical output looks like so:

```c++
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This is a code-generated file.
 *
 * Generation timestamp: 2020-01-22T08:29:41
 * WARNING: do not edit this file manually.
 * Generated by MASD Dogen v1.0.21
 *
```

In this sprint we did some minor improvements around the sourcing of this timestamp. Previously, we obtained it individually for each and every generated file, resulting in a (possibly) moving timestamp across a model generation. With this release, the timestamp for a given activity - _e.g._ conversion, generation, _etc._ - is now obtained once upfront and reused by all those who require it. Not only is this approach more performant but it yields a better outcome because users are not particularly interested in the precise second _any given file_ was generated, but care more about knowing when _a given model_ was generated.

In addition, we decided to allow users to control this timestamp externally. The main rationale for this was unit testing, where having a moving timestamp with each test run was just asking for trouble. While we were at it, we also deemed sensible to allow users to override this timestamp, if, for whatever reason, they need to. Now, lest you start to think we are enabling "tampering", we repeat the previous warning:

> :warning: **Important**: Remember that generation timestamps in Dogen **are NOT a security measure**; they exist **only** for informational purposes.

With that disclaimer firmly in hand, lets see how one can override the generation timestamp. A new command line argument was introduced:

```
Processing:
<SNIP>
  --activity-timestamp arg       Override the NOW value used for the activity
                                 timestamp. Format: %Y-%m-%dT%H:%M:%S
```

For instance, to change the generation timestamp of the example above, one could set it to ```--activity-timestamp 2020-02-01T01:01:01```, obtaining the following output:

```c++
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * This is a code-generated file.
 *
 * Generation timestamp: 2020-02-01T01:01:01
 * WARNING: do not edit this file manually.
 * Generated by MASD Dogen v1.0.21
```

Clearly, this is more of a troubleshooting feature than anything else, but it may prove to be useful.

# Development Matters

In this section we cover topics that are mainly of interest if you follow Dogen development, such as details on internal stories that consumed significant resources, important events, etc. As usual, for all the gory details of the work carried out this sprint, see the [sprint log](https://github.com/MASD-Project/dogen/blob/master/doc/agile/v1/sprint_backlog_20.org).

## Milestones

The 9999th commit was made to Dogen this sprint.

![100th release](https://github.com/MASD-Project/dogen/raw/master/doc/blog/images/milestones_9999_commits.png)
_Figure 2: GitHub repo at the 9999th commit._

## Significant Internal Stories

The sprint was mostly dominated by one internal story, which this section describes in detail.

### Add relational tracing support

This sprint brought to a close work on the relational model. It was the culmination of a multi-sprint effort that required some significant changes to the core of Dogen - particularly to the tracing subsystem, as well as to ORM. The hard-core Dogen fan may be interested in a series of videos which captured the design and development of this feature:

[![MASD - Dogen Coding: Relational Model for Tracing - Part 1](https://img.youtube.com/vi/re36Sr1u0Iw/0.jpg)](https://www.youtube.com/watch?v=re36Sr1u0Iw&list=PLwfrwe216gF3EzrrvwNFivnLSZ2l8X9k6&index=2)
_Video 2: Playlist "MASD - Dogen Coding: Relational Model for Tracing"._

The (rather long) series of videos will hopefully reach its "climax" next sprint, but (spoiler alert) its "TL; DR" is that it is now possible to dump all information produced by a Dogen run into a relational database. This includes both tracing data as well as all logging, at the user-chosen log level. It is important to note that a full run in this manner is slow: dumping all of Dogen's models (18, at the present count) can take the best part of an hour. Interestingly, the majority of the cost comes from dumping the log at debug level. A dump with just tracing information takes less than 10 minutes, making it reasonably useful. Regardless of the wait, once the data is in the database, the full power of SQL and Postgres can be harnessed.

Implementation-wise, we decided to take path of least resistance and create a small number of tables, code-generated by Dogen and [ODB](https://www.codesynthesis.com/products/odb/):

```
musseque=> \dt
            List of relations
 Schema |      Name       | Type  | Owner
--------+-----------------+-------+-------
 DOGEN  | LOG_EVENT       | table | build
 DOGEN  | RUN_EVENT       | table | build
 DOGEN  | TRANSFORM_EVENT | table | build
(3 rows)
```

Models and other complex data types stored in JSONB fields, _e.g._:

```
musseque=> \dS "RUN_EVENT"
                            Table "DOGEN.RUN_EVENT"
     Column     |            Type             | Collation | Nullable | Default
----------------+-----------------------------+-----------+----------+---------
 TIMESTAMP      | timestamp without time zone |           |          |
 RUN_ID         | text                        |           | not null |
 EVENT_TYPE     | integer                     |           | not null |
 VERSION        | text                        |           | not null |
 PAYLOAD        | jsonb                       |           | not null |
 ACTIVITY       | text                        |           | not null |
 LOGGING_IMPACT | text                        |           | not null |
 TRACING_IMPACT | text                        |           | not null |
Indexes:
    "RUN_EVENT_pkey" PRIMARY KEY, btree ("RUN_ID", "EVENT_TYPE")
```

Though by no means trivial, this approach required fewer changes to Dogen itself, pushing instead the complexity to the queries over the generated dataset. This seemed like a worthwhile trade-off at the time, because normalising a Dogen model in code was a non-trivial exercise. Nonetheless, as we sooon find out, writing queries with complex JSON documents and multiple rows is not an entirely trivial exercise either. As an example, the following query returns objects in a Dia diagram:

```sql
create or replace function classes_in_diagram(in p_transform_instance_id text)
    returns table("ID" text, "NAME" text)
as $$
    select "ID", substring(attrs."ATTRIBUTES"->'values'->0->'data'->>'value', 2,
            length(attrs."ATTRIBUTES"->'values'->0->'data'->>'value') - 2
        ) "NAME"
    from (
        select
            objects."OBJECT"->>'id' "ID",
            objects."OBJECT"->>'type' "TYPE",
            jsonb_array_elements(objects."OBJECT"->'attributes') "ATTRIBUTES"
            from (
                select * from dia_objects_in_diagram(p_transform_instance_id)
            ) as objects
     ) as attrs
     where
         attrs."ATTRIBUTES"->>'name' like 'name' and "TYPE" like 'UML - Class';
$$ language 'sql';
```

This function can be used as follows:

```
=> select * from dia_objects_names_and_stereotypes('8ce7069e-6261-4f9f-b701-814bed17cafb');
 ID  |    NAME     |        STEREOTYPES
-----+-------------+----------------------------
 O1  | cpp         | masd::decoration::modeline
 O2  | cs          | masd::decoration::modeline
 O3  | cmake       | masd::decoration::modeline
 O4  | odb         | masd::decoration::modeline
 O5  | xml         | masd::decoration::modeline
 O7  | xml         | masd::decoration::modeline
 O8  | odb         | masd::decoration::modeline
 O9  | cmake       | masd::decoration::modeline
 O10 | cs          | masd::decoration::modeline
 O11 | cpp         | masd::decoration::modeline
 O13 | apache_v2_0 | masd::decoration::licence
 O14 | bsl_v1_0    | masd::decoration::licence
 O15 | gpl_v2      | masd::decoration::licence
 O16 | gpl_v3      | masd::decoration::licence
 O17 | proprietary | masd::decoration::licence
 O18 | sln         | masd::decoration::modeline
 O19 | sln         | masd::decoration::modeline
````
A library of assorted functions was assembled this way (see [functions.sql](https://github.com/MASD-Project/dogen/blob/master/projects/dogen.relational/sql/functions.sql)), and proved useful enough to track the problem at hand which was to figure out why the [new meta-element registrar](https://github.com/MASD-Project/dogen/blob/master/doc/agile/v1/sprint_backlog_20.org#move-registrar-into-assets) was not being generated. In addition, the expectation is that, over time, more and more powerful queries will be written, allowing us to better exploit the available information. However, it must be said that the complexity of writing JSONB queries is much higher than anticipated, and as such, the feature is not quite as useful as we envisioned. With a bit of luck, next sprint we shall produce a blog post narrating in more detail the saga and its somewhat surprising conclusions.

## Resourcing

Now that we have moved to part-time sprints, looking only at the overall commitment makes less sense; after all, by definition, one is guaranteed to have around 80 hours of work on a sprint. Whilst pondering on this matter, another interesting measure popped up on our radars: the _utilisation rate_ - though, perhaps, not yet its final name. The utilisation rate is computed as the number of days on a full time sprint (_e.g._, 14) divided by the total number of days elapsed since the previous sprint. The utilisation rate measures how "expensive" a day of work is in terms of elapsed days. A high utilisation rate is good, and a low one is bad; on a good sprint we are aiming for close to 50%. In this particular sprint our utilisation rate was around 23%. Since the previous sprint involved a long stretch where we were not doing any work at all, we do not have any comparative figures, but we'll keep tracking this number from now on and hopefully it will became a useful indicator.In terms of our more traditional measurements, the sprint was rather well behaved, as the chart demonstrates:

![Story Pie Chart](https://github.com/MASD-Project/dogen/raw/master/doc/agile/v1/sprint_20_pie_chart.jpg)
_Figure 3: Cost of stories for sprint 20._

Some 45% of the total committed time was taken by the relational model and related activities; and even diversions such as the SHA1 hashes (6.8%) and improvements on generation timestamps (2.3%) were actually byproducts of this work. In terms of process, this was an expensive sprint: whilst the demo was cheap (3%), the release notes were very expensive (13.7%) and so was backlog grooming (5.7%), resulting on an overall figure of 22.4% for process - one of the most costly sprints in this department. Part of this is related to the amount of "uncoordinated" work that had been carried out previously and which was difficult to describe in a manner suitable for the release notes  (remember that demo and release notes describe the work of the _previous sprint_, _e.g. sprint 19 in this case). All and all, for a part time sprint, it was a rather successful one, though we are clearly aiming for a higher utilisation rate for the next one.

## Roadmap

We still haven't quite managed to get the roadmap to work for us, but it seems to provide some kind of visual indication of just how long the road ahead is so we're keeping it for now. However, for it to became truly useful in our current process it requires some more tuning. Perhaps some time spent learning [task juggler](http://taskjuggler.org/) is in order...

![Project Plan](https://github.com/MASD-Project/dogen/raw/master/doc/agile/v1/sprint_20_project_plan.png)

![Resource Allocation Graph](https://github.com/MASD-Project/dogen/raw/master/doc/agile/v1/sprint_20_resource_allocation_graph.png)

# Next Sprint

Now that the relational model is out of the way, the focus on meta-model entities and the fabric clean-up is resumed once more. We are hoping to get one or two of these entities out of the way by sprint end.

# Binaries

You can download binaries from [Bintray](https://bintray.com/masd-project/main/dogen) for OSX, Linux and Windows (all 64-bit):

- [dogen_1.0.20_amd64-applications.deb](https://dl.bintray.com/masd-project/main/1.0.20/dogen_1.0.20_amd64-applications.deb)
- [dogen-1.0.20-Darwin-x86_64.dmg](https://dl.bintray.com/masd-project/main/1.0.20/DOGEN-1.0.20-Darwin-x86_64.dmg)
- [dogen-1.0.20-Windows-AMD64.msi](https://dl.bintray.com/masd-project/main/DOGEN-1.0.20-Windows-AMD64.msi)

**Note:** The OSX and Linux binaries are not stripped at present and so are larger than they should be. We have [an outstanding story](https://github.com/MASD-Project/dogen/blob/master/doc/agile/product_backlog.org#linux-and-osx-binaries-are-not-stripped) to address this issue, but sadly CMake does not make this trivial.

For all other architectures and/or operative systems, you will need to build Dogen from source. Source downloads are available below.

Happy Modeling!
#+END_SRC markdown

- [[https://twitter.com/MarcoCraveiro/status/1220738254158344196][twitter]]
- [[https://www.linkedin.com/posts/marco-craveiro-31558919_dogen-the-masd-code-generator-generates-activity-6626505315070332929-a5pv/][https://www.linkedin.com/posts/marco-craveiro-31558919_masd-projectdogen-activity-6626505954353569792-JAue]]
- [[https://gitter.im/MASD-Project/Lobby][Gitter]]

https://lnkd.in/eAwwjRv

*** COMPLETED Create a demo and presentation for previous sprint      :story:
    CLOSED: [2020-01-24 Fri 15:28]
    :LOGBOOK:
    CLOCK: [2020-01-25 Sat 14:40]--[2020-01-25 Sat 14:55] =>  0:15
    CLOCK: [2020-01-24 Fri 14:20]--[2020-01-24 Fri 15:28] =>  1:08
    CLOCK: [2020-01-24 Fri 12:59]--[2020-01-24 Fri 13:25] =>  0:26
    :END:

Time spent creating the demo and presentation. Use the demo project:

- https://github.com/MASD-Project/demo

Actually since the features are quite trivial, we can demonstrate them
using the Dogen test models.

*** STARTED Sprint and product backlog grooming                       :story:
    :LOGBOOK:
    CLOCK: [2020-01-27 Mon 17:42]--[2020-01-27 Mon 17:49] =>  0:07
    CLOCK: [2020-01-25 Sat 23:41]--[2020-01-25 Sat 23:56] =>  0:15
    :END:

Updates to sprint and product backlog.

*** COMPLETED Create the final video on the relational model series   :story:
    CLOSED: [2020-01-24 Fri 15:59]
    :LOGBOOK:
    CLOCK: [2020-01-24 Fri 15:29]--[2020-01-24 Fri 15:59] =>  0:30
    :END:

Do a video summarising the work on the relational model.

*** COMPLETED Move registrar into assets                              :story:
    CLOSED: [2020-01-26 Sun 22:40]
    :LOGBOOK:
    CLOCK: [2020-01-27 Mon 18:09]--[2020-01-27 Mon 18:22] =>  0:13
    CLOCK: [2020-01-26 Sun 21:45]--[2020-01-26 Sun 22:40] =>  0:55
    CLOCK: [2020-01-26 Sun 13:21]--[2020-01-26 Sun 13:36] =>  0:15
    CLOCK: [2020-01-26 Sun 12:35]--[2020-01-26 Sun 12:46] =>  0:11
    CLOCK: [2020-01-26 Sun 10:02]--[2020-01-26 Sun 10:48] =>  0:46
    CLOCK: [2020-01-25 Sat 23:27]--[2020-01-25 Sat 23:40] =>  0:13
    CLOCK: [2020-01-25 Sat 22:06]--[2020-01-25 Sat 23:26] =>  1:20
    CLOCK: [2020-01-25 Sat 14:55]--[2020-01-25 Sat 16:18] =>  1:23
    :END:

Move the registrar type into assets, in the quickest way possible.

Notes:

- In order to avoid blocking due to lots of analysis, we need
  to split this story into three:
  - first, we need to just move the registrar as is into assets.
  - a second story is to clean up the existing registrar code to have
    less templates and possibly address the existing registration
    bugs. We could also look into calling the registrars for
    referenced models automatically as part of this work (at present
    we are doing this manually).
  - finally, we need some meta-level refactoring to figure out if the
    pattern can be generalised to include initialisers, etc.
  In general that should be our approach: try to split out the
  capturing of patterns into as many steps as possible, to make sure
  we don't get overwhelmed as we implement things.
- we need to keep track of all type registrars on referenced models,
  not on the referenced models themselves. We need to know which
  models we referenced directly, and then find the registrars for
  those models.
- leaves need to know of the registrar. This is so that we can call it
  in their generated tests. We could use the registrar transform to go
  and find all leaves and populate their registrar name. This can be
  added as a property in the generalisation object template.
- current state is that we cannot generate the registrar for some
  reason.
- test model with registrar is C++ model. Type is called
  registrar. Its probably not a good idea to also call it registrar -
  wouldn't that clash with the existing type?
- we should have a warning/error: if using boost serialisation with a
  model that has inheritance, the registrar should be present. Added
  to warnings story.
- we started by trying to make type registrars available only to leaf
  types. However, this does not work:
  - all other members of the inheritance graph also need to know of
    their type registrar, else their tests will fail.
  - types which are composed of types which are in an inheritance
    relationship (directly or through further composition) also need
    to know of the model's type registrar. To know which types would
    require a DAG of the model.
  A slightly easier solution, which we had used before, is to make all
  objects aware of the registrar regardless. This is only needed for
  generated tests anyhow and the complexity of getting this right
  makes the right solution too expensive. However, by the time we get
  to the type registrar transform we have already merged the model, so
  now we have the issue of determining which type registrar belongs to
  which models. We could check =model_modules= of each object.
- we have an inconsistency: the name of the method is =register_types=
  but we can call instances of the =type_registrar= meta-type anything
  we like. It would make more sense to create a class with the name of
  the instance and then call a static method in that class. However,
  we did some hackery with templates which may not work with this
  approach. An alternative is to keep the function as is but use the
  type name to name the function. This is not entirely clean but its
  also not entirely wrong conceptually.
- registrar has a set of model dependencies. Its not clear that we
  still need those. Check to see if deleting it causes any errors.

*** COMPLETED Fix error in asserter tests                             :story:
    CLOSED: [2020-01-27 Mon 17:58]
    :LOGBOOK:
    CLOCK: [2020-01-27 Mon 17:50]--[2020-01-27 Mon 17:58] =>  0:08
    :END:

At present we cannot run the utility tests twice.

*** STARTED Fix nightly error in registrar                            :story:
    :LOGBOOK:
    CLOCK: [2020-01-27 Mon 17:59]--[2020-01-27 Mon 18:08] =>  0:09
    :END:

We are not using the fully qualified name of the registrar when
calling referenced models.

*** STARTED Move visual studio fabric types into assets               :story:
    :LOGBOOK:
    CLOCK: [2020-01-27 Mon 18:23]--[2020-01-27 Mon 18:29] =>  0:06
    :END:

We need to do this for both C# and C++. We should create a namespace
for build infrastructure.

Notes:

- do we need visual studio configuration? Can't seem to find any uses
  for it.

** Deprecated
