#+title: Sprint Backlog 11
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) }

* Mission Statement

- resolve the refactoring problem with lots of duplicated types;
- work on the masd profile.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2018-11-23 Fri 21:49]
| <75>                                                                        |          |        |        |       |
| Headline                                                                    | Time     |        |        |     % |
|-----------------------------------------------------------------------------+----------+--------+--------+-------|
| *Total time*                                                                | *128:00* |        |        |   0.0 |
|-----------------------------------------------------------------------------+----------+--------+--------+-------|
| Stories                                                                     | 128:00   |        |        |   0.0 |
| Active                                                                      |          | 128:00 |        |   0.0 |
| Edit release notes for previous sprint                                      |          |        |   2:03 |   0.0 |
| Sprint and product backlog grooming                                         |          |        |   3:10 |   0.0 |
| Work on MASD theory                                                         |          |        | 113:38 |   0.0 |
| Read up on framework and API design                                         |          |        |   0:57 |   0.0 |
| Rename models to fit MASD architecture                                      |          |        |   4:56 |   0.0 |
| Great meta-data rename                                                      |          |        |   3:16 |   0.0 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** COMPLETED Edit release notes for previous sprint                  :story:
    CLOSED: [2018-10-29 Mon 10:46]
     :LOGBOOK:
     CLOCK: [2018-10-29 Mon 10:47]--[2018-10-29 Mon 10:52] =>  0:05
     CLOCK: [2018-10-29 Mon 10:24]--[2018-10-29 Mon 10:46] =>  0:22
     CLOCK: [2018-10-29 Mon 09:27]--[2018-10-29 Mon 10:23] =>  0:56
     CLOCK: [2018-10-29 Mon 08:46]--[2018-10-29 Mon 09:26] =>  0:40
     :END:

 Add github release notes for previous sprint.

 Title: Dogen v1.0.10, "Lucira"

#+begin_src markdown
![Lucira](http://www.redeangola.info/wp-content/uploads/2016/06/roteiro_lucira_pedro-carreno_5-580x361.jpg)
_Lucira fishing village, Namibe province, Angola. [(C) 2016 Rede Angola](http://www.redeangola.info/roteiros/lucira/)_.

# Overview

This sprint brought the infrastructural work to a close. Much was achieved, though mainly relevant to the development process. As always, you can get the gory details in [the sprint log](https://github.com/MASD-Project/dogen/blob/master/doc/agile/v1/sprint_backlog_10.org), but the below has the highlights.

## Complete the vcpkg transition

There were still a number of issues to mop-up including proper OSX build support, removing all references to conan (the previous packaging system) and fixing a number of warnings that resulted from the build settings on vcpkg. We have now fully transitioned to vcpkg and we're already experiencing the benefits of the new package management system: adding new packages across all operative systems now takes a couple of hours (the time it takes to rebuild the vcpkg export in three VMs). However, not all packages are available in vcpkg and not all packages that are available build cleanly on all our supported platforms, so we haven't reached nirvana just yet.

## Other build improvements

In parallel to the vcpkg transition we also cleaned up most warnings, resulting in very clean builds on [CDash](https://my.cdash.org/index.php?project=MASD+Project+-+Dogen). The only warnings we see are real warnings that need to be addressed. We have tried moving to ```/W4``` and even ```Wall``` on MSVC but quickly discovered that [it isn't feasible at present](https://github.com/Microsoft/vcpkg/issues/4577), so we are using the compiler default settings until the issues we raised are addressed.

Sadly, we've had to ignore all failing tests across all platforms for now (thus taking a further hit on code coverage). This had to be done because at present the tests do not provide enough information for us to understand why they are failing when looking at the Travis/AppVeyor logs. Since reproducing things locally is just too expensive, we need to rewrite these tests to make them easy to troubleshoot from CI logs. This will be done as part of the code generation of model tests.

A final build "improvement" was the removal of facets that were used only to test the code generator, such as hashing, serialisation etc. This has helped immensely in terms of the build time outs but the major downside is we've lost yet another significant source of testing. It seems the only way forward is to create a nightly build that exercises all features of the code generator and runs on our machines - we just do not have enough time on Travis / AppVeyor to compile non-essential code. We still appear to hit occasional timeouts, but these are much less frequent.

## Code coverage

We've lacked code coverage for a very long time, and this has been a pressing need because we need to know which parts of the generated code are not being exercised. We finally managed to get it working thanks to the amazing [kcov](https://github.com/SimonKagstrom/kcov). It is far superior to gcov and previous alternative approaches, requiring very little work to set up. Unfortunately how coverage numbers are very low now due to the commenting out of many unit tests to resolve the build times issues. However, the great news is we can now monitor the coverage as we re-introduce the tests. Sadly, the code coverage story on C# is still weak as we do not seem to be able to generate any information at present (likely due to NUnit shadowing). This will have to be looked at in the future.

We now have support for both [Codecov](https://codecov.io/gh/MASD-Project/dogen) and [Coveralls](https://coveralls.io/github/MASD-Project/dogen?branch=master), which appear to give us different results.

##  C++ 17 support

One of the long time desires has been to migrate from C++ 14 to C++ 17 so that we can use the new features. However, this migration was blocked due to the difficulties of upgrading packages across all platforms. With the completion of the vcpkg story, we finally had all the building blocks in place to move to C++ 17, which was achieved successfully this sprint. This now means we can start to make use of ```ranges```, ```string_view``` and all the latest developments. The very first feature we've introduced is nested namespaces, described below.

## Project naming clean-up

Now we've settled on the new standard namespaces structure, as defined by the [Framework Design Guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-namespaces), we had to update all projects to match. We've also made the build targets match this structure, as well as the folders in the file system, making them all consistent. Since we had to update the CMake files, we started to make them a bit more modern - but we only scratched the surface.

## Defining a Dogen API

As part of the work with Framework Design Guidelines, we've created a model to define the product level API and tested it via scenarios. The API is much cleaner and suitable for interoperability (e.g. SWIG) as well as for the code generation of the remotable interfaces.

# User visible changes

The main feature added this sprint was the initial support for C++ 17. You can now set your standard to this version:

```
#DOGEN quilt.cpp.standard=c++-17
```

At present the only difference is how nested namespaces are handled. Using our annotations class as an example, prior to enabling C++ 17 we had:

```
namespace masd
namespace dogen
namespace annotations {
<snip>
} } }
```

Now we generate the following code:

```
namespace masd::dogen::annotations {
<snip>
}
```

# Next Sprint

We have reached a bit of a fork in Dogen's development: we have got some good ideas on how to address the fundamental architectural problems, but these require very significant surgery into the core of Dogen and its not yet clear if this can be achieved in an incremental manner. On the other hand, there are a number of important stories that need to be implemented in order to get us in a good shape (such as sorting out the testing story). Hard decisions will have to be made in the next sprint.

# Binaries

You can download binaries from [Bintray](https://bintray.com/masd-project/main/dogen) for OSX, Linux and Windows (all 64-bit):

- [dogen_1.0.10_amd64-applications.deb](https://dl.bintray.com/masd-project/main/1.0.10/dogen_1.0.10_amd64-applications.deb)
- [dogen-1.0.10-Darwin-x86_64.dmg](https://dl.bintray.com/masd-project/main/1.0.10/dogen-1.0.10-Darwin-x86_64.dmg)
- [dogen-1.0.10-Windows-AMD64.msi](https://dl.bintray.com/masd-project/main/dogen-1.0.10-Windows-AMD64.msi)

For all other architectures and/or operative systems, you will need to build Dogen from source. Source downloads are available below.#+end_src

 - [[https://twitter.com/MarcoCraveiro/status/1051785972206247936][Tweet]]
 - [[https://www.linkedin.com/feed/update/urn:li:activity:6457553749215899648/][LinkedIn]]
 - [[https://gitter.im/MASD-Project/Lobby][Gitter]]
#+end_src

- [[https://twitter.com/MarcoCraveiro/status/1056856688983187456][Tweet]]
- [[https://www.linkedin.com/feed/update/urn:li:activity:6462624611979841536][LinkedIn]]
- [[https://gitter.im/MASD-Project/Lobby][Gitter]]

*** STARTED Sprint and product backlog grooming                       :story:
    :LOGBOOK:
    CLOCK: [2018-11-22 Thu 10:21]--[2018-11-22 Thu 11:25] =>  1:01
    CLOCK: [2018-11-19 Mon 09:10]--[2018-11-19 Mon 11:01] =>  1:51
    CLOCK: [2018-10-29 Mon 08:30]--[2018-10-29 Mon 08:45] =>  0:15
    :END:

Updates to sprint and product backlog.

*** COMPLETED Work on MASD theory                                     :story:
    CLOSED: [2018-11-19 Mon 11:35]
    :LOGBOOK:
    CLOCK: [2018-11-16 Fri 16:07]--[2018-11-16 Fri 17:07] =>  1:00
    CLOCK: [2018-11-16 Fri 13:28]--[2018-11-16 Fri 15:00] =>  1:32
    CLOCK: [2018-11-16 Fri 09:12]--[2018-11-16 Fri 12:54] =>  3:42
    CLOCK: [2018-11-15 Thu 18:02]--[2018-11-15 Thu 19:29] =>  1:27
    CLOCK: [2018-11-15 Thu 13:20]--[2018-11-15 Thu 17:05] =>  3:45
    CLOCK: [2018-11-15 Thu 09:20]--[2018-11-15 Thu 12:06] =>  2:46
    CLOCK: [2018-11-15 Thu 09:11]--[2018-11-15 Thu 09:18] =>  0:07
    CLOCK: [2018-11-14 Wed 13:15]--[2018-11-14 Wed 18:15] =>  5:00
    CLOCK: [2018-11-14 Wed 08:12]--[2018-11-14 Wed 12:15] =>  4:03
    CLOCK: [2018-11-13 Tue 14:02]--[2018-11-13 Tue 17:02] =>  3:00
    CLOCK: [2018-11-13 Tue 09:00]--[2018-11-13 Tue 12:09] =>  3:09
    CLOCK: [2018-11-12 Mon 13:25]--[2018-11-12 Mon 17:35] =>  4:10
    CLOCK: [2018-11-12 Mon 09:04]--[2018-11-12 Mon 12:09] =>  4:10
    CLOCK: [2018-11-10 Sat 14:10]--[2018-11-10 Sat 17:50] =>  3:40
    CLOCK: [2018-11-09 Fri 14:05]--[2018-11-09 Fri 18:10] =>  4:05
    CLOCK: [2018-11-09 Fri 08:22]--[2018-11-09 Fri 12:30] =>  4:08
    CLOCK: [2018-11-08 Thu 13:40]--[2018-11-08 Thu 17:22] =>  3:42
    CLOCK: [2018-11-08 Thu 08:15]--[2018-11-08 Thu 12:22] =>  9:07
    CLOCK: [2018-11-07 Wed 13:10]--[2018-11-07 Wed 18:29] =>  5:19
    CLOCK: [2018-11-07 Wed 08:15]--[2018-11-07 Wed 12:21] =>  4:06
    CLOCK: [2018-11-06 Tue 08:15]--[2018-11-06 Tue 10:39] =>  2:24
    CLOCK: [2018-11-05 Mon 14:25]--[2018-11-05 Mon 18:20] =>  3:55
    CLOCK: [2018-11-05 Mon 08:30]--[2018-11-05 Mon 12:20] =>  3:50
    CLOCK: [2018-11-04 Sun 14:00]--[2018-11-04 Sun 18:00] =>  4:00
    CLOCK: [2018-11-03 Sat 07:30]--[2018-11-03 Sat 11:20] =>  3:50
    CLOCK: [2018-11-02 Fri 13:50]--[2018-11-02 Fri 18:20] =>  4:30
    CLOCK: [2018-11-02 Fri 10:01]--[2018-11-02 Fri 12:19] =>  2:18
    CLOCK: [2018-11-01 Thu 15:45]--[2018-11-01 Thu 18:16] =>  2:31
    CLOCK: [2018-11-01 Thu 10:10]--[2018-11-01 Thu 12:43] =>  2:33
    CLOCK: [2018-10-31 Wed 16:27]--[2018-10-31 Wed 17:45] =>  1:18
    CLOCK: [2018-10-31 Wed 15:00]--[2018-10-31 Wed 15:08] =>  0:08
    CLOCK: [2018-10-31 Wed 12:02]--[2018-10-31 Wed 14:59] =>  2:57
    CLOCK: [2018-10-31 Wed 08:28]--[2018-10-31 Wed 11:07] =>  2:39
    CLOCK: [2018-10-30 Tue 17:14]--[2018-10-30 Tue 18:31] =>  1:17
    CLOCK: [2018-10-30 Tue 13:36]--[2018-10-30 Tue 15:08] =>  1:32
    CLOCK: [2018-10-30 Tue 08:55]--[2018-10-30 Tue 12:05] =>  3:10
    CLOCK: [2018-10-29 Mon 15:32]--[2018-10-29 Mon 18:10] =>  2:38
    CLOCK: [2018-10-29 Mon 12:35]--[2018-10-29 Mon 14:08] =>  1:33
    CLOCK: [2018-10-29 Mon 10:53]--[2018-10-29 Mon 11:35] =>  0:42
    :END:

Work on defining the theory for MASD:

- update latex templates.
- update API scenarios.
- finish foundations chapter.

*** COMPLETED Rename input models directory to models                 :story:
    CLOSED: [2018-11-22 Thu 10:30]

*Rationale*: Already done.

We need to move the dogen project to the new directory layout whereby
all models are kept in the =models= directory.

*** STARTED Read up on framework and API design                       :story:
    :LOGBOOK:
    CLOCK: [2018-11-22 Thu 09:55]--[2018-11-22 Thu 10:20] =>  0:25
    CLOCK: [2018-11-19 Mon 11:02]--[2018-11-19 Mon 11:34] =>  0:32
    :END:

Now that we are creating a top-level API for Dogen we should really
read up on books about good API design.

Namespacing guideline:

- company | project
- product | technology
- feature
- subnamespace

So in our case, =masd::dogen= and =masd::cpp_ref_impl=. We are
violating the guideline on no abbreviations with ref_impl but
=cpp_reference_implementation= seems a tad long.

It seems we have several types of classes:

- interfaces
- abstract base classes
- values
- objects where data dominates and behaviours are small or trivial
- objects where behaviour dominates and data is small or trivial
- static classes

These should be identifiable at the meta-model level, with appropriate
names.

*** STARTED Rename models to fit MASD architecture                    :story:
    :LOGBOOK:
    CLOCK: [2018-11-23 Fri 11:40]--[2018-11-23 Fri 11:57] =>  0:17
    CLOCK: [2018-11-23 Fri 10:19]--[2018-11-23 Fri 11:39] =>  1:20
    CLOCK: [2018-11-23 Fri 09:02]--[2018-11-23 Fri 10:18] =>  1:16
    CLOCK: [2018-11-22 Thu 15:16]--[2018-11-22 Thu 15:17] =>  0:01
    CLOCK: [2018-11-22 Thu 13:14]--[2018-11-22 Thu 15:16] =>  2:02
    :END:

We now have the following top-level models:

- injection
- coding
- generation
- extraction
- tracing

We need to update the models to match this.

*** STARTED Great meta-data rename                                    :story:
    :LOGBOOK:
    CLOCK: [2018-11-23 Fri 21:43]
    CLOCK: [2018-11-23 Fri 20:55]--[2018-11-23 Fri 21:42] =>  0:47
    CLOCK: [2018-11-23 Fri 16:57]--[2018-11-23 Fri 18:08] =>  1:11
    CLOCK: [2018-11-23 Fri 16:50]--[2018-11-23 Fri 16:56] =>  0:06
    CLOCK: [2018-11-23 Fri 15:37]--[2018-11-23 Fri 16:49] =>  1:12
    :END:

All of the existing stereotypes and meta-data need to be moved from
the existing names (e.g. =quilt=, =yarn=, etc) into
=masd=. Interestingly, we can take this opportunity to make dia
diagrams a bit more readable. Instead of

: #DOGEN a.b.c=d

we can now just do:

: masd.a.b.c=4

It is very unlikely dia users will need lines starting with =masd.=.

We should probably try to tackle this rename sooner rather than later
since it badly breaks model-compatibility.

We should use the new names as part of this rename, e.g.:

: masd.injection.dia.comment
: masd.extraction.cpp.enabled

Rename =is_proxy_model= to =platform_definition_model=.

*** Create the =orchestration= model                                  :story:

Create a model with the top-level transforms.

*** Create a single binary for all of dogen                           :story:

As per analysis, we need to create a single dogen binary, like so:

: dogen.cli COMMAND COMMAND_SPECIFIC_OPTIONS

Where =COMMAND= is:

- =transform=: functionality that is currently in tailor.
- =generate=: functionality that is currently in knitter.
- =expand=: functionality that is currently in stitcher plus expansion
  of wale templates.
- =make=: functionality in darter: create project, structure etc.

In order to support sub-commands we need to do a lot of hackery with
program options:

- [[https://gist.github.com/randomphrase/10801888][cmdoptions.cpp]]: Demonstration of how to do subcommand option
  processing with boost program_options
- [[https://stackoverflow.com/questions/15541498/how-to-implement-subcommands-using-boost-program-options][How to implement subcommands using Boost.Program_options?]]

*Merged Stories*

We started off by creating lots of little executables: knitter,
darter, tailor, stitcher. Each of these has its own project,
command-line options etc. However, now that we are concentrating all
of the domain knowledge in yarn, it seems less useful to have so many
executables that are simply calling yarn transforms. Instead, it may
make more sense to use an approach similar to git and have a
"sub-command":

: dogen knit
: dogen tailor

And so forth. Of course, we could also take this opportunity and clean
up these names to making them more meaningful to end users. Perhaps:

: dogen codegen
: dogen transform

Each of these sub-commands or modes would have their own set of
associated options. We need to figure out how this is done using boost
program options. We also need to spend a bit of time working out the
sub-commands to make sure they make sense across the board.

In terms of names, we can't really call the project "dogen". We should
call it something allusive to the command line, such as cli. However,
the final binary should be called dogen or perhaps, =dogen.cli=. This
fits in with other binaries such as =dogen.web=, =dogen.http=,
=dogen.gui= etc.

*** Implement the new dogen product API                               :story:

Now the API has been designed and generated, we need to implement it.

*** Clean up the mess of refactors in dogen core                      :story:

The first task is to try to abort the OOP refactors that we made in
the past.

*** Fix cmake emacs variable for tab width                            :story:

We need to replace uses of =tab-width= in cmake files with
=cmake-tab-width=, as explained here:

[[http://stackoverflow.com/questions/25751408/controlling-the-indent-offset-for-cmake-in-emacs][Controlling the indent/offset for CMake in emacs]]

We need to do this for both code generated and manually generated
files.

*** Fix =cp= error on cmake with local third-party packages           :story:

We are getting strange errors in cmake:

: cp: cannot stat ‘/usr/lib/i386-linux-gnu/libpthread.so.1.54.0’: No such file or directory

*** Assorted improvements to CMake files                               :epic:

It seems we are not using proper CMake idioms to pick up compiler
features, as explained here:

- [[http://unclejimbo.github.io/2018/06/08/Modern-CMake-for-Library-Developers/][Modern CMake for Library Developers]]
- [[http://www.slideshare.net/DanielPfeifer1/cmake-48475415][CMake - Introduction and best practices]]
- [[https://datascience.lanl.gov/data/151208-LANL-Hoffman-Science.pdf][Building Science with CMake]]
- [[http://voices.canonical.com/jussi.pakkanen/2013/03/26/a-list-of-common-cmake-antipatterns/][A list of common CMake antipatterns]]
- [[https://rix0r.nl/blog/2015/08/13/cmake-guide/][The Ultimate Guide to Modern CMake]]
- [[https://github.com/crezefire/cxp][CXP: C++ Cross Platform]]: A template project for creating a cross
  platform C++ CMake project using modern CMake syntax and transitive
  dependencies.

We need to implement this using proper CMake idioms.

Notes:

- Add version and language to project.
- start using [[https://cmake.org/cmake/help/v3.3/command/target_compile_options.html][target compile options]] for each target. We will have to
  repeat the same flags; this could be avoided by passing in a
  variable. See also [[http://stackoverflow.com/questions/23995019/what-is-the-modern-method-for-setting-general-compile-flags-in-cmake][What is the modern method for setting general
  compile flags in CMake?]]
- define qualified aliases for all libraries, including nested
  aliasing for =dogen::test_models=. Ensure all linking is done
  against qualified names.
- use target include directories for each target and only add the
  required include directories to each target. Mark them with the
  appropriate visibility, including using =interface=. We should then
  remove all duplication of libraries in the specs.
- try replacing calls to =-std=c++-14= with compiler feature
  detection. We need to create a list of all C++-14 features we're
  using.
- remove all of the debug/release compilation options and start using
  =CMAKE_BUILD_TYPE= instead. See [[http://pastebin.com/jCDW5Aa9][this]] example. We added build type
  support to our builds, but as a result, the binaries moved from
  =stage/bin= to =bin=. There is no obvious explanation for this.
- remove =STATIC= on all libraries and let users specify which linkage
  to use. We already have a story to capture this work.
- remove the stage folder and use the traditional CMake
  directories. This will also fix the problems we have with
  BUILD_TYPE.
- consider buying the CMake book: https://crascit.com/professional-cmake/.

Merged stories:

*Usage of external module path in cmakelists*                       :story:

It seems like we are not populating the target names
properly. Originally the target name for test model all built-ins was:

: dogen_all_builtins

When we moved the test models into =test_models= the target name did
not change. It should have changed to:

: dogen_test_models_all_builtins

*** Support for cmake components and groups                           :story:

#+begin_quote
*Story*: As a dogen user, I need to integrate the generated models
with my existing packaging code.
#+end_quote

We recently added support for creating multiple packages from a single
source tree. We need generated models to have a new top-level cmake file:

: add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/src)
: add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/tests)
:
: install(
:     DIRECTORY include/
:     DESTINATION include
:     COMPONENT headers
:     FILES_MATCHING PATTERN "*.hpp")

And the =src= cmake file:

: install(TARGETS dia ARCHIVE DESTINATION lib COMPONENT libraries)

*** Mop-up nested namespaces using legacy syntax                      :story:

It seems we still have a number of places in the templates where we
are using the legacy nested namespaces. Its probably only in
serialisation, given that's the only place where we've hard-coded the
namespaces and they are more than one level deep (we have a lot of
=std= but that's not affected):

: namespace boost {
: namespace serialization {

We need to wrap these in if's for C++ 17 and add nested namespaces.

*** Add DTL to vcpkg                                                  :story:

DTL seems to be the easiest library to work with in terms of
generating diffs. However, its not on vcpkg.

Tasks:

- add CMake support to DTL. Not strictly needed but seems like an easy
  thing to do and will make vcpkg easier. It also means we can build
  tests and examples to make sure it all works in isolation. Actually
  this was tried before and not accepted by the maintainer.
- add DTL port.

Links:

- [[https://github.com/google/diff-match-patch/tree/master/cpp][diff-match-patch]]: interesting diff library but requires QT.
- [[https://github.com/Martinsos/edlib#usage-and-examples][edlib]]: interesting library but seems to be more for Levehnstein
  diffs. Also not on vcpkg.
- [[https://github.com/cubicdaiya/dtl/pull/2][Add cmake support]]: PR to add CMake support to DTL, not accepted by
  the maintainer. See also [[https://github.com/chino540off/dtl][the repo]].
- [[https://github.com/Microsoft/vcpkg/tree/master/ports/libodb][libodb]]: example of a project with a vcpkg specific CMake support.
- [[https://stackoverflow.com/questions/13438547/linux-c-or-c-library-to-diff-and-patch-strings][Linux C or C++ library to diff and patch strings?]]

*** Add tests for external and model modules                          :story:

At present we do not have tests exercising different combinations of
external and model modules.

Tests:

- 0-3 levels of external modules
- 1-3 levels of model modules

*** Rewrite name resolution in terms of lists                         :story:

Even since we did the external modules / model modules change we broke
code generation; this is because we do not go up the model modules
during name resolution. We did a quick hack to fix this but it needs
to be done properly.

Let's walk through a simple example:. Name cames in as:

- model module: =probing=
- simple: =prober=

We are in model:

- model module: =dogen.external=

Expected behaviour is to try all combinations of model modules:

- =dogen.external.probing=
- =dogen.probing
- =probing=

This highlights a fundamental problem with resolution: we view the
{external, model, internal} modules as if they are separate entities
but in reality, for the purposes of resolution, there is only one
thing that is relevant: the module path. If it matches because of
{external, model, internal} modules, well that is not relevant to
resolution. Other users of =name= do need to know this information
(for example to generate directories or file names) but not the
resolver.

Interestingly, because we are only looking for an id, it doesn't
really matter how we get to it (in terms of the internal composition
of the name), as long as it matches bitwise. This means we can look at
the process slightly differently:

- start off with the name as the user provided it. Extract all strings
  from it to create a list, in order: external, model, internal,
  simple. Try to resolve that. Call it user list.
- then create a second list from model / context: external, model,
  internal. Call it model list.
- try concantenating model list and user list, pretty printing and
  resolving it. If it fails, pop model list and concatenate again. Try
  until model list is empty.

Tasks:

- first add a quick hack just to get the code generator working
  again. For example, take the first model module of the model and try
  resolving with that. Then worry about fixing this properly.
- split the conversion of name into list from pretty printer. Printer
  should merely take a string or list of strings and do its thing. We
  need to find a good location for this method, since (for now) we
  cannot place it in the right location which is the name class
  itself.
- change resolver to obtain the lists as per above. The to list
  machinery can be used for this, though we need to handle model names
  somehow. We can copy the =model_name_mode= logic from printer.
- drop all of the logic in resolver at present and use the list logic
  as per above. Do not check references, etc.

Notes:

- there are a few useful functions here:
  - subtraction: given a base list, subtract another list. Fro
    example, given =masd::dogen::annotations::annotation=, subtract
    =masd::dogen::annotations=. This is useful when determining the
    right qualification inside a class.
  - addition: concatenate a list with another.
  - combination: given a base list, create all possible permutations
    for a second list. For example: =masd::dogen::annotations= and
    =some::type=, we want =masd::dogen::annotations::some::type=,
    =masd::dogen::some::type=, =masd::some::type=, =some::type=. We
    are iterating upwards the first list.
  - make id: given a list, generate an ID. This was we don't even need
    to go though the whole "name building" exercise, we simply go from
    lists into ID's and check the containers.
- we probably should introduce a type for this: =flat_location=?
  something that can be converted from a =location= (but not the
  opposite) and has the properties defined above. Or we could have a
  "location flattener" that performs these actions, but this is less
  clean as we now need a few of these helpers.
- there are two fundamental concepts: a path (which is what we call a
  location) and an address (which is what we call an ID). Path implies
  an hierarchical space, which is what modeling and generation space
  are. Address is flat and unique. There is a function to go from
  paths to addresses but not vice-versa. Given two paths we can
  generate all possible addresses by performing a "climb" in the
  hierarchical space.
- we could make addresses URIs, and preserve almost all of the
  information: =masd://some.model.name/a/b.c=. The problem is we
  cannot tell the difference between model modules and external
  modules. However, we could simplify this and say model modules and
  external modules are all the same thing; users can choose to express
  external modules as part of the file name or not. (e.g. "express
  full path" or some such flag). We can also choose to express
  external modules as directories or as a dotted path. URIs may not be
  the best of ideas because models exist in contexts (workspaces,
  servers, users) rather than in one universal space. However, we
  could use URLs as a way to identify resources once we clear up the
  REST story.

*** Default model modules from filename                               :story:

It would be nice to be able to not have to supply model modules when
its obvious from the filename.

*** Nested external model path results in strange references          :story:

Note: we have probably already implemented a solution for this, need
to check the resolver.

The external model path does not contribute to path resolution in a
model. Up til now that has actually been a feature; it would have been
annoying to have to dype =dogen::= on every type for every
model. Instead, we refer to say =dogen::a::b= as simply =a::b= in all
models that use =a=. However this masks a deeper problem: this is not
the desired behaviour at all times. We saw this problem when we
created multiple models under dynamic: =dynamic::schema= and
=dynamic::expansion=. In this case, users of these models referred to
them as =schema= and =expansion= respectively, and this was not
ideal. In general:

- external module path should contribute to references just like
  internal module path does - there should be no difference;
- dogen should be clever enough to determine if two models share a
  top-level namespace (regardless if it was obtained from the external
  or internal module path) that there is no need to have an absolute
  path. So in the case of =dogen=, since every model has =dogen= as
  their external module path, according to this rule we should not
  have to type it.

*** Remove hello world model                                          :story:

 It is confusing to have it mixed up with product models. Use a regular
 dogen model to test the package. We could have it on the reference
 model as a stand alone example, or we could create a "hello dogen"
 product for a trivial example of dogen usage.

*** Move from doxygen to standardese                                  :story:

We should try to use standardese to generate the documentation for
dogen. Seems easier to use and CMake friendly. Also, it seems more c++
compliant because it uses libclang.

Once the move is done, we should update dogen to generate comments in
either markup via a meta-data parameter (documentation markup?).

Links:

- https://github.com/foonathan/standardese

*** Update ref impl namespaces to match the new specification         :story:

Perform the namespace update to the reference implementation.

*** New approach to model testsing                                    :story:

In the beginning we generated all models with all facets, even the
dogen core models. The idea was to test the generator even though
these facets were not useful for the product. This was really useful
because the dogen models are much more realistic than the test models
and due to this we picked up a number of bugs. However, we have now
hit the maximum build times on travis and we need to start removing
all ballast. This will mean we lose these valuable tests. The
alternative is to create these tests on the fly:

- create a new override flag that forces all facets to be emitted.
- create a new test facet with templates that are dependent on the
  enabled facets; each test tests the dependent facet.
- create a ctest nightly build that generates code using these new
  facets, compiles it and runs all tests.
- we need some meta-data to "ignore" some modeling elements for
  certain facets such as composition which are known to be broken. Or
  maybe we should just leave the tests as red so we know.
- the tests should be designed not to use templates etc to make the
  debug dumps really obvious (unlike the existing tests). It may even
  make more sense to test each type individually so that when the test
  fails its really obvious:

: MY_TYPE_serialisation_roundtrips_correctly

  this way when we look at CDash we know exactly which types failed to
  serialise.

During the transition phase, we will remove all of the existing tests.

*** Add support for multiple profile binds per modeling element       :story:

At present we can only bind an element to one profile. The reason why
is because we've already expanded the profile graphs into a flat
annotation and if we were to apply two of these expanded annotations
with common parents, the second application would overwrite the
first. Of course, we bumped into the exact same problem when doing
profile inheritance; there it was solved by ensuring each parent
profile is applied only once for each graph.

One possible solution for this problem is to consider each model
element as a "dynamic profile" (for want of a better name; on the fly
profile?). We would create a profile which is named after each of the
profiles it includes, e.g. say we include =dogen::hashable= and
=dogen::pretty_printable= for model element e0. Then the "on the fly
profile" would be:

: dogen::hashable_dogen::pretty_printable

It would be generated by the profiler, with parents =dogen::hashable=
and =dogen::pretty_printable=, and cached so that if anyone shows up
with that same profile we can reuse it. Because of the additive nature
of profile graphs this would have the desired result. Actually we
could probably have a two pass-process; first identify all of the
required dynamic profiles and generate them; then process them. This
way we can rely on a const data structure.

This will all be made easier when we have a two-pass pipeline because
we can do the profile processing on the first pass, and we can even
generate the "dynamic profiles" as real meta-model elements, created
on the fly.

*** Facet enablement and model references is buggy                    :story:

At present we are processing enablement as part of the
post-processing. This means that we are using the target model's
annotation profile in order to determine the facet enablement. This
can cause problems as follows: say we enable hashing on a model via
the model profile of M0. We then consume that model as a reference and
disable hashing on M1. When processing types from M0 for M1 we will
disable hashing for them as well. Thus, no includes for hashing will
be generated even if a hash map is used.

Actually this is not quite right. We are expanding annotations at the
external model transform level; this means the enablement on the
reference must be correct. However, somehow we seem to be looking at
the element on the target model when deciding to include the hash
file from reference model.

*** Consider creating a test build for all facets                     :story:

In the past we had enabled a lot of facets on the dogen models to
serve as part of the testing infrastructure. However, its no longer
feasible to do this because the build is taking too long. However, the
reference models just can't capture all of the complexity of a
codebase like dogen's so we lost some testability with this move. What
would be really nice is if we could create "test builds":

- given a set of test models, copy them somewhere, generate a product
  configuration with some kind of override that enables all facets
  everywhere. some will just not come through like ORM.
- build the product. all handcrafted code is now blank but all facets
  are coming though.
- this could be part of the ctest script, as a "mode" - product
  generation test. Every time there is a commit to a product the build
  kicks in.

Notes:

- one way to achieve this would be to force the profile of the
  model. However, we are moving away from profiles, and in the future
  there will be a list of stereotypes associated with the model. Then
  it will be much harder to figure out what stereotypes do what and to
  overwrite them.
- an alternative would be to have some kind of "test mode"; when
  handling enablement, we'd check the "mode". If we're in test mode,
  we simply enable all and ignore any other settings. We could have a
  "force enable" flag or some such like we do for
  overwriting. However, we may then hit another problem: enabling all
  facets may result in non-buildable models:
  - facets may be incompatible. This is not a problem at present.
  - handcrafted classes may result in code that does not
    compile. Shouldn't though because we are still checking the status
    of the attributes.
- the key thing though is the overall build time must be below the
  threshold. Maybe we can have this on a nightly, running on our own
  hardware.

Conclusions:

- create a new flag: =force-enablement=. When set to true, we ignore
  all enablement settings and generate all facets. We do not generate
  all kernels though (e.g. the kernel must be on in the model).
- create a script that copies the models to a new product and
  generates them with fore-enablement. This will only work when we can
  generate products.
- as facets are enabled, tests are automatically generated for them.
- build the result and run all tests.

*** Create some basic naming guidelines                               :story:

As per Framework Design Guidelines, we need some basic guidelines for
naming in Dogen. We don't need to go overboard, we just need something
to get us started and evolve it as we go along.

Links:

- [[https://isocpp.org/wiki/faq/coding-standards][C++ Coding Standards]]
- [[http://wiki.c2.com/?CapitalizationRules][Capitalization Rules]]
- [[https://en.wikipedia.org/wiki/Snake_case][Snake Case]]
- [[http://cs.smu.ca/~porter/csc/ref/stl/naming_conventions.html][Naming Conventions for these STL Reference Pages]]
- [[https://style-guides.readthedocs.io/en/latest/cpp.html][C++ coding style guide]]
- [[https://stxxl.org/tags/1.4.1/coding_style.html][Coding Style Guidelines]]
- [[https://www.fluentcpp.com/2018/04/24/following-conventions-stl/][Make Your Containers Follow the Conventions of the STL]]

*** Consider generating program options code                          :story:

If there was a syntax to describe boost program options, we should be
able to generate most of the code for it:

- the code that initialises the options;
- the domain objects that will store the options;
- the copying of values from program options objects into domain
  objects.

This would mean that creating a command line tool would be a matter of
just supplying an options file. We could then have a stereotype for
this (name to be yet identified). Marking a type with this stereotype
and supplying the appropriate meta-data so one could locate the
options file would cause dogen to emit the program options binding
code.

A similar concept seems to exist for python: [[http://docopt.org/][docopt]]. We should keep
the same syntax. We just need to have a well defined domain object for
these. The aim would be to replace config.

For models such as these, the dia representation is just overhead. It
would be great if we could do it using just JSON.

Actually even better would be if we could have a text file in docopt
format and parse it and then use it to generate the code described
above.

Actually maybe we are just making this too complicated. We probably
just need some very trivial meta-data extensions that express the
required concept:

- create a yarn element to model this new meta-class. We basically
  need to model the structure of program options with option groups
  and options.
- define a stereotype for the new yarn elements, say
  =CommandLineOptionGroup=.
- for types facet we simply generate the regular c++ code. But in
  addition, we also generate a new facet that: a) injects the
  propertties into boost program options b) instantiates the c++
  objects from boost program options.
- this means that instead of creating a new meta-type, we need to
  augment =yarn::object= with command line options stuff.

Notes:

- create stereotypes for options group, options; allow users to define
  members of type options in options group. Or should the options just
  be member variables? In which case we could have
  =command_line::options= as the stereotype.
- generate the options classes.
- inject a hand-crafted validator or consider generating the validator
  given the meta-data supplied by the user (mandatory, at most X
  times, etc).
- generate an options builder that takes on the building
  responsibilities from the parser.
- generate a parser that hooks the builder and copies data from the
  options map into the options.
- allow users to supply the help text and the version text as
  parameters; these should probably be done in a similar way to what
  we do with the modeline etc.
- allow users to set default values in the options attributes and set
  them in generated code. This is probably just adding default value
  support to dogen, for which we have a separate story.
- one very useful way in which to use program options is via
  projections. That is a given model M0 defines the configuration and
  a second model M1 defines the options parsing. In this case the
  options defined in M0 already has the required shape:
  - there is a top-level class housing all options, traditionally
    called "configuration";
  - the top-level class contains meta-data with the product blurb;
  - attributes of that class can be annotated as "modes", "groups" or
    nothing. A mode will result in a modal CLI interface. Groups
    result in top-level groupings of options. Nothing means the
    attribute must be of a simple type and will be a global option
    (e.g. =help=, =version=, etc).
  - attributes have a description, etc associated as meta-data. They
    also have other useful annotations such as optional, mandatory
    etc. These are used in validation. Interestingly this may mean we
    can also automatically generate a validator.
  - dogen generates in M1 a set of chained program option parsers
    (assuming a modal interface; otherwise just one) which generate
    the M0 options.
  - in M1, users define a class with attribute
    =masd::command_line_options=, associated with an options class.
  - users can choose the "backend": boost program options, etc. Each
    is implemented as a separate template.
  - dogen generates a parser with an associated exception
    (parser_validation_error). The exception is simply injected as a
    type.

Links:

- [[https://github.com/abolz/CmdLine2][CmdLine2]]: alternative library to program options.

*** Exclude profiles from stereotypes processing                      :story:

At present we are manually excluding profiles from the stereotypes
transform. This was just a quick hack to get us going. We need to
replace this with a call to annotations to get a list of profile names
and exclude those.

We should also rename =is_stereotype_handled_externally= to something
more like "is profile" or "matches profile name".

Actually the right thing may even be to just remove all of the profile
stereotypes during annotations processing. However, we should wait
until we complete the exomodel work since that will remove scribble
groups, etc. Its all in the annotations transform.

*** Problems in tailor generation of dogen models                     :story:

Regenerated all models, got the following errors:

- we are adding the extension to the dia filename because of how CMake
  works. We should probably remove the output parameter or at least
  allow defaulting it to a replacement of the extension.
- we are removing the dependencies due to duplicates in JSON keys.
- we are looking for .dia diagrams instead of .json for references.

*Previous Understanding*

We converted all of dogen's models from dia into JSON using tailor and
code-generated them to see if there were any differences.

Issues to address:

- problems with =quilt.cpp= and =yarn.dia= / =yarn.json=: the
  conversion of the model path did not work as expected - we do not
  know of the "."  separator. Fixed it manually and then it all worked
  (minus CMakeLists, see below). We could possibly fix the builder to
  automatically use the "." to separate model paths. Actually with the
  latest changes we now seem to only be looking at the first model
  module, so for =yarn.dia= we only have =yarn=.
- CMakeLists were deleted on all models for some reason, even though
  the annotations profile look correct.
- in quilt we correctly generated the forward declarations for
  registrar error and workflow error without including boost
  exception. Not sure why that is, nor why it is that we are including
  them for forward declarations.
- Missing include of registrar serialisation in
  =all_ser.hpp=. Instability in =registrar_ser.cpp=, but content is
  correct otherwise.
- =database.json= generated invalid JSON.
- references in dia diagrams have the dia extension. This means that
  they do not resolve when converted to JSON.

"Script":

#+begin_src
rm *.json
A="dia knit quilt.cpp wale yarn.json annotations formatters quilt yarn database options stitch yarn.dia"
for a in $A; do /home/marco/Development/DomainDrivenConsulting/dogen/build/output/gcc/Release/stage/bin/dogen.tailor -t $a.dia -o $a.json; done
for a in $A; do /home/marco/Development/DomainDrivenConsulting/dogen/build/output/gcc/Release/stage/bin/dogen.knitter -t ${a}.json --cpp-project-dir /home/marco/Development/DomainDrivenConsulting/dogen/projects --ignore-files-matching-regex .*/CMakeLists.txt --ignore-files-matching-regex .*/test/.* --ignore-files-matching-regex .*/tests/.* --verbose --delete-extra-files; done
#+end_src

In an ideal world, we should probably have a script that we run as
part of =knit_and_stitch= that converts to tailor and then runs
knitter on the models, so that we keep track of tailor breaks outside
of JSON test models.

*** Log file names do not have frontend                               :story:

Add extension to log file name so that we can see both Dia and JSON
logs at the same time. At present, one overwrites the other because we
do not have the frontend (e.g. the extension) on the log file name.

*** Update static strings to string views                             :story:

Now we're on C++17 we can start making use of its new features. One
low hanging fruit is string view. We use static strings quite a lot
for logging etc. We can just replace these with string views.

Links:

- [[https://www.bfilipek.com/2018/10/strings17talk.html][Let's Talk About String Operations in C++17]]

*** Add basic "diff mode"                                             :story:

We need a very simple way of checking all generated files in memory
against what's in the file system and returning a flag if they are
different. We can then use these flags to determine if tests pass. In
the future we can extend this approach to include a proper diff of the
files, but for now we just need a reliable way to run system tests
again.

Actually the right solution for this is to see the processing as part
of a chain:

- out of the generator come a set of artefacts with operations (write,
  merge, ignore)
- these get joined with a transform that reads the state of the file
  system. It then adds more operations: delete, etc. If there are no
  diffs, it marks those files as skip.
- the final step is a processor which gets that model and executes the
  operations. This can then be replaced by a "reporter" that simply
  states what the operations would be.

Diff mode is using the report to see if there are any diffs.

Merged Stories:

*Validation-only or dry-run mode*

Both stitcher and knitter could do with a "dry-run" mode in which we'd
do everything except for actually outputting.

*For Knitter*

It would be nice if one could just check if a dia diagram is valid for
code generation, e.g. =--validate= or something along those lines.

*For Stitch*

We are interested in performing the parsing. This would be useful for
example for a flymake mode in emacs.

An additional feature of dry-run would be to run, generate the model
and then produce a unified diff, e.g. tell me what you'd change. For
this we'd have to link against a diff library. We need to
automatically exclude non-overwrite files (or have an option to
exclude/include them).

Links:

- [[https://github.com/google/diff-match-patch/tree/master/cpp][google Diff Match Patch library]]
- [[https://github.com/cubicdaiya/dtl][DTL: Diff Template Library]]
- [[https://stackoverflow.com/questions/1451694/is-there-a-way-to-diff-files-from-c][SO: Is there a way to diff files from C++?]]

*Dry-run option to just diff with existing generated code*

#+begin_quote
*Story*: As a dogen user, I want to know what has changed with the
next code generation so that I can evaluate if the changes are as
expected or not.
#+end_quote

It would be useful to have an option that would do everything except
writing the files to disk; instead, it would diff them with the
existing files and report if there are any differences. This would be
useful to make sure the source code matches the latest version of the
diagram.

We could use something like the [[https://code.google.com/p/dtl-cpp/wiki/Tutorial][DTL library]].

** Deprecated
*** CANCELLED Update =yarn.dia= traits to external                    :story:
    CLOSED: [2018-11-22 Thu 10:38]

*Rationale*: superseded by the MASD rename.

We renamed the model but did not update the traits.
