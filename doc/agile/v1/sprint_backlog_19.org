#+title: Sprint Backlog 19
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) spike(p) }

* Mission Statement

- Move fabric into coding meta-model.

* Stories

** Active
#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2019-06-03 Mon 19:45]
| <75>                                               |        |      |      |       |
| Headline                                           | Time   |      |      |     % |
|----------------------------------------------------+--------+------+------+-------|
| *Total time*                                       | *7:43* |      |      | 100.0 |
|----------------------------------------------------+--------+------+------+-------|
| Stories                                            | 7:43   |      |      | 100.0 |
| Active                                             |        | 7:43 |      | 100.0 |
| Edit release notes for previous sprint             |        |      | 3:36 |  46.7 |
| Create a demo and presentation for previous sprint |        |      | 1:39 |  21.4 |
| Sprint and product backlog grooming                |        |      | 0:24 |   5.2 |
| Remove test model sanitizer                        |        |      | 0:20 |   4.3 |
| Remove master headers                              |        |      | 1:02 |  13.4 |
| Move registrar into assets                         |        |      | 0:42 |   9.1 |
#+TBLFM: $5='(org-clock-time%-mod @3$2 $2..$4);%.1f
#+end:

*** COMPLETED Edit release notes for previous sprint                  :story:
    CLOSED: [2019-06-03 Mon 12:59]
    :LOGBOOK:
    CLOCK: [2019-06-03 Mon 16:01]--[2019-06-03 Mon 16:30] =>  0:29
    CLOCK: [2019-06-03 Mon 12:51]--[2019-06-03 Mon 12:59] =>  0:08
    CLOCK: [2019-06-03 Mon 09:51]--[2019-06-03 Mon 10:45] =>  0:54
    CLOCK: [2019-06-03 Mon 06:47]--[2019-06-03 Mon 08:52] =>  2:05
    :END:

Add github release notes for previous sprint.

Title: Dogen v1.0.18, "Estação de Comboio"

#+begin_src markdown
![Nova estação de comboio e a antiga](https://gdb.voanews.com/957FFA4D-4D6B-49D0-B3C4-C5577701EEE8_w1597_n_r1_st.jpg)

_The new CFM train station, next to the old. Moçamedes, Namibe, Angola. (C) 2018 [Armando Chicoa (VOA)](https://www.voaportugues.com/a/autoridades-falam-em-neglig%C3%AAncia-no-acidente-de-comboios-no-namibe/4559078.html)._

**DRAFT: Release notes under construction**

# Introduction

At about three quarters of the planned commitment, this sprint was slightly shorter than usual. Nevertheless, it is still packed with intense work and exciting progress. The "meta-model all things" theme continues in full flow, and we just about reached the next great refactoring battlefront: the ```fabric``` namespaces in the C# and C++ generation models. Predictably, there are not many user facing stories, as the refactoring continues to gather steam.

# User visible changes

This section normally covers stories that affect end users, with the video providing a quick demonstration of the new features. As this sprint had only a very trivial user visible change (discussed below), we took the opportunity to demo a couple of existing features instead.

[![Sprint 1.0.18 Demo](https://img.youtube.com/vi/TkYQTW_jAGk/0.jpg)](https://youtu.be/TkYQTW_jAGk)

## Data directory clean up

For the last few sprints we have been chasing an elusive target: the removal of the assortment of non-model JSON files that have long lived in our ```data``` directory. If nothing else, anything with a name like "data" triggers immediately the "code smells" part of any developer's brain. With this sprint, we have finally achieved this milestone: the text templates that we use in the C++ and C# models have now been moved into the models themselves, with the addition of the text templates meta-modeling elements.

The change gave us the opportunity to rethink the approach from first principles. As a result, the ```data``` directory is no longer, and instead we now have only the ```library``` directory under the Dogen ```shared``` folder. It too will one day cease to exist, when we implement proper support for the PDMs (Platform Description Models) - but for the next three or four sprints it will continue to house the simplified version of the PDMs as they are currently implemented.

# Development Matters

In this section we cover topics that are mainly of interest if you follow Dogen development, such as details on internal stories that consumed significant resources, important events, etc. As usual, for all the gory details of the work carried out this sprint, see the [sprint log](https://github.com/MASD-Project/dogen/blob/master/doc/agile/v1/sprint_backlog_18.org).

## Significant Internal Stories

There were four very significant stories this sprint, which we cover briefly below.

### Use generated static configurations in transforms

 First and foremost, consuming the majority of the sprint's resourcing, was the move towards using code generated static configurations. We started this work when we moved feature templates into the meta-model; it seemed only logical to start code-generating the C++ types to represent the dynamic configurations, as well as the "deserialisation" code that converted dynamic configurations to static configurations.

With this release we removed the majority of the hand-crafted uses of static configurations, making the code more readable. As an added bonus, It also means it's much easier to add new features to the code generator now: simply create a new instance of a ```masd::variability::feature_bundle``` modeling element, and add the required feature templates. While we were at it, we also cleaned up the way bundles were modeled, meaning we now have less boilerplate to add features and bundles are now more logically consistent.

 As an example of how feature bundles are used, here's how we declare the generalisation feature bundle:

```json
    {
      "name": "features::generalization",
      "documentation": "Features related to the generalization relationship.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "tagged_values": {
        "masd.variability.default_binding_point": "element",
        "masd.variability.archetype_location.kernel": "masd",
        "masd.variability.template_kind": "instance"
      },
      "attributes": [
        {
          "name": "masd.generalization.is_final",
          "type": "masd::variability::boolean",
          "documentation": "Whether to mark a type as final or not.\n",
          "tagged_values": {
            "masd.variability.qualified_name": "masd.generalization.is_final",
            "masd.variability.is_optional": "true"
          }
        },
        {
          "name": "masd.generalization.parent",
          "type": "masd::variability::text",
          "documentation": "Name of the parent of the current element.\n",
          "tagged_values": {
            "masd.variability.qualified_name": "masd.generalization.parent",
            "masd.variability.is_optional": "true"
          }
        }
      ]
    },

```

Users then make use of these features in their diagrams:

```
#DOGEN masd.generalization.is_final=true
#DOGEN masd.generalization.parent=some_package::some_type
```

We've already noticed how much quicker the development of new features has been since this new functionality has been added, so this is a great win.

### Make wale templates meta-model elements

As explained above, we have been chasing the "meta-modelisation" of all configuration files that lived in the data directory for a long time. Wale text templates were one of the most annoying cases, because they **really** did not belong in the data directory; after all, text templates are internal to the model that uses them, rather than visible to all users of the code generator.

With this release, we've finished adding support for a logic-less text template meta-modeling element, which represents the text template. We then moved the templates into their respective models, under the new ```templates``` directory. The name logic-less was chosen [to be close to the domain terminology](https://en.wikipedia.org/wiki/Mustache_(template_system)) but it perhaps yet another example of "domain overfitting": it seems it's more a source of confusion rather than enlightenment, as many users (and even domain experts!) are not familiar with the term. We will probably rename it to just "text templates".

![Logic-less templates](https://github.com/MASD-Project/dogen/raw/master/doc/blog/images/logic_less_templates_modeling_elements.png)

Interestingly, _in theory_, this change should have made possible for users to create their own text templates. However, _in practice_, it is of extremely limited value because:

- we do not yet have a stable API for the meta-modeling elements;
- nor do we expose these properly to the templates;
- nor do we have a proper logic-less templating engine such as one of the mustache-like clones that exist in C++.

However, it lays an important foundation for the work to come in this space and, though long in coming, the end goal in the area is now very well defined.

### Rename the ```coding``` model

Ever since we renamed our core model to ```coding``` we've been wondering if this was the right name. We've spent a fair bit of time wading through the literature in search of a fitting name, which would simultaneously reflect the domain terminology of [MDE](https://en.wikipedia.org/wiki/Model-driven_engineering), as well as clarifying our intent. We've finally settled on ```assets```, after reading the most enlightening review article by JM Jézéquel: ["Model-driven engineering for software product lines"](http://downloads.hindawi.com/journals/isrn.software.engineering/2012/670803.pdf).

The new name is also consistent with the fact that we intend to model both products and components within this meta-model, so hopefully the rename is future-proof, and - gasp - final. We have gone through some four or five names since Dogen's inception, so take that with a grain of salt.

### Start of Fabric clean-up

One of the most anticipated tasks has been moving the fabric meta-model elements from the C++ and C# generation models into the assets model (as it is now known). This sprint fired the starting shot in this race: we have addressed the modeling of forward declarations in C++'s fabric. These have now been made consistent with the modeling ideas in Fabric. Sadly, many more items remain: some 15 or so elements need to be re-thought and re-modeled, moved into assets and then all of the associated formatting code needs to be updated.

## Resourcing

As explained on the introduction, we've had around three quarters of the usual resourcing for this sprint, which was not ideal. On the plus side, over 77% of the sprint's total ask was spent on stories directly related to the sprint's mission, and just shy of 18% on process related work - with the release notes and demo consuming over 12% of that. Finally, we spent the remaining ~4% on spikes, mainly related to investigating the (many) test failures we're experiencing on Windows. Sadly no easy answers were to be found, so the investigation continues.

![Story Pie Chart](https://github.com/MASD-Project/dogen/raw/master/doc/agile/v1/sprint_18_pie_chart.jpg)

## Planning

The project plan has suffered a couple of major setbacks this sprint. First, predictably, the fabric clean up was not completed this sprint. In addition, it is now clear it will be much harder than what we had estimated, so its now set to cost us the entirety of the next sprint. In addition, the PDM work is significant and it had not yet been added to the project plan.

The updated plan is now as follows.

![Project Plan](https://github.com/MASD-Project/dogen/raw/master/doc/agile/v1/sprint_18_project_plan.png)

![Resource Allocation Graph](https://github.com/MASD-Project/dogen/raw/master/doc/agile/v1/sprint_18_resource_allocation_graph.png)

# Next Sprint

We shall focus on the Fabric clean-up for the entirety of the next sprint. It is likely that there will be some overrun, but we remain optimistic.

# Binaries

You can download binaries from [Bintray](https://bintray.com/masd-project/main/dogen) for OSX, Linux and Windows (all 64-bit):

- [dogen_1.0.18_amd64-applications.deb](https://dl.bintray.com/masd-project/main/1.0.18/dogen_1.0.18_amd64-applications.deb)
- [dogen-1.0.18-Darwin-x86_64.dmg](https://dl.bintray.com/masd-project/main/1.0.18/DOGEN-1.0.18-Darwin-x86_64.dmg)
- [dogen-1.0.18-Windows-AMD64.msi](https://dl.bintray.com/masd-project/main/DOGEN-1.0.18-Windows-AMD64.msi)

**Note 1**: we've made some slight improvements to the build duration, but in truth we're still desperately close to our 50 minutes allocation on Travis, and as such we're getting many red builds. This is not ideal, so next sprint we will probably need to start disabling some of the generated tests to lower the build times.

**Note 2:** The OSX and Linux binaries are not stripped at present and so are larger than they should be. We have [an outstanding story](https://github.com/MASD-Project/dogen/blob/master/doc/agile/product_backlog.org#linux-and-osx-binaries-are-not-stripped) to address this issue, but sadly CMake does not make this trivial.

For all other architectures and/or operative systems, you will need to build Dogen from source. Source downloads are available below.

Happy Modeling!
#+end_src markdown

- [[https://twitter.com/MarcoCraveiro/status/1135567734010523648][twitter]]
- [[https://www.linkedin.com/feed/update/urn:li:activity:6541333935140458497][linkedin]]
- [[https://gitter.im/MASD-Project/Lobby][Gitter]]

*** COMPLETED Create a demo and presentation for previous sprint      :story:
    CLOSED: [2019-06-03 Mon 12:59]
    :LOGBOOK:
    CLOCK: [2019-06-03 Mon 10:46]--[2019-06-03 Mon 12:25] =>  1:39
    :END:

Time spent creating the demo and presentation.

*** STARTED Sprint and product backlog grooming                       :story:
    :LOGBOOK:
    CLOCK: [2019-06-03 Mon 06:31]--[2019-06-03 Mon 06:46] =>  0:15
    CLOCK: [2019-06-03 Mon 06:21]--[2019-06-03 Mon 06:30] =>  0:09
    :END:

Updates to sprint and product backlog.

*** COMPLETED Remove test model sanitizer                             :story:
    CLOSED: [2019-06-03 Mon 16:51]
    :LOGBOOK:
    CLOCK: [2019-06-03 Mon 16:31]--[2019-06-03 Mon 16:51] =>  0:20
    :END:

We seem to have introduced testing to the reference implementation but
left the canned tests still there. There shouldn't be any reason to
keep these so remove them.

*** COMPLETED Remove master headers                                   :story:
    CLOSED: [2019-06-03 Mon 19:05]
    :LOGBOOK:
    CLOCK: [2019-06-03 Mon 18:49]--[2019-06-03 Mon 19:01] =>  0:12
    CLOCK: [2019-06-03 Mon 18:28]--[2019-06-03 Mon 18:48] =>  0:20
    CLOCK: [2019-06-03 Mon 17:56]--[2019-06-03 Mon 18:12] =>  0:16
    CLOCK: [2019-06-03 Mon 16:52]--[2019-06-03 Mon 17:06] =>  0:14
    :END:

At present we are not making use of this feature, and it could even be
argued that it is not a feature that should be used; by having a
single header that includes all files we encourage unnecessary
inclusion, increasing build times. We had a use for this, which was
related to testing model types, but since we replace that with
generated tests, we no longer required it. Remove this feature.

Notes:

- actually, we left the test model sanitizer. Not clear why.

*** STARTED Move registrar into assets                                :story:
    :LOGBOOK:
    CLOCK: [2019-06-03 Mon 19:34]--[2019-06-03 Mon 19:45] =>  0:11
    CLOCK: [2019-06-03 Mon 19:27]--[2019-06-03 Mon 19:34] =>  0:07
    CLOCK: [2019-06-03 Mon 19:02]--[2019-06-03 Mon 19:26] =>  0:24
    :END:

At present we have a registrar in C++ generation model which is used
to generate the code to register types for boost serialisation. This
principle is fairly universal, and probably all serialisation
technologies will require something of this kind in presence of
inheritance. In addition to this, we have the related notion of
"initialisers". These are used to register types such as:

- formatters
- feature templates

The notion here is that we need to know of a set of related
types. Whilst registration happens at run time, in reality all is
known at compile time and we generate all of the required code up
front. If we attempt to generalise this idea, it seems we have:

- a set of types that need to be registered, according to some
  condition. Examples: the meta-type (feature template, etc), the fact
  that the type is a base class/derived class, etc.
- a class responsible for registration.
- a container of some kind that remembers what was registered. The
  type of the data stored is a parameter. It could be that we want
  pointers to an interface (e.g. formatters) or just remember some
  strings.
- a set of initialisers that talk to the registrar to register the
- there is a top-level class that creates the repository and then
  passes it through to the initialisers to get it populated. Further
  transforms may then be made to the repository.

We should look into registrar terminology to see if all of these
actors have names.

Notes:

- the construction of the type may be non-trivial. We may need to
  supply some arguments, etc. We need to catalogue all of the
  initialisers and see the comonalities.
- bundle initialisers introduced the notion of "scope" whereby an
  initialiser will look for types in the same package and worry only
  about those. Then, a higher level initialiser would call all of the
  lower level initialisers.
- we need to somehow create different initialisers per type or else
  these are going to become too complicated.
- the problem of the serialisation registrar is that, instead of using
  actual data stored in a repository, it works at the template
  level/compule time, with each type being registered against an
  archive. We need to look into the boost serialisation documentation
  and see if there is a way to make the code look a bit more like the
  other instances of this pattern.

*** Windows clang-cl release build is failing 4 tests                 :spike:

This has been going on for a fair bit, and we've ignored it so far but
its a bit annoying. It also makes it likely that we break something
without noticing because we are getting used to seeing red.

The problem started at build [[https://ci.appveyor.com/project/mcraveiro/dogen/builds/23959333/job/r34e67jyjk6s8x66][1771]]. It happened with commit
[[https://github.com/MASD-Project/dogen/commit/2eca4e92de08cd3a84944abc9cf26e7e117e7144][2eca4e92de08cd3a84944abc9cf26e7e117e7144]]. Everything was fine up to
commit [[https://github.com/MASD-Project/dogen/commit/655b56cd32b94b7091e79c4cc76f6a2db5458416][655b56cd32b94b7091e79c4cc76f6a2db5458416]]. However, manually
checking the commits in this interval did not reveal anything obvious.

Failing tests:

- masd.dogen.coding.tests/object_templates_transform_tests/model_with_object_template_that_parents_missing_object_template_throws (Failed)
- masd.dogen.coding.tests/object_templates_transform_tests/model_with_object_that_models_missing_object_template_throws (Failed)
- masd.dogen.coding.tests/object_templates_transform_tests/model_with_object_with_missing_parent_throws (Failed)
- masd.dogen.coding.tests/stereotypes_transform_tests/visitable_object_with_no_leaves_throws (Failed)

All failing tests are related to exceptions that should be thrown. All
work on all other builds (debug and release) except this one,
including MSVC release. However, they were previously working fine on
this build (over 10 successful runs).

Interestingly, on failure we do not seem to get any output at all.

Notes:

- History of builds available [[https://my.cdash.org/index.php?project=MASD+Project+-+Dogen&filtercount=4&showfilters=1&filtercombine=and&field1=site&compare1=61&value1=appveyor&field2=buildname&compare2=61&value2=clang-cl-Windows-AMD64-Release&field3=buildtype&compare3=61&value3=Continuous&field4=buildstarttime&compare4=0&value4=][here]].
- it would be nice to be able to enable debug logging for these tests
  test and have the CI dump the log files into the main build
  log. That is, what we really need is to dump the log to the console
  for a specific set of tests. We could create a different macro that
  does this and manually replace it just for these tests.
- seems like we've managed to fix the clang-cl errors that have been
  traffic-lighting of late. This was a result of the assets changes on
  enumerations, primitives and parsing. Changes are between commits:
  - end: [[https://github.com/MASD-Project/dogen/commit/c629048f0c873f76f576200073ee647acbfbfcea][c629048f0c873f76f576200073ee647acbfbfcea]]
  - start: [[https://github.com/MASD-Project/dogen/commit/166110a944587b0dfb2a53794fd71b504da89065][166110a944587b0dfb2a53794fd71b504da89065]]
- started again with next build. Its traffic lighting, but the pattern
  is not yet obvious.

*** Fix issues with nightly build and CI                              :story:

Time spent fixing build issues with either nightlies and/or CI.

- make space for builds in CDash.

*** Read variability papers                                           :story:

Time spent reading the literature on variability.

*** Element extensions considered harmful                             :story:

When we implemented forward declarations we created them as "element
extensions"; that is, some kind of hack where we'd have two model
elements stuck together (the main model element and its "extension",
the forward declaration). In reality, they are just projections of the
same model element. We need to handle them just as we handle class
header / implementation. We just need to use the formatter specific
postfix to distinguish between files.

The problem with this approach, of course, is that we now need to
create many formatters (per element type). A possible solution is to
factor them out into a formatting helper function that they call. We
still need all of the common machinery to formatters
though. Nevertheless, this is a price worth paying in order to keep
the meta-model simple (e.g. none of the hacks we introduced for
element extensions).

Notes:

- add forward declaration formatters for each type. Create common
  formatting function.
- remove forward declaration element in fabric.
- remove element extensions across the code base. Actually this is not
  possible at present as it is used by ODB options. We need to first
  move them into assets before this can be done.

Merged stories:

*Remove element segmentation*

We need to remove the idea of forward declarations being handled as
"element segmentation". They should just be different facets of the
same elements. There is another story for this which should be merged
with this one.

*Move element segmentation into yarn*

We've added the notion that an element can be composed of other
elements in quilt, in order to handle forward declarations. However,
with a little bit of effort we can generalise it into yarn. It would
be useful for other things such as inner classes. We don't need to
actually implement inner classes right now but we should make sure the
moving of this feature into yarn is compatible with it.

Notes:

- seems like we have two use cases: a) we need all elements, master
  and extensions and we don't really care about which is which. b) we
  only want masters. However, we must be able to access the same
  element properties from either the master or the extension. Having
  said all that, it seems we don't really need all of the element
  properties for both - forward declarations probably only need:
  decoration and artefact properties.
- we don't seem to use the map in formattables model anywhere, other
  than to find master/extension elements.
- Yarn model could have two simple list containers (masters and
  all). Or maybe we don't even need this to start off with, we can
  just iterate and skip extensions where required.
- so in conclusion, we to move decoration, enablement and dependencies
  into yarn (basically decoration and artefact properties) first and
  then see where segmentation ends.

Tasks:

- add a concept for element extensions: =Extensible=. Contains a list
  of element pointers.
- populate it with the extensions.
- change enablement to merge all element properties of extensible
  elements.

*** Validate feature template names                                   :story:

We need to ensure the template names are valid identifiers in C++.

*** Move models into the project directory                            :story:

At present we have a models directory in each component of a
product. However, perhaps it makes more sense to have it as a
subdirectory of the component itself. This is because in an ideal
world, we should create a package for the component with the model and
the header files as well as the SO, allowing users to consume it. In
the Dogen case, it means users can create plugins for Dogen. In the
PDM case, it means users can make use of the PDM in their own models.

However, one downside of this approach is that we then need to have
many directories in the include path for models. If we take the
include headers as an example, there are a small number of directories
in the path:

- compiler specific directories
- =/usr/include=
- ...

Maybe we have two separate issues here:

- when creating a product, where should the models be placed? If we
  keep in mind that models are themselves an asset like any other and
  as such require a meta-model representation, it would be logical to
  keep the model with the component it generates (just like we keep
  the product model within the product it generates). This means for
  instance that we could easily initialise a component via the command
  line and create a "template" blank model (in dia or JSON) with a
  number of things already set. We probably also need a way to avoid
  deleting multiple files (e.g. if we have both a dia and a JSON
  model, we need to know to ignore both of them). This means that when
  building a product we need multiple include directories for models,
  just as we do for headers. This work should be done as part of
  adding products to the asset model because models will be in the
  same namespace. The dia and JSON directories are then the facets for
  the model. This also means that we can now add the targets for
  generation, conversion etc directly into each component. So,
  somewhat paradoxically, when we create a model, we need to have a
  model of the model in it (or maybe two models of the model, Dia and
  JSON). Interestingly, now that we have a model of the model, we can
  suddenly move all of the keys that we have placed at the top-level
  into this modeling element. We can aslo associate it with a profile
  via stereotypes, removing the need for
  =masd.variability.profile=. And if we take it to the next leve, then
  perhaps references are themselves also modeling elements. Its not
  clear if this is an advantage though.
- from a "consumption" perspective, perhaps we could have a single
  =shared/dogen/models= directory, just like we will also place all of
  the PDM's includes under =/usr/include= and the SO's under
  =/usr/lib=. We could split it into Dia and JSON if need be.

*** Emacs maintenance and exploration work                            :story:

Any time spent improving emacs, exploring new modes, fixing snags,
etc.

- add support for indent guides. [[https://github.com/DarthFennec/highlight-indent-guides][highlight-indent-guides]], [[https://stackoverflow.com/questions/1587972/how-to-display-indentation-guides-in-emacs/56144459#56144459][SO question]].
- treemacs issues: when blank type g to refresh.
- lsp seems to update with every character we type. It would be nice
  to update on save only.

** Deprecated
