#+title: Sprint Backlog 68
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- Implement as many formatters as possible using the new cpp
  architecture.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75
#+CAPTION: Clock summary at [2015-06-09 Tue 20:57]
| <75>                                                                        |        |      |      |
| Headline                                                                    | Time   |      |      |
|-----------------------------------------------------------------------------+--------+------+------|
| *Total time*                                                                | *5:25* |      |      |
|-----------------------------------------------------------------------------+--------+------+------|
| Stories                                                                     | 5:25   |      |      |
| Active                                                                      |        | 5:25 |      |
| STARTED Sprint and product backlog grooming                                 |        |      | 0:17 |
| STARTED Implement class implementation formatter using stitch               |        |      | 5:08 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-06-09 Tue 20:45]--[2015-06-09 Tue 20:54] =>  0:09
    CLOCK: [2015-06-08 Mon 18:01]--[2015-06-08 Mon 18:09] =>  0:08

Updates to sprint and product backlog.

*** Updates to the manual and readme files                            :story:

Use downtime to update the manual and / or readme file.

*** STARTED Implement class implementation formatter using stitch     :story:
    CLOCK: [2015-06-09 Tue 20:54]--[2015-06-09 Tue 20:57] =>  0:03
    CLOCK: [2015-06-09 Tue 20:37]--[2015-06-09 Tue 20:45] =>  0:08
    CLOCK: [2015-06-09 Tue 20:06]--[2015-06-09 Tue 20:35] =>  0:29
    CLOCK: [2015-06-09 Tue 18:52]--[2015-06-09 Tue 20:05] =>  1:13
    CLOCK: [2015-06-09 Tue 17:36]--[2015-06-09 Tue 18:08] =>  0:32
    CLOCK: [2015-06-09 Tue 16:52]--[2015-06-09 Tue 17:35] =>  0:43
    CLOCK: [2015-06-09 Tue 16:13]--[2015-06-09 Tue 16:32] =>  0:19
    CLOCK: [2015-06-09 Tue 16:04]--[2015-06-09 Tue 16:12] =>  0:08
    CLOCK: [2015-06-09 Tue 15:09]--[2015-06-09 Tue 16:03] =>  0:54
    CLOCK: [2015-06-09 Tue 14:30]--[2015-06-09 Tue 15:09] =>  0:39

We need to implement a stitch template for the class
implementation formatter in types, plug it in and start working
through the diffs.

Problems to solve:

- includes will fail on stream manipulators. This is because we need
  to check if we require them when generating dependencies, but we
  have to do so manually since the class info doesn't exist yet. We
  need to hack this for now - once we have "field gathering" support
  this will be easier. Actually we can't hack it as such - we need to
  traverse the nested types info in SML. It may be easier to implement
  it properly.

Solved problems:

- we need family back to determine what helpers to generate from the
  properties. Hack is fine for now.
- no includes and no space after includes.
- float property with too mnay close brackets:

: -      float_property_(float_property) { }
: +      float_property_(float_property)) { }

- no swap, equality, assignment, getters and setters
- legacy incorrectly includes io of parents in types. Remove
  it. Actually this is more complicated than that. There is a mistake:
  we are including the io header of the parent when in reality we
  don't need io support for the parent, because we rely on
  =to_stream=. However, we still need to include the io headers for
  all other relationships when in presence of inheritance. Its easier
  to add the parent as well for now since we need to add the other
  ones too.
- inserter is still not quite right; we need to know if in a class or
  not. Since we do, move the whole nonsense of method name etc into
  helper template.
- remove needle includes.

*** Add support for "field gathering"                                 :story:

We need to add support in dynamic and SML for the "gathering" of
fields; this consists in marking a field as "gatherable" in the
JSON. We then need to find all types that have that field and gather
their qnames in the model.

Note: we do not need to handle inclusion_required this way; it already
works well so leave it as is.

Tasks:

- find a good name for gathering and gatherable.
- add support in dynamic for marking fields as gatherable. Add a
  method in field definition repository that returns a list of all
  gatherable fields.
- mark all required fields as gatherable.
- add a container of string (qualified field name) to qname in model,
  with a suggestive name (qnames by dynamic field? gathered qnames?).
- create an SML class to process all gathered fields: obtain fields
  that are gatherable, then loop through the model; for all types that
  have gatherable fields, add them to container against the field.
- implement transformer in terms of gathered fields (i.e. consult the
  container for requires_stream_manipulators, etc).

** Deprecated
