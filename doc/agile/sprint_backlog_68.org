#+title: Sprint Backlog 68
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- Implement as many formatters as possible using the new cpp
  architecture.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75
#+CAPTION: Clock summary at [2015-06-11 Thu 08:30]
| <75>                                                                        |         |       |      |
| Headline                                                                    | Time    |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                                | *13:00* |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| Stories                                                                     | 13:00   |       |      |
| Active                                                                      |         | 13:00 |      |
| STARTED Sprint and product backlog grooming                                 |         |       | 1:27 |
| STARTED Implement class implementation formatter using stitch               |         |       | 8:51 |
| COMPLETED Add helper methods for equals operator                            |         |       | 0:44 |
| CANCELLED Add support for "field gathering"                                 |         |       | 0:56 |
| COMPLETED Hack inclusion to take into account stream manipulation           |         |       | 1:02 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-06-11 Thu 07:38]--[2015-06-11 Thu 07:45] =>  0:07
    CLOCK: [2015-06-10 Wed 15:30]--[2015-06-10 Wed 15:40] =>  0:10
    CLOCK: [2015-06-10 Wed 14:32]--[2015-06-10 Wed 15:25] =>  0:53
    CLOCK: [2015-06-09 Tue 20:45]--[2015-06-09 Tue 20:54] =>  0:09
    CLOCK: [2015-06-08 Mon 18:01]--[2015-06-08 Mon 18:09] =>  0:08

Updates to sprint and product backlog.

*** Updates to the manual and readme files                            :story:

Use downtime to update the manual and / or readme file.

*** STARTED Implement class implementation formatter using stitch     :story:
    CLOCK: [2015-06-10 Wed 22:38]--[2015-06-10 Wed 22:54] =>  0:16
    CLOCK: [2015-06-10 Wed 21:46]--[2015-06-10 Wed 22:37] =>  0:51
    CLOCK: [2015-06-10 Wed 21:25]--[2015-06-10 Wed 21:45] =>  0:20
    CLOCK: [2015-06-10 Wed 21:14]--[2015-06-10 Wed 21:24] =>  0:10
    CLOCK: [2015-06-10 Wed 18:14]--[2015-06-10 Wed 18:55] =>  0:41
    CLOCK: [2015-06-10 Wed 18:07]--[2015-06-10 Wed 18:13] =>  0:06
    CLOCK: [2015-06-10 Wed 17:35]--[2015-06-10 Wed 18:06] =>  0:31
    CLOCK: [2015-06-10 Wed 17:22]--[2015-06-10 Wed 17:33] =>  0:11
    CLOCK: [2015-06-10 Wed 16:44]--[2015-06-10 Wed 17:21] =>  0:37
    CLOCK: [2015-06-09 Tue 20:54]--[2015-06-09 Tue 20:57] =>  0:03
    CLOCK: [2015-06-09 Tue 20:37]--[2015-06-09 Tue 20:45] =>  0:08
    CLOCK: [2015-06-09 Tue 20:06]--[2015-06-09 Tue 20:35] =>  0:29
    CLOCK: [2015-06-09 Tue 18:52]--[2015-06-09 Tue 20:05] =>  1:13
    CLOCK: [2015-06-09 Tue 17:36]--[2015-06-09 Tue 18:08] =>  0:32
    CLOCK: [2015-06-09 Tue 16:52]--[2015-06-09 Tue 17:35] =>  0:43
    CLOCK: [2015-06-09 Tue 16:13]--[2015-06-09 Tue 16:32] =>  0:19
    CLOCK: [2015-06-09 Tue 16:04]--[2015-06-09 Tue 16:12] =>  0:08
    CLOCK: [2015-06-09 Tue 15:09]--[2015-06-09 Tue 16:03] =>  0:54
    CLOCK: [2015-06-09 Tue 14:30]--[2015-06-09 Tue 15:09] =>  0:39

We need to implement a stitch template for the class
implementation formatter in types, plug it in and start working
through the diffs.

Problems to solve:

- missing includes for smart pointers even though we have weak
  relationships.
- borked models: boost.

Solved problems:

- we need family back to determine what helpers to generate from the
  properties. Hack is fine for now.
- no includes and no space after includes.
- float property with too mnay close brackets:

: -      float_property_(float_property) { }
: +      float_property_(float_property)) { }

- no swap, equality, assignment, getters and setters
- legacy incorrectly includes io of parents in types. Remove
  it. Actually this is more complicated than that. There is a mistake:
  we are including the io header of the parent when in reality we
  don't need io support for the parent, because we rely on
  =to_stream=. However, we still need to include the io headers for
  all other relationships when in presence of inheritance. Its easier
  to add the parent as well for now since we need to add the other
  ones too.
- inserter is still not quite right; we need to know if in a class or
  not. Since we do, move the whole nonsense of method name etc into
  helper template.
- remove needle includes.
- includes will fail on stream manipulators. This is because we need
  to check if we require them when generating dependencies, but we
  have to do so manually since the class info doesn't exist yet. We
  need to hack this for now - once we have "field gathering" support
  this will be easier. Actually we can't hack it as such - we need to
  traverse the nested types info in SML. It may be easier to implement
  it properly.
- enumerations are using by ref.
- bugs in default constructor
- streaming borked in a couple of places.
- spurious blank lines: this is actually a very tricky problem, due to
  the fact that we are using "managed" blank lines in the indent
  filter. It is suppressing blank lines. We can't switch this off
  altogether as it generates other diffs in boilerplate. Height of
  insanity. Also, we can't quickly fix the legacy formatters because we
  need to know if the helper method is the first one and if so, skip
  blank line. A hack around this may be the only solution. A number of
  stories were raised to deal with the evilness of indentation
  "management" in templates.
- if string, we need to include =<boost/algorithm/string.hpp>=. same
  hack as streaming. Actually this problem will keep on
  reoccurring. We need a hack that takes into account all of the known
  "special" includes (variant, pair, etc). We already have a good
  solution for this in the backlog so for now we can do the quickest
  possible hack which is to compute all of these in the builder and
  return it as a type. All this logic already exists in extractor and
  could be lifted.
- more inserter breakage in stereotypes model.
- missing operator== helper methods.

*** COMPLETED Add helper methods for equals operator                  :story:
    CLOSED: [2015-06-11 Thu 08:29]
    CLOCK: [2015-06-11 Thu 07:45]--[2015-06-11 Thu 08:29] =>  0:44

We need to generate equals operators in the same fashion as we
generated inserters. Add it to types.

*** CANCELLED Add support for "field gathering"                       :story:
    CLOSED: [2015-06-10 Wed 15:24]
    CLOCK: [2015-06-10 Wed 13:35]--[2015-06-10 Wed 14:31] =>  0:56

We need to add support in dynamic and SML for the "gathering" of
fields; this consists in marking a field as "gatherable" in the
JSON. We then need to find all types that have that field and gather
their qnames in the model.

Note: we do not need to handle =inclusion_required= this way; it
already works well so leave it as is.

Tasks:

- find a good name for gathering and gatherable.
- add support in dynamic for marking fields as gatherable. Add a
  method in field definition repository that returns a list of all
  gatherable fields.
- mark all required fields as gatherable.
- add a container of string (qualified field name) to qname in model,
  with a suggestive name (qnames by dynamic field? gathered qnames?).
- create an SML class to process all gathered fields: obtain fields
  that are gatherable, then loop through the model; for all types that
  have gatherable fields, add them to container against the field.
- implement transformer in terms of gathered fields (i.e. consult the
  container for requires_stream_manipulators, etc).

More notes on this:

- actually this is not a good idea. In reality, this is a variation of
  the "enabled" problem. What we really need is a generic solution for
  this and that will take a lot of thinking.
- we need to define various relations that are possible in models: a)
  association: inheritance + aggregation b) inheritance c)
  aggregation etc. Each relation has a graph that is a set of ordered
  pairs of types (a, b). For example aggregation in SML would contain
  the pair (sml::model, sml::object). Actually it is not even _that_
  straightforward since model has a container of object. But this is
  the gist.
- we then need to define certain functions over these relations. For
  example, if =requires_stream_manipulators= is true for b and if a
  aggregates b then =requires_stream_manipulators= is also true for
  a. Then it becomes obvious that there are two "kinds" of functions,
  those where a single "step" is "transitive" and those where any
  number of steps - provided that there is a path - are
  "transitive". Enabled is one such function.
- all of this is really complicated. We need to find someone who
  understands maths properly to express these concepts correctly.
- we need to raise a story with all of the use cases for this and
  converts them to a more maths like view of the world.

For now we should simply hack this by copying the logic in transformer
to the includer.

*** COMPLETED Hack inclusion to take into account stream manipulation :story:
    CLOSED: [2015-06-10 Wed 16:43]
    CLOCK: [2015-06-10 Wed 15:40]--[2015-06-10 Wed 16:42] =>  1:02

We need to copy the logic in transformer to see if a type needs stream
manipulator includes or not.

** Deprecated
*** CANCELLED Indent stream can be made a bit less inefficient        :story:
    CLOSED: [2015-06-10 Wed 18:52]

*Rationale*: manual indentation in templates is considered evil. It
had a large amount of complexity and it never quite works
properly. All indentation will be left to clang format.

Out first attempt at creating a stream with indentation support was a
bit naive: we are intercepting every character and then deciding if we
need to change any states in the state machine. Its probably wiser to
just use manipulators to perform the state transitions and leave the
=put= undisturbed. We can leave this until we have a good way of
getting metrics out of the system.

Actually we should also decide if indent stream is needed at all in a
stitch world.

It was shown that indent streams are useful for at least one use case:
for comments.

*** CANCELLED Consider creating an iostreams filter for comments      :story:
    CLOSED: [2015-06-10 Wed 18:53]

*Rationale*: in a world of templates this filtering streams add very
little value and make life more complicated.

Seems logic to follow the filtering idea and add a doxygen (or
generic) commenting filter; one inserts into the stream and it
automatically inserts all the comment markers such as =/**=, =@brief=
and so on. Basically takes on the work of =comment_formatter=. This
would mean we would no longer need the =contents= vector, and we could
stream directly to the stream, after pushing the comments formatter on
to it. However, it would probably mean we need to cast the stream to a
=filtering_ostream= in order to do the push.
