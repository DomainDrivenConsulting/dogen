#+title: Sprint Backlog 68
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- Implement as many formatters as possible using the new cpp
  architecture.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75
#+CAPTION: Clock summary at [2015-06-15 Mon 18:10]
| <75>                                                                        |         |       |       |
| Headline                                                                    | Time    |       |       |
|-----------------------------------------------------------------------------+---------+-------+-------|
| *Total time*                                                                | *23:52* |       |       |
|-----------------------------------------------------------------------------+---------+-------+-------|
| Stories                                                                     | 23:52   |       |       |
| Active                                                                      |         | 23:52 |       |
| STARTED Sprint and product backlog grooming                                 |         |       |  2:07 |
| COMPLETED Implement class implementation formatter using stitch             |         |       | 10:02 |
| COMPLETED Add helper methods for equals operator                            |         |       |  0:44 |
| CANCELLED Add support for "field gathering"                                 |         |       |  0:56 |
| COMPLETED Hack inclusion to take into account stream manipulation           |         |       |  1:02 |
| COMPLETED Inclusion relies on knowing sml to cpp mapping                    |         |       |  0:23 |
| COMPLETED Implement class header formatter in hash                          |         |       |  0:51 |
| COMPLETED Fix borked builds due to formatter differences                    |         |       |  2:40 |
| COMPLETED Stitch gcc release builds are borked                              |         |       |  0:28 |
| COMPLETED Do we use =formatter_types=?                                      |         |       |  0:08 |
| STARTED Implement class header implementation in hash                       |         |       |  4:31 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-06-11 Thu 21:56]--[2015-06-11 Thu 22:36] =>  0:40
    CLOCK: [2015-06-11 Thu 07:38]--[2015-06-11 Thu 07:45] =>  0:07
    CLOCK: [2015-06-10 Wed 15:30]--[2015-06-10 Wed 15:40] =>  0:10
    CLOCK: [2015-06-10 Wed 14:32]--[2015-06-10 Wed 15:25] =>  0:53
    CLOCK: [2015-06-09 Tue 20:45]--[2015-06-09 Tue 20:54] =>  0:09
    CLOCK: [2015-06-08 Mon 18:01]--[2015-06-08 Mon 18:09] =>  0:08

Updates to sprint and product backlog.

- Backlog reviewed up to "In next major release".

*** Updates to the manual and readme files                            :story:

Use downtime to update the manual and / or readme file.

*** COMPLETED Implement class implementation formatter using stitch   :story:
    CLOSED: [2015-06-11 Thu 21:31]
    CLOCK: [2015-06-11 Thu 20:59]--[2015-06-11 Thu 21:31] =>  0:32
    CLOCK: [2015-06-11 Thu 18:52]--[2015-06-11 Thu 19:08] =>  0:16
    CLOCK: [2015-06-11 Thu 18:28]--[2015-06-11 Thu 18:51] =>  0:23
    CLOCK: [2015-06-10 Wed 22:38]--[2015-06-10 Wed 22:54] =>  0:16
    CLOCK: [2015-06-10 Wed 21:46]--[2015-06-10 Wed 22:37] =>  0:51
    CLOCK: [2015-06-10 Wed 21:25]--[2015-06-10 Wed 21:45] =>  0:20
    CLOCK: [2015-06-10 Wed 21:14]--[2015-06-10 Wed 21:24] =>  0:10
    CLOCK: [2015-06-10 Wed 18:14]--[2015-06-10 Wed 18:55] =>  0:41
    CLOCK: [2015-06-10 Wed 18:07]--[2015-06-10 Wed 18:13] =>  0:06
    CLOCK: [2015-06-10 Wed 17:35]--[2015-06-10 Wed 18:06] =>  0:31
    CLOCK: [2015-06-10 Wed 17:22]--[2015-06-10 Wed 17:33] =>  0:11
    CLOCK: [2015-06-10 Wed 16:44]--[2015-06-10 Wed 17:21] =>  0:37
    CLOCK: [2015-06-09 Tue 20:54]--[2015-06-09 Tue 20:57] =>  0:03
    CLOCK: [2015-06-09 Tue 20:37]--[2015-06-09 Tue 20:45] =>  0:08
    CLOCK: [2015-06-09 Tue 20:06]--[2015-06-09 Tue 20:35] =>  0:29
    CLOCK: [2015-06-09 Tue 18:52]--[2015-06-09 Tue 20:05] =>  1:13
    CLOCK: [2015-06-09 Tue 17:36]--[2015-06-09 Tue 18:08] =>  0:32
    CLOCK: [2015-06-09 Tue 16:52]--[2015-06-09 Tue 17:35] =>  0:43
    CLOCK: [2015-06-09 Tue 16:13]--[2015-06-09 Tue 16:32] =>  0:19
    CLOCK: [2015-06-09 Tue 16:04]--[2015-06-09 Tue 16:12] =>  0:08
    CLOCK: [2015-06-09 Tue 15:09]--[2015-06-09 Tue 16:03] =>  0:54
    CLOCK: [2015-06-09 Tue 14:30]--[2015-06-09 Tue 15:09] =>  0:39

We need to implement a stitch template for the class
implementation formatter in types, plug it in and start working
through the diffs.

Problems to solve:

- extra spaces in cpp model and incorrect inserter.

Solved problems:

- we need family back to determine what helpers to generate from the
  properties. Hack is fine for now.
- no includes and no space after includes.
- float property with too mnay close brackets:

: -      float_property_(float_property) { }
: +      float_property_(float_property)) { }

- no swap, equality, assignment, getters and setters
- legacy incorrectly includes io of parents in types. Remove
  it. Actually this is more complicated than that. There is a mistake:
  we are including the io header of the parent when in reality we
  don't need io support for the parent, because we rely on
  =to_stream=. However, we still need to include the io headers for
  all other relationships when in presence of inheritance. Its easier
  to add the parent as well for now since we need to add the other
  ones too.
- inserter is still not quite right; we need to know if in a class or
  not. Since we do, move the whole nonsense of method name etc into
  helper template.
- remove needle includes.
- includes will fail on stream manipulators. This is because we need
  to check if we require them when generating dependencies, but we
  have to do so manually since the class info doesn't exist yet. We
  need to hack this for now - once we have "field gathering" support
  this will be easier. Actually we can't hack it as such - we need to
  traverse the nested types info in SML. It may be easier to implement
  it properly.
- enumerations are using by ref.
- bugs in default constructor
- streaming borked in a couple of places.
- spurious blank lines: this is actually a very tricky problem, due to
  the fact that we are using "managed" blank lines in the indent
  filter. It is suppressing blank lines. We can't switch this off
  altogether as it generates other diffs in boilerplate. Height of
  insanity. Also, we can't quickly fix the legacy formatters because we
  need to know if the helper method is the first one and if so, skip
  blank line. A hack around this may be the only solution. A number of
  stories were raised to deal with the evilness of indentation
  "management" in templates.
- if string, we need to include =<boost/algorithm/string.hpp>=. same
  hack as streaming. Actually this problem will keep on
  reoccurring. We need a hack that takes into account all of the known
  "special" includes (variant, pair, etc). We already have a good
  solution for this in the backlog so for now we can do the quickest
  possible hack which is to compute all of these in the builder and
  return it as a type. All this logic already exists in extractor and
  could be lifted.
- more inserter breakage in stereotypes model.
- missing operator== helper methods.
- missing includes for smart pointers even though we have weak
  relationships.

*** COMPLETED Add helper methods for equals operator                  :story:
    CLOSED: [2015-06-11 Thu 08:29]
    CLOCK: [2015-06-11 Thu 07:45]--[2015-06-11 Thu 08:29] =>  0:44

We need to generate equals operators in the same fashion as we
generated inserters. Add it to types.

*** CANCELLED Add support for "field gathering"                       :story:
    CLOSED: [2015-06-10 Wed 15:24]
    CLOCK: [2015-06-10 Wed 13:35]--[2015-06-10 Wed 14:31] =>  0:56

We need to add support in dynamic and SML for the "gathering" of
fields; this consists in marking a field as "gatherable" in the
JSON. We then need to find all types that have that field and gather
their qnames in the model.

Note: we do not need to handle =inclusion_required= this way; it
already works well so leave it as is.

Tasks:

- find a good name for gathering and gatherable.
- add support in dynamic for marking fields as gatherable. Add a
  method in field definition repository that returns a list of all
  gatherable fields.
- mark all required fields as gatherable.
- add a container of string (qualified field name) to qname in model,
  with a suggestive name (qnames by dynamic field? gathered qnames?).
- create an SML class to process all gathered fields: obtain fields
  that are gatherable, then loop through the model; for all types that
  have gatherable fields, add them to container against the field.
- implement transformer in terms of gathered fields (i.e. consult the
  container for requires_stream_manipulators, etc).

More notes on this:

- actually this is not a good idea. In reality, this is a variation of
  the "enabled" problem. What we really need is a generic solution for
  this and that will take a lot of thinking.
- we need to define various relations that are possible in models: a)
  association: inheritance + aggregation b) inheritance c)
  aggregation etc. Each relation has a graph that is a set of ordered
  pairs of types (a, b). For example aggregation in SML would contain
  the pair (sml::model, sml::object). Actually it is not even _that_
  straightforward since model has a container of object. But this is
  the gist.
- we then need to define certain functions over these relations. For
  example, if =requires_stream_manipulators= is true for b and if a
  aggregates b then =requires_stream_manipulators= is also true for
  a. Then it becomes obvious that there are two "kinds" of functions,
  those where a single "step" is "transitive" and those where any
  number of steps - provided that there is a path - are
  "transitive". Enabled is one such function.
- all of this is really complicated. We need to find someone who
  understands maths properly to express these concepts correctly.
- we need to raise a story with all of the use cases for this and
  converts them to a more maths like view of the world.

For now we should simply hack this by copying the logic in transformer
to the includer.

*** COMPLETED Hack inclusion to take into account stream manipulation :story:
    CLOSED: [2015-06-10 Wed 16:43]
    CLOCK: [2015-06-10 Wed 15:40]--[2015-06-10 Wed 16:42] =>  1:02

We need to copy the logic in transformer to see if a type needs stream
manipulator includes or not.

*** COMPLETED Inclusion relies on knowing sml to cpp mapping          :story:
    CLOSED: [2015-06-11 Thu 21:55]
    CLOCK: [2015-06-11 Thu 21:32]--[2015-06-11 Thu 21:55] =>  0:23

At present we are including types based on what we think the formatter
is. For example, we can take a random qname that is part of regular
associations and ask for its class header formatter name whenever we
want to include its definition. However, this is not correct; this
type could be an enumeration for instance, in which case we should
have asked for the enum header formatter and so the include will not
be found.

It is not clear why we got away with it up til now. In the types
header, whenever we try to include all regular associations of a
class, we should have failed to find anything other than classes so
=std_model= and =enumeration= should both be broken as they rely on
primitives and enumerations respectively. Since they have managed to
find an include, this must mean that we are generating a class header
formatter include even for types which are not classes.

We need to investigate why this has worked so far and find a proper
solution.

The reason why this works is because we are generating all possible
includes for all possible formatters. And since a class header
formatter produces the same include file as does a enumeration header
formatter it all works. We probably need a better solution but it will
require quite a bit of thinking. Story added to backlog.

*** COMPLETED Consider dropping the prefix inclusion in formattables  :story:
    CLOSED: [2015-06-11 Thu 22:01]

*Rationale*: Considered, but we need to keep it. The names just don't
make any sense without it.

*New Understanding*

The problem with this is that "directive" does not have any
meaning. We could get away with dependencies, but directive is very
open ended. We cannot start changing meta-data keys (e.g. =directive=
instead of =inclusion_directive=) because that would confuse users; so
we would end up with two names in two different places, probably even
more confusing.

*Previous Understanding*

At present we have really long class names because they all need
"inclusion" on the name. In reality, we have two concepts:

- directives
- dependencies

We don't need the prefix "inclusion" to make these understandable. We
can probably get away with removing it from all of the expansion
classes without significant loss of meaning.

*** COMPLETED Consider renaming path derivatives                      :story:
    CLOSED: [2015-06-11 Thu 22:03]

*Rationale*: Considered, but since we now have a clear separation
between settings (stuff read off of the meta-data) and formattables
(stuff generated from somewhere) this is no longer as important.

We should have a name that implies that all fields of this class were
obtained by "computation", rather than reading it from somewhere.

*** COMPLETED Implement class header formatter in hash                :story:
    CLOSED: [2015-06-12 Fri 11:52]
    CLOCK: [2015-06-12 Fri 11:01]--[2015-06-12 Fri 11:52] =>  0:51

Create the formatter, stitch template and all associated
machinery. Fix all differences.

Solved problems:

- we seem to have hash enabled even when the facet has been disabled
  from the command line. Enablement computations must be wrong.

*** COMPLETED Fix borked builds due to formatter differences          :story:
    CLOSED: [2015-06-12 Fri 20:55]
    CLOCK: [2015-06-12 Fri 20:25]--[2015-06-12 Fri 20:55] =>  0:30
    CLOCK: [2015-06-12 Fri 15:10]--[2015-06-12 Fri 17:07] =>  1:57
    CLOCK: [2015-06-12 Fri 13:50]--[2015-06-12 Fri 14:03] =>  0:13

All our builds except for the local build are failing since we put the
types implementation formatter in. The diff is:

: --- /home/ctest/build/Continuous/dogen/debian-testing-i686-gcc-4.7/build/stage/bin/../test_data/all_primitives/expected/all_primitives/src/types/a_class.cpp	2015-06-07 09:19:04.000000000 +0100
: +++ /home/ctest/build/Continuous/dogen/debian-testing-i686-gcc-4.7/build/stage/bin/../test_data/all_primitives/actual/all_primitives/src/types/a_class.cpp	2015-06-12 06:32:15.667923782 +0100
: @@ -53,7 +53,7 @@
:      const unsigned short ushort_property,
:      const double double_property,
:      const float float_property)
: -    : bool_property_(bool_property),
: +      bool_property_(bool_property),
:        char_property_(char_property),
:        uchar_property_(uchar_property),
:        int_property_(int_property),
: @@ -85,7 +85,7 @@
:  }
:
:  bool a_class::operator==(const a_class& rhs) const {
: -    return bool_property_ == rhs.bool_property_ &&
: +        bool_property_ == rhs.bool_property_ &&
:          char_property_ == rhs.char_property_ &&
:          uchar_property_ == rhs.uchar_property_ &&
:          int_property_ == rhs.int_property_ &&

The problem is specific to gcc on all platforms - works fine with
clang. It is also in multiple versions of gcc.

The problem is reordering of instructions. We basically can't do a
mutable postfix because we may end up evaluating the postfix before
the prefix.

*** COMPLETED Stitch gcc release builds are borked                    :spike:
    CLOSED: [2015-06-12 Fri 21:24]
    CLOCK: [2015-06-12 Fri 20:55]--[2015-06-12 Fri 21:23] =>  0:28

When running stitch for a gcc release build we get:

: FAILED: cd /home/marco/Development/DomainDrivenConsulting/output/dogen/gcc-4.9 && /home/marco/Development/DomainDrivenConsulting/output/dogen/gcc-4.9/stage/bin/dogen_stitcher --target /home/marco/Development/DomainDrivenConsulting/dogen/projects/cpp/src/ --verbose

Debug builds work. All builds work for clang. According to gdb:

: #0  0x00000000004cb36e in std::_Hashtable<std::string, std::pair<std::string const, dogen::dynamic::schema::field_definition>, std::allocator<std::pair<std::string const, dogen::dynamic::schema::field_definition> >, std::__detail::_Select1st, std::equal_to<std::string>, std::hash<std::string>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::find(std::string const&) const ()
: #1  0x00000000004c96bd in dogen::dynamic::schema::workflow::obtain_field_definition(std::string const&) const ()
: #2  0x00000000004ca24b in dogen::dynamic::schema::workflow::create_fields_activity(std::unordered_map<std::string, std::list<std::string, std::allocator<std::string> >, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, std::list<std::string, std::allocator<std::string> > > > > const&, dogen::dynamic::schema::scope_types) const ()

This was a comedy of errors:

- constructor in dynamic workflow was not marked as explicit;
- compiler created a temporary workflow off of the repository and
  passed it in;
- temporary went away in gcc and caused crash.

*** COMPLETED Do we use =formatter_types=?                            :story:
    CLOSED: [2015-06-13 Sat 07:09]
    CLOCK: [2015-06-13 Sat 07:01]--[2015-06-13 Sat 07:09] =>  0:08

We need to figure out if we need this enumeration in =cpp::formatters=
and if not remove it.

*** STARTED Implement class header implementation in hash             :story:
    CLOCK: [2015-06-15 Mon 18:03]--[2015-06-15 Mon 18:10] =>  0:07
    CLOCK: [2015-06-15 Mon 17:55]--[2015-06-15 Mon 18:02] =>  0:07
    CLOCK: [2015-06-15 Mon 17:26]--[2015-06-15 Mon 17:55] =>  0:29
    CLOCK: [2015-06-15 Mon 16:02]--[2015-06-15 Mon 17:25] =>  1:23
    CLOCK: [2015-06-15 Mon 15:35]--[2015-06-15 Mon 16:00] =>  0:25
    CLOCK: [2015-06-14 Sun 13:29]--[2015-06-14 Sun 13:41] =>  0:12
    CLOCK: [2015-06-14 Sun 12:35]--[2015-06-14 Sun 12:45] =>  0:10
    CLOCK: [2015-06-14 Sun 11:32]--[2015-06-14 Sun 12:21] =>  0:49
    CLOCK: [2015-06-13 Sat 21:00]--[2015-06-13 Sat 21:41] =>  0:41
    CLOCK: [2015-06-13 Sat 07:11]--[2015-06-13 Sat 07:19] =>  0:08

Create the formatter, stitch template and all associated
machinery. Fix all differences.

Solved Problems:

- no inclusion for parent or members
- hash of path now requires helper. we were generating helper
  previously but it seems we were not using it. Best to just remove
  helper in legacy and see what breaks. Actually this is not quite
  right; we were using it, it was just placed in the wrong
  namespace. The problem is the helpers should not be in namespaces.
- hash combine has incorrect indentation on open bracket and no space
  between =&v=.
- other helpers have no space before open bracket.

*** Remove intermediate fields from dynamic                           :story:

With the previous approach we had fields in dynamic that were
generated within dogen; we now should only have fields that are set
from the outside world. Remove all of the fields that are not supposed
to be settable from the outside world. At present this just file path.

** Deprecated
*** CANCELLED Indent stream can be made a bit less inefficient        :story:
    CLOSED: [2015-06-10 Wed 18:52]

*Rationale*: manual indentation in templates is considered evil. It
had a large amount of complexity and it never quite works
properly. All indentation will be left to clang format.

Out first attempt at creating a stream with indentation support was a
bit naive: we are intercepting every character and then deciding if we
need to change any states in the state machine. Its probably wiser to
just use manipulators to perform the state transitions and leave the
=put= undisturbed. We can leave this until we have a good way of
getting metrics out of the system.

Actually we should also decide if indent stream is needed at all in a
stitch world.

It was shown that indent streams are useful for at least one use case:
for comments.

*** CANCELLED Consider creating an iostreams filter for comments      :story:
    CLOSED: [2015-06-10 Wed 18:53]

*Rationale*: in a world of templates this filtering streams add very
little value and make life more complicated.

Seems logic to follow the filtering idea and add a doxygen (or
generic) commenting filter; one inserts into the stream and it
automatically inserts all the comment markers such as =/**=, =@brief=
and so on. Basically takes on the work of =comment_formatter=. This
would mean we would no longer need the =contents= vector, and we could
stream directly to the stream, after pushing the comments formatter on
to it. However, it would probably mean we need to cast the stream to a
=filtering_ostream= in order to do the push.
*** CANCELLED Implement options copier and remove options from context :story:
    CLOSED: [2015-06-11 Thu 22:00]

*Rationale*: does not make sense in a non-expansion world.

At present the path derivatives expander is getting access to the C++
options via the expansion context. This was obviously a temporary hack
to get things moving. The right thing must surely be to add the root
object to the context, and to read the options from the root
object. These for now must be populated via the options copier; in the
future one can imagine that users define them in diagrams.

Actually, the directories supplied to dogen do need to be command line
options. This is because they tend to be created by CMake on the fly
as absolute paths and as such cannot be hard-coded into the
diagram. This being the case, perhaps we should just supply the
knitting options to the expansion context. This does mean that now
expansion is a knitting thing - it could have been used by
stitch. Needs a bit more thinking.

*Tasks to read options from root object*

Not yet clear this is the right solution, but if it is, this is what
needs to be done.

- check that we have all the required fields in JSON for all of the
  c++ options we require for now.
- update options copier to copy these options. In many cases we will
  have to "redirect" the option. For example, =domain_facet_folder=
  becomes the types directory and so forth. Having said that we
  probably won't need these for now.
- remove options from context, and add root object instead. We may
  need to do the usual "locate root object" routine.
- update the path settings factory to read these from the root object.
- add options to type settings where it makes sense (e.g. disable
  complete constructor) and implement the type settings factory.
*** CANCELLED Move sorting of includes into utility                   :story:
    CLOSED: [2015-06-11 Thu 22:07]

*Rationale*: no point now when we are almost about to finish
converting types to the new world.

When we implemented the sorting of includes we added it directly to
=cpp_formatters= and to =inclusion_dependency_factory=, copy and
paste. Maybe we should move this to utility, even if we are only using
it temporarily, to avoid having problems when the code gets out of sync.

*** CANCELLED Populate the "new" =class_info= properties              :story:
    CLOSED: [2015-06-11 Thu 22:13]

*Rationale*: We removed new class info.

We need a way of populating the class aspects via the type settings
and via information obtained in the SML model. We may want to create a
class to handle this logic or maybe it can be done in transformer.
