#+title: Sprint Backlog 85
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) }

* Mission Statement

- finish implementing hashing and test data helpers.
- start implementing class info formatters in terms of yarn types.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-07-22 Fri 22:06]
| <75>                                                                        |         |       |      |       |
| Headline                                                                    | Time    |       |      |     % |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| *Total time*                                                                | *11:12* |       |      | 100.0 |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| Stories                                                                     | 11:12   |       |      | 100.0 |
| Active                                                                      |         | 11:12 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |         |       | 0:39 |   5.8 |
| COMPLETED Implement hashing using dynamic helpers                           |         |       | 2:53 |  25.7 |
| COMPLETED Analysis on pointers and type parameters                          |         |       | 0:37 |   5.5 |
| COMPLETED Add support for numbers in dynamic                                |         |       | 0:32 |   4.8 |
| COMPLETED Add type parameters support to yarn                               |         |       | 1:56 |  17.3 |
| COMPLETED Implement is circular dependency correctly                        |         |       | 0:13 |   1.9 |
| COMPLETED Implement "fallback" helpers                                      |         |       | 1:03 |   9.4 |
| STARTED Implement test data using dynamic helpers                           |         |       | 3:19 |  29.6 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-07-20 Wed 17:38]--[2016-07-20 Wed 17:55] =>  0:17
    CLOCK: [2016-07-19 Tue 20:30]--[2016-07-19 Tue 20:52] =>  0:22

Updates to sprint and product backlog.

*** Manual updates and blog posts                                     :story:

Time taken with blog posts and updates to the manual.

*** COMPLETED Implement hashing using dynamic helpers                 :story:
    CLOSED: [2016-07-20 Wed 00:08]
    CLOCK: [2016-07-19 Tue 23:57]--[2016-07-20 Wed 00:08] =>  0:11
    CLOCK: [2016-07-19 Tue 23:50]--[2016-07-19 Tue 23:56] =>  0:06
    CLOCK: [2016-07-19 Tue 22:29]--[2016-07-19 Tue 23:30] =>  1:01
    CLOCK: [2016-07-19 Tue 20:53]--[2016-07-19 Tue 22:28] =>  1:35

Update formatters in hash to use new helpers.

- =requires_hashing_helper_method=: is there a hashing helper for type
  t? We can tell if the type requires helpers, but this is across all
  facets, so we don't know if this is for hashing or not. But for a
  given family, the helpers register against a owning formatter. If a
  type exists for that owning formatter then a helper is required. We
  could add an attribute to properties that is computed based on this.

*** COMPLETED Analysis on pointers and type parameters                :story:
    CLOSED: [2016-07-20 Wed 17:37]
    CLOCK: [2016-07-20 Wed 17:00]--[2016-07-20 Wed 17:37] =>  0:37

Originally we created opaque and transparent relationships as a way to
figure out which types can be forward-declared. We then added
=are_children_opaque= to the name tree so that we could figure out
which type of relationship to use. But:

- we never marked types as =are_children_opaque=.
- transparent and opaque are "weird" terms.

What we were looking for was the general (in the "category" sense) way
of classifying types such that we could infer which ones could be
forward declared. Another way of looking at this is to classify types
in terms of memory allocation: heap, stack or both. In the vast
majority of cases, allocation is determined by looking at the name
tree. But in some cases, allocation is determined by the containing
type - i.e. smart pointers allocate on the heap.

- we could add type parameters to the objects.
- type parameters could have a stack or heap location.

So what can we say about a type (see [[https://www.sgi.com/tech/stl/table_of_contents.html][SGL container concepts]]):

- is it a container
- forward container
- reversible container
- random access container
- fixed size, size
- variable sized
- sequence
- associative container
- unique associative container, multiple associative container
- pair associative container, simple associative container
- sorted associative container
- hashed associative container

Actually containerisation and generics are somewhat orthogonal: a type
can be a container and not have type parameters; a type can have type
parameters and not be a container (in the STL concept sense). So we
can reduce our focus to the type parameter side. We can have a class
=type_parameterisation_properties=, which has the following
attributes:

- number of parameters (0 by default)
- parameters are allocated in heap?

This still sounds extremely hacky. The key difference between a shared
pointer and say a list of pointers is this: the underlying type is
always in the heap for a shared pointer, whereas for a list, it is
dependent on the type parameter. Also, in the specific case of yarn,
we are only worried about cases where there are type parameters, so
the right place to put this detail is with the type parameter
information.

In conclusion: add type parameter properties.

*** COMPLETED Add support for numbers in dynamic                      :story:
    CLOSED: [2016-07-21 Thu 20:32]
    CLOCK: [2016-07-21 Thu 20:09]--[2016-07-21 Thu 20:41] =>  0:32

In order to be able to process the number of type parameters we need
numeric support in dynamic. Add all required infrastructure.

*** COMPLETED Add type parameters support to yarn                     :story:
    CLOSED: [2016-07-21 Thu 22:51]
    CLOCK: [2016-07-21 Thu 22:43]--[2016-07-21 Thu 22:51] =>  0:08
    CLOCK: [2016-07-21 Thu 22:01]--[2016-07-21 Thu 22:42] =>  0:41
    CLOCK: [2016-07-21 Thu 20:01]--[2016-07-21 Thu 20:08] =>  0:07
    CLOCK: [2016-07-21 Thu 07:12]--[2016-07-21 Thu 07:42] =>  0:30
    CLOCK: [2016-07-21 Thu 06:59]--[2016-07-21 Thu 07:11] =>  0:12
    CLOCK: [2016-07-20 Wed 23:01]--[2016-07-20 Wed 23:05] =>  0:04
    CLOCK: [2016-07-20 Wed 22:46]--[2016-07-20 Wed 23:00] =>  0:14

- add enum type parameterisation styles: none, variable, fixed.
- add type parameter settings class with fields: type parameterisation
  styles, number of type parameters and type parameters always in
  heap.
- add type parameter settings factory which reads type parameters from
  meta-data.
- create a method to obtain all id's of types with type
  parameters. Supply that container to the factory generating name
  trees.
- in the factory, validate that types in a name tree have the expected
  number of type parameters.
- in the factory, if "type parameters always in heap" for a type, set
  are children opaque.
- add a "is pointer" attribute to helpers.
- set it to true if the parent has "are children opaque" set to true.
- update library to use new tags.

*** COMPLETED Implement is circular dependency correctly              :story:
    CLOSED: [2016-07-21 Thu 23:05]
    CLOCK: [2016-07-21 Thu 22:52]--[2016-07-21 Thu 23:05] =>  0:13

At present we are marking the top-level type as circular dependency if
it or any of its children have a reference to the owning type. This is
not useful. What we need is for the actual name tree that causes the
cycle to be marked so that when we are creating the helper we can set
a flag in the helper. This flag could also be "is circular
dependency".

*** COMPLETED Implement "fallback" helpers                            :story:
    CLOSED: [2016-07-22 Fri 21:43]
    CLOCK: [2016-07-22 Fri 20:58]--[2016-07-22 Fri 21:40] =>  0:42
    CLOCK: [2016-07-21 Thu 23:24]--[2016-07-21 Thu 23:29] =>  0:05
    CLOCK: [2016-07-21 Thu 23:07]--[2016-07-21 Thu 23:23] =>  0:16

For test data we need to introduce the notion of "fallback helpers":
if a type has no helper, look for a fallback helper for a given
formatter. If that exists, use it.

Actually this is not quite that easy. What we are trying to say is
that types for which there is no helper family should have a default
helper family. This would mean all types across yarn and across the
target model would end up mapping to the same helper, which is not
ideal - e.g. enumerations, concepts, primitives, etc would map to the
same fallback helper. By sheer luck this probably works, because we
only use helpers for nested type info and only objects can have nested
type infos.

The second problem is that we are only looking for a helper if the
type had a helper assistant in the first place. But the notion of
fallbacks implies that no helper assistant existed - or that we must
always set the helper assistant to fallback, meaning all types will
need helper assistants.

This can be achieved by using a default value for the family. It is
not ideal because it means we will now create helpers for _all_ types
in a name tree. But it should work.

*** STARTED Implement test data using dynamic helpers                 :story:
    CLOCK: [2016-07-22 Fri 21:43]--[2016-07-22 Fri 22:06] =>  0:23
    CLOCK: [2016-07-20 Wed 22:31]--[2016-07-20 Wed 22:44] =>  0:13
    CLOCK: [2016-07-20 Wed 21:57]--[2016-07-20 Wed 22:30] =>  0:33
    CLOCK: [2016-07-20 Wed 21:41]--[2016-07-20 Wed 21:56] =>  0:15
    CLOCK: [2016-07-20 Wed 19:10]--[2016-07-20 Wed 19:14] =>  0:04
    CLOCK: [2016-07-20 Wed 18:40]--[2016-07-20 Wed 19:09] =>  0:29
    CLOCK: [2016-07-20 Wed 18:14]--[2016-07-20 Wed 18:21] =>  0:07
    CLOCK: [2016-07-20 Wed 17:56]--[2016-07-20 Wed 18:13] =>  0:17
    CLOCK: [2016-07-20 Wed 15:50]--[2016-07-20 Wed 16:20] =>  0:30
    CLOCK: [2016-07-20 Wed 13:41]--[2016-07-20 Wed 14:09] =>  0:28

Update formatters in test data to use new helpers.

- for test data we need to introduce the notion of "fallback
  helpers". If a type has no helper, look for a fallback helper for a
  given formatter. If that exists, use it.
- for composite types: detect composition when creating the name trees
  in yarn. Mark the type as composite. Actually, composite is the
  wrong name. We should call it "recursive type" (a type defined in
  terms of itself).
- we need to detect types that are contained in pointers so that we
  generate the helpers accordingly.
- for pointers we already have =are_children_opaque=. We just need to
  populate this correctly.
- we can merge composite with domain, we just need a flag "generate
  with default values" or "generate with values". The nested type info
  could record type recursion at the point where it happens.
- rename int, char, bool.

*** Model should contain set of primitive id's                        :story:

We are computing the set of all primitive id's in quilt but this
should really be part of yarn.

*** Check generation type before dispatching element                  :story:

At present we are doing this check in =visit=:

:     if (o.generation_type() == yarn::generation_types::no_generation)
:        return;

If we did it before the =visit= call we'd save the cost of
dispatching.

*** Add test with smart pointer in base class                         :story:

At present we have the following helper formatters registered against
SmartPointer:

:      {
:        "quilt.cpp.types.class_implementation_formatter": [
:          "<quilt.cpp.types><smart_pointer_helper>",
:          "<quilt.cpp.io><smart_pointer_helper>"
:        ]
:      }

This should have caused something to break. It didn't because we don't
seem to have a test case with a smart pointer on the base class. This
raises the interesting point: do we ever need more than one helper for
a given family and a given file formatter? If so, we should change it
from a list to a single shared pointer.

Interestingly, for AssociativeContainer we have:

:    "AssociativeContainer": [
:      {
:        "quilt.cpp.types.class_implementation_formatter": [
:          "<quilt.cpp.io><associative_container_helper>"
:        ]
:      },
:      {
:        "quilt.cpp.io.class_implementation_formatter": [
:          "<quilt.cpp.io><associative_container_helper>"
:        ]
:      },

*** Update types formatters to use =yarn::object=                     :story:

Replace class info in types formatters with yarn's object.

*** Clean-up helper terminology                                       :story:

The name "helper" was never really thought out. It makes little
sense - anything can be a helper. In addition, we have helpers that do
not behave in the same manner (inserter vs every other helper). We
need to come up with a good vocabulary around this.

- static aspects: those that are baked in to the file formatter.
- dynamic aspects: those that are inserted in to the file formatter at
  run time.
- type-dependent dynamic aspects: those that are connected to the
  types used in the file formatter.

*** Dump container of files in formatter workflow                     :story:

At present we are polluting the log file with lots of entries for each
file name in formatter's workflow. Ideally we want a single entry with
a container of file names. The problem is, if we dump the entire
container we will also get the file contents. But if we create a
temporary container we will have to pay the cost even though log level
may not be enabled.

*** Type-bound helpers and generic helpers                            :story:

Not all helpers are bound to a type. We have the case of inserter
helper in io which is used by main formatters directly. We need to
make this distinction in the manual.

*** Check which properties need to loop through the entire model      :story:

In certain cases such as helpers we probably don't need to go through
all types; only the target types matter. Ensure we are not processing
other types for no reason.

*** Add validation for helper families                                :story:

At present we are checking that the name tree has the expected number
of type arguments:

:    const auto children(t.children());
:    if (children.size() != 1) {
:        BOOST_LOG_SEV(lg, error) << invalid_smart_pointer;
:        BOOST_THROW_EXCEPTION(formatting_error(invalid_smart_pointer));
:    }
:    smart_pointer_helper_stitch(fa, t);

In the future with dynamic helpers we will remove these checks. In
order to implement them we need to declare the type families up front
in a JSON file, with a name and number of type arguments. When
constructing the type helpers, we can check the name tree to make sure
the number of type arguments is correct.

This can be done as a helper setting (number of type arguments?).

Actually this is a core yarn property. So:

- add number of type arguments to object;
- read this as a dynamic field;
- during validation, check that all name trees that instantiate this
  object have the expected number of type arguments.
- in order to cope with cases such as variant we also need some kind
  of enum, e.g. type parameterisation: none, variable, fixed. if
  fixed, then number of type parameters must be non-zero.

*** Remove =requires_explicit_call= and =function_name=               :story:

Check to see if we are using the following helper properties:

- =requires_explicit_call=
- =function_name=

If not, remove them.

*** Update assistant to use new helper information                    :story:

Once all the pieces are in place, the assistant can then use the
element properties to find out which helpers are required for each
type; call those helpers and populate the file with the generate
code. We can remove all previous helper support.

*** Create a settings class for the "requires" settings               :story:

We need to populate these in a settings workflow of some kind.

*** Implement formattables in terms of yarn types                     :epic:

At present formattables are just a shadow copy of yarn types plus
additional =cpp= specific types. In practice:

- for the types that are shadow copies, we could have helper utilities
  that do the translation on the fly (e.g. for names).
- for additional information which cannot be translated, we could have
  containers indexed by qualified name and query those just before we
  call the transformer. This is the case with formatter properties. We
  need something similar to house "type properties" such as
  =requires_stream_manipulators=. These could be moved into aspect
  settings.
- for types that do not exist in yarn, we could inherit from element;
  this is the case for registrar, forward declarations, cmakelists and
  odb options. Note that with this we are now saying that element
  space contains anything which can be modeled, regardless of if they
  are part of the programming language type system, or build system,
  etc. This is not ideal, but its not a problem just yet. We could
  update the factory to generate these types and then take a copy of
  the model and inject them in it.

*** Remove nested type info                                           :story:

Once all of the infrastructure is in place, we should not need this
class any more. Remove code from transformer and remove object types
and anything else that was used to dispatch based on type.

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

** Deprecated

*** CANCELLED Write next interesting instalment in blog               :story:
    CLOSED: [2016-07-12 Tue 17:33]

*Rationale*: Not much of a point of having "interesting" related
stories in backlog.

We have a number of links backlogged and we need to offload them in an
"interesting..." post.
*** CANCELLED Create a ebook and dead-tree book for the manual        :story:
    CLOSED: [2016-07-12 Tue 18:07]

*Rationale*: this story does not add any value. We need to write the
manual and then worry about this.

We should probably start by creating a simple ebook first and then
explore the dead-tree options such as [[http://www.lulu.com][Lulu]]. We should also see what
Luigi did for [[https://leanpub.com/implementingquantlib/][QuantLib]].
