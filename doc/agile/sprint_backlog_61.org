#+title: Sprint Backlog 61
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission

Integrate the new C++ namespaces into a combined workflow and start
implementing the types header formatter.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2015-02-07 Sat 17:21]

| Headline                                                            | Time    |       |      |
|---------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                        | *10:06* |       |      |
|---------------------------------------------------------------------+---------+-------+------|
| Active                                                              |         | 10:06 |      |
| STARTED Sprint and product backlog grooming                         |         |       | 0:25 |
| COMPLETED Improvements to product backlog                           |         |       | 1:01 |
| COMPLETED Tidy-up formatters workflow                               |         |       | 0:20 |
| COMPLETED Create a =formattable= base class                         |         |       | 0:32 |
| COMPLETED Rename =file_settings= to =file_properties=               |         |       | 0:11 |
| COMPLETED Create a class to generate file names                     |         |       | 0:20 |
| COMPLETED Create a class to generate file properties                |         |       | 0:30 |
| COMPLETED Create a formattables workflow                            |         |       | 1:56 |
| COMPLETED Facet and formatter settings factories to use definitions |         |       | 1:54 |
| COMPLETED Split global settings by formatter and facet              |         |       | 0:04 |
| COMPLETED Create a settings facade for querying                     |         |       | 1:25 |
| STARTED Implement file name factory without using formatters        |         |       | 0:58 |
| STARTED Create settings expander and switcher                       |         |       | 0:30 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-02-07 Sat 15:45]--[2015-02-07 Sat 15:52] =>  0:07
    CLOCK: [2015-02-04 Wed 20:50]--[2015-02-04 Wed 21:08] =>  0:18

Updates to sprint and product backlog.

*** STARTED Updates to the manual and readme files                    :story:

Use downtime to update the manual and / or readme file.

*** COMPLETED Improvements to product backlog                         :story:
    CLOSED: [2015-02-02 Mon 20:21]
    CLOCK: [2015-02-02 Mon 19:20]--[2015-02-02 Mon 20:21] =>  1:01

We need to make the product backlog a bit more manageable. It has
grown quite a lot, and we spend a lot of time grooming. The main
problem is that there are many stories which we are not going to look
at for a very long time but yet they are interspersed with stories
that are needed now. We should:

- remove the deprecated section; deprecation is a "sprint-only"
  phenomena.
- Split active stories into: a) short term b) medium term c) long
  term. All the vision stuff should go into long term. Actually we
  probably should use names that are more reflective: bugs, long term
  features, etc.

*** COMPLETED Tidy-up formatters workflow                             :story:
    CLOSED: [2015-02-03 Tue 20:40]
    CLOCK: [2015-02-03 Tue 20:19]--[2015-02-03 Tue 20:39] =>  0:20

We need to remove all of the facet code and work directly off of the
formatter container.

*** COMPLETED Create a =formattable= base class                       :story:
    CLOSED: [2015-02-03 Tue 21:22]
    CLOCK: [2015-02-03 Tue 20:40]--[2015-02-03 Tue 21:12] =>  0:32

We need to start using the =formattable= base class instead of
entity. Make entity non-visitable and deal with the fall out.

*** COMPLETED Rename =file_settings= to =file_properties=             :story:
    CLOSED: [2015-02-03 Tue 21:33]
    CLOCK: [2015-02-03 Tue 21:22]--[2015-02-03 Tue 21:33] =>  0:11

- rename file settings to file properties because these are not a
  direct translation from dynamic.
- create a file properties factory that merges the output of the
  includes generator and file name generator and spits out file
  properties per qname, per formatter.
- use the file properties factory in transformer.

*** COMPLETED Create a class to generate file names                   :story:
    CLOSED: [2015-02-03 Tue 22:29]
    CLOCK: [2015-02-03 Tue 22:08]--[2015-02-03 Tue 22:28] =>  0:20

Create a "file name generator" (name needs thinking) that will receive
the settings as input and generate file names per formatter for each
qname. It will use the postfixes for facet/formatter settings to
generate the file name. It will take into account file name overrides
in file name settings. We no longer need help from the formatter - the
algorithm just uses the settings. Remove all file name related code
from formatters.

*** COMPLETED Add support for local settings                          :story:
    CLOSED: [2015-02-03 Tue 22:30]

*New Understanding*

- local settings have: general, file name settings (for the file name
  overrides), type settings, additional includes. Presumably all of
  these need to be optional. We need to ensure general settings have a
  scope of any.
- we need a local settings factory. See the scratch pad for an example
  using =sml::consumer_interface=.

*Previous Understanding*

- create a local settings class that is made up of file settings,
  opaque settings and formatter settings. Entity to have a container
  of local settings (map of formatter id to local settings).
- create a local settings factory that takes on the work from workflow
  in generating the file settings. It also takes on a container of
  opaque settings factory by formatter id to generate the opaque
  settings. Finally, it uses the formatter settings factory for the
  overrides. These should be optional. If populated, they should take
  on the global settings as defaults so that we don't have to worry
  about global settings for formatters any more. This means the local
  settings factory must have access to the global settings.

*** COMPLETED Create a settings class                                 :story:
    CLOSED: [2015-02-03 Tue 22:30]

*New Understanding*

We need a container for both local and global settings that gets
passed around. It should really be called =settings= but given that it
exists in the =settings= namespace, it may sound a bit
"repetitive". Brainstorm on naming.

*Previous Understanding*

- create a settings class that has a map of formatter id to global
  settings. It could also have a map of c++ entity name (produced with
  name builder to include namespaces), to formatter id to local
  settings. With this we can now move the settings away from entity
  because we no longer require the qname.
- pass the settings class to the includes builder.

*** COMPLETED Create a class to generate file properties              :story:
    CLOSED: [2015-02-03 Tue 23:00]
    CLOCK: [2015-02-03 Tue 22:30]--[2015-02-03 Tue 23:00] =>  0:30

Create a "file properties generator" (name needs thinking) that will
receive the file names from the "file name generator" as well as the
settings and produce the complete file properties per qname per
formatter. It will delegate to each formatter for the includes
generation. Formatters to take into account the additional includes
settings.

Notes:

- consider passing in a container of includes builder (or formatters)
  rather than querying the registrar directly.

*** COMPLETED Create a formattables workflow                          :story:
    CLOSED: [2015-02-03 Tue 23:44]
    CLOCK: [2015-02-03 Tue 22:30]--[2015-02-03 Tue 23:44] =>  1:14
    CLOCK: [2015-02-03 Tue 21:33]--[2015-02-03 Tue 22:06] =>  0:33
    CLOCK: [2015-02-03 Tue 20:10]--[2015-02-03 Tue 20:19] =>  0:09

We need to move across all code in the C++ workflow which is actually
part of the formattables sub-workflow.

*** COMPLETED Add global formatter settings support                   :story:

A use case that is very well understood is the need to enable/disable
optional formatters at the global level. For example, one should be
able to disable all of the forward declarations at the top-level and
then enable only those that are needed. We should check if formatters
like serialisation etc already have a requirement on forward
declarations.

*** COMPLETED Create a transformation and formatting sub-workflow     :story:

At present we have two template functions in the main workflow,
linking the different steps of transformation and formatting. However,
it may make more sense to plug in to the all types traversal. For this
we need a sub-workflow that owns the model and the transformer and
which overloads =operator()=. It produces files.

It can receive a formatter dispatcher and a transformer on
construction and keep references these. Execute returns the list of
files.

*** COMPLETED Create top-level initialisers                           :story:

It would be nice if top-level models such as =knit= had their own
static initialiser and consumers of that model didn't have to manually
initialise every dependent model.

*** COMPLETED Use formatting settings in formatters model             :story:

We need to replace the references to the c++ settings directly with
formatter settings.

*** COMPLETED Facet and formatter settings factories to use definitions :story:
    CLOSED: [2015-02-04 Wed 23:02]
    CLOCK: [2015-02-04 Wed 22:44]--[2015-02-04 Wed 23:02] =>  0:18
    CLOCK: [2015-02-04 Wed 21:08]--[2015-02-04 Wed 22:44] =>  1:36

*Analysis*

We need a way to obtain the set of facets and formatters "implied" by
the registered field definitions. We could do this like we did with
content extensions by adding a set of helper methods that process
field definitions.

Actually, since we need to build "indexes" it makes more sense to have
some kind of class with state: =indexer=.

We also need to fix the naming of facets and formatters in field
definitions: we need to make use of traits.

*Action Items*

- rename =facet_id= and =formatter_id= to =facet_name= and
  =formatter_name=.
- use traits when generating field definitions (facet and formatter
  names).
- remove generation of default facet settings.
- pass a list of facet names into facet factory. This is obtained by
  querying the registered formatters (activity in workflow). Actually,
  we don't really need this. We should just throw if a formatter looks
  for a facet/formatter name in the settings that does not exist.
- create a =dynamic::indexer= that indexes by facet name.
- pass the indexer into facet factory, or just the results of the
  indexer.
- for each facet in the list, get all fields from default values from
  the indexer; get the corresponding field instance if any; find the
  matching property in facet settings and set it with either the field
  instance or the default value.

*** COMPLETED Split global settings by formatter and facet            :story:
    CLOSED: [2015-02-04 Wed 23:08]
    CLOCK: [2015-02-04 Wed 23:04]--[2015-02-04 Wed 23:08] =>  0:04

*Analysis*

Update formatter and facet settings to split them by qname, by
formatter. This includes the work required to split the default
settings too. Change global settings to have facet/formatter settings
by qname, by formatter. We should probably also generate local
overrides for general settings immediately. This means the formatter
can go straight to the local settings.

For defaults: at present we are manually generating default settings
for both facets and formatters. We should do these from dynamic's
field definitions.

Dynamic could provide field definition aggregation services for
formatter and facet.

*** COMPLETED Create a settings facade for querying                   :story:
    CLOSED: [2015-02-07 Sat 17:21]
    CLOCK: [2015-02-07 Sat 15:55]--[2015-02-07 Sat 17:20] =>  1:25

Now that we have global and local settings, we should be able to hide
the overriding behind some kind of facade so that the formatter does
not need to know if a setting is global or local; it should just query
by some properties and get the desired settings.

Name: =selector=?

*** STARTED Implement file name factory without using formatters      :story:
    CLOCK: [2015-02-07 Sat 15:53]--[2015-02-07 Sat 15:55] =>  0:02
    CLOCK: [2015-02-05 Thu 21:00]--[2015-02-05 Thu 21:56] =>  0:56

*New Understanding*

We should actually keep the formatters doing the file names. The
problem is that we need to know if we are a header or not, etc. This
logic could be added to the formatter interface, but it would be
cumbersome. So pass in the settings selector to the =make_file_name=
function, extract all of the relevant settings and make a call to name
builder passing in all relevant flags. Builder does not know of
settings.

*Previous Understanding*

There is no longer a need to go to the formatter to obtain the file
path. We should remove this and use the settings directly within the
file name factory.

*** STARTED Create settings expander and switcher                     :story:
    CLOCK: [2015-02-07 Sat 15:15]--[2015-02-07 Sat 15:45] =>  0:30

We need a class responsible for copying over all settings that exist
both locally and globally. The idea is that, for those settings, the
selector should be able to just query by formatter name locally and
get the right values. This could be the expander.

We also need a more intelligent class that determines what formatters
are enabled and disabled. This is due to:

- lack of support for a given formatter/facet by a type in the graph;
  it must be propagated to all dependent types. We must be careful
  with recursion (for example in the composite pattern).
- a facet has been switched off. This must be propagated to all
  formatters in that facet.
- user has switched off a formatter. As with lack of support, this
  must be propagated through the graph.

This could be done by the switcher. We should first expand the
settings then switch them.

*** Populate entity's identity during transformation                  :story:

In order to use the settings selector, we need entities to have their
identity properly populated.

*** Implement include generation for class header formatter           :story:

Now that we have finished generating the path spec details, we need to
make sure includes generation works as expected. Add both formatter
level includes as well as model level includes.

We also need to deal with:

- exposing formatter id as a static property so we can create
  dependencies between formatters;
- includes overrides via dynamic extensions, so we can start using
  STL, Boost etc classes.
- includes of STL, Boost etc that are formatter level dependencies -
  this needs to be handled via traits.

*** Includer generation should be done from dynamic extensions        :story:

*New Understanding*

The true use case of this story is not to allow users to add includes
at random; it is actually only useful in one scenario:

- *merging code generation*: users add code which requires additional
  includes. Without support for this, merging code generation would
  have limited usefulness.

*Previous Understanding*

It would be nice if we could determine which includer files to create
by looking at the dynamic extensions. For this we need a notion of an
inclusion group, defined at the model level:

- =cpp.types.includers.general=
- =cpp.types.includers.value_objects=
- ...

Under each of these one would configure the aspect:

- =cpp.types.includers.general.generate=: =true=
- =cpp.types.includers.general.file_name=: =a/b/c=
- =cpp.types.includers.general.is_system=: =false=

Then, each type, module etc would declare its membership (as a list):

- =cpp.includers.member=: =cpp.types.includers.general=
- =cpp.includers.member=: =cpp.types.includers.value_objects=
- ...

*Previous understanding*

We should simply go through all the types in the SML model and for
each type and each facet create the corresponding inclusion
path. locator can be used to generate standard paths, and a model
specific mapping is required for other models such as std.

Include then takes the relationships extracted by extractor, the
mappings generated by this mapper and simply appends to the inclusion
list the file names. it also appends the implementation specific
headers.

*** Add support for opaque formatter settings                         :story:

- create an empty opaque formatter settings class. Create a opaque
  formatter settings factory interface class. Formatter interface to
  return an opaque formatter settings factory interface.
- add opaque formatter settings to local settings.
- when formatting, cast additional formatter settings (if available)
  and throw if cast fails. For formatters without opaque settings,
  throw if any supplied.
- we need multiple opaque settings (more than one formatter will need
  them).

*** Consider using an abstract factory in formatters                  :story:

At present we have a number of interfaces (or quasi-interfaces) coming
out of formatter:

- file name generation
- includes generation
- opaque settings generation
- opaque settings validator

Perhaps it makes more sense to aggregate them all into a factory of
factories. We should look into the abstract factory pattern as it
seems particularly suitable for this. The factory should remember the
id of the formatter it comes from.

In terms of names, it is difficult to find a name for such an
aggregate:

- formatter components, e.g. =formatter_components_factory_interface=
- formatter properties
- formatter parts

*** Implement class header formatter                                  :story:

- look at the old =om= types formatter implementation to see if there
  is any code to scavenge. This model was deleted around commit
  10157ad.

**** Tidy-up =types_main_header_file_formatter=                        :task:

Clean up internal functions in file and add documentation.

**** Copy across documentation from =om=                               :task:

We did a lot of doxygen comments that are readily applicable, copy
them across.

**** Make use of indenting stream                                      :task:

Remove uses of old indenter.

**** Copy across =om= types formatter tests                            :task:

Not sure how applicable this would be, but we may be able to scavenge
some tests.

*** Support "cross-facet interference"                                :story:

In a few cases its useful to disable bits of a facet when another
facet is switched off because those bits do not belong to the main
facet the formatter is working on. At present this happens in the
following cases:

- Forward declaration of serialisation in domain when serialisation is
  off
- Friend of serialisation in domain when serialisation is
  off
- declaration and implementation of to_stream when IO is off
- declaration and implementation of inserter when IO is off and
  integrated IO is on.

We need a way of accessing the on/off state of all facets from any
formatter so that they can make cross facet decisions. A quick hack
was to add yet another flag: =disable_io= which is disabled when the
IO facet is not present and passed on to the relevant formatters. This
needs to be replaced by a more general approach.

*** Consider a more selective hashing generation                       :epic:

At present we either generate hashing for all types or none at all. In
practice, most users only need hashing for a few types. It would be
great if we could have certain facets like hashing with a "disabled
for all types except" approach. Users would then enable the types that
they need.

*** Use boilerplate to generate annotations                           :story:

#+begin_quote
*Story*: As a dogen user, I want to be able to use my own licence and
copyright attribution so that the generated code matches the general
project choices.
#+end_quote

Remove all of the manual boilerplate and make use of the new
class. This will involve bring across some dynamic extensions into the
C++ model.

*** Move all the fundamental configuration options into dynamic extensions  :story:

#+begin_quote
*Story*: As a dogen user, I do not want to have to specify fundamental
model options from the command line so that I do not forget to specify
them and generate invalid models.
#+end_quote

There are a set of options that must not be supplied as command line
arguments, such as backend and facet related properties etc. These
should be attached to the diagram itself so that one does not need to
supply it every time one code generates.

**** Update all models and tests to use the new tags

Once the config options are in we need to start making use of them to
ensure they work exactly as before.

**** Remove all C++ command line settings

Once the overrides have been proven to work, we need to remove the
command line options and make sure nothing breaks.

**** Remove all of the config classes

We have a number of settings in the =config= model that won't be used
any longer:

- =formatting_settings=
- =annotation_settings=
- =cpp_settings=
- =code_generation_marker_settings=

These should all be removed, with the corresponding command line
arguments.

*** Improve formatters code generation marker                         :story:

Things the marker can/should have:

- model level version;
- the dogen version too. However, this will make all our tests break
  every time there is a new commit so perhaps we need to have this
  switched off by default.

*** C++ workflow should perform a consistency check                   :story:

We should ensure that all facets and formatters available in the
registrar have corresponding field definitions and vice-versa. This
was originally to be done by some kind of "feature graph" class, but
since we need to use this data for other purposes, the main workflow
could take on this responsibility - or we could create some kind of
"validator" class to which the workflow delegates.

*** Add "model types"                                                 :story:

At present we have a number of dynamic extensions that exist purely to
deal with non-dogen models:

- supported: is the facet supported by the external model
- file_name: what is the external model naming for files for this
  facet
- is_system: is the file name a system include file or not?

In reality, all of this could be avoided if we had a way of
distinguishing between models that follow dogen conventions and those
who do not; a "model type" of sorts such as "external" and "dogen" -
naming needs more thought. With this we could infer the rest: if no
file name is supplied then a given formatter/facet is not supported;
if the model is_system then all types are system and so on.

We should also have a flag in field definitions that verify that a
parameter is only present if the model is a non-dogen model. For
example, it makes no sense to supply =cpp.type.family= in a dogen
model but it may make sense to do so in an external model. However,
this would mean that if a user manually adds a type to a dogen model
it cannot be extended. Requires a bit of thinking.

*** Consider renaming general settings                                :story:

A while ago we came up with this name for the settings of the generic
formatter model. This is the model with basic infrastructure to be
reused by the more specialised formatters. However, now that we have
many (many) settings classes, general settings may not be the most
appropriate name. We need to look a bit more deeply into the role of
this class and see if a better name is not available.

*** Copyright holders is scalar when it should be an array            :story:

At present its only possible to specify a single copyright holder. It
should be handled the same was as odb parameters, but because that is
done with a massive hack, we are not going to extend the hack to
copyright holders.

*** Populate the "new" =class_info= properties                        :story:

We need a way of populating the class aspects via the type settings
and via information obtained in the SML model. We may want to create a
class to handle this logic or maybe it can be done in transformer.

*** Consider creating constants for common fields                     :story:

Fields such as =enabled=, =postfix= etc are common to all formatters
and facets. It may make more sense to define some string constants for
them, perhaps in =traits=?

** Deprecated
*** CANCELLED Towards a more generic use of dynamic extensions         :epic:
    CLOSED: [2015-02-07 Sat 15:52]

*New Understanding*: We have decided to limit the dynamic extensions
usage to extensibility. Where required parameters will be made visible
via dynamic extensions but this should be kept to just those
parameters that users can sensibly control.

*Previous Understanding*

We should do an inventory of all dogen features which can be
reimplemented as dynamic extensions. For example, immutability should
result in a generic parameter being added to the type at the SML
level:

: immutable = true

which then gets resolved into a set of language specific parameters:

: cpp.copy_constructor.status = disabled
: cpp.setters.status = disabled
: ...

The formatter then looks for these tags to decide whether to add a
method or not. If we had more languages, they would have equivalent
formatting commands.

The same would apply to facets. These would have a top-level generic
parameter such as =hashing=:

: hashing = true

Which then expands to implementation specific hashing:

: cpp.hashing.std_hashing = true

or

: cpp.hashing.boost_hashing = true

The facet is now just a short-hand for a set of implementation
specific parameters. There is some default mapping applied in this
grouping. The user can shortcut the process by disabling the mapping
and supplying implementation specific parameters:

: hashing = false
: cpp.hashing.boost_hashing = true

Assuming =std_hashing= as a default.

In addition, depending on the parameter, it may be propagatable /
expandable. For example, if hashing is set to false in a type at the
bottom of a graph relationship, we must propagate it to all members of
the graph. Similarly, if hashing is disabled in the model, we must
propagate it to all types in the model.
