#+title: Release Notes for Sprint 37
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED
#+tags: story(s) epic(e) task(t) note(n) spike(p)

* Release Notes

This file contains all stories that were closed during sprint 37.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2013-10-28 Mon 19:15]

| Headline                                                                 | Time    |       |      |
|--------------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                             | *15:11* |       |      |
|--------------------------------------------------------------------------+---------+-------+------|
| Development Stories Implemented                                          |         | 15:11 |      |
| IMPLEMENTATION Release notes and backlog grooming                        |         |       | 0:06 |
| COMPLETED Add types header formatter to workflow                         |         |       | 4:14 |
| COMPLETED Add support for =boost::property_tree::ptree=                  |         |       | 1:43 |
| COMPLETED Implement meta-data support as a =ptree=                       |         |       | 2:36 |
| COMPLETED ODB pragma generation was broken with =ptree= change           |         |       | 1:14 |
| COMPLETED Refactor tags, router, adaptor, etc                            |         |       | 1:57 |
| COMPLETED Implement formatter factory and plug it into workflow          |         |       | 0:39 |
| IMPLEMENTATION Add module support to types header formatter              |         |       | 2:12 |
| IMPLEMENTATION Add tests for properties and compiler generated functions |         |       | 0:30 |
#+end:

*** IMPLEMENTATION Release notes and backlog grooming                  :task:
    CLOCK: [2013-10-21 Mon 07:53]--[2013-10-21 Mon 07:59] =>  0:06

*** COMPLETED Add types header formatter to workflow                  :story:
    CLOSED: [2013-10-24 Thu 20:28]
    CLOCK: [2013-10-25 Fri 07:48]--[2013-10-25 Fri 07:55] =>  0:07
    CLOCK: [2013-10-24 Thu 08:22]--[2013-10-24 Thu 08:33] =>  0:11
    CLOCK: [2013-10-24 Thu 07:51]--[2013-10-24 Thu 08:17] =>  0:26
    CLOCK: [2013-10-21 Mon 08:32]--[2013-10-21 Mon 08:40] =>  0:08
    CLOCK: [2013-10-21 Mon 08:14]--[2013-10-21 Mon 08:17] =>  0:03
    CLOCK: [2013-10-21 Mon 07:59]--[2013-10-21 Mon 08:14] =>  0:15

**** COMPLETED Change type formatter interface                         :task:
     CLOSED: [2013-10-21 Mon 20:44]
     CLOCK: [2013-10-21 Mon 19:45]--[2013-10-21 Mon 20:00] =>  0:15
     CLOCK: [2013-10-21 Mon 18:20]--[2013-10-21 Mon 18:53] =>  0:33
     CLOCK: [2013-10-21 Mon 18:19]--[2013-10-21 Mon 18:20] =>  0:01

- no stream
- returns a file

**** COMPLETED add all types traversal and hook it up to workflow      :task:
     CLOSED: [2013-10-25 Fri 00:19]
     CLOCK: [2013-10-24 Thu 22:40]--[2013-10-25 Fri 00:19] =>  1:39
     CLOCK: [2013-10-24 Thu 18:14]--[2013-10-24 Thu 18:46] =>  0:32
     CLOCK: [2013-10-24 Thu 18:10]--[2013-10-24 Thu 18:14] =>  0:04

*** COMPLETED Add support for =boost::property_tree::ptree=           :story:
    CLOSED: [2013-10-27 Sun 17:53]
    CLOCK: [2013-10-27 Sun 17:50]--[2013-10-27 Sun 17:53] =>  0:03
    CLOCK: [2013-10-27 Sun 16:07]--[2013-10-27 Sun 17:47] =>  1:40

*** COMPLETED Implement meta-data support as a =ptree=                :story:
    CLOSED: [2013-10-27 Sun 20:33]
    CLOCK: [2013-10-27 Sun 19:30]--[2013-10-27 Sun 20:33] =>  1:03
    CLOCK: [2013-10-27 Sun 18:54]--[2013-10-27 Sun 19:30] =>  0:36
    CLOCK: [2013-10-27 Sun 17:57]--[2013-10-27 Sun 18:54] =>  0:57

We started off by creating tags as key-value-pairs because this
reflected the nature of the inputs coming in from SML. It was also
handy for a JSON format. However, the infrastructure that is growing
around tags (e.g. adaptor, router) seems to imply that a flat
structure is not quite the right way of modeling this; adaptor and
router are just a way of solving the impedance mismatch. Perhaps a
better approach is to create an object model around meta-data.

The main issues with the current approach are:

- very verbose: the whole nonsense around tagger, adaptor and router
  makes it really cumbersome to write code that gets and sets. Having
  said that, in order for defaulting to work we would need a way of
  checking if something was already set before setting it. We would
  need something akin to =std::optional= or =boost::optional= for
  this.
- the aspects in a section are hard-coded. At present we have the main
  header file, the implementation file, the forward declarations and
  the includer; in the future we could have more (boost parameter,
  boost concept, etc). Its annoying to have to add new blocks to tags
  every time we need to add an aspect. This would be solved if we had
  a container for aspects with some aspect enumeration. The
  enumeration would have to have a language prefix
  (e.g. =cpp_aspects=).
- on the same vein, the facets themselves are hard-coded. Like the
  aspects, we expect these to expand overtime and we want to make it
  as easy as possible to do so. At present we need to add more facet
  blocks into tags and then do a whole load of population in
  tagger. This would be solved if we have a container for facets with
  some enumeration associated. The enumerators would have to have a
  language prefix (e.g. =cpp_types=, =cpp_hash_standard=, etc.)

Of course the key issue with an object model is that the data would
still be inputted as key-value-pairs in the dia diagram or the JSON
file. This means we still would need to solve this impedance mismatch,
probably via tags (e.g. the graph of the object model is encoded in
the key names as it is at present).

The other thing that may be useful is to think of the meta-data as a
tree, with the following levels:

- *language-agnostic*: or root; applies to everything in this
  model. e.g. =comment=, =identity_attribute=, etc.
- *language-specific*: applies to a specific language like C++. All
  the stuff in tags under =cpp=.
- *facet-specific*: applies to just a facet in a language,
  e.g. =types= in =cpp=.
- *aspect-specific*: all the file names, etc for the given aspect.

With this we can now handle all facets in the same way (even
regardless of language), as well as all aspects in the same way. We
could have methods that take the facet/aspect node and do stuff
without needing to know which facet/aspect they're processing (of
course the nodes of the tree would still have an enumeration so
identification is still possible).

We could use boost property tree as a way of managing the tree. It
supports paths - e.g. the tags - out of the box. It would also support
the complex/simple tags; complex tags would be like a container in
JSON, where the ordering is guaranteed by the order of nodes in a
given level. Finally it also supports boost serialisation. We just
need to find a way to JSON serialise it as per the IO stream
requirements, which could just be a case of using JSON support in
property tree.

When considering the tree approach, we should also take into account
the "facet with multiple implementations scenario". This is for cases
such as hashing or serialisation where there may be more than one way
of providing an implementation for a facet - and we may need to use
more than one at the same time. One option is to consider these things
as distinct facets - entirely unrelated at this level. For example we
could have a standard_hash facet and a boost_hash facet.

*** COMPLETED ODB pragma generation was broken with =ptree= change    :spike:
    CLOSED: [2013-10-28 Mon 00:06]
    CLOCK: [2013-10-27 Sun 22:52]--[2013-10-28 Mon 00:06] =>  1:14

*** COMPLETED Refactor tags, router, adaptor, etc                     :story:
    CLOSED: [2013-10-28 Mon 01:57]
    CLOCK: [2013-10-28 Mon 01:48]--[2013-10-28 Mon 01:57] =>  0:09
    CLOCK: [2013-10-28 Mon 00:50]--[2013-10-28 Mon 01:48] =>  0:58
    CLOCK: [2013-10-27 Sun 20:33]--[2013-10-27 Sun 20:39] =>  0:06

Terminology around meta-data has become really confusing - we seem to
have too many things called "tags". In truth only the keys should be
tags. Tidy-up classes, methods etc.

Also, in some cases its easier to just use the =ptree= API directly
rather than the nonsense of adaptor and router. We need to figure out
how to best rewrite existing code in terms of =ptree=.

**** COMPLETED Rename tags to meta-data                                :task:
     CLOSED: [2013-10-28 Mon 00:33]
     CLOCK: [2013-10-28 Mon 00:08]--[2013-10-28 Mon 00:33] =>  0:25
     CLOCK: [2013-10-27 Sun 22:50]--[2013-10-27 Sun 22:52] =>  0:02

**** COMPLETED Rename router to =ptree_writer=                         :task:
     CLOSED: [2013-10-28 Mon 01:48]
     CLOCK: [2013-10-28 Mon 00:33]--[2013-10-28 Mon 00:50] =>  0:17

**** COMPLETED Rename adaptor to =ptree_reader=                        :task:
     CLOSED: [2013-10-28 Mon 01:48]
**** COMPLETED Remove =make_tag_xyz= methods                           :task:
     CLOSED: [2013-10-28 Mon 01:48]
**** COMPLETED Make template methods in workflow use meta-data directly :task:
     CLOSED: [2013-10-28 Mon 01:48]

*** COMPLETED Implement formatter factory and plug it into workflow
    CLOSED: [2013-10-28 Mon 19:15]
    CLOCK: [2013-10-28 Mon 18:35]--[2013-10-28 Mon 19:14] =>  0:39

*** IMPLEMENTATION Add module support to types header formatter       :story:
**** Add test for module in model
**** COMPLETED Generic module support                                  :task:
     CLOSED: [2013-10-27 Sun 11:33]
     CLOCK: [2013-10-27 Sun 09:39]--[2013-10-27 Sun 11:32] =>  1:53

**** COMPLETED Support model as a module                               :task:
     CLOSED: [2013-10-27 Sun 11:33]
     CLOCK: [2013-10-27 Sun 09:20]--[2013-10-27 Sun 09:39] =>  0:19

*** IMPLEMENTATION Add tests for properties and compiler generated functions :story:
    CLOCK: [2013-10-25 Fri 08:27]--[2013-10-25 Fri 08:35] =>  0:08
    CLOCK: [2013-10-25 Fri 07:56]--[2013-10-25 Fri 08:18] =>  0:22

*** Add tests for tagging of abstract objects                         :story:

** Deprecated Development Stories
