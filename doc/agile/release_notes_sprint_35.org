g#+title: Release Notes for Sprint 35
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED
#+tags: story(s) epic(e) task(t) note(n) spike(p)

* Release Notes

This file contains all stories that were closed during sprint 35.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2013-09-25 Wed 18:53]

| Headline                                                     | Time   |      |      |
|--------------------------------------------------------------+--------+------+------|
| *Total time*                                                 | *6:32* |      |      |
|--------------------------------------------------------------+--------+------+------|
| Development Stories Implemented                              |        | 6:32 |      |
| IMPLEMENTATION Release notes and backlog grooming            |        |      | 0:12 |
| COMPLETED Refactor OM tests to avoid over-inclusion          |        |      | 0:32 |
| COMPLETED Convert implementation specific parameters to list |        |      | 1:06 |
| COMPLETED Rename implementation specific parameters          |        |      | 0:50 |
| IMPLEMENTATION Implement the property cache in SML           |        |      | 1:14 |
| IMPLEMENTATION Implement the opaque parameter cache in SML   |        |      | 0:56 |
| IMPLEMENTATION Create a complete domain formatter in OM      |        |      | 1:42 |
#+end:

*** IMPLEMENTATION Release notes and backlog grooming                  :task:
    CLOCK: [2013-09-23 Mon 07:50]--[2013-09-23 Mon 08:02] =>  0:12

*** COMPLETED Refactor OM tests to avoid over-inclusion               :spike:
    CLOSED: [2013-09-23 Mon 23:41]
    CLOCK: [2013-09-23 Mon 23:05]--[2013-09-23 Mon 23:37] =>  0:32

At present OM builds take too long on slow hardware because we are
using the facet includers in tests. This means that every time a
service changes one has to rebuild all the specs in OM. Include all
the types manually in unit tests to reduce the dependencies.

*** COMPLETED Convert implementation specific parameters to list      :spike:
    CLOSED: [2013-09-24 Tue 22:49]
    CLOCK: [2013-09-24 Tue 23:19]--[2013-09-24 Tue 23:36] =>  0:17
    CLOCK: [2013-09-24 Tue 22:49]--[2013-09-24 Tue 23:19] =>  0:30
    CLOCK: [2013-09-24 Tue 17:56]--[2013-09-24 Tue 18:08] =>  0:12
    CLOCK: [2013-09-24 Tue 08:13]--[2013-09-24 Tue 08:20] =>  0:07

We need to do lookups into the parameters, so a vector is not
suitable. change it to a =std::unordered_map=.

Actually, It is not possible to do this due to the way ODB parameters
work; we need to maintain the order defined by the user (and it needs
to allow for duplicates). However, might as well use a =std::list= instead of
a =std::vector=.

*** COMPLETED Rename implementation specific parameters               :story:
    CLOSED: [2013-09-24 Tue 18:33]
    CLOCK: [2013-09-24 Tue 22:27]--[2013-09-24 Tue 22:49] =>  0:22
    CLOCK: [2013-09-24 Tue 18:12]--[2013-09-24 Tue 18:40] =>  0:28

These should really be called back end specific parameters at the SML
level. At the dia level, if a parameter is passed in which has a
representation at the SML level it should simply be converted to this
representation instead of being added to the KVP.

Actually, these are more like generic parameters:

- at the dia level they are used to fill in gaps in dia (e.g. packages
  and diagrams do not have comments)
- at the SML level, they are used to add information which does not
  make sense for it to be in dia: is property key.
- at the backend level, they are used to provide information which
  does not make sense to live in SML: for example the ODB parameters.

Also, when the string table support has been added, we need to create
a string table with all valid values for the parameter keys.

Name choices:

- opaque parameters
- untyped parameters

*** IMPLEMENTATION Implement the property cache in SML                :story:
    CLOCK: [2013-09-25 Wed 08:09]--[2013-09-25 Wed 08:17] =>  0:08
    CLOCK: [2013-09-25 Wed 07:47]--[2013-09-25 Wed 08:09] =>  0:22
    CLOCK: [2013-09-24 Tue 23:40]--[2013-09-25 Wed 00:24] =>  0:44

*** IMPLEMENTATION Implement the opaque parameter cache in SML        :story:
    CLOCK: [2013-09-26 Thu 22:31]--[2013-09-26 Thu 23:31] =>  1:00
    CLOCK: [2013-09-26 Thu 22:25]--[2013-09-26 Thu 22:31] =>  0:06
    CLOCK: [2013-09-26 Thu 19:11]--[2013-09-26 Thu 19:18] =>  0:07
    CLOCK: [2013-09-26 Thu 18:22]--[2013-09-26 Thu 18:43] =>  0:21
    CLOCK: [2013-09-25 Wed 18:02]--[2013-09-25 Wed 18:53] =>  0:51
    CLOCK: [2013-09-25 Wed 17:57]--[2013-09-25 Wed 18:02] =>  0:05

There is a fundamental problem with the parameter cache approach: it
does not take into account parameters in properties. If we were to
create another layer in the cache, we would be duplicating the object
graph that we already have in =abstract_object= so the entire idea is
questionable.

A much better way of doing this is to create two types of parameters:

- sequence: odb pragmas
- associative: everything else

Also, parameters are really some kind of meta-data tag, so we should
rename it to avoid confusion. So we have:

- =tag_store=: place where all tags live. we should add methods for easy
  tag retrieval with the right type.
- =Taggable=: concept for those which have the ability of being tagged.
- =tags=: property of Taggable entities.
- =tag_router=: takes a pair of strings and routes it to the right
  location on the =tag_store=.
- =tagger=: visits the model as a graph and propagates tags across
  generalisations and associations.

*** IMPLEMENTATION Create a complete domain formatter in OM           :story:
    CLOCK: [2013-09-26 Thu 22:08]--[2013-09-26 Thu 22:25] =>  0:17
    CLOCK: [2013-09-26 Thu 08:25]--[2013-09-26 Thu 08:33] =>  0:08
    CLOCK: [2013-09-26 Thu 08:06]--[2013-09-26 Thu 08:18] =>  0:12
    CLOCK: [2013-09-26 Thu 07:46]--[2013-09-26 Thu 08:06] =>  0:20
    CLOCK: [2013-09-23 Mon 18:20]--[2013-09-23 Mon 18:50] =>  0:30
    CLOCK: [2013-09-23 Mon 18:12]--[2013-09-23 Mon 18:17] =>  0:05
    CLOCK: [2013-09-23 Mon 17:56]--[2013-09-23 Mon 18:05] =>  0:09
    CLOCK: [2013-09-23 Mon 08:02]--[2013-09-23 Mon 08:15] =>  0:13

The OM domain formatter must produce the same code as the C++
formatter across all types. Add all infrastructure around it such as
SML type visitors, etc.

**** COMPLETED Implement class open and close methods                  :task:
     CLOSED: [2013-09-23 Mon 23:54]
     CLOCK: [2013-09-23 Mon 23:43]--[2013-09-23 Mon 23:54] =>  0:11

**** COMPLETED Refactor unit tests with utility method                 :task:
     CLOSED: [2013-09-24 Tue 08:05]
     CLOCK: [2013-09-24 Tue 07:46]--[2013-09-24 Tue 08:10] =>  0:19
     CLOCK: [2013-09-24 Tue 07:33]--[2013-09-24 Tue 07:43] =>  0:18

**** Add compiler generated constructors                               :task:
*** Create an hydrator from JSON into SML                             :story:

Using the JSON representation defined in the previous iteration (in
data/library) and boost property tree, create an hydrator/transformer
that generates SML models.

*** Create an SML level concept for facets                            :story:

In reality, "facets" are not a C++ thing; they are language
neutral. They are, however, expressed differently in different
languages. For example:

- types: same on all languages
- debug_printing: overloaded operator<< in C++, toString() in Java,
  ToString() in C#, etc.
- serialisation: slightly less obvious, but effectively the most
  "native" serialisation available for the given programming
  language. For C++ this is boost serialisation.
- hashing: language specific support for hashing, in C++ either std
  hash or boost hash, in Java/C# overloading of hash functions.
- test_data: some facilities for test data generation
- relational: bindings for relational databases. ODB in C++.

We can introduce these concepts at the SML level, probably at the
=model= and =abstract_object= level; we can then do further
translation at the language level, as required.

*** Propagatable parameters                                           :story:

Some implementation specific parameters should be propagated along the
composition graph (e.g. boost serialisation status disabled). We could
spot these parameters whilst building the model and do the propagation
there and then.

** Deprecated Development Stories
