g#+title: Release Notes for Sprint 35
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED
#+tags: story(s) epic(e) task(t) note(n) spike(p)

* Release Notes

This file contains all stories that were closed during sprint 35.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2013-09-24 Tue 23:36]

| Headline                                                     | Time   |      |      |
|--------------------------------------------------------------+--------+------+------|
| *Total time*                                                 | *4:22* |      |      |
|--------------------------------------------------------------+--------+------+------|
| Development Stories Implemented                              |        | 4:22 |      |
| IMPLEMENTATION Release notes and backlog grooming            |        |      | 0:12 |
| COMPLETED Refactor OM tests to avoid over-inclusion          |        |      | 0:32 |
| COMPLETED Convert implementation specific parameters to list |        |      | 1:06 |
| COMPLETED Rename implementation specific parameters          |        |      | 0:50 |
| IMPLEMENTATION Create a complete domain formatter in OM      |        |      | 1:42 |
#+end:

*** IMPLEMENTATION Release notes and backlog grooming                  :task:
    CLOCK: [2013-09-23 Mon 07:50]--[2013-09-23 Mon 08:02] =>  0:12

*** COMPLETED Refactor OM tests to avoid over-inclusion               :spike:
    CLOSED: [2013-09-23 Mon 23:41]
    CLOCK: [2013-09-23 Mon 23:05]--[2013-09-23 Mon 23:37] =>  0:32

At present OM builds take too long on slow hardware because we are
using the facet includers in tests. This means that every time a
service changes one has to rebuild all the specs in OM. Include all
the types manually in unit tests to reduce the dependencies.

*** COMPLETED Convert implementation specific parameters to list      :spike:
    CLOSED: [2013-09-24 Tue 22:49]
    CLOCK: [2013-09-24 Tue 23:19]--[2013-09-24 Tue 23:36] =>  0:17
    CLOCK: [2013-09-24 Tue 22:49]--[2013-09-24 Tue 23:19] =>  0:30
    CLOCK: [2013-09-24 Tue 17:56]--[2013-09-24 Tue 18:08] =>  0:12
    CLOCK: [2013-09-24 Tue 08:13]--[2013-09-24 Tue 08:20] =>  0:07

We need to do lookups into the parameters, so a vector is not
suitable. change it to a =std::unordered_map=.

Actually, It is not possible to do this due to the way ODB parameters
work; we need to maintain the order defined by the user (and it needs
to allow for duplicates). However, might as well use a =std::list= instead of
a =std::vector=.

*** COMPLETED Rename implementation specific parameters               :story:
    CLOSED: [2013-09-24 Tue 18:33]
    CLOCK: [2013-09-24 Tue 22:27]--[2013-09-24 Tue 22:49] =>  0:22
    CLOCK: [2013-09-24 Tue 18:12]--[2013-09-24 Tue 18:40] =>  0:28

These should really be called back end specific parameters at the SML
level. At the dia level, if a parameter is passed in which has a
representation at the SML level it should simply be converted to this
representation instead of being added to the KVP.

Actually, these are more like generic parameters:

- at the dia level they are used to fill in gaps in dia (e.g. packages
  and diagrams do not have comments)
- at the SML level, they are used to add information which does not
  make sense for it to be in dia: is property key.
- at the backend level, they are used to provide information which
  does not make sense to live in SML: for example the ODB parameters.

Also, when the string table support has been added, we need to create
a string table with all valid values for the parameter keys.

Name choices:

- opaque parameters
- untyped parameters

*** IMPLEMENTATION Create a complete domain formatter in OM           :story:
    CLOCK: [2013-09-23 Mon 18:20]--[2013-09-23 Mon 18:50] =>  0:30
    CLOCK: [2013-09-23 Mon 18:12]--[2013-09-23 Mon 18:17] =>  0:05
    CLOCK: [2013-09-23 Mon 17:56]--[2013-09-23 Mon 18:05] =>  0:09
    CLOCK: [2013-09-23 Mon 08:02]--[2013-09-23 Mon 08:15] =>  0:13

The OM domain formatter must produce the same code as the C++
formatter across all types. Add all infrastructure around it such as
SML type visitors, etc.

**** COMPLETED Implement class open and close methods
     CLOSED: [2013-09-23 Mon 23:54]
     CLOCK: [2013-09-23 Mon 23:43]--[2013-09-23 Mon 23:54] =>  0:11

**** COMPLETED Refactor unit tests with utility method
     CLOSED: [2013-09-24 Tue 08:05]
     CLOCK: [2013-09-24 Tue 07:46]--[2013-09-24 Tue 08:10] =>  0:19
     CLOCK: [2013-09-24 Tue 07:33]--[2013-09-24 Tue 07:43] =>  0:18

*** Create an hydrator from JSON into SML                             :story:

Using the JSON representation defined in the previous iteration (in
data/library) and boost property tree, create an hydrator/transformer
that generates SML models.

*** Create an SML level concept for facets                            :story:

In reality, "facets" are not a C++ thing; they are language
neutral. They are, however, expressed differently in different
languages. For example:

- types: same on all languages
- debug_printing: overloaded operator<< in C++, toString() in Java,
  ToString() in C#, etc.
- serialisation: slightly less obvious, but effectively the most
  "native" serialisation available for the given programming
  language. For C++ this is boost serialisation.
- hashing: language specific support for hashing, in C++ either std
  hash or boost hash, in Java/C# overloading of hash functions.
- test_data: some facilities for test data generation
- relational: bindings for relational databases. ODB in C++.

We can introduce these concepts at the SML level, probably at the
=model= and =abstract_object= level; we can then do further
translation at the language level, as required.

*** Propagatable parameters                                           :story:

Some implementation specific parameters should be propagated along the
composition graph (e.g. boost serialisation status disabled). We could
spot these parameters whilst building the model and do the propagation
there and then.

** Deprecated Development Stories
