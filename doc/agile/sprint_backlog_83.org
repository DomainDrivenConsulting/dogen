#+title: Sprint Backlog 83
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- finish implementing helper methods dynamically and using yarn types.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-06-22 Wed 16:16]
| <75>                                                                        |         |       |      |       |
| Headline                                                                    | Time    |       |      |     % |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| *Total time*                                                                | *24:22* |       |      | 100.0 |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| Stories                                                                     | 24:22   |       |      | 100.0 |
| Active                                                                      |         | 24:22 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |         |       | 2:19 |   9.5 |
| STARTED Manual updates and blog posts                                       |         |       | 0:44 |   3.0 |
| COMPLETED Refactor helper settings                                          |         |       | 0:35 |   2.4 |
| COMPLETED Add properties for helpers                                        |         |       | 1:35 |   6.5 |
| COMPLETED Consider renaming =yarn::property= to attribute                   |         |       | 1:23 |   5.7 |
| COMPLETED Rename formattables to properties                                 |         |       | 0:50 |   3.4 |
| COMPLETED Rename helper instances                                           |         |       | 0:37 |   2.5 |
| COMPLETED Tidy-up pretty printer                                            |         |       | 1:10 |   4.8 |
| COMPLETED Rename qualified to id                                            |         |       | 0:51 |   3.5 |
| COMPLETED Rename unparsed type  in name tree                                |         |       | 0:47 |   3.2 |
| COMPLETED Add a builder-like API to pretty printer                          |         |       | 1:18 |   5.3 |
| COMPLETED Implement automatic model name detection in name builder          |         |       | 0:51 |   3.5 |
| COMPLETED Populate qualified and identifiable name                          |         |       | 2:05 |   8.5 |
| COMPLETED Rename =name_tree='s parent                                       |         |       | 0:16 |   1.1 |
| COMPLETED Compute yarn property related information                         |         |       | 2:17 |   9.4 |
| COMPLETED Remove redundancy in properties' repositories                     |         |       | 0:22 |   1.5 |
| COMPLETED Create a top-level type to aggregate properties and helpers       |         |       | 1:42 |   7.0 |
| COMPLETED Refactor helper descriptor                                        |         |       | 0:23 |   1.6 |
| COMPLETED Add an helper method interface                                    |         |       | 1:03 |   4.3 |
| COMPLETED Remove encoded from yarn's name tree                              |         |       | 1:24 |   5.7 |
| STARTED Implement types helper methods with new helper infrastructure       |         |       | 1:50 |   7.5 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-06-21 Tue 21:30]--[2016-06-21 Tue 21:42] =>  0:12
    CLOCK: [2016-06-20 Mon 20:45]--[2016-06-20 Mon 21:07] =>  0:22
    CLOCK: [2016-06-20 Mon 15:12]--[2016-06-20 Mon 15:39] =>  0:27
    CLOCK: [2016-06-17 Fri 23:46]--[2016-06-17 Fri 23:50] =>  0:04
    CLOCK: [2016-06-17 Fri 22:55]--[2016-06-17 Fri 23:45] =>  0:50
    CLOCK: [2016-06-17 Fri 10:40]--[2016-06-17 Fri 11:04] =>  0:24

Updates to sprint and product backlog.

*** STARTED Manual updates and blog posts                             :story:
    CLOCK: [2016-06-21 Tue 20:46]--[2016-06-21 Tue 21:30] =>  0:44

Time taken with blog posts and updates to the manual.

*** COMPLETED Refactor helper settings                                :story:
    CLOSED: [2016-06-17 Fri 12:29]
    CLOCK: [2016-06-17 Fri 11:55]--[2016-06-17 Fri 12:29] =>  0:34
    CLOCK: [2016-06-17 Fri 11:50]--[2016-06-17 Fri 11:51] =>  0:01

- use =boost::optional= to denote no helper settings;
- remove the nonsense around visitors since we don't need concrete types;
- add some basic validation to ensure we throw if no family is supplied.

*** COMPLETED Add properties for helpers                              :story:
    CLOSED: [2016-06-17 Fri 22:54]
    CLOCK: [2016-06-17 Fri 22:41]--[2016-06-17 Fri 22:54] =>  0:13
    CLOCK: [2016-06-17 Fri 12:33]--[2016-06-17 Fri 13:11] =>  0:38
    CLOCK: [2016-06-17 Fri 11:05]--[2016-06-17 Fri 11:49] =>  0:44

We should pre-compute all of the required helper instances for a given
element and have them ready for formatting. Create all of the types
required for this.

What we were trying to say in this terse form is this:

- every type needs a set of helpers with zero or more elements. This
  is a set in that there are no duplicates.
- this set is computed on the basis of relationships with other types
  which themselves have helper settings.
- once we got this set, we can then loop through it and ask the
  registrar for the helpers for each family.
- however, we must also have the helper settings next to this
  information as we will need these.
- finally, a given helper may call other methods inside it. This is
  why we need to have the associated helpers. At present this happens
  only in hashing.

Notes:

- we must keep track of types done by complete name. This can be done
  in main function.
- we must remember the children's helper instance properties to
  populate associated helpers (but just direct children). This can be
  achieved by returning these in the recursive function.
- we must build helper instances for all children. This requires
  supplying a list by reference.
- we must build the complete name.
- we need the complete name in two places: helpers and properties. For
  properties all we care about is the top-level complete name. We
  don't really need identifiable names etc. For helpers we need the
  child complete names and their identifiable versions. Since we are
  using C++ syntax for the unparsed type, we could extend this logic
  and move the unparsed type from the property into the name tree - at
  all levels.

*Previous Understanding*

We need to store the identifiable name of the name tree, as well as
the language specific representation of the type. The container should
make use of the name tree index - e.g. use a vector. The only problem
is that we do not know what the size of the container is without doing
look ups. We could have a property nested name size in
stateful. Naming it is not easy though. Nested name cardinality?

*Previous Understanding*

We need to store the identifiable name of the nested name, as well as
the language specific representation of the type. These are properties
at the level of the =yarn::property=. The container should make use of
the index - e.g. use a vector of size of properties list.

Note that these are not properties of the property, but instead
properties of the property type.

Actually this is not correct; we need the properties for each nested
name and for each particular nested name structure, possibly unique to
each property. An alternative is then to come up with an index that
takes into account the nesting (effectively flattens the nested
structure). The index starts at zero for a type and increments for
every property for every level of nesting. Each nested name has an
index. Then, nested name properties is a flat container for each name
with the required properties. With this the helpers can continue to
rely on just the nested name (plus the nested name properties via the
assistant).

*** COMPLETED Consider renaming =yarn::property= to attribute         :story:
    CLOSED: [2016-06-18 Sat 01:13]
    CLOCK: [2016-06-17 Fri 23:50]--[2016-06-18 Sat 01:13] =>  1:23

Since we use properties quite a lot in =quilt.cpp= - and more so when
we rename formattables to properties - we should probably avoid the
need to overload the term in yarn. We could rename it to attribute.

Or perhaps the problem is with formatter properties. After all these
are not "properties of the formatter"; these are inputs into the
formatting process (and so are settings).

We need to add properties for =yarn::property= so it cannot stay as
property. We cannot think of a better name other than "properties" for
formatters so yarn will have to be renamed.

Actually this is no longer urgent so the story can go back to backlog.

*** COMPLETED Rename formattables to properties                       :story:
    CLOSED: [2016-06-18 Sat 02:04]
    CLOCK: [2016-06-18 Sat 01:14]--[2016-06-18 Sat 02:04] =>  0:50

Now that we are getting close to the end of the quilt refactor we
should rename formattables to properties.

*** COMPLETED Rename helper instances                                 :story:
    CLOSED: [2016-06-18 Sat 02:42]
    CLOCK: [2016-06-18 Sat 02:05]--[2016-06-18 Sat 02:42] =>  0:37

- rename helper instances etc to helper properties
- rename helper properties etc to helper descriptor

*** COMPLETED Tidy-up pretty printer                                  :story:
    CLOSED: [2016-06-19 Sun 12:13]
    CLOCK: [2016-06-19 Sun 12:05]--[2016-06-19 Sun 12:13] =>  0:08
    CLOCK: [2016-06-19 Sun 11:02]--[2016-06-19 Sun 12:04] =>  1:02

- rename it to just pretty printer as it will print more than names
  soon.
- clean up printing styles - these are just separators. Also make it
  explicit as the double colon rather than scope operator since we are
  not using language specific terminology at this level. We don't need
  to worry about =.= operator for now (as we don't yet support java or
  C#) but the code should be refactored to make it easy to add it.
- add support for printing to stream.

*** COMPLETED Rename qualified to id                                  :story:
    CLOSED: [2016-06-19 Sun 12:37]
    CLOCK: [2016-06-20 Mon 21:41]--[2016-06-20 Mon 21:58] =>  0:17
    CLOCK: [2016-06-19 Sun 12:36]--[2016-06-19 Sun 12:49] =>  0:13
    CLOCK: [2016-06-19 Sun 12:14]--[2016-06-19 Sun 12:35] =>  0:21

Now that we have language specific qualified names, it became obvious
that what we are calling "qualified" is not a qualified name at all
but an identifier. Rename:

- qualified to id
- qualified for to qualified.

*** COMPLETED Rename unparsed type  in name tree                      :story:
    CLOSED: [2016-06-19 Sun 13:37]
    CLOCK: [2016-06-19 Sun 12:50]--[2016-06-19 Sun 13:37] =>  0:47

The name "unparsed type" in name tree is very misleading because:

- we are parsing the type in order to obtain the child representation;
- it is using a dogen specific notation.

We need to rename it, and also make identifiable clearer.

Actually we just can't think of a good name for identifiable so let's
stick with that for now.

*** COMPLETED Add a builder-like API to pretty printer                :story:
    CLOSED: [2016-06-19 Sun 21:00]
    CLOCK: [2016-06-19 Sun 20:13]--[2016-06-19 Sun 21:00] =>  0:47
    CLOCK: [2016-06-19 Sun 18:14]--[2016-06-19 Sun 18:43] =>  0:29
    CLOCK: [2016-06-19 Sun 13:38]--[2016-06-19 Sun 13:40] =>  0:02

- make the entire API a builder based API, even for the simpler case
  of printing just a name.
- implement name tree builder with new API.

*Previous Understanding*

The more one thinks about it the more pretty printer looks weird:

- it is not actually pretty printing types for user visualisation; it
  is encoding types according to a scheme into a string
  representation.
- the name tree "pretty printing" is partially done in name tree
  builder.
- in order to move it to "pretty printer" avoiding looping through the
  tree again we need a builder interface.

So:

- rename =pretty_printer= to =encoder=;
- add an =encoder::builder= which handles name trees.

Encoder is a bit of a strong name though. Some reading up on printing
AST into code reveals a couple of possibilities:

- rewriter: clang; not ideal
- code printer: closure.

Lets go with =name_printer=. A bit misleading since we also do name
tree's but better than just petty printer.

Final decision on this:

- make the entire API a builder based API, even for the simpler case
  of printing just a name.
- after much discussion with names, the name that seems to lie the
  list is still =pretty_printer=. We will have to stick with that for
  now.

*** COMPLETED Implement automatic model name detection in name builder :story:
    CLOSED: [2016-06-19 Sun 23:19]
    CLOCK: [2016-06-19 Sun 22:33]--[2016-06-19 Sun 23:18] =>  0:45
    CLOCK: [2016-06-19 Sun 21:25]--[2016-06-19 Sun 21:31] =>  0:06

At present we have a flag in name builder to detect if we are building
a model name; if so, we deal with the simple name correctly. However,
we implemented some logic in quilt that detects this without user
input. Remove the flag and add this logic.

Actually, instead of wasting cycles detecting things, we should just
have modes of operation - we always know when we are building a model
name.

*** COMPLETED Populate qualified and identifiable name                :story:
    CLOSED: [2016-06-20 Mon 01:03]
    CLOCK: [2016-06-20 Mon 00:03]--[2016-06-20 Mon 01:03] =>  1:00
    CLOCK: [2016-06-19 Sun 23:30]--[2016-06-20 Mon 00:02] =>  0:32
    CLOCK: [2016-06-19 Sun 23:20]--[2016-06-19 Sun 23:30] =>  0:10
    CLOCK: [2016-06-19 Sun 21:01]--[2016-06-19 Sun 21:24] =>  0:23

We need to populate the new name and name tree properties for
qualified and identifiable name.

*** COMPLETED Rename =name_tree='s parent                             :story:
    CLOSED: [2016-06-20 Mon 01:20]
    CLOCK: [2016-06-20 Mon 01:04]--[2016-06-20 Mon 01:20] =>  0:16

Parent is not a good name as we are referring to the current
node. Maybe =self=? We went with =current= in the end. Not ideal, but
at least it does not lie like =parent= did.

*** COMPLETED Create a module indexer in sml                          :story:
    CLOSED: [2016-06-20 Mon 15:39]

*Rationale*: This was done as part of the yarn refactors.

We need to create a class that computes module containment. At present
this is done in JSON hydrator.

In addition, we also have huge amounts of nonsense in injector, in
particular =add_containing_module_to_non_contained_entities=. This
should also be handled by the module indexer.

*** COMPLETED Remove complete name and use qualified name             :story:
    CLOSED: [2016-06-20 Mon 15:39]

*Rationale*: This won't be a problem after the
formattables/properties/fabric refactor in quilt.

At present we have both complete name and qualified name in
formatables. Qualified name is blank. We should remove complete name
and populate qualified name.

This is in nested type info.

*** COMPLETED Thoughts on simplifying the formattables generation     :story:
    CLOSED: [2016-06-20 Mon 15:39]

*Rationale*: This is already under way with the
formattables/properties/fabric refactor in quilt.

We have a problem in the way which we are doing the formattables:
because we are doing model traversals for each of the factories, we
cannot easily introduce a set of manually generated qnames such as the
registrar and includers. However, if we started off the main workflow
by creating a structure like so:

- qname
- optional entity (new base class in yarn); if null we need to create
  extensions as an empty object.

We then need a list of these that get passed in to all repository
factories. These use a visitor of entity to resolve to a type (where
required).

We can inject types to this list that have a qname but no entity. For
these we generate some parts of the formatter properties. Actually, we
still need to generate inclusion lists even when there is no
entity. Perhaps we need to create a new method in the provider that
does not take an yarn entity but still generates the inclusion list.

Actually this should all be done in yarn. We should have zero qname
look-ups coming out of yarn, just follow references. This story is a
variation of the split between "partial" models and "full" models.

Well not everything should be done in yarn. We still need to create a
structure with the properties above, but that is done by iterating
through a list in the yarn model.

One slight problem with this approach: sometimes we need to preserve
some relationships in the newly generated objects. For registrar we
need to preserve the model leaves. For the includers / master headers
we need to express somehow the inclusion relationship at the formatter
level. The latter is definitely a special case because it is a pure
C++ concept: include files cannot be modeled in yarn. However,
registrar is slightly different because we still need to compute the
includes based on the leaves. This means that the above approach will
not provide a clean solution, unless we synthesise an yarn object when
providing the includes. And of course we need to be careful taking
that route or else we will end up generating the object across all
facets.

*** COMPLETED Move all properties in =cpp= to a properties namespace  :story:
    CLOSED: [2016-06-20 Mon 15:39]

Once all formattables are gone, we should have only properties left in
the formattables namespace. We should then rename it to
properties. Thus we have two kinds of things: settings, which are a
direct translation of meta-data without any further processing and
properties which require processing.

Merged stories:

*Split formatter properties and associated classes from formattables*

We have two kinds of data: the formattables themselves (mapped from
yarn) and associated data (formatter properties). The latter is
totally independent. We should create a namespace for all of these
classes and a workflow that produces the data ready for consumption. A
tentative name is =manifest=.

*** COMPLETED Compute yarn property related information               :story:
    CLOSED: [2016-06-20 Mon 15:44]
    CLOCK: [2016-06-21 Tue 23:33]--[2016-06-22 Wed 00:14] =>  0:41
    CLOCK: [2016-06-18 Sat 23:05]--[2016-06-18 Sat 23:10] =>  0:05
    CLOCK: [2016-06-18 Sat 22:52]--[2016-06-18 Sat 23:04] =>  0:12
    CLOCK: [2016-06-18 Sat 22:05]--[2016-06-18 Sat 22:51] =>  0:46
    CLOCK: [2016-06-18 Sat 08:13]--[2016-06-18 Sat 08:46] =>  0:33

Now that we no longer have nested type infos, we need to recompute the
complete names etc for all properties up front and store them in a
repository. This information is almost identical to that of the
helpers but its not easy to share it. For now we should just brute
force it and then look for patterns.

By brute-force it we mean recompute it every time we need to use
it. Or alternatively we could just add these directly to the name
tree. After all they are (or should be) applicable to all languages.

- add the three properties to name tree;
- add logic to compute them into yarn;
- change helpers to reuse this.

Actually the qualified name is language specific. Having said that,
its such a minimal thing that we could conceivably add it to yarn: we
could have a language specific representation on a a container.

- add enumeration for language as per language agnostic story
  (backlog);
- add language specific containers for qualified name.

We need to update the name pretty printer to take on responsibilities
from the name builder in quilt:

- add support for name trees - and so rename it to just pretty
  printer? We can then have a print name and a print name tree.
- the name builder can then be responsible for programming language
  specific logic and calls to the pretty printer to populate the new
  properties.

*** COMPLETED Remove redundancy in properties' repositories           :story:
    CLOSED: [2016-06-20 Mon 16:36]
    CLOCK: [2016-06-20 Mon 21:08]--[2016-06-20 Mon 21:16] =>  0:08
    CLOCK: [2016-06-20 Mon 16:22]--[2016-06-20 Mon 16:36] =>  0:14

At present we have attributes in repositories such as:

: path_derivatives_by_name

Since we are in =path_derivatives_repository=, perhaps we could call
the attribute simply =by_name=.

*** COMPLETED Create a top-level type to aggregate properties and helpers :story:
    CLOSED: [2016-06-20 Mon 19:00]
    CLOCK: [2016-06-20 Mon 18:32]--[2016-06-20 Mon 19:00] =>  0:28
    CLOCK: [2016-06-20 Mon 16:57]--[2016-06-20 Mon 17:34] =>  0:37
    CLOCK: [2016-06-20 Mon 16:08]--[2016-06-20 Mon 16:22] =>  0:14
    CLOCK: [2016-06-20 Mon 15:44]--[2016-06-20 Mon 16:07] =>  0:23

We need a way to create an aggregate type that contains all of the
"auxiliary" information about a type: basically formatter properties
and helper settings.

This type should be called =element_properties=.

- change the return type of the properties workflow to be element
  properties (well pair of element properties and formattables - for
  now).
- have a look at the context type in formatters. Looked at this, we
  just need to do minor updates to it to take in the element
  properties.

*** COMPLETED Refactor helper descriptor                              :story:
    CLOSED: [2016-06-20 Mon 21:39]
    CLOCK: [2016-06-20 Mon 21:17]--[2016-06-20 Mon 21:40] =>  0:23

It seems there is an impedance mismatch between the helper formatters
and the helper descriptor. These are expecting a name tree. Since we
have all the required information in the name tree, we don't even need
the descriptor any more.

The problem with this approach though is that its no longer clear
which type we are helping though. Best to tidy-up the descriptor to
make sure the name reflect the yarn provenience.

*** COMPLETED Add an helper method interface                          :story:
    CLOSED: [2016-06-20 Mon 23:22]
    CLOCK: [2016-06-20 Mon 22:56]--[2016-06-20 Mon 23:21] =>  0:25
    CLOCK: [2016-06-20 Mon 22:45]--[2016-06-20 Mon 22:55] =>  0:10
    CLOCK: [2016-06-20 Mon 22:16]--[2016-06-20 Mon 22:44] =>  0:28

We should also investigate on the need for the nested type info
assistant.

Tasks:

- create interface.
- add interface to registrar.
- implement interface in at least one helper.
- update assistant to query registrar for helpers based on type family
  in context. Performs a recursive descent on nested name.
- problem: io helpers in types should only be enabled if io is enabled
  and if type is in an inheritance relationship. For this we need to
  have access to formatter properties (potentially via assistant) but
  we also need to have access to the type that owns the properties. We
  could augment helper interface with the assistant - easy as we
  already have it on the format method - and the element - harder; we
  need to supply the object as part of helper method creation.
- problem: we need to ask for complete and identifiable name N times
  for a given formatter. It is not a good idea to dynamically compute
  it or to store it in an associative container - it somehow needs to
  be next to the nested name.

*Previous Understanding*

- create a registrar for interface with family and formatter name.
- update all helpers to implement interface and to register
  themselves.
- it seems we have two use cases here: the formatter helper interface
  for formatting purposes and the helper family interface that tells
  us what formatter this helper belongs to. We do not want to leak
  details of formatting into formattables. We need to find a name for
  such an interface in formattables, a bit like the inclusion
  dependencies provider. Formatter helper details provider? We can
  then extend the existing formattables registrar and container to
  store this interface; the formatter helper interface can extend this
  interface; the main workflow returns all registered formatter
  helpers in terms of the formatter helper details provider interface.
- problem: we need additional properties related to the helper which
  have been hard-coded:
  - requires generic string; in a general form "string conversion
    method";
  - requires quoting;
  - requires tidying up; in a general form "remove unprintable
    characters";
  - requires hashing helper method; in a general form: we need a way
    to query the helper settings to figure out if a given type has an
    associated helper method for a given formatter, and if we need to
    call it implicitly or explicitly; and, if explicitly, we need to
    ask the helper method formatter for the name of the helper method.
  - requires dereferencing; for pointer types.
- seems like yet again we found the wrong solution for this
  problem. We need to create a top-level set of helper settings for
  each type with all additional properties; propagate those into
  formatters via context; and then use the assistant to loop through
  the nested name (nested info for now) and pick the helper
  settings. It should also consult the registrar to see if there are
  any helpers available for this formatter and family.

*** COMPLETED Remove encoded from yarn's name tree                    :story:
    CLOSED: [2016-06-21 Tue 23:33]
    CLOCK: [2016-06-21 Tue 23:09]--[2016-06-21 Tue 23:33] =>  0:24
    CLOCK: [2016-06-21 Tue 22:08]--[2016-06-21 Tue 23:08] =>  1:00

Encoded was a mistake: we don't really need to preserve the
intermediate format for the type in a non-language specific way (at
least not at the moment). What we do need is a language specific
qualified name tree.

We also need the helper descriptor to follow the same pattern.

*** STARTED Implement types helper methods with new helper infrastructure :story:
    CLOCK: [2016-06-22 Wed 15:47]--[2016-06-22 Wed 16:16] =>  0:29
    CLOCK: [2016-06-22 Wed 15:30]--[2016-06-22 Wed 15:46] =>  0:16
    CLOCK: [2016-06-21 Tue 21:46]--[2016-06-21 Tue 22:07] =>  0:21
    CLOCK: [2016-06-21 Tue 20:01]--[2016-06-21 Tue 20:45] =>  0:44

- call the new method from the formatters in types and ensure the
  generated code matches previous code.
- remove/disable all legacy helper method generation.

Notes:

- there can be more than one helper for a given formatter and
  family. Example: types needs both IO and types helpers.
- conversely a helper can have more than one owning formatter (io
  helper has types and io formatters).
- helper's is enabled is similar to includes provision: we need access
  to the yarn object to determine if the helper is enabled.

*** Add validation for helper families                                :story:

At present we are checking that the name tree has the expected number
of type arguments:

:    const auto children(t.children());
:    if (children.size() != 1) {
:        BOOST_LOG_SEV(lg, error) << invalid_smart_pointer;
:        BOOST_THROW_EXCEPTION(formatting_error(invalid_smart_pointer));
:    }
:    smart_pointer_helper_stitch(fa, t);

In the future with dynamic helpers we will remove these checks. In
order to implement them we need to declare the type families up front
in a JSON file, with a name and number of type arguments. When
constructing the type helpers, we can check the name tree to make sure
the number of type arguments is correct.

*** Update assistant to use new helper information                    :story:

Once all the pieces are in place, the assistant can then use the
element properties to find out which helpers are required for each
type; call those helpers and populate the file with the generate
code. We can remove all previous helper support.

*** Create a settings class for the "requires" settings               :story:

We need to populate these in a settings workflow of some kind.

*** Consider caching "all modules" in location                        :story:

At present we are adding the module lists together to build the
qualified name; location could have a "all modules" list that
concatenates external, model and internal modules. We should look at
performance before doing this change though.

*** Consider reducing the number of qname lookups in cpp model        :story:

At present we are still using =yarn::name= in a lot of repositories in
quilt. We already had one go in moving to id's but there are still
quite a few left. Investigate to see if there are more that can be
moved.

*** Implement formattables in terms of yarn types                     :epic:

At present formattables are just a shadow copy of yarn types plus
additional =cpp= specific types. In practice:

- for the types that are shadow copies, we could have helper utilities
  that do the translation on the fly (e.g. for names).
- for additional information which cannot be translated, we could have
  containers indexed by qualified name and query those just before we
  call the transformer. This is the case with formatter properties. We
  need something similar to house "type properties" such as
  =requires_stream_manipulators=. These could be moved into aspect
  settings.
- for types that do not exist in yarn, we could inherit from element;
  this is the case for registrar, forward declarations, cmakelists and
  odb options. Note that with this we are now saying that element
  space contains anything which can be modeled, regardless of if they
  are part of the programming language type system, or build system,
  etc. This is not ideal, but its not a problem just yet. We could
  update the factory to generate these types and then take a copy of
  the model and inject them in it.

*** Remove nested type info                                           :story:

Once all of the infrastructure is in place, we should not need this
class any more. Remove code from transformer and remove object types
and anything else that was used to dispatch based on type.

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

*** Consider using indices rather than associative containers         :story:

Once we generate the final model the model becomes constant; this
means we can easily assign an [[https://en.wikipedia.org/wiki/Ordinal_number][ordinal number]] to each model
element. These could be arranged so that we always start with
generatable types first; this way we always generate dense
containers - there are some cases where we need both generatable types
and non-generatable types; in other cases we just need generatable
types; we never need just non-generatable types. We also need to know
the position of the first non-generatable type (or alternatively, the
size of the generatable types set).

Once we have this, we can start creating vectors with a fixed size
(either total number of elements or just size of generatable
types). We can also make it so that each name has an id which is the
ordinal (another model post-processing activity). Actually we should
call it "type index" or some other name because its a transient
id. This means both properties and settings require no lookups at all
since all positions are known beforehand (except in cases where the
key of the associative container must be the =yarn::name= because we
use it for processing).

In theory, a similar approach can be done for formatters too. We know
upfront what the ordinal number is for each formatter because they are
all registered before we start processing. If formatters obtained
their ordinal number at registration, wherever we are using a map of
formatter name to a resource, we could use a fixed-size
vector. However, formatters may be sparse in many cases (if not all
cases?). For example, we do not have formatter properties for all
formatters for every =yarn::name= because many (most) formatters don't
make sense for every yarn type. Thus this is less applicable, at least
for formatter properties. We need to look carefully at all use cases
and see if there is any place where this approach is applicable.

*** Handle "special includes" correctly                               :story:

We did a quick hack to handle "special includes": we simply "detected"
them in include builder and then did the appropriate action in each of
the include providers. In order to make this work dynamically, we need
somehow to have "associated includes" on a per type basis. For
example:

- type =x= requires include =y= in formatter =f=.

This can easily be achieved via an "additional inclusion directive"
which is a container. For example:

:        "extensions" : {
:                "quilt.cpp.helper.family" : "Dereferenceable",
:                "quilt.cpp.types.class_header_formatter.inclusion_directive" : "<boost/weak_ptr.hpp>",

Could have:

:                "quilt.cpp.types.class_header_formatter.additional_inclusion_directive" : "<some_include.hpp>",

If multiple are provided then they are all added. This highlights an
important point: we need a way to inject type specific includes from a
formatter. It makes no sense to declare all of these up front in a
library since we do not know what all possible formatters are, nor
what requirements they may have for inclusion. At the same time,
formatters cannot be expected to declare types. The solution is to be
able to "inject" these dependencies from a JSON file associated with
the formatter. We could supply the qualified name and the properties
to inject. This problem can be solved later on - create a separate
story for this.

*** Registrar in serialisation is not stable sorted                   :story:

We seem to have a traffic light diff on =registrar_ser.cpp=:

: -    dogen::config::register_types(ar);
:      dogen::quilt::cpp::register_types(ar);
:      dogen::yarn::register_types(ar);
: +    dogen::config::register_types(ar);

This is probably a lack of a stable sort in model dependencies.

*** Support only specific attributes for certain facets               :story:

Whenever an object has a unique identifier, it may make sense to make
use of it for:

- hashing
- equality
- less than

And so forth. For example, names and name trees don't really require
comparing the entire state of the object. We need a way to mark
properties against each facet in the meta-data.

** Deprecated
*** CANCELLED Investigate slow down                                   :story:
    CLOSED: [2016-06-20 Mon 15:51]

*Rationale*: Speed is back to normal so lets not waste time on this.

With commit 7e89ddb we introduced a set of hacks to inject settings
and formatter properties into the repositories. This seems to have had
a very negative impact in performance. We need to ensure performance
goes back to normal after the hacks have been removed.

*** CANCELLED Consider splitting =formattables::transformer=          :story:
    CLOSED: [2016-06-20 Mon 15:51]

*Rationale*: We will decom transformer so no need to worry.

We have two different responsibilities within transformer:

- to perform an individual (1-1) transformation of a tack type into a
  formatable;
- to determine how many transformations of a tack type are required,
  and to do them.

Maybe we should have a transformer sub-workflow that collaborates with
specific transformers, aligned to =cpp= types
(e.g. =class_info_transformer=, =enum_info_transformer= and so on,
each taking different tack types). The role of the top-level
transformer is to call all of the sub-transformers for a given tack
type.

The other option is to align them to tack types and to produce
different =cpp= types.
