#+title: Sprint Backlog 83
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- implement helper methods dynamically for as many facets as possible.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-06-29 Wed 15:40]
| <75>                                                                        |         |       |      |       |
| Headline                                                                    | Time    |       |      |     % |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| *Total time*                                                                | *38:02* |       |      | 100.0 |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| Stories                                                                     | 38:02   |       |      | 100.0 |
| Active                                                                      |         | 38:02 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |         |       | 3:57 |  10.4 |
| STARTED Manual updates and blog posts                                       |         |       | 0:53 |   2.3 |
| COMPLETED Refactor helper settings                                          |         |       | 0:35 |   1.5 |
| COMPLETED Add properties for helpers                                        |         |       | 1:35 |   4.2 |
| COMPLETED Consider renaming =yarn::property= to attribute                   |         |       | 1:23 |   3.6 |
| COMPLETED Rename formattables to properties                                 |         |       | 0:50 |   2.2 |
| COMPLETED Rename helper instances                                           |         |       | 0:37 |   1.6 |
| COMPLETED Tidy-up pretty printer                                            |         |       | 1:10 |   3.1 |
| COMPLETED Rename qualified to id                                            |         |       | 0:51 |   2.2 |
| COMPLETED Rename unparsed type  in name tree                                |         |       | 0:47 |   2.1 |
| COMPLETED Add a builder-like API to pretty printer                          |         |       | 1:18 |   3.4 |
| COMPLETED Implement automatic model name detection in name builder          |         |       | 0:51 |   2.2 |
| COMPLETED Populate qualified and identifiable name                          |         |       | 2:05 |   5.5 |
| COMPLETED Rename =name_tree='s parent                                       |         |       | 0:16 |   0.7 |
| COMPLETED Compute yarn property related information                         |         |       | 2:17 |   6.0 |
| COMPLETED Remove redundancy in properties' repositories                     |         |       | 0:22 |   1.0 |
| COMPLETED Create a top-level type to aggregate properties and helpers       |         |       | 1:42 |   4.5 |
| COMPLETED Refactor helper descriptor                                        |         |       | 0:23 |   1.0 |
| COMPLETED Add an helper method interface                                    |         |       | 1:03 |   2.8 |
| COMPLETED Remove encoded from yarn's name tree                              |         |       | 1:24 |   3.7 |
| COMPLETED Add support for helpers bound to multiple formatters.             |         |       | 0:41 |   1.8 |
| COMPLETED Add class info to is enabled in formatter helper interface        |         |       | 0:29 |   1.3 |
| COMPLETED Fix issues with build in laptop                                   |         |       | 0:48 |   2.1 |
| COMPLETED Remove helper name from formatter helper interface                |         |       | 0:08 |   0.4 |
| COMPLETED Fix a number of Windows build errors                              |         |       | 0:41 |   1.8 |
| COMPLETED Fix Mingw build's warning                                         |         |       | 0:10 |   0.4 |
| COMPLETED Implement types helper methods with new helper infrastructure     |         |       | 3:12 |   8.4 |
| COMPLETED Move identifiable and qualified to assistant                      |         |       | 0:32 |   1.4 |
| COMPLETED Refactor helper properties yet again                              |         |       | 2:56 |   7.7 |
| COMPLETED Remove =aggregator= in dynamic                                    |         |       | 0:07 |   0.3 |
| STARTED Rename aspect settings to element settings                          |         |       | 0:38 |   1.7 |
| STARTED Implement IO helper methods with new helper infrastructure          |         |       | 3:21 |   8.8 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-06-29 Wed 14:37]--[2016-06-29 Wed 14:52] =>  0:15
    CLOCK: [2016-06-27 Mon 15:35]--[2016-06-27 Mon 16:15] =>  0:40
    CLOCK: [2016-06-24 Fri 13:10]--[2016-06-24 Fri 13:17] =>  0:07
    CLOCK: [2016-06-23 Thu 08:17]--[2016-06-23 Thu 08:22] =>  0:05
    CLOCK: [2016-06-22 Wed 20:39]--[2016-06-22 Wed 20:49] =>  0:10
    CLOCK: [2016-06-22 Wed 16:17]--[2016-06-22 Wed 16:38] =>  0:21
    CLOCK: [2016-06-21 Tue 21:30]--[2016-06-21 Tue 21:42] =>  0:12
    CLOCK: [2016-06-20 Mon 20:45]--[2016-06-20 Mon 21:07] =>  0:22
    CLOCK: [2016-06-20 Mon 15:12]--[2016-06-20 Mon 15:39] =>  0:27
    CLOCK: [2016-06-17 Fri 23:46]--[2016-06-17 Fri 23:50] =>  0:04
    CLOCK: [2016-06-17 Fri 22:55]--[2016-06-17 Fri 23:45] =>  0:50
    CLOCK: [2016-06-17 Fri 10:40]--[2016-06-17 Fri 11:04] =>  0:24

Updates to sprint and product backlog.

*** STARTED Manual updates and blog posts                             :story:
    CLOCK: [2016-06-22 Wed 22:22]--[2016-06-22 Wed 22:31] =>  0:09
    CLOCK: [2016-06-21 Tue 20:46]--[2016-06-21 Tue 21:30] =>  0:44

Time taken with blog posts and updates to the manual.

*** COMPLETED Refactor helper settings                                :story:
    CLOSED: [2016-06-17 Fri 12:29]
    CLOCK: [2016-06-17 Fri 11:55]--[2016-06-17 Fri 12:29] =>  0:34
    CLOCK: [2016-06-17 Fri 11:50]--[2016-06-17 Fri 11:51] =>  0:01

- use =boost::optional= to denote no helper settings;
- remove the nonsense around visitors since we don't need concrete types;
- add some basic validation to ensure we throw if no family is supplied.

*** COMPLETED Add properties for helpers                              :story:
    CLOSED: [2016-06-17 Fri 22:54]
    CLOCK: [2016-06-17 Fri 22:41]--[2016-06-17 Fri 22:54] =>  0:13
    CLOCK: [2016-06-17 Fri 12:33]--[2016-06-17 Fri 13:11] =>  0:38
    CLOCK: [2016-06-17 Fri 11:05]--[2016-06-17 Fri 11:49] =>  0:44

We should pre-compute all of the required helper instances for a given
element and have them ready for formatting. Create all of the types
required for this.

What we were trying to say in this terse form is this:

- every type needs a set of helpers with zero or more elements. This
  is a set in that there are no duplicates.
- this set is computed on the basis of relationships with other types
  which themselves have helper settings.
- once we got this set, we can then loop through it and ask the
  registrar for the helpers for each family.
- however, we must also have the helper settings next to this
  information as we will need these.
- finally, a given helper may call other methods inside it. This is
  why we need to have the associated helpers. At present this happens
  only in hashing.

Notes:

- we must keep track of types done by complete name. This can be done
  in main function.
- we must remember the children's helper instance properties to
  populate associated helpers (but just direct children). This can be
  achieved by returning these in the recursive function.
- we must build helper instances for all children. This requires
  supplying a list by reference.
- we must build the complete name.
- we need the complete name in two places: helpers and properties. For
  properties all we care about is the top-level complete name. We
  don't really need identifiable names etc. For helpers we need the
  child complete names and their identifiable versions. Since we are
  using C++ syntax for the unparsed type, we could extend this logic
  and move the unparsed type from the property into the name tree - at
  all levels.

*Previous Understanding*

We need to store the identifiable name of the name tree, as well as
the language specific representation of the type. The container should
make use of the name tree index - e.g. use a vector. The only problem
is that we do not know what the size of the container is without doing
look ups. We could have a property nested name size in
stateful. Naming it is not easy though. Nested name cardinality?

*Previous Understanding*

We need to store the identifiable name of the nested name, as well as
the language specific representation of the type. These are properties
at the level of the =yarn::property=. The container should make use of
the index - e.g. use a vector of size of properties list.

Note that these are not properties of the property, but instead
properties of the property type.

Actually this is not correct; we need the properties for each nested
name and for each particular nested name structure, possibly unique to
each property. An alternative is then to come up with an index that
takes into account the nesting (effectively flattens the nested
structure). The index starts at zero for a type and increments for
every property for every level of nesting. Each nested name has an
index. Then, nested name properties is a flat container for each name
with the required properties. With this the helpers can continue to
rely on just the nested name (plus the nested name properties via the
assistant).

*** COMPLETED Consider renaming =yarn::property= to attribute         :story:
    CLOSED: [2016-06-18 Sat 01:13]
    CLOCK: [2016-06-17 Fri 23:50]--[2016-06-18 Sat 01:13] =>  1:23

Since we use properties quite a lot in =quilt.cpp= - and more so when
we rename formattables to properties - we should probably avoid the
need to overload the term in yarn. We could rename it to attribute.

Or perhaps the problem is with formatter properties. After all these
are not "properties of the formatter"; these are inputs into the
formatting process (and so are settings).

We need to add properties for =yarn::property= so it cannot stay as
property. We cannot think of a better name other than "properties" for
formatters so yarn will have to be renamed.

Actually this is no longer urgent so the story can go back to backlog.

*** COMPLETED Rename formattables to properties                       :story:
    CLOSED: [2016-06-18 Sat 02:04]
    CLOCK: [2016-06-18 Sat 01:14]--[2016-06-18 Sat 02:04] =>  0:50

Now that we are getting close to the end of the quilt refactor we
should rename formattables to properties.

*** COMPLETED Rename helper instances                                 :story:
    CLOSED: [2016-06-18 Sat 02:42]
    CLOCK: [2016-06-18 Sat 02:05]--[2016-06-18 Sat 02:42] =>  0:37

- rename helper instances etc to helper properties
- rename helper properties etc to helper descriptor

*** COMPLETED Tidy-up pretty printer                                  :story:
    CLOSED: [2016-06-19 Sun 12:13]
    CLOCK: [2016-06-19 Sun 12:05]--[2016-06-19 Sun 12:13] =>  0:08
    CLOCK: [2016-06-19 Sun 11:02]--[2016-06-19 Sun 12:04] =>  1:02

- rename it to just pretty printer as it will print more than names
  soon.
- clean up printing styles - these are just separators. Also make it
  explicit as the double colon rather than scope operator since we are
  not using language specific terminology at this level. We don't need
  to worry about =.= operator for now (as we don't yet support java or
  C#) but the code should be refactored to make it easy to add it.
- add support for printing to stream.

*** COMPLETED Rename qualified to id                                  :story:
    CLOSED: [2016-06-19 Sun 12:37]
    CLOCK: [2016-06-20 Mon 21:41]--[2016-06-20 Mon 21:58] =>  0:17
    CLOCK: [2016-06-19 Sun 12:36]--[2016-06-19 Sun 12:49] =>  0:13
    CLOCK: [2016-06-19 Sun 12:14]--[2016-06-19 Sun 12:35] =>  0:21

Now that we have language specific qualified names, it became obvious
that what we are calling "qualified" is not a qualified name at all
but an identifier. Rename:

- qualified to id
- qualified for to qualified.

*** COMPLETED Rename unparsed type  in name tree                      :story:
    CLOSED: [2016-06-19 Sun 13:37]
    CLOCK: [2016-06-19 Sun 12:50]--[2016-06-19 Sun 13:37] =>  0:47

The name "unparsed type" in name tree is very misleading because:

- we are parsing the type in order to obtain the child representation;
- it is using a dogen specific notation.

We need to rename it, and also make identifiable clearer.

Actually we just can't think of a good name for identifiable so let's
stick with that for now.

*** COMPLETED Add a builder-like API to pretty printer                :story:
    CLOSED: [2016-06-19 Sun 21:00]
    CLOCK: [2016-06-19 Sun 20:13]--[2016-06-19 Sun 21:00] =>  0:47
    CLOCK: [2016-06-19 Sun 18:14]--[2016-06-19 Sun 18:43] =>  0:29
    CLOCK: [2016-06-19 Sun 13:38]--[2016-06-19 Sun 13:40] =>  0:02

- make the entire API a builder based API, even for the simpler case
  of printing just a name.
- implement name tree builder with new API.

*Previous Understanding*

The more one thinks about it the more pretty printer looks weird:

- it is not actually pretty printing types for user visualisation; it
  is encoding types according to a scheme into a string
  representation.
- the name tree "pretty printing" is partially done in name tree
  builder.
- in order to move it to "pretty printer" avoiding looping through the
  tree again we need a builder interface.

So:

- rename =pretty_printer= to =encoder=;
- add an =encoder::builder= which handles name trees.

Encoder is a bit of a strong name though. Some reading up on printing
AST into code reveals a couple of possibilities:

- rewriter: clang; not ideal
- code printer: closure.

Lets go with =name_printer=. A bit misleading since we also do name
tree's but better than just petty printer.

Final decision on this:

- make the entire API a builder based API, even for the simpler case
  of printing just a name.
- after much discussion with names, the name that seems to lie the
  list is still =pretty_printer=. We will have to stick with that for
  now.

*** COMPLETED Implement automatic model name detection in name builder :story:
    CLOSED: [2016-06-19 Sun 23:19]
    CLOCK: [2016-06-19 Sun 22:33]--[2016-06-19 Sun 23:18] =>  0:45
    CLOCK: [2016-06-19 Sun 21:25]--[2016-06-19 Sun 21:31] =>  0:06

At present we have a flag in name builder to detect if we are building
a model name; if so, we deal with the simple name correctly. However,
we implemented some logic in quilt that detects this without user
input. Remove the flag and add this logic.

Actually, instead of wasting cycles detecting things, we should just
have modes of operation - we always know when we are building a model
name.

*** COMPLETED Populate qualified and identifiable name                :story:
    CLOSED: [2016-06-20 Mon 01:03]
    CLOCK: [2016-06-20 Mon 00:03]--[2016-06-20 Mon 01:03] =>  1:00
    CLOCK: [2016-06-19 Sun 23:30]--[2016-06-20 Mon 00:02] =>  0:32
    CLOCK: [2016-06-19 Sun 23:20]--[2016-06-19 Sun 23:30] =>  0:10
    CLOCK: [2016-06-19 Sun 21:01]--[2016-06-19 Sun 21:24] =>  0:23

We need to populate the new name and name tree properties for
qualified and identifiable name.

*** COMPLETED Rename =name_tree='s parent                             :story:
    CLOSED: [2016-06-20 Mon 01:20]
    CLOCK: [2016-06-20 Mon 01:04]--[2016-06-20 Mon 01:20] =>  0:16

Parent is not a good name as we are referring to the current
node. Maybe =self=? We went with =current= in the end. Not ideal, but
at least it does not lie like =parent= did.

*** COMPLETED Create a module indexer in sml                          :story:
    CLOSED: [2016-06-20 Mon 15:39]

*Rationale*: This was done as part of the yarn refactors.

We need to create a class that computes module containment. At present
this is done in JSON hydrator.

In addition, we also have huge amounts of nonsense in injector, in
particular =add_containing_module_to_non_contained_entities=. This
should also be handled by the module indexer.

*** COMPLETED Remove complete name and use qualified name             :story:
    CLOSED: [2016-06-20 Mon 15:39]

*Rationale*: This won't be a problem after the
formattables/properties/fabric refactor in quilt.

At present we have both complete name and qualified name in
formatables. Qualified name is blank. We should remove complete name
and populate qualified name.

This is in nested type info.

*** COMPLETED Thoughts on simplifying the formattables generation     :story:
    CLOSED: [2016-06-20 Mon 15:39]

*Rationale*: This is already under way with the
formattables/properties/fabric refactor in quilt.

We have a problem in the way which we are doing the formattables:
because we are doing model traversals for each of the factories, we
cannot easily introduce a set of manually generated qnames such as the
registrar and includers. However, if we started off the main workflow
by creating a structure like so:

- qname
- optional entity (new base class in yarn); if null we need to create
  extensions as an empty object.

We then need a list of these that get passed in to all repository
factories. These use a visitor of entity to resolve to a type (where
required).

We can inject types to this list that have a qname but no entity. For
these we generate some parts of the formatter properties. Actually, we
still need to generate inclusion lists even when there is no
entity. Perhaps we need to create a new method in the provider that
does not take an yarn entity but still generates the inclusion list.

Actually this should all be done in yarn. We should have zero qname
look-ups coming out of yarn, just follow references. This story is a
variation of the split between "partial" models and "full" models.

Well not everything should be done in yarn. We still need to create a
structure with the properties above, but that is done by iterating
through a list in the yarn model.

One slight problem with this approach: sometimes we need to preserve
some relationships in the newly generated objects. For registrar we
need to preserve the model leaves. For the includers / master headers
we need to express somehow the inclusion relationship at the formatter
level. The latter is definitely a special case because it is a pure
C++ concept: include files cannot be modeled in yarn. However,
registrar is slightly different because we still need to compute the
includes based on the leaves. This means that the above approach will
not provide a clean solution, unless we synthesise an yarn object when
providing the includes. And of course we need to be careful taking
that route or else we will end up generating the object across all
facets.

*** COMPLETED Move all properties in =cpp= to a properties namespace  :story:
    CLOSED: [2016-06-20 Mon 15:39]

Once all formattables are gone, we should have only properties left in
the formattables namespace. We should then rename it to
properties. Thus we have two kinds of things: settings, which are a
direct translation of meta-data without any further processing and
properties which require processing.

Merged stories:

*Split formatter properties and associated classes from formattables*

We have two kinds of data: the formattables themselves (mapped from
yarn) and associated data (formatter properties). The latter is
totally independent. We should create a namespace for all of these
classes and a workflow that produces the data ready for consumption. A
tentative name is =manifest=.

*** COMPLETED Compute yarn property related information               :story:
    CLOSED: [2016-06-20 Mon 15:44]
    CLOCK: [2016-06-21 Tue 23:33]--[2016-06-22 Wed 00:14] =>  0:41
    CLOCK: [2016-06-18 Sat 23:05]--[2016-06-18 Sat 23:10] =>  0:05
    CLOCK: [2016-06-18 Sat 22:52]--[2016-06-18 Sat 23:04] =>  0:12
    CLOCK: [2016-06-18 Sat 22:05]--[2016-06-18 Sat 22:51] =>  0:46
    CLOCK: [2016-06-18 Sat 08:13]--[2016-06-18 Sat 08:46] =>  0:33

Now that we no longer have nested type infos, we need to recompute the
complete names etc for all properties up front and store them in a
repository. This information is almost identical to that of the
helpers but its not easy to share it. For now we should just brute
force it and then look for patterns.

By brute-force it we mean recompute it every time we need to use
it. Or alternatively we could just add these directly to the name
tree. After all they are (or should be) applicable to all languages.

- add the three properties to name tree;
- add logic to compute them into yarn;
- change helpers to reuse this.

Actually the qualified name is language specific. Having said that,
its such a minimal thing that we could conceivably add it to yarn: we
could have a language specific representation on a a container.

- add enumeration for language as per language agnostic story
  (backlog);
- add language specific containers for qualified name.

We need to update the name pretty printer to take on responsibilities
from the name builder in quilt:

- add support for name trees - and so rename it to just pretty
  printer? We can then have a print name and a print name tree.
- the name builder can then be responsible for programming language
  specific logic and calls to the pretty printer to populate the new
  properties.

*** COMPLETED Remove redundancy in properties' repositories           :story:
    CLOSED: [2016-06-20 Mon 16:36]
    CLOCK: [2016-06-20 Mon 21:08]--[2016-06-20 Mon 21:16] =>  0:08
    CLOCK: [2016-06-20 Mon 16:22]--[2016-06-20 Mon 16:36] =>  0:14

At present we have attributes in repositories such as:

: path_derivatives_by_name

Since we are in =path_derivatives_repository=, perhaps we could call
the attribute simply =by_name=.

*** COMPLETED Create a top-level type to aggregate properties and helpers :story:
    CLOSED: [2016-06-20 Mon 19:00]
    CLOCK: [2016-06-20 Mon 18:32]--[2016-06-20 Mon 19:00] =>  0:28
    CLOCK: [2016-06-20 Mon 16:57]--[2016-06-20 Mon 17:34] =>  0:37
    CLOCK: [2016-06-20 Mon 16:08]--[2016-06-20 Mon 16:22] =>  0:14
    CLOCK: [2016-06-20 Mon 15:44]--[2016-06-20 Mon 16:07] =>  0:23

We need a way to create an aggregate type that contains all of the
"auxiliary" information about a type: basically formatter properties
and helper settings.

This type should be called =element_properties=.

- change the return type of the properties workflow to be element
  properties (well pair of element properties and formattables - for
  now).
- have a look at the context type in formatters. Looked at this, we
  just need to do minor updates to it to take in the element
  properties.

*** COMPLETED Refactor helper descriptor                              :story:
    CLOSED: [2016-06-20 Mon 21:39]
    CLOCK: [2016-06-20 Mon 21:17]--[2016-06-20 Mon 21:40] =>  0:23

It seems there is an impedance mismatch between the helper formatters
and the helper descriptor. These are expecting a name tree. Since we
have all the required information in the name tree, we don't even need
the descriptor any more.

The problem with this approach though is that its no longer clear
which type we are helping though. Best to tidy-up the descriptor to
make sure the name reflect the yarn provenience.

*** COMPLETED Add an helper method interface                          :story:
    CLOSED: [2016-06-20 Mon 23:22]
    CLOCK: [2016-06-20 Mon 22:56]--[2016-06-20 Mon 23:21] =>  0:25
    CLOCK: [2016-06-20 Mon 22:45]--[2016-06-20 Mon 22:55] =>  0:10
    CLOCK: [2016-06-20 Mon 22:16]--[2016-06-20 Mon 22:44] =>  0:28

We should also investigate on the need for the nested type info
assistant.

Tasks:

- create interface.
- add interface to registrar.
- implement interface in at least one helper.
- update assistant to query registrar for helpers based on type family
  in context. Performs a recursive descent on nested name.
- problem: io helpers in types should only be enabled if io is enabled
  and if type is in an inheritance relationship. For this we need to
  have access to formatter properties (potentially via assistant) but
  we also need to have access to the type that owns the properties. We
  could augment helper interface with the assistant - easy as we
  already have it on the format method - and the element - harder; we
  need to supply the object as part of helper method creation.
- problem: we need to ask for complete and identifiable name N times
  for a given formatter. It is not a good idea to dynamically compute
  it or to store it in an associative container - it somehow needs to
  be next to the nested name.

*Previous Understanding*

- create a registrar for interface with family and formatter name.
- update all helpers to implement interface and to register
  themselves.
- it seems we have two use cases here: the formatter helper interface
  for formatting purposes and the helper family interface that tells
  us what formatter this helper belongs to. We do not want to leak
  details of formatting into formattables. We need to find a name for
  such an interface in formattables, a bit like the inclusion
  dependencies provider. Formatter helper details provider? We can
  then extend the existing formattables registrar and container to
  store this interface; the formatter helper interface can extend this
  interface; the main workflow returns all registered formatter
  helpers in terms of the formatter helper details provider interface.
- problem: we need additional properties related to the helper which
  have been hard-coded:
  - requires generic string; in a general form "string conversion
    method";
  - requires quoting;
  - requires tidying up; in a general form "remove unprintable
    characters";
  - requires hashing helper method; in a general form: we need a way
    to query the helper settings to figure out if a given type has an
    associated helper method for a given formatter, and if we need to
    call it implicitly or explicitly; and, if explicitly, we need to
    ask the helper method formatter for the name of the helper method.
  - requires dereferencing; for pointer types.
- seems like yet again we found the wrong solution for this
  problem. We need to create a top-level set of helper settings for
  each type with all additional properties; propagate those into
  formatters via context; and then use the assistant to loop through
  the nested name (nested info for now) and pick the helper
  settings. It should also consult the registrar to see if there are
  any helpers available for this formatter and family.

*** COMPLETED Remove encoded from yarn's name tree                    :story:
    CLOSED: [2016-06-21 Tue 23:33]
    CLOCK: [2016-06-21 Tue 23:09]--[2016-06-21 Tue 23:33] =>  0:24
    CLOCK: [2016-06-21 Tue 22:08]--[2016-06-21 Tue 23:08] =>  1:00

Encoded was a mistake: we don't really need to preserve the
intermediate format for the type in a non-language specific way (at
least not at the moment). What we do need is a language specific
qualified name tree.

We also need the helper descriptor to follow the same pattern.

*** COMPLETED Add support for helpers bound to multiple formatters.   :story:
    CLOSED: [2016-06-22 Wed 21:32]
    CLOCK: [2016-06-22 Wed 20:50]--[2016-06-22 Wed 21:31] =>  0:41

Update the formatter helper interface to cater for the following use
cases:

- there can be more than one helper for a given formatter and
  family. Example: types needs both IO and types helpers.
- conversely a helper can have more than one owning formatter (io
  helper has types and io formatters).

*** COMPLETED Add class info to is enabled in formatter helper interface :story:
    CLOSED: [2016-06-22 Wed 22:55]
    CLOCK: [2016-06-22 Wed 22:32]--[2016-06-22 Wed 22:54] =>  0:22
    CLOCK: [2016-06-22 Wed 22:14]--[2016-06-22 Wed 22:21] =>  0:07

In order to determine if a helper is enabled or not we need to have
access to the yarn type. Since those are not yet available we need
access to the class info. The interesting thing is that the helper is
not directly bound to the yarn type, we just need some information for
enablement. We probably should avoid coupling the two together -
e.g. what happens when we are generating helpers for enumerations;
there is no yarn object then. At present we have a uniform interface
for the helpers across yarn types. We should preserve this.

For now we will just hack it in and supply it as a parameter. In the
future we need to consider having it as an element property.

*** COMPLETED Fix issues with build in laptop                         :story:
    CLOSED: [2016-06-23 Thu 08:21]
    CLOCK: [2016-06-23 Thu 08:03]--[2016-06-23 Thu 08:16] =>  0:13
    CLOCK: [2016-06-22 Wed 23:05]--[2016-06-22 Wed 23:40] =>  0:35

For some reason we can't get dogen to build on the laptop. Fix it.

*** COMPLETED Remove helper name from formatter helper interface      :story:
    CLOSED: [2016-06-23 Thu 19:22]
    CLOCK: [2016-06-23 Thu 19:14]--[2016-06-23 Thu 19:22] =>  0:08

We are not using the helper's name anywhere at present and it with the
many to many change (between helpers and formatters) its not so easy
to determine what its implementation should be. So take the easy way
out and remove it.

*** COMPLETED Fix a number of Windows build errors                     :epic:
    CLOSED: [2016-06-24 Fri 21:07]
    CLOCK: [2016-06-24 Fri 15:02]--[2016-06-24 Fri 15:43] =>  0:51

This epic contains all the known errors in the windows build. We
should create stories for each error as we fix them.

Tasks:

- remove #define BOOST_TEST_DYN_LINK
- add =using element_visitor::accept= to all descendants.
- add qualified name to friend functions.
- add scoping to register types in template function.

These should fix all of the below errors.

**** Fix windows errors on boost test                                 :story:

Boost test warning:

: C:\Users\appveyor\.conan\data\Boost\1.60.0\lasote\stable\package\7569deb7626b9f88e03d1b57f5ad4b34f8383a6f\include\boost/test/impl/test_tools.ipp(369): warning C4273: 'boost::test_tools::tt_detail::format_assertion_result': inconsistent dll linkage [C:\proj
: ects\dogen\build\output\projects\config\spec\config_spec.vcxproj]
:   C:\Users\appveyor\.conan\data\Boost\1.60.0\lasote\stable\package\7569deb7626b9f88e03d1b57f5ad4b34f8383a6f\include\boost/test/tools/detail/fwd.hpp(96): note: see previous definition of 'format_assertion_result'

Boost test errors:

: C:\Users\appveyor\.conan\data\Boost\1.60.0\lasote\stable\package\7569deb7626b9f88e03d1b57f5ad4b34f8383a6f\include\boost/test/impl/test_tools.ipp(396): error C2491: 'boost::test_tools::tt_detail::prod_report_format': definition of dllimport function not all
: owed [C:\projects\dogen\build\output\projects\config\spec\config_spec.vcxproj]

: C:\Users\appveyor\.conan\data\Boost\1.60.0\lasote\stable\package\7569deb7626b9f88e03d1b57f5ad4b34f8383a6f\include\boost/test/tools/old/impl.hpp(118): error C2264: 'boost::test_tools::tt_detail::equal_impl': error in function definition or declaration; func
: tion not called [C:\projects\dogen\build\output\projects\config\spec\config_spec.vcxproj]

It may be due to this:

[[http://lists.boost.org/Archives/boost/2015/01/219016.php][{boost} {Test}{Thread} Regression since 9 December?"]]

Reading this entire thread, it seems that Boost.Test had a change that
caused a lot of issues related to linkage. Strange we don't see this
on Linux.

**** Boost serialisation

: C:\projects\dogen\projects\utility\include\dogen/utility/test/serialization_tester.hpp(73): error C2668: 'dogen::config::register_types': ambiguous call to overloaded function [C:\projects\dogen\build\output\projects\config\spec\config_spec.vcxproj]
:   C:\projects\dogen\projects\config\include\dogen/config/serialization/registrar_ser.hpp(32): note: could be 'void dogen::config::register_types<OutputArchive>(Archive &)'
:           with
:           [
:               OutputArchive=boost::archive::binary_oarchive,
:               Archive=boost::archive::binary_oarchive
:           ]
:   C:\projects\dogen\projects\config\spec\serialization_spec.cpp(30): note: or       'void register_types<OutputArchive>(Archive &)'
:           with
:           [
:               OutputArchive=boost::archive::binary_oarchive,
:               Archive=boost::archive::binary_oarchive
:           ]
:   C:\projects\dogen\projects\utility\include\dogen/utility/test/serialization_tester.hpp(73): note: while trying to match the argument list '(boost::archive::binary_oarchive)'
:   C:\projects\dogen\projects\utility\include\dogen/utility/test/serialization_tester.hpp(121): note: see reference to function template instantiation 'void dogen::utility::test::serialization_tester<dogen::config::knitting_options_generator::result_type>::
: roundtrip_produces_the_same_entity<boost::archive::binary_iarchive,boost::archive::binary_oarchive>(const dogen::config::knitting_options &)' being compiled
:   C:\projects\dogen\projects\utility\include\dogen/utility/test/serialization_tester.hpp(121): note: see reference to function template instantiation 'void dogen::utility::test::serialization_tester<dogen::config::knitting_options_generator::result_type>::
: roundtrip_produces_the_same_entity<boost::archive::binary_iarchive,boost::archive::binary_oarchive>(const dogen::config::knitting_options &)' being compiled
:   C:\projects\dogen\projects\utility\include\dogen/utility/test/serialization_tester.hpp(116): note: while compiling class template member function 'void dogen::utility::test::serialization_tester<dogen::config::knitting_options_generator::result_type>::bi
: nary_roundtrip_produces_the_same_entity(const dogen::config::knitting_options &)'
:   C:\projects\dogen\projects\utility\include\dogen/utility/test/serialization_tester.hpp(130): note: see reference to function template instantiation 'void dogen::utility::test::serialization_tester<dogen::config::knitting_options_generator::result_type>::
: binary_roundtrip_produces_the_same_entity(const dogen::config::knitting_options &)' being compiled
:   C:\projects\dogen\projects\utility\include\dogen/utility/test/canned_tests.hpp(72): note: see reference to class template instantiation 'dogen::utility::test::serialization_tester<dogen::config::knitting_options_generator::result_type>' being compiled
:   C:\projects\dogen\projects\config\spec\serialization_spec.cpp(54): note: see reference to function template instantiation 'void dogen::utility::test::roundtrip_type<dogen::config::knitting_options_generator>(void)' being compiled

**** Dogen yarn exception

: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(60): error C2063: 'boost::serialization::save': not a function [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(63): error C2063: 'boost::serialization::load': not a function [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(67): error C3927: '->': trailing return type is not allowed after a non-function declarator [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(67): error C3484: syntax error: expected '->' before the return type [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(67): error C3613: missing return type after '->' ('int' assumed) [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(67): error C3646: 'visit': unknown override specifier [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(67): error C2988: unrecognizable template declaration/definition [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(67): error C2059: syntax error: '(' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(67): error C2238: unexpected token(s) preceding ';' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(66): error C3668: 'dogen::yarn::exception::accept': method with override specifier 'override' did not override any base class methods [C:\projects\dogen\build\output\projects\yarn\src\y
: arn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(70): error C2628: 'dogen::yarn::exception' followed by 'void' is illegal (did you forget a ';'?) [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(70): error C2270: 'accept': modifiers not allowed on nonmember functions [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(70): error C2259: 'dogen::yarn::exception': cannot instantiate abstract class [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(70): note: due to following members:
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(70): note: 'void dogen::yarn::element::accept(dogen::yarn::element_visitor &)': is abstract
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/element.hpp(83): note: see declaration of 'dogen::yarn::element::accept'
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(70): note: 'void dogen::yarn::element::accept(const dogen::yarn::element_visitor &)': is abstract
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/element.hpp(82): note: see declaration of 'dogen::yarn::element::accept'
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(70): note: 'void dogen::yarn::element::accept(dogen::yarn::element_visitor &) const': is abstract
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/element.hpp(81): note: see declaration of 'dogen::yarn::element::accept'
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(70): note: 'void dogen::yarn::element::accept(const dogen::yarn::element_visitor &) const': is abstract
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/element.hpp(80): note: see declaration of 'dogen::yarn::element::accept'
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/exception.hpp(70): note: 'bool dogen::yarn::element::equals(const dogen::yarn::element &) const': is abstract
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/element.hpp(171): note: see declaration of 'dogen::yarn::element::equals'

**** Dogen yarn primitive

: C:\projects\dogen\projects\yarn\include\dogen/yarn/serialization/primitive_fwd_ser.hpp(30): error C2143: syntax error: missing ';' before '{' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/serialization/primitive_fwd_ser.hpp(30): error C2447: '{': missing function header (old-style formal list?) [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(47): error C2059: syntax error: 'public' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(47): error C2143: syntax error: missing ';' before ':' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(47): error C2059: syntax error: ':' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(49): error C2059: syntax error: 'const' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(58): error C2059: syntax error: 'private' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(60): error C2255: 'friend': not allowed outside of a class definition [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(60): error C2244: 'save': unable to match function definition to an existing declaration [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(60): note: see declaration of 'save'
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(63): error C2255: 'friend': not allowed outside of a class definition [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(63): error C2244: 'load': unable to match function definition to an existing declaration [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/primitive.hpp(63): note: see declaration of 'load'

**** Dogen yarn enumeration

: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumerator.hpp(40): error C2990: 'dogen::yarn::enumerator': non-class template has already been declared as a class template [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumerator_fwd.hpp(31): note: see declaration of 'dogen::yarn::enumerator'
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumerator.hpp(121): error C2027: use of undefined type 'dogen::yarn::enumerator' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumerator_fwd.hpp(31): note: see declaration of 'dogen::yarn::enumerator'
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumerator.hpp(121): error C2228: left of '.swap' must have class/struct/union [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumeration.hpp(52): error C3203: 'enumerator': unspecialized class template can't be used as a template argument for template parameter '_Ty', expected a real type [C:\projects\dogen\build\output\pr
: ojects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumeration.hpp(106): error C3203: 'enumerator': unspecialized class template can't be used as a template argument for template parameter '_Ty', expected a real type [C:\projects\dogen\build\output\p
: rojects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumeration.hpp(107): error C3203: 'enumerator': unspecialized class template can't be used as a template argument for template parameter '_Ty', expected a real type [C:\projects\dogen\build\output\p
: rojects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumeration.hpp(108): error C3203: 'enumerator': unspecialized class template can't be used as a template argument for template parameter '_Ty', expected a real type [C:\projects\dogen\build\output\p
: rojects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumeration.hpp(109): error C3203: 'enumerator': unspecialized class template can't be used as a template argument for template parameter '_Ty', expected a real type [C:\projects\dogen\build\output\p
: rojects\yarn\src\yarn.vcxproj]

**** Dogen mock model factory

: C:\projects\dogen\projects\yarn\include\dogen/yarn/test/mock_intermediate_model_factory.hpp(264): error C2259: 'dogen::yarn::exception': cannot instantiate abstract class [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/test/mock_intermediate_model_factory.hpp(264): note: due to following members:
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/test/mock_intermediate_model_factory.hpp(264): note: 'void dogen::yarn::element::accept(dogen::yarn::element_visitor &)': is abstract
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/element.hpp(83): note: see declaration of 'dogen::yarn::element::accept'
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/test/mock_intermediate_model_factory.hpp(264): note: 'void dogen::yarn::element::accept(const dogen::yarn::element_visitor &)': is abstract
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/element.hpp(82): note: see declaration of 'dogen::yarn::element::accept'
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/test/mock_intermediate_model_factory.hpp(264): note: 'void dogen::yarn::element::accept(dogen::yarn::element_visitor &) const': is abstract
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/element.hpp(81): note: see declaration of 'dogen::yarn::element::accept'
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/test/mock_intermediate_model_factory.hpp(264): note: 'void dogen::yarn::element::accept(const dogen::yarn::element_visitor &) const': is abstract
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/element.hpp(80): note: see declaration of 'dogen::yarn::element::accept'
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/test/mock_intermediate_model_factory.hpp(264): note: 'bool dogen::yarn::element::equals(const dogen::yarn::element &) const': is abstract
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/element.hpp(171): note: see declaration of 'dogen::yarn::element::equals'
: C:\projects\dogen\projects\yarn\src\test\mock_intermediate_model_factory.cpp(533): error C2027: use of undefined type 'dogen::yarn::enumerator' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumerator_fwd.hpp(31): note: see declaration of 'dogen::yarn::enumerator'
: C:\projects\dogen\projects\yarn\src\test\mock_intermediate_model_factory.cpp(534): error C2079: 'r' uses undefined class 'dogen::yarn::enumerator' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
: C:\projects\dogen\projects\yarn\src\test\mock_intermediate_model_factory.cpp(535): error C2228: left of '.name' must have class/struct/union [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
:   C:\projects\dogen\projects\yarn\src\test\mock_intermediate_model_factory.cpp(535): note: type is 'int'
: C:\projects\dogen\projects\yarn\src\test\mock_intermediate_model_factory.cpp(536): error C2228: left of '.value' must have class/struct/union [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
:   C:\projects\dogen\projects\yarn\src\test\mock_intermediate_model_factory.cpp(536): note: type is 'int'
: C:\projects\dogen\projects\yarn\src\test\mock_intermediate_model_factory.cpp(540): error C2027: use of undefined type 'dogen::yarn::enumerator' [C:\projects\dogen\build\output\projects\yarn\src\yarn.vcxproj]
:   C:\projects\dogen\projects\yarn\include\dogen/yarn/types/enumerator_fwd.hpp(31): note: see declaration of 'dogen::yarn::enumerator'

*** COMPLETED Fix Mingw build's warning                               :story:
    CLOSED: [2016-06-24 Fri 21:07]
    CLOCK: [2016-06-24 Fri 15:44]--[2016-06-24 Fri 15:54] =>  0:10

We've added the initial support to MinGW on Appveyor:

- [[http://help.appveyor.com/discussions/questions/372-build-setup-for-a-c-program][Build setup for a C program]]
- [[https://github.com/imazen/libpng/blob/master/appveyor.yml][libpng appveyor.yml]]
- [[https://www.appveyor.com/updates/2015/05/30][Appveyor adds support for MinGW]]
- [[http://altrepo.eu/matyapiro31/mingw-w64-thrift/blob/master/appveyor.yml][mingw-w64-thrift]]

However the build is now failing with:

: cmake ../.. -DCMAKE_BUILD_TYPE=%configuration% -G "%generator%"
: CMake Error at C:/Program Files (x86)/CMake/share/cmake-3.4/Modules/CMakeMinGWFindMake.cmake:22 (message):
:   sh.exe was found in your PATH, here:
:
:   C:/Program Files/Git/usr/bin/sh.exe
:
:   For MinGW make to work correctly sh.exe must NOT be in your path.
:
:   Run cmake from a shell that does not have sh.exe in your PATH.
:
:   If you want to use a UNIX shell, then use MSYS Makefiles.
:
: Call Stack (most recent call first):
:   CMakeLists.txt:25 (project)
:
:
: CMake Error: CMAKE_C_COMPILER not set, after EnableLanguage
: CMake Error: CMAKE_CXX_COMPILER not set, after EnableLanguage
: -- Configuring incomplete, errors occurred!

We have attempted to remove Git from path as per these instructions:

- [[https://github.com/jibsen/brieflz/blob/0c6fb73984f11e697dfaade5cdc5e291c1655c67/appveyor.yml][Removing Git's sh from the path]]

But it did not resolve the error above.

*** COMPLETED Implement types helper methods with new helper infrastructure :story:
    CLOSED: [2016-06-27 Mon 16:34]
    CLOCK: [2016-06-24 Fri 21:12]--[2016-06-24 Fri 21:35] =>  0:23
    CLOCK: [2016-06-24 Fri 15:55]--[2016-06-24 Fri 15:58] =>  0:03
    CLOCK: [2016-06-23 Thu 19:23]--[2016-06-23 Thu 19:50] =>  0:27
    CLOCK: [2016-06-23 Thu 08:22]--[2016-06-23 Thu 08:51] =>  0:29
    CLOCK: [2016-06-22 Wed 15:47]--[2016-06-22 Wed 16:16] =>  0:29
    CLOCK: [2016-06-22 Wed 15:30]--[2016-06-22 Wed 15:46] =>  0:16
    CLOCK: [2016-06-21 Tue 21:46]--[2016-06-21 Tue 22:07] =>  0:21
    CLOCK: [2016-06-21 Tue 20:01]--[2016-06-21 Tue 20:45] =>  0:44

- call the new method from the formatters in types and ensure the
  generated code matches previous code.
- remove/disable all legacy helper method generation.

*** COMPLETED Move identifiable and qualified to assistant            :story:
    CLOSED: [2016-06-27 Mon 17:22]
    CLOCK: [2016-06-27 Mon 17:11]--[2016-06-27 Mon 17:21] =>  0:10
    CLOCK: [2016-06-27 Mon 16:48]--[2016-06-27 Mon 17:10] =>  0:22

After a lot of faffing it is becoming obvious that we should just
supply a raw name tree to quilt and let it do whats required. We need
to get rid of the additional attributes we added to helper and move
the machinery across to the assistant.

*** COMPLETED Refactor helper properties yet again                    :story:
    CLOSED: [2016-06-28 Tue 17:28]
    CLOCK: [2016-06-28 Tue 17:29]--[2016-06-28 Tue 17:36] =>  0:07
    CLOCK: [2016-06-28 Tue 15:39]--[2016-06-28 Tue 17:28] =>  1:49
    CLOCK: [2016-06-28 Tue 15:01]--[2016-06-28 Tue 15:39] =>  0:38
    CLOCK: [2016-06-27 Mon 17:23]--[2016-06-27 Mon 17:45] =>  0:22

We don't seen to be able to capture helper properties correctly. The
final understanding is now:

- we need at the top level a pair of current name tree, helper
  settings.
- we don't need descriptor at all.
- the associated helpers are actually the direct descendants, paired
  with their helper settings.

With this structure we should be able to satisfy all use cases so far.

*** COMPLETED Remove =aggregator= in dynamic                          :story:
    CLOSED: [2016-06-29 Wed 15:00]
    CLOCK: [2016-06-29 Wed 14:53]--[2016-06-29 Wed 15:00] =>  0:07

We seem to have an unused class in dynamic: =aggregator=. Remove it if so.

*** COMPLETED Rename aspect settings to element settings              :story:
    CLOSED: [2016-06-29 Wed 16:22]
    CLOCK: [2016-06-29 Wed 16:05]--[2016-06-29 Wed 16:22] =>  0:17
    CLOCK: [2016-06-29 Wed 15:41]--[2016-06-29 Wed 16:04] =>  0:23
    CLOCK: [2016-06-29 Wed 15:02]--[2016-06-29 Wed 15:40] =>  0:38

We need to pile up other type related settings which are not related
to our ideas around aspects. =type= is sufficiently vague for now.

Backlog search for related stories:

- [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_79.org#rename-aspect-settings-to-element-settings][Rename aspect settings to element settings]]: Original renaming in
  Sprint 79.
- [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_79.org#add-a-field-for-quiltcpphelper_family][Add a field for =quilt.cpp.helper_family=]]: renamed it back to aspect
  settings.

The rationale in these previous stories was that if we could contain
the settings to just aspects then we can call the class aspect
settings; if however we end up bundling more generic element settings
then we need to rename it to element settings. We now have a case to
rename it because we need to add =string_conversion_method=.

Tasks:

- rename classes to element settings.
- rename fields to element instead of type. Also good because it
  avoids confusion with =types= facet.
- add =string_conversion_method= field.

*** COMPLETED Thoughts on the overall design for settings             :story:
    CLOSED: [2016-06-29 Wed 17:32]
    CLOCK: [2016-06-29 Wed 16:23]--[2016-06-29 Wed 17:32] =>  1:09

We need to pre-process the global settings bundle, extract the string
conversion methods and add those to the context.

Actually the more one thinks about this the more obvious it seems that
most of the properties that are under helper settings are actually
element settings. These are not specific to the helper at all (we will
use them from the inserter formatter for example). We need to move
these properties across and then extend context as required. We should
create a "global element repository" container.

A lot of the confusion arises because we are modeling different things
under the same name:

- the definition and instantiation of a helper; e.g. whether a type
  has a helper method associated with it or not. For these we can have
  the usual 1-1 mapping.
- the configuration of the streaming invocation for a type. For these
  we need a global container of these "IO settings".

With this simple change of perspective, it all now makes sense:

- bundle is in reality "element settings"; that is to say, all
  settings at the element level that will be passed directly into
  formatting (e.g. without any post-processing). It is the
  mirror-image of "element properties".
- general settings are really file properties; the configuration of
  how a file will be formatted, produced from post-processing "file
  settings". Thus they should be moved from bundle into element
  properties. File properties belong here because we have one file per
  element.
- we need the "IO settings" as described above. "IO settings" needs an
  "IO settings repository" which is passed in to context. These are
  global settings, per ID.
- helper settings are just family; the rest are IO settings. We can
  just have a field for this in helper properties, which also makes it
  cleaner. Now we can move the family into helper properties where it
  is mandatory, and remove it from the descriptor.
- streaming for type uses IO settings and should probably be called
  "IO invocation for type". It is called with an ID; we look up the
  corresponding settings in the global IO settings container.

*** Rename element settings back to aspect settings                   :story:

As per design story, we incorrectly added non-aspect attributes to
this class. Remove them and rename the class.

*** Rename bundle to element settings                                 :story:

As per design story, these are really the settings that belong to the
element. Rename and deal with the fallout.

*** Create a IO settings class                                        :story:

Add a class to model all of the settings required to produce the io
invocation, create a repository for it and associated factory and
finally add the repository to the context.

*** Implement streaming for type in terms of IO settings              :story:

- rename it o "IO invocation for type".
- call it with an ID; look up the corresponding IO settings in the global
  IO settings container from context.
- remove all other streaming for type implementations and use the new
  one in the legacy formatters.

*** Refactor general settings                                         :story:

Tasks:

- create a file settings class that reflects dynamic (and nothing
  more). Create an associated factory, repository etc.
- rename the existing general settings to file properties. Make the
  factory use the file settings to produce the properties.
- move general settings from the bundle into element properties.

*Previous Understanding*

A while ago we came up with this name for the settings of the generic
formatter model. This is the model with basic infrastructure to be
reused by the more specialised formatters. However, now that we have
many (many) settings classes, general settings may not be the most
appropriate name. We need to look a bit more deeply into the role of
this class and see if a better name is not available.

We could call it preamble settings because all settings are related to
the file preamble; annoyingly, we also generate a post-amble from
it. There doesn't seem to be any good names for the pair (preamble,
post-amble). In networking this would be called frame markers perhaps.

Now that we are not using =meta_data= any more, perhaps we could
re-purpose it for this (=meta_data_settings=). In a way, preambles and
post-ambles are meta-data, as opposed to the real file
contents. Having said that, one could say the same about any kind of
comments.

We could also use [[http://www1.appstate.edu/~yaleread/typographichierarchy.pdf][typography terminology]]: headers and footers.

Now that we have subsidiary settings and principal settings do we need
the rename? We should consider "universal settings" maybe.

In addition, the convention is now that "settings" mean a strongly
typed representation of =dynamic= data; general "settings" are not
settings in this sense. However, we do need a class to model settings
properly (i.e. to mirror dynamic exactly, without any
transformations).

In truth, =annotation= is probably sufficient - or perhaps
=annotation_properties=. It could then have an =enabled= property to
replace =generate_preamble=. This is more accurate due to the
preamble/postamble setup explained above. In this setup, we'd have
=annotation_settings= to map to dynamic data, with an annotation
settings factory which reads these off of dynamic object; then, an
annotation factory to generate annotations. Finally, we can introduce
the annotation formatter to generate the portion of boilerplate
related to just the annotation. Boilerplate formatter collaborates
with annotation formatter.

More ideas on this: are these not just "file settings"? After all the
meta-data it contains relates to file-level properties. As =file= is
an entity defined in =formatters= this fits the bill nicely. We still
have to deal with the dilemma described above (these "settings" are
not all directly read out of meta-data). We should then call these
"file properties". We need to then refactor the code so that there is
a file settings class that is an exact match of what is read out of
dynamic and is then used as input to generate the file properties.

*** STARTED Implement IO helper methods with new helper infrastructure :story:
    CLOCK: [2016-06-29 Wed 14:10]--[2016-06-29 Wed 14:36] =>  0:26
    CLOCK: [2016-06-28 Tue 22:22]--[2016-06-28 Tue 23:01] =>  0:39
    CLOCK: [2016-06-28 Tue 21:57]--[2016-06-28 Tue 22:21] =>  0:24
    CLOCK: [2016-06-28 Tue 21:49]--[2016-06-28 Tue 21:56] =>  0:07
    CLOCK: [2016-06-28 Tue 20:46]--[2016-06-28 Tue 21:48] =>  1:02
    CLOCK: [2016-06-28 Tue 17:37]--[2016-06-28 Tue 17:50] =>  0:13
    CLOCK: [2016-06-27 Mon 16:34]--[2016-06-27 Mon 16:47] =>  0:13
    CLOCK: [2016-06-27 Mon 16:16]--[2016-06-27 Mon 16:33] =>  0:17

Problems:

- we do not have a "streaming for type" function in assistant. We need
  to figure out how to obtain this data from the helper.
- we do not have a name tree so we do not know what the key and value
  names are for associative containers. We probably need to add the
  name tree to the helper descriptor.
- =string_conversion_method= cannot be implemented as is;we need it
  for all properties, not just in the context of helpers. This seems
  to imply we need a way to access this information directly from the
  property. It will need some thinking.

*** Group the file related fields under a prefix                      :story:

Now we have =element= as a prefix, it probably makes sense to also
group the fields that are related to file names, paths etc. These
could be under =file= or perhaps =paths=? Examples:

- =quilt.cpp.file.include_directory_name=
- =quilt.cpp.source_directory_name=

*** Implement qualified name efficiently                              :story:

We used a =std::map= to store qualified names. In practice, we don't
need something this expensive.

- instead of mapping names to languages, we could map them to
  "styles". There are only a few "styles" across all programming
  languages (e.g. =.= separated, =::= separated and so on).
- we can also create an array of these styles. We know up front how
  many styles there are.
- finally we can create a enumeration to access the array. At present
  this is not possible because we cannot disable invalid, nor is it
  possible to move it to a different position (e.g. last). Also we
  will have to static cast the enum to access the int, which is not
  very pretty.

Once all of this is done we can simply do, at O(1):

: name.qualified[static_cast<unsigned int>(styles::double_colon_separated_style)]

We can prettify it a bit: [[http://stackoverflow.com/questions/8357240/how-to-automatically-convert-strongly-typed-enum-into-int][How to automatically convert strongly typed
enum into int?]]

: template <typename E>
: constexpr typename std::underlying_type<E>::type to_underlying(E e) {
:     return static_cast<typename std::underlying_type<E>::type>(e);
: }
:
: std::cout << foo(to_underlying(b::B2)) << std::endl;

Giving us:

: name.qualified[to_underlying(styles::double_colon_separated_style)]

*** Create utility methods for =__type__= etc                         :story:

At present we've hard-coded the field name for =__type__= and so forth
in each formatter. This is not ideal. Create a simple utility method
that returns it and update all formatters to use it instead. List of
hard-coded things:

- =__type__=
- =<empty>=
- =data=
- =value=
- =memory=
- string helper variables: =<new_line>=, =<quote>=
- =tidy_up_string=

*** Why do we need helpers and io for some types?                     :story:

At present we have helper support for maps, sets, pairs etc. We also
seem to have utility support for these. Originally the idea was that
we needed utility so that users could have a map of dogen types and
still have streaming support. This is useful. However, what is
slightly less clear is why we don't just use the utility methods
inside the IO subsystem to output these types, but instead use
helpers. We should try doing that and see what breaks, there may be a
reasons for this.

In theory we just have to remove the helpers in IO for utility
supported types and add the includes to the meta-data; regenerate and
see what breaks. It could be related to the ordering of template
functions or some such problem. If so we need to document this in
manual. We should also do a quick search in backlog for this.

*** Character member variables are not tidied up on io                :story:

At present there is no code to convert non-printable chars into
something acceptable in JSON. We probably never noticed this before
because test data generates printable chars. Code generated is as
follows (all primitives model):

: << "\"char_property\": " << "\"" << v.char_property() << "\"" << ", "

We need a "tidy-up char" function to handle this properly.

*** Lists of strings are not properly tidied up on io                 :story:

In the log file, when we dump include dependencies we see invalid
JSON:

: [ "<iosfwd>", ""dogen/sml/types/merger.hpp"" ]

This implies we are not calling =tidy_up_string=. This can be tested
by creating a container of =filesystem::path=.

*** Fix Windows build timeout                                         :story:

At present the windows build is taking over 1h and its only building
the knitter target. We need to think of ways to reduce the build
time. Things to try:

- remove all of the hashing etc for the types we don't need to hash.
- get rid of the warnings for boost.

*** Build boost for MinGW                                             :story:

At present our MinGW build is borked because we do not have a boost
build. Create one and add it to DropBox or Conan.

*** Type-bound helpers and generic helpers                            :story:

Not all helpers are bound to a type. We have the case of inserter
helper in io which is used by main formatters directly. We need to
make this distinction in the manual.

*** Check which properties need to loop through the entire model      :story:

In certain cases such as helpers we probably don't need to go through
all types; only the target types matter. Ensure we are not processing
other types for no reason.

*** Add validation for helper families                                :story:

At present we are checking that the name tree has the expected number
of type arguments:

:    const auto children(t.children());
:    if (children.size() != 1) {
:        BOOST_LOG_SEV(lg, error) << invalid_smart_pointer;
:        BOOST_THROW_EXCEPTION(formatting_error(invalid_smart_pointer));
:    }
:    smart_pointer_helper_stitch(fa, t);

In the future with dynamic helpers we will remove these checks. In
order to implement them we need to declare the type families up front
in a JSON file, with a name and number of type arguments. When
constructing the type helpers, we can check the name tree to make sure
the number of type arguments is correct.

*** Update assistant to use new helper information                    :story:

Once all the pieces are in place, the assistant can then use the
element properties to find out which helpers are required for each
type; call those helpers and populate the file with the generate
code. We can remove all previous helper support.

*** Create a settings class for the "requires" settings               :story:

We need to populate these in a settings workflow of some kind.

*** Consider caching "all modules" in location                        :story:

At present we are adding the module lists together to build the
qualified name; location could have a "all modules" list that
concatenates external, model and internal modules. We should look at
performance before doing this change though.

*** Consider reducing the number of qname lookups in cpp model        :story:

At present we are still using =yarn::name= in a lot of repositories in
quilt. We already had one go in moving to id's but there are still
quite a few left. Investigate to see if there are more that can be
moved.

*** Implement formattables in terms of yarn types                     :epic:

At present formattables are just a shadow copy of yarn types plus
additional =cpp= specific types. In practice:

- for the types that are shadow copies, we could have helper utilities
  that do the translation on the fly (e.g. for names).
- for additional information which cannot be translated, we could have
  containers indexed by qualified name and query those just before we
  call the transformer. This is the case with formatter properties. We
  need something similar to house "type properties" such as
  =requires_stream_manipulators=. These could be moved into aspect
  settings.
- for types that do not exist in yarn, we could inherit from element;
  this is the case for registrar, forward declarations, cmakelists and
  odb options. Note that with this we are now saying that element
  space contains anything which can be modeled, regardless of if they
  are part of the programming language type system, or build system,
  etc. This is not ideal, but its not a problem just yet. We could
  update the factory to generate these types and then take a copy of
  the model and inject them in it.

*** Add support for selectively disabling helpers on a family         :story:

At present when a type belongs to a helper family it must provide all
helpers across all facets. This means that we can't support the cases
where a helper is required for one facet for one type but not for
others. For example, we cannot create a family for =Dereferenceable=
including both smart pointers and optionals because optional does not
need a helper for =types=.

One solution for this is to allow disabling the helper for a given
type on a given facet. However, our templating mechanism in dynamic is
not able to cope with this use case. Changes required:

- add a "component" to ownership hierarchy. This would be "helper" in
  our case. We should also set "type" which has been hacked via the
  qualified name.
- create a supported/enabled field with a component of helper and a
  facet template. We could change this to formatter template if
  required in the future.
- merge the families of optional and smart pointer into
  =Dereferenceable=.
- disable the helper for types for optional.
- update the helper settings to read this new field.
- enabled method now checks the helper properties.

*** Remove nested type info                                           :story:

Once all of the infrastructure is in place, we should not need this
class any more. Remove code from transformer and remove object types
and anything else that was used to dispatch based on type.

*** Rename methods parsing name trees                                 :story:

We have a variety of names for the methods parsing name trees
recursively. The best one seems to be =walk_name_tree=. We should use
this name consistently.

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

*** Consider using indices rather than associative containers         :story:

Once we generate the final model the model becomes constant; this
means we can easily assign an [[https://en.wikipedia.org/wiki/Ordinal_number][ordinal number]] to each model
element. These could be arranged so that we always start with
generatable types first; this way we always generate dense
containers - there are some cases where we need both generatable types
and non-generatable types; in other cases we just need generatable
types; we never need just non-generatable types. We also need to know
the position of the first non-generatable type (or alternatively, the
size of the generatable types set).

Once we have this, we can start creating vectors with a fixed size
(either total number of elements or just size of generatable
types). We can also make it so that each name has an id which is the
ordinal (another model post-processing activity). Actually we should
call it "type index" or some other name because its a transient
id. This means both properties and settings require no lookups at all
since all positions are known beforehand (except in cases where the
key of the associative container must be the =yarn::name= because we
use it for processing).

In theory, a similar approach can be done for formatters too. We know
upfront what the ordinal number is for each formatter because they are
all registered before we start processing. If formatters obtained
their ordinal number at registration, wherever we are using a map of
formatter name to a resource, we could use a fixed-size
vector. However, formatters may be sparse in many cases (if not all
cases?). For example, we do not have formatter properties for all
formatters for every =yarn::name= because many (most) formatters don't
make sense for every yarn type. Thus this is less applicable, at least
for formatter properties. We need to look carefully at all use cases
and see if there is any place where this approach is applicable.

*** Handle "special includes" correctly                               :story:

We did a quick hack to handle "special includes": we simply "detected"
them in include builder and then did the appropriate action in each of
the include providers. In order to make this work dynamically, we need
somehow to have "associated includes" on a per type basis. For
example:

- type =x= requires include =y= in formatter =f=.

This can easily be achieved via an "additional inclusion directive"
which is a container. For example:

:        "extensions" : {
:                "quilt.cpp.helper.family" : "Dereferenceable",
:                "quilt.cpp.types.class_header_formatter.inclusion_directive" : "<boost/weak_ptr.hpp>",

Could have:

:                "quilt.cpp.types.class_header_formatter.additional_inclusion_directive" : "<some_include.hpp>",

If multiple are provided then they are all added. This highlights an
important point: we need a way to inject type specific includes from a
formatter. It makes no sense to declare all of these up front in a
library since we do not know what all possible formatters are, nor
what requirements they may have for inclusion. At the same time,
formatters cannot be expected to declare types. The solution is to be
able to "inject" these dependencies from a JSON file associated with
the formatter. We could supply the qualified name and the properties
to inject. This problem can be solved later on - create a separate
story for this.

*** Registrar in serialisation is not stable sorted                   :story:

We seem to have a traffic light diff on =registrar_ser.cpp=:

: -    dogen::config::register_types(ar);
:      dogen::quilt::cpp::register_types(ar);
:      dogen::yarn::register_types(ar);
: +    dogen::config::register_types(ar);

This is probably a lack of a stable sort in model dependencies.

*** Support only specific attributes for certain facets               :story:

Whenever an object has a unique identifier, it may make sense to make
use of it for:

- hashing
- equality
- less than

And so forth. For example, names and name trees don't really require
comparing the entire state of the object. We need a way to mark
properties against each facet in the meta-data.

** Deprecated
*** CANCELLED Investigate slow down                                   :story:
    CLOSED: [2016-06-20 Mon 15:51]

*Rationale*: Speed is back to normal so lets not waste time on this.

With commit 7e89ddb we introduced a set of hacks to inject settings
and formatter properties into the repositories. This seems to have had
a very negative impact in performance. We need to ensure performance
goes back to normal after the hacks have been removed.

*** CANCELLED Consider splitting =formattables::transformer=          :story:
    CLOSED: [2016-06-20 Mon 15:51]

*Rationale*: We will decom transformer so no need to worry.

We have two different responsibilities within transformer:

- to perform an individual (1-1) transformation of a tack type into a
  formatable;
- to determine how many transformations of a tack type are required,
  and to do them.

Maybe we should have a transformer sub-workflow that collaborates with
specific transformers, aligned to =cpp= types
(e.g. =class_info_transformer=, =enum_info_transformer= and so on,
each taking different tack types). The role of the top-level
transformer is to call all of the sub-transformers for a given tack
type.

The other option is to align them to tack types and to produce
different =cpp= types.
