#+title: Release Notes for Sprint 42
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED
#+tags: story(s) epic(e) task(t) note(n) spike(p)

* Release Notes

This file contains all stories that were closed during sprint 42.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2014-01-03 Fri 00:21]

| Headline                                                                | Time    |       |      |
|-------------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                            | *21:59* |       |      |
|-------------------------------------------------------------------------+---------+-------+------|
| Development Stories Implemented                                         |         | 21:59 |      |
| IMPLEMENTATION Release notes and backlog grooming                       |         |       | 1:30 |
| COMPLETED Investigate availability of boost 1.55 for debian             |         |       | 0:18 |
| COMPLETED Add more valgrind suppressions                                |         |       | 0:06 |
| COMPLETED Add absolute path support to =om=                             |         |       | 2:40 |
| COMPLETED Add plumbing to engine to toggle =om= on or off               |         |       | 1:53 |
| COMPLETED Ensure OM header files are at the expected location           |         |       | 0:35 |
| COMPLETED Fix differences in code generation between =om= and C++ model |         |       | 6:45 |
| IMPLEMENTATION Add include file support to main type formatter          |         |       | 1:13 |
| IMPLEMENTATION Solve the new lines issue in formatters                  |         |       | 6:41 |
| Includer generation should be done from meta-data                       |         |       | 0:18 |
#+end:

*** IMPLEMENTATION Release notes and backlog grooming                  :task:
    CLOCK: [2013-12-30 Mon 11:59]--[2013-12-30 Mon 12:29] =>  0:30
    CLOCK: [2013-12-30 Mon 11:53]--[2013-12-30 Mon 11:58] =>  0:05
    CLOCK: [2013-12-30 Mon 10:29]--[2013-12-30 Mon 11:05] =>  0:36
    CLOCK: [2013-12-30 Mon 10:00]--[2013-12-30 Mon 10:10] =>  0:10
    CLOCK: [2013-12-30 Mon 09:50]--[2013-12-30 Mon 09:59] =>  0:09

Updates to release notes and backlog.

*** Update manual                                                     :story:

Use compilation downtime to update the manual.

We never got round to doing this during this iteration as there were a
number of compilation fixes that used the downtime.

*** COMPLETED Investigate availability of boost 1.55 for debian        :task:
    CLOSED: [2013-12-30 Mon 12:59]
    CLOCK: [2013-12-30 Mon 12:31]--[2013-12-30 Mon 12:49] =>  0:18

We need to retest the PFH changes when boost 1.55 becomes available in
debian. Checked the [[https://wiki.debian.org/Teams/DebianBoostTeam][team page]] - there is no open bug yet. Subscribed
to the [[http://packages.qa.debian.org/b/boost-defaults.html][package feed]].

*** COMPLETED Add more valgrind suppressions                           :task:
    CLOSED: [2013-12-30 Mon 13:54]
    CLOCK: [2013-12-30 Mon 13:48]--[2013-12-30 Mon 13:54] =>  0:06

*** COMPLETED Add absolute path support to =om=                       :story:
    CLOSED: [2013-12-30 Mon 16:37]
    CLOCK: [2013-12-30 Mon 13:56]--[2013-12-30 Mon 16:36] =>  2:40

- use settings to compute the key paths in engine workflow: project
  directory, source directory, include directory
- supply key paths to the OM workflow and formatter factory
- supply required paths to the applicable formatters
- make header guards configurable

*** COMPLETED Add plumbing to engine to toggle =om= on or off         :story:
    CLOSED: [2013-12-30 Mon 19:03]
    CLOCK: [2013-12-30 Mon 18:28]--[2013-12-30 Mon 19:03] =>  0:35
    CLOCK: [2013-12-30 Mon 17:10]--[2013-12-30 Mon 18:28] =>  1:18

We need a way to create models with =om= files superimposed on top of
=cpp_formatter= files; this would allow us to work through the diffs
quickly. To do so:

- create a flag in workflow to enable/disable OM. default it to false.
- pass it to backend factory.
- update a test to have the flag set to true.

*** COMPLETED Ensure OM header files are at the expected location     :spike:
    CLOSED: [2013-12-30 Mon 19:38]
    CLOCK: [2013-12-30 Mon 19:03]--[2013-12-30 Mon 19:38] =>  0:35

We seem to be creating om files in an incorrect directory. We need to
fix this before we can start looking at the diffs.

*** COMPLETED Fix differences in code generation between =om= and C++ model :story:
    CLOSED: [2014-01-01 Wed 14:00]
    CLOCK: [2013-12-30 Mon 19:38]--[2013-12-30 Mon 19:46] =>  0:08

Problems have been detected by the diff, and attached to this story as
tasks. One item won't be handled by this story:

-  missing includes: already covered by this [[*Add%20include%20file%20support%20to%20main%20type%20formatter][story]].

**** COMPLETED Missing licence                                         :task:
     CLOSED: [2013-12-31 Tue 13:21]
     CLOCK: [2013-12-31 Tue 12:24]--[2013-12-31 Tue 13:29] =>  1:05

Licence not coming out, need to add appropriate meta data.

**** COMPLETED Type of the variables is blank                          :task:
     CLOSED: [2013-12-31 Tue 15:41]
     CLOCK: [2013-12-31 Tue 13:53]--[2013-12-31 Tue 15:41] =>  1:48
     CLOCK: [2013-12-31 Tue 13:30]--[2013-12-31 Tue 13:53] =>  0:23

Problems:

- instead of =int= we're getting nothing at all.
- member variables are public

We were missing the entire story of tagging properties with required
meta-data.

**** COMPLETED Default constructor is compiler generated               :task:
     CLOSED: [2013-12-31 Tue 16:28]
     CLOCK: [2013-12-31 Tue 15:54]--[2013-12-31 Tue 16:28] =>  0:34

It should have been manually generated as we have an int member
variable.

**** COMPLETED =to_stream= and - =operator== have been added           :task:
     CLOSED: [2013-12-31 Tue 16:38]
     CLOCK: [2013-12-31 Tue 16:34]--[2013-12-31 Tue 16:50] =>  0:07

Should only be added in inheritance scenarios.

Partially fixes the swap issue, but more work still required.

**** COMPLETED No external =std::swap=                                 :task:
     CLOSED: [2014-01-01 Wed 14:00]
     CLOCK: [2014-01-01 Wed 13:09]--[2014-01-01 Wed 14:00] =>  0:51
     CLOCK: [2014-01-01 Wed 11:59]--[2014-01-01 Wed 13:07] =>  1:08
     CLOCK: [2014-01-01 Wed 10:29]--[2014-01-01 Wed 10:33] =>  0:04

The swap function is not being generated.

**** COMPLETED Broke the build whilst fixing a diff in std namespace  :spike:
     CLOSED: [2014-01-01 Wed 14:30]
     CLOCK: [2014-01-01 Wed 14:21]--[2014-01-01 Wed 14:29] =>  0:08
     CLOCK: [2014-01-01 Wed 14:01]--[2014-01-01 Wed 14:21] =>  0:20

- first get the build green
- then fix the diff properly

*** IMPLEMENTATION Add include file support to main type formatter    :story:

Inclusion support needs to be moved to the formatters. SML provides
all the required information at the model level in terms of type
dependencies, but only the formatter itself knows what includes it
needs because these are related to the implementation. Even
determining which facets of a type one should include is formatter
dependent. We need to distribute the logic of the includer into each
formatter.

**** COMPLETED Add initial inclusion processing support                :task:
     CLOSED: [2014-01-01 Wed 15:44]
     CLOCK: [2014-01-01 Wed 14:59]--[2014-01-01 Wed 15:43] =>  0:44
     CLOCK: [2014-01-01 Wed 14:35]--[2014-01-01 Wed 14:59] =>  0:24

Drill through all the layers to ensure the C++ inclusion class is
populated when we format the file.

**** COMPLETED Fix modeling errors in terms of forward declaration files :task:
     CLOSED: [2014-01-01 Wed 17:33]
     CLOCK: [2014-01-01 Wed 16:50]--[2014-01-01 Wed 16:55] =>  0:05

We need to be able to support forward declaration files at the facet
level; we incorrectly modeled this as if there was only one forward
declaration file for all the facets.

Actually, this was modeled correctly, we were just looking at the
wrong place.

**** Add includes for standard library types                           :task:
*** IMPLEMENTATION Solve the new lines issue in formatters            :spike:

We did a number of hacks to get the newlines to work correctly but in
reality all of these approaches are really bad. The problem is that
its not possible to know, when formatting one block, if there is a
need for a whitespace after or before it; only someone that has
visibility of both the current block, the previous and the one after
can make that decision. The best way of doing this is to create a
list of blocks and then use that to decide where to put in the new
lines.

**** ANALYSIS Analysis of the problem                                  :task:
     CLOCK: [2014-01-02 Thu 12:18]--[2014-01-02 Thu 13:28] =>  1:10
     CLOCK: [2014-01-02 Thu 12:00]--[2014-01-02 Thu 12:18] =>  0:18
     CLOCK: [2014-01-01 Wed 17:53]--[2014-01-01 Wed 18:20] =>  0:24
     CLOCK: [2014-01-01 Wed 17:34]--[2014-01-01 Wed 17:42] =>  0:08
     CLOCK: [2014-01-01 Wed 16:55]--[2014-01-01 Wed 17:34] =>  0:39

Result of white-boarding session:

- we need a class that acts as an interface in between the streaming
  and discretises the stream into "blocks". perhaps
  =stream_discretizer=? we could of course create a =discrete_stream=
  which is a specialised =ostream=.
- blocks are a logical construct, determined by the formatters
  themselves; they need to decide when a block starts and ends.
- this discretiser class then has an =assemble= method that can be
  called at the end to construct a string from all the blocks, adding
  new lines as required.

These are the options when it comes to joining blocks:

- do not add a new line before block: first block, doxygen comments.
- do not add line after block: last block, licence
- add line before block
- add line after block

Maybe an enumeration can model this:

- always add line before block
- add line before block if there is a previous block
- never add line before block
- same for after block

Actually what we really need is to create a new stream. All of these
could be modeled as manipulators. In addition we could also add most
of the members of utility and re-implement them as
manipulators. Internally, the device would be doing the chunking. At
the end it would provide access to the internal data structure so that
an assembler could create a single contiguous stream from the chunks.

Read up on the following:

- [[http://www.boost.org/doc/libs/1_55_0/libs/iostreams/doc/index.html][Boost IOStreams library]]
- [[http://comments.gmane.org/gmane.comp.lib.boost.devel/171399][Manipulators for ostreaming_streams]]

To check out Larry Evans code:

: svn co http://svn.boost.org/svn/boost/sandbox-branches/cppljevans

The end conclusion is we need to define our own =ostream= class and
provide it with an interface that suits our needs:

- indent in, indent out: ideally via the ++ and -- operators
- divisor: some way of stating that there is a split in the stream;
  the split is then interpreted depending on whether there is content
  before it, content after it, etc.
- We won't be able to add a lot of the utility stuff into the stream.

**** IMPLEMENTATION Add classes modeling stream and blocks             :task:
     CLOCK: [2014-01-02 Thu 23:23]--[2014-01-03 Fri 00:21] =>  0:58
     CLOCK: [2014-01-02 Thu 23:11]--[2014-01-02 Thu 23:22] =>  0:11
     CLOCK: [2014-01-02 Thu 16:09]--[2014-01-02 Thu 18:59] =>  2:50

Create the classes as per analysis.

*** Add required meta-data to test models                             :story:

In order for om to match the C++ model we need to make sure we are
passing in the correct meta-data such as licences, etc.

*** Add tests for =flat_name_builder=                                 :story:

We refactored tagger code related to flattening names into this class
but added no tests. We need good coverage, hopefully available from
C++ formatters.

*** Add tests for =annotation_factory=                                :story:

We added this class without any tests initially because we wanted to
first prove =om= worked. Once this is achieved we need to revisit this
class and add tests.

- missing licence
- missing modeline
- empty marker
- different marker for two objects
- consider moving generate preamble into annotation

*** Add tests for main header file formatter with optionality         :story:

We should add a couple of tests that exercise the annotation
factory. As it will have its own tests, we just need to make sure it
works in general. For example, pass in an empty annotation.

*** Use lowercase for all meta-data keys                              :story:

We have a number of legacy meta-data keys which are in uppercase and
need to be in lowercase. They may also need to be renamed to follow
the "namespacing" structure. Example:

: #DOGEN IDENTITY_ATTRIBUTE=true

This should really be:

: #DOGEN identity_attribute=true

*** Remove speculative facet layers for hash and serialization        :story:

For some unfathomable reason we decided to add a layer of indirection
for both hash and serialization. This is for speculative reasons as in
the future we may want to add boost hash and other forms of
serialization. However, in keeping with the (often violated) rule that
we never add code without a use case, we need to remove this.

*** Parameter to disable cpp file                                     :story:

It would be really useful to define a implementation specific
parameter which disables the generation of a cpp file for a
service. This would stop us from having to create noddy translation
units with dummy functions just to avoid having to define exclusion
regexes.

*** "Data driven" includer                                            :story:

We should simply go through all the types in the SML model and for
each type and each facet create the corresponding inclusion
path. locator can be used to generate standard paths, and a model
specific mapping is required for other models such as std.

Include then takes the relationships extracted by extractor, the
mappings generated by this mapper and simply appends to the inclusion
list the file names. it also appends the implementation specific
headers.

This story is very closely related to [[*Loading%20external%20models%20from%20file][profiles]].

*** Includer generation should be done from meta-data                 :story:
    CLOCK: [2013-10-27 Sun 20:40]--[2013-10-27 Sun 20:58] =>  0:18

It would be nice if we could determine which includer files to create
by looking at the meta-data. For this we need a notion of an inclusion
group, defined at the model level:

- =cpp.types.includers.general=
- =cpp.types.includers.value_objects=
- ...

Under each of these one would configure the aspect:

- =cpp.types.includers.general.generate=: =true=
- =cpp.types.includers.general.file_name=: =a/b/c=
- =cpp.types.includers.general.is_system=: =false=

Then, each type, module etc would declare its membership (as a list):

- =cpp.includers.member=: =cpp.types.includers.general=
- =cpp.includers.member=: =cpp.types.includers.value_objects=
- ...

** Deprecated Development Stories
*** CANCELLED Refactor Licence formatter                              :story:
    CLOSED: [2013-12-30 Mon 10:35]

Note: Implemented as part of =om=.

- year is hard-coded to 2012: At present the licence formatter has an
  hard-coded year of 2012. It should really be a parameter passed in.
- we should really only have one formatter that understands different
  commenting syntaxes (e.g. cmake comments, c++ comments).
- we should support multiple licences.

*** CANCELLED Add a code generation marker                            :story:
    CLOSED: [2013-12-30 Mon 10:35]

Note: Implemented as part of =om=.

Now that we've started to mix-and-match hand-crafted code with
code-generated code, we should really have an easy way to distinguish
which files are which. A simple comment at the top for files generated
by dogen (with the corresponding dogen version) would suffice. This
could be done in a similar fashion to the licence formatter. It should
either be after the licence or at the very top and take on the
responsibilities of emacs/vi headers.

We should also add a model level version which will be stamped on the
marker.

In addition, we should also stamp the dogen version too. However, this
will make all our tests break every time there is a new commit so
perhaps we need to have this switched off by default.

*** CANCELLED Stereotypes to disable facets                           :story:
    CLOSED: [2013-12-30 Mon 10:37]

Note: =om= provides a better way of implementing this functionality.

At present we do not generate files for all facets in a service other
than types. However, the correct fix is to have stereotypes to disable/enable
facets:

- =nonhashable=, =hashable=: hashing support
- =nontestable=, =testable=: test data support
- =nonserializable=, =serializable=: serialisation support
- =nonimplementable=, =implementable=: service does not have a CPP file
- =nonstreamable=, =streamable=: IO support

These stereotypes can then be combined:

: service,nonimplementable,serializable

Results in a service for which there will only be a header file and
serialization support.

By default services would have all aspects other than domain disabled,
entities and values would have all aspects enabled.

*** CANCELLED Create an SML level concept for facets                  :story:
    CLOSED: [2013-12-30 Mon 10:42]

Note: with the meta-data approach, this is no longer needed.

In reality, "facets" are not a C++ thing; they are language
neutral. They are, however, expressed differently in different
languages. For example:

- types: same on all languages
- debug_printing: overloaded operator<< in C++, toString() in Java,
  ToString() in C#, etc.
- serialisation: slightly less obvious, but effectively the most
  "native" serialisation available for the given programming
  language. For C++ this is boost serialisation.
- hashing: language specific support for hashing, in C++ either std
  hash or boost hash, in Java/C# overloading of hash functions.
- test_data: some facilities for test data generation
- relational: bindings for relational databases. ODB in C++.

We can introduce these concepts at the SML level, probably at the
=model= and =abstract_object= level; we can then do further
translation at the language level, as required.
