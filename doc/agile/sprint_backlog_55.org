#+title: Sprint Backlog 55
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) task(t) note(n) spike(p) }
#+tags: { refactor(r) bug(b) feature(f) vision(v) }
#+tags: { meta_data(m) tests(a) packaging(q) media(h) build(u) validation(x) diagrams(w) frontend(c) backend(g) }
#+tags: dia(y) sml(l) cpp(k) config(o) formatters(d)

* Stories

This file contains all stories that were closed during sprint 55.

The *Mission Statement* for this sprint is to continue to finish
implementing the C++ model workflow skeleton, creating the end-to-end
pipeline for at least one formatter.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2014-11-09 Sun 23:18]

| Headline                                                               | Time    |       |      |
|------------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                           | *13:21* |       |      |
|------------------------------------------------------------------------+---------+-------+------|
| Development Stories Implemented                                        |         | 13:21 |      |
| IMPLEMENTATION Sprint and product backlog grooming                     |         |       | 0:16 |
| COMPLETED Sort out postgres update problems                            |         |       | 0:36 |
| COMPLETED Refactor static data initialisation                          |         |       | 1:08 |
| COMPLETED Add support for facet settings                               |         |       | 4:10 |
| COMPLETED Implement factory for c++ settings                           |         |       | 0:20 |
| COMPLETED Copy across boilerplate formatter and specs                  |         |       | 0:38 |
| COMPLETED Implement transformation for class info objects in cpp model |         |       | 1:30 |
| IMPLEMENTATION Populate file name and includes                         |         |       | 4:00 |
| IMPLEMENTATION Implement class header formatter                        |         |       | 0:43 |
#+end:

*** IMPLEMENTATION Sprint and product backlog grooming                 :task:
    CLOCK: [2014-11-03 Mon 08:09]--[2014-11-03 Mon 08:16] =>  0:07
    CLOCK: [2014-11-03 Mon 07:59]--[2014-11-03 Mon 08:08] =>  0:09

Updates to sprint and product backlog.

*** Updates to the manual and readme files                       :task:media:

Use downtime to update the manual and / or readme file.

*** COMPLETED Sort out postgres update problems                       :spike:
    CLOSED: [2014-11-03 Mon 18:14]
    CLOCK: [2014-11-03 Mon 18:02]--[2014-11-03 Mon 18:14] =>  0:12
    CLOCK: [2014-11-03 Mon 08:26]--[2014-11-03 Mon 08:43] =>  0:17
    CLOCK: [2014-11-03 Mon 08:16]--[2014-11-03 Mon 08:23] =>  0:07

The latest dist-upgrade failed due to a format change on postgres
9.4. We need to drop and recreate the cluster or else we can't run
unit tests.

- dropped cluster 9.4 main
- created new cluster
- created user build with permissions to create dabatases
- altered it's password
- changed hba conf to use md5
- created databases from user build and added schemas
- un-commented create schema from database tests

*** COMPLETED Refactor static data initialisation             :task:refactor:
    CLOSED: [2014-11-03 Mon 22:23]
    CLOCK: [2014-11-03 Mon 22:01]--[2014-11-03 Mon 22:26] =>  0:25
    CLOCK: [2014-11-03 Mon 19:13]--[2014-11-03 Mon 19:24] =>  0:11
    CLOCK: [2014-11-03 Mon 18:26]--[2014-11-03 Mon 18:46] =>  0:20
    CLOCK: [2014-11-03 Mon 18:14]--[2014-11-03 Mon 18:26] =>  0:12

The objective of this story is to consider if there is any advantage
in aligning our names a bit more to C# IoC names, and/or to decide if
we should rename =static_initializer=.

We created registrar as a poor man's DI (dependency injection)
container. It had only the bare minimum functionality required to
allow dynamic discovery of backends and formatters. We also decided to
call it "registrar" rather than "container" because the latter would
be meaningless to pretty much any C++ programmer that is not familiar
with DI terminology in C#. We then created static data
initialisers. These are similar to installers in say Windsor Castle,
in that they are responsible for setting up the container. As with
Castle, it makes sense to create a chain of installers, and to have a
top level installer that calls all dependent installers so that a user
of a library does not have to worry about setting up its
dependencies. The next logical step after this is within the library
itself. For example, each facet is responsible for setting itself up
(in the future by creating its default facet settings). It would be
natural to create a facet-level installer and call it from the
model-level installer. however, the name =static_initializer= starts
becoming a bit cumbersome when one has so many of these lying around.

Conclusions:

- the names container and installer are confusing (container in
  particular);
- registrar is a good name since it manages registration;
- it is a shame that we interface with the registrar via the workflow
  though. Removed the delegation and made the registrar visible.
- we should rename =static_initializer= to just =initializer= and have
  an =initializer= per facet.

In general, we want to wait until C++ supports reflection properly
(C++ 17 hopefully) at which point proper DI libraries will start to
appear. For now we just want the bare minimum.

*** COMPLETED Add support for facet settings                          :story:
    CLOSED: [2014-11-05 Wed 20:47]
    CLOCK: [2014-11-05 Wed 20:21]--[2014-11-05 Wed 20:47] =>  0:26
    CLOCK: [2014-11-05 Wed 19:46]--[2014-11-05 Wed 19:59] =>  0:13
    CLOCK: [2014-11-05 Wed 18:05]--[2014-11-05 Wed 18:49] =>  0:44
    CLOCK: [2014-11-05 Wed 07:54]--[2014-11-05 Wed 08:51] =>  0:57
    CLOCK: [2014-11-04 Tue 19:53]--[2014-11-04 Tue 20:04] =>  0:11
    CLOCK: [2014-11-04 Tue 07:55]--[2014-11-04 Tue 08:46] =>  0:51
    CLOCK: [2014-11-03 Mon 23:16]--[2014-11-03 Mon 23:20] =>  0:04
    CLOCK: [2014-11-03 Mon 22:56]--[2014-11-03 Mon 23:09] =>  0:13
    CLOCK: [2014-11-03 Mon 22:28]--[2014-11-03 Mon 22:56] =>  0:28
    CLOCK: [2014-11-03 Mon 08:23]--[2014-11-03 Mon 08:26] =>  0:03

- create default settings in facet initialisers.
- create a facet settings factory: given a facet id, locates the
  meta-data for the facet.
- apply factory to all facets in workflow.
- supply all settings to formatter dispatcher, including map of facet
  settings by facet
- build the settings bundle in dispatcher

*** COMPLETED Implement factory for c++ settings                      :story:
    CLOSED: [2014-11-05 Wed 21:10]
    CLOCK: [2014-11-05 Wed 20:50]--[2014-11-05 Wed 21:10] =>  0:20

Add support for all of the main C++ properties in factory.

*** COMPLETED Copy across boilerplate formatter and specs     :task:refactor:
    CLOSED: [2014-11-05 Wed 22:44]
    CLOCK: [2014-11-05 Wed 22:24]--[2014-11-05 Wed 22:44] =>  0:20
    CLOCK: [2014-11-05 Wed 22:05]--[2014-11-05 Wed 22:23] =>  0:18

Seems like we didn't move across the boilerplate formatter and
associated classes. Move it now from =cpp_formatters=.

*** COMPLETED Implement transformation for class info objects in cpp model :story:
    CLOSED: [2014-11-06 Thu 22:19]
    CLOCK: [2014-11-06 Thu 22:10]--[2014-11-06 Thu 22:19] =>  0:09
    CLOCK: [2014-11-06 Thu 19:05]--[2014-11-06 Thu 19:50] =>  0:45
    CLOCK: [2014-11-06 Thu 08:08]--[2014-11-06 Thu 08:44] =>  0:36

In order to implement the class header formatter we need classes to
format. Copy across the code from the legacy transformer and refactor
it to fit the new class info.

*** IMPLEMENTATION Populate file name and includes                    :task:
     CLOCK: [2014-11-07 Fri 07:54]--[2014-11-07 Fri 08:45] =>  0:51
     CLOCK: [2014-11-06 Thu 22:38]--[2014-11-06 Thu 22:51] =>  0:13

Overall objectives:

- formatters must be able to populate the meta-data for the file name
  and system/user include files during SML workflow;
- transformer must be able to read this information using registrar to
  access all available formatters.

After reading all that has been written on this subject, it seems like
we have taken a wrong turn in the transition of =enricher= to
=consumer_interface=. We thought we could accumulate state rather than
mutate the meta-data in the model; however, if we accumulate state by
=qname= we then need to store it somewhere. It can't be stored in SML
(since we do not want to mutate the model) nor can we store it in C++
(we are).

**** COMPLETED Refactor diagram to include new classes
     CLOSED: [2014-11-09 Sun 23:17]
     CLOCK: [2014-11-09 Sun 23:03]--[2014-11-09 Sun 23:17] =>  0:14
     CLOCK: [2014-11-09 Sun 22:37]--[2014-11-09 Sun 23:03] =>  0:26
     CLOCK: [2014-11-09 Sun 20:28]--[2014-11-09 Sun 21:08] =>  0:40
     CLOCK: [2014-11-09 Sun 18:44]--[2014-11-09 Sun 19:38] =>  0:54
     CLOCK: [2014-11-07 Fri 17:25]--[2014-11-07 Fri 18:07] =>  0:42

We need to create a sub-workflow for the path specs.

*** IMPLEMENTATION Implement class header formatter :task:refactor:formatters:cpp:
    CLOCK: [2014-11-06 Thu 22:19]--[2014-11-06 Thu 22:36] =>  0:17
    CLOCK: [2014-11-06 Thu 07:54]--[2014-11-06 Thu 08:07] =>  0:13
    CLOCK: [2014-11-05 Wed 22:46]--[2014-11-05 Wed 22:59] =>  0:13

- look at the old =om= types formatter implementation to see if there
  is any code to scavenge. This model was deleted around commit
  10157ad.

**** COMPLETED Make use of boilerplate                                 :task:
     CLOSED: [2014-11-06 Thu 22:38]

Generate the licence, etc using boilerplate formatter.

**** Tidy-up =types_main_header_file_formatter=                        :task:

Clean up internal functions in file and add documentation.

**** Copy across documentation from =om=                               :task:

We did a lot of doxygen comments that are readily applicable, copy
them across.

**** Make use of indenting stream                                      :task:

Remove uses of old indenter.

**** Copy across =om= types formatter tests                            :task:

Not sure how applicable this would be, but we may be able to scavenge
some tests.

*** Populate property =is_original_parent_visitable= in SML   :task:refactor:

To make life easier in C++ model, we've added a new SML property:
=is_original_parent_visitable=. We need to look at the SML
transformation and ensure this property is populated correctly.

*** Add include files at the formatter level    :task:refactor:meta_data:cpp:

We need to remove all the include files from =includer= which are
related to formatter specific code. We need to inject these
dependencies inside of the formatters.

- implement includer in terms of json files
- get includer to work off of object relationships
- remove relationships from transformer
- remove helper models boost and std

*** Includer generation should be done from meta-data         :task:refactor:

It would be nice if we could determine which includer files to create
by looking at the meta-data. For this we need a notion of an inclusion
group, defined at the model level:

- =cpp.types.includers.general=
- =cpp.types.includers.value_objects=
- ...

Under each of these one would configure the aspect:

- =cpp.types.includers.general.generate=: =true=
- =cpp.types.includers.general.file_name=: =a/b/c=
- =cpp.types.includers.general.is_system=: =false=

Then, each type, module etc would declare its membership (as a list):

- =cpp.includers.member=: =cpp.types.includers.general=
- =cpp.includers.member=: =cpp.types.includers.value_objects=
- ...

*Previous understanding*

We should simply go through all the types in the SML model and for
each type and each facet create the corresponding inclusion
path. locator can be used to generate standard paths, and a model
specific mapping is required for other models such as std.

Include then takes the relationships extracted by extractor, the
mappings generated by this mapper and simply appends to the inclusion
list the file names. it also appends the implementation specific
headers.

*** Support "cross-facet interference"                         :task:feature:

In a few cases its useful to disable bits of a facet when another
facet is switched off because those bits do not belong to the main
facet the formatter is working on. At present this happens in the
following cases:

- Forward declaration of serialisation in domain when serialisation is
  off
- Friend of serialisation in domain when serialisation is
  off
- declaration and implementation of to_stream when IO is off
- declaration and implementation of inserter when IO is off and
  integrated IO is on.

We need a way of accessing the on/off state of all facets from any
formatter so that they can make cross facet decisions. A quick hack
was to add yet another flag: =disable_io= which is disabled when the
IO facet is not present and passed on to the relevant formatters. This
needs to be replaced by a more general approach.

*** Add frontends and backends to =info= command line option  :story:feature:

#+begin_quote
*Story*: As a dogen user, I want to know what frontends and backends
are available in my dogen version so that I don't try to use features
that are not present.
#+end_quote

With the static registration of frontends and backends, we should add
some kind of mechanism to display whats on offer in the command line,
via the =--info= option. This is slightly tricky because the
=frontend= and =backend= models do not know of the command line. We
need a method in the frontends that returns a description and a method
in the workflow that returns all descriptions. These must be
static. The knitter can then call these methods and build the info
text.

*** Rename the include tags and add them to CPP model          :task:bug:sml:

Update all the JSON files with names in the form
=cpp.include.types.header_file=. Add properties in =cpp= to capture
these.

While we're at it, add support for =family= too.

** Deprecated Development Stories

Stories that do not make sense any longer.
