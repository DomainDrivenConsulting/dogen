#+title: Sprint Backlog 88
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) }

* Mission Statement

- finish working on remaining formattables.
- document the conceptual model.
- implement wale and rewrite formatters in terms of wale templates.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-09-12 Mon 09:41]
| <75>                                                                        |        |      |      |       |
| Headline                                                                    | Time   |      |      |     % |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| *Total time*                                                                | *1:23* |      |      | 100.0 |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| Stories                                                                     | 1:23   |      |      | 100.0 |
| Active                                                                      |        | 1:23 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |        |      | 0:48 |  57.8 |
| COMPLETED Fix chocolatey warning                                            |        |      | 0:08 |   9.6 |
| COMPLETED Edit release notes for previous sprint                            |        |      | 0:27 |  32.5 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-09-12 Mon 09:28]--[2016-09-12 Mon 09:41] =>  0:13
    CLOCK: [2016-09-12 Mon 09:10]--[2016-09-12 Mon 09:20] =>  0:10
    CLOCK: [2016-09-12 Mon 08:15]--[2016-09-12 Mon 08:40] =>  0:25

Updates to sprint and product backlog.

*** COMPLETED Fix chocolatey warning                                  :story:
    CLOSED: [2016-09-12 Mon 09:28]
    CLOCK: [2016-09-12 Mon 09:20]--[2016-09-12 Mon 09:28] =>  0:08

We have a strange warning on our windows builds:

: cinst cmake -version 3.4.3
: Parsing -version resulted in exception:
: Cannot bundle unregistered option '-e'.

This doesn't appear to be fatal but its annoying.

Its covered by this issue:

[[https://github.com/chocolatey/choco/issues/842][#842: Parsing "-version" results in a warning message (instead of
"--version")]]

Fixed by using =--version=.

*** COMPLETED Edit release notes for previous sprint                  :story:
    CLOSED: [2016-09-12 Mon 08:55]
    CLOCK: [2016-09-12 Mon 08:56]--[2016-09-12 Mon 09:09] =>  0:13
    CLOCK: [2016-09-12 Mon 08:41]--[2016-09-12 Mon 08:55] =>  0:14

We should really start adding some kind of text with the
release. GitHub supports release notes so we should use them.

Text:

#+begin_src markdown
Dogen v0.87.0, "Cambongue"
==========================

This release is still mainly focused on internal refactorings of both the yarn and quilt.cpp models, but added a couple of user visible features:

- **Support for cross-model inheritance**: it is now possible to inherit types from referenced models. In addition, if the parent type was visitable, an "augmented" visitor is generated that takes into account the new derived types.
- **Performance improvements**: due to the changes required for cross-model inheritance, the overall performance of the code generator has gone up a bit; finger in the air measurements reveal its taking 60-50% of the time to generate the dogen models.
- **Visitor's accept methods have been moved to the cpp file**: in the past, adding a new descendant to a visitable parent resulted in large rebuilds because the parent included the visitor and the visitor had to change to accommodate the new descendant. Thus, all code that depended on the parent would get rebuilt. To avoid this, the accept methods have now been moved to the cpp file, resulting in smaller builds. We are also now using forward declarations in the visitor.

For more details see the [sprint log](https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_87.org).
#+end_src

*** Move =cmakelists_info= to fabric                                  :story:

Add the generation of CMakeLists to fabric and remove the legacy
formattable.

*** Move =odb_options_info= to fabric                                 :story:

Add the generation of ODB options to fabric and remove the legacy
formattable.

*** Document the conceptual model                                     :story:

We seem to be pretty close to the end of the conceptual model for
dogen. We should write it up whilst its still fresh. We should try to
use mathematical notation where possible to practice it. We should
also get it reviewed.

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

*** Generate formatter interfaces                                      :epic:

We should create another template language, in addition to stitch:
"wale". Wale is a very simple language that has templates that just do
token replacement. The tokens must have a special format:
={{{TOKEN}}}=. We receive a map of keys to values and do a blind
replacement to the keys on the wale document.

This links to stitch as follows:

- create a single file implementation of a formatter. It will
  implement both the provider interface and the appropriate formatter
  interface. It will call the stitch method to start off with. There
  are no headers, just cpp. It does the formatter registration.
- add support in stitch for "named sections": its possible to start a
  section and assign it a name. A stitch template will have two
  sections: inclusion provision and formatting.
- add support in stitch for "wale variables". These are just kvp's
  defined at the top:

: <#@ wale.variable="formatter_name=abcd" #>

  wale variables and sections are converted into a kvp container for
  wale input. Examples: facet, formatter name, etc.
- convert the formatter code into a wale template, adding wale
  variables as required.
- update stitch to detect wale usage and to call wale in those
  cases. This could be done by supplying a wale template:

: <#@ wale.template="abcd.wale" #>

- note that wale could be useful outside of stitch, for example for
  dart: we could wale-lise utility and then instantiate it for a given
  project.

*Previous Understanding*

It should be possible to generate some trivial types such as formatter
interfaces, formatter container, registrar and so on. For this we
need:

- a mustache type template;
- a set of fields from yarn types to be exposed to mustache;
- a list of types to iterate through.

Once we got this we could instantiate the templates. To integrate this
with knit we would need some way of specifying which types the
iteration would be over. We could mark a specific type with a given
stereotype, and then supply say the base class ("all leaf descendants
of xyz"). Dogen would then locate the descendants and for each call
the template.

For registrar and container its a bit trickier because we want a
collection of types in one go.

We also need a way to keep these templates away from the main (user
visible) code, since they are useful only for dogen.

See also [[https://github.com/cierelabs/boostache/tree/develop][boostache]].

Notes:

- we will need some "special" tags for copyright, includes
  etc. Includes will be particularly special because we need to
  augment the include list with additional includes. However, we may
  not even need to be aware of this.

*** Remove =optional<list>=                                           :story:

We should not really be using optional<list>. The empty list is
sufficient for this.

Uses:

- include provider.

*** Run tests that are passing on windows                             :story:

At present we have a release build on windows but we are not running
any tests. This is because some of the tests are failing at the
moment. We should run all test suites that are green to ensure we
don't regress without noticing.

*** Consider renaming settings to annotations                         :story:

Whilst its pretty clear now that settings are a strongly-typed
representation of the meta-data and properties are the post-processed
version, the names "settings" and "properties" still sound far too
similar. It would be nicer to have something more meta-data-like for
settings such as annotations. Read up the past discussions on
naming. One possible reason not to use annotations was because we used
it already in the formatters model. Perhaps that could be renamed to
something else, freeing up the name?

*** Consider removing the overwrite flag in =formatters::file=        :story:

Investigate if the overwrite flag makes sense in file; it seems we
only use it in two scenarios: force overwrite requested by user or
file contents have changed, both of which can be done in the
file_writer.

Actually this flag is needed. It is required to handle the case where
we do not code-generate files, unless they do not exist. For example,
for service headers and implementation we should create the files, but
then subsequently not touch them. The overwrite flag should be set to
false. We need to figure out how to implement this and remove the
hacks around file writing.

For now we have abused this flag to allow legacy files overrides of
the new world formatters. This is just until we move totally to new
world though.

*** Vistor is only supported at the base class level                  :story:

Due to implementation constraints, we only support visitable at the
base class level. Add an exception if users attempt to use visitable
stereotype in a class that has parents.

Note: is this true? We are using derived visitable in C++ model.

*** Add test model sanitizer to test models target                    :story:

At present if we build test models we don't seem to build the
sanitizer.

*** Remove =formattable_origin_type=                                  :story:

We seem to distinguish between "internal" and "external"
formattables. This probably won't make sense after the injection
refactor.

*** Path derivatives factory generates all possible includes          :story:

At present we are generating all possible includes for all
formatters. The problem is that we do not have a way to map a yarn type
to a set of  C++ formatters, so to make our life easier we simply
generate them all. This has another (lucky) side-effect: when we are
doing the includes, we do not know what formatter the qname belongs to
so we just default to the class header formatter. As it happens this
is not a problem (as explained [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_68.org#inclusion-relies-on-knowing-sml-to-cpp-mapping][here]]).

We need a proper solution for this:

- only generate includes for the formatters that need them;
- find a way to look for the right formatter given a qname.

This last bit requires a bit of thinking. From a certain angle, we
don't particularly care about formatters - we are simply asking for
"the domain header for this type" or the "serialisation header for
this type". It seems we need a higher level concept that formatters
can belong to (similar to the formatter groups). This concept should
allow one and only one formatter to exist for a given qname - we can't
have both an enumeration header and a class header.

*** Model should contain set of primitive id's                        :story:

We are computing the set of all primitive id's in quilt but this
should really be part of yarn.

*** Implement formattables in terms of yarn types                     :epic:

At present formattables are just a shadow copy of yarn types plus
additional =cpp= specific types. In practice:

- for the types that are shadow copies, we could have helper utilities
  that do the translation on the fly (e.g. for names).
- for additional information which cannot be translated, we could have
  containers indexed by qualified name and query those just before we
  call the transformer. This is the case with formatter properties. We
  need something similar to house "type properties" such as
  =requires_stream_manipulators=. These could be moved into aspect
  settings.
- for types that do not exist in yarn, we could inherit from element;
  this is the case for registrar, forward declarations, cmakelists and
  odb options. Note that with this we are now saying that element
  space contains anything which can be modeled, regardless of if they
  are part of the programming language type system, or build system,
  etc. This is not ideal, but its not a problem just yet. We could
  update the factory to generate these types and then take a copy of
  the model and inject them in it.

*** Handle "special includes" correctly                              ::story:

We did a quick hack to handle "special includes": we simply "detected"
them in include builder and then did the appropriate action in each of
the include providers. In order to make this work dynamically, we need
somehow to have "associated includes" on a per type basis. For
example:

- type =x= requires include =y= in formatter =f=.

This can easily be achieved via an "additional inclusion directive"
which is a container. For example:

:        "extensions" : {
:                "quilt.cpp.helper.family" : "Dereferenceable",
:                "quilt.cpp.types.class_header_formatter.inclusion_directive" : "<boost/weak_ptr.hpp>",

Could have:

:                "quilt.cpp.types.class_header_formatter.additional_inclusion_directive" : "<some_include.hpp>",

If multiple are provided then they are all added. This highlights an
important point: we need a way to inject type specific includes from a
formatter. It makes no sense to declare all of these up front in a
library since we do not know what all possible formatters are, nor
what requirements they may have for inclusion. At the same time,
formatters cannot be expected to declare types. The solution is to be
able to "inject" these dependencies from a JSON file associated with
the formatter. We could supply the qualified name and the properties
to inject. This problem can be solved later on - create a separate
story for this.

*** Supply model references via meta-data rather than command line    :story:

It doesn't make any sense to have model dependencies in the command
line. After all, the model cannot be interpreted without them. A
better way to do this would be to split this functionality into two:

- command line supplies "import directories", that is, directories
  to search when looking for models. By default the system directory
  is already in the path.
- model supplies "import statements". The problem here is that we need
  to also supply the file name of the model. We could perhaps omit the
  extension and then load all files that match (e.g. =.dia=, =.json=,
  etc). If more than one matches we should error. Actually we should
  just supply the full filename, as well as keep the current notation
  for the external project path.

This is also a nice way to avoid loading system models unnecessary;
users still need to declare the models they depend on, regardless if
system or user.

Each model should also supply the external module path as meta-data.

This is particularly painful since cross-model inheritance was
introduced because it means references are now transitive (we need to
know of the references of any model we reference).

Merged stories

*External module path and references as meta-data*

It actually does not make a lot of sense to allow users to supply
external module paths and references as command line options. This is
because the model will fail to build unless we provide the correct
ones; these are not configurable items in this sense. The project
path, etc are - and so should remain command line options.

We need to move these two into the meta-data. This would also mean we
no longer need to pass in external module paths for references, which
is much cleaner.

** Deprecated
*** CANCELLED Consider renaming formatters                            :story:
    CLOSED: [2016-09-12 Mon 09:29]

*Rationale*: Actually, we don't want users to think of the
presentation model when looking at formatters. It is a good analogy if
you understand what it is that we are trying to do, but its probably
confusing for someone new to code generation. We'll stick to
formatters and use formatting functions in our description of the
conceptual model.

After reading the [[http://martinfowler.com/eaaDev/PresentationModel.html][Presentation Model]] pattern a bit more carefully, it
seems it provides a good approach for formatters. If one thinks of the
file as the view, then the formatters are the presenters and the model
representing all presentation logic (e.g. =cpp=) is the presentation
model. We could:

- create a top-level folder called =presentation=;
- rename =formatters= to =core= and move it to =presentation=;
- move =cpp= to =presentation=;
- in =cpp=:
  - rename =formattables= to =presentables=;
  - rename =formatters= to =presenters=;
- in this light, =backend= is really the "meta-workflow" for all
  possible presentations. It should really live under presentation. It
  would make more sense to merge it with =core=, if it were not that
  core contains all sorts of loose bits that are useful only in the
  guts of presentation. We could call it =orchestration= or some such
  name. Or we could leave it as =presentation::backends=.
- move =file= to =backends=. We don't really want external clients to
  have to know about =core= just to obtain a single type. Also,
  backends shouldn't really have any dependencies.
- grep for formatting, formattables, formatter, format, etc. and
  ensure all usages have been replaced with present*.

We should wait until the "great refactoring" is done so that we do not
have to rename the legacy models too.

*Merged with duplicate*

These are not really formatters; not sure what the right name should
be though; templates?
