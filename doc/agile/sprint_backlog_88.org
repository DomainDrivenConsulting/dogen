#+title: Sprint Backlog 88
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) }

* Mission Statement

- finish working on remaining formattables.
- document the conceptual model.
- implement wale and rewrite formatters in terms of wale templates.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-09-15 Thu 11:35]
| <75>                                                                        |         |       |      |       |
| Headline                                                                    | Time    |       |      |     % |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| *Total time*                                                                | *21:11* |       |      | 100.0 |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| Stories                                                                     | 21:11   |       |      | 100.0 |
| Active                                                                      |         | 21:11 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |         |       | 2:13 |  10.5 |
| COMPLETED Fix chocolatey warning                                            |         |       | 0:08 |   0.6 |
| COMPLETED Edit release notes for previous sprint                            |         |       | 0:27 |   2.1 |
| COMPLETED Analysis on current state of file path generation                 |         |       | 0:57 |   4.5 |
| CANCELLED Remove inclusion dependencies builder factory                     |         |       | 0:14 |   1.1 |
| COMPLETED Analysis on formatters, elements and extensibility                |         |       | 1:18 |   6.1 |
| COMPLETED Refactor =inclusion_dependencies_provider_interface=              |         |       | 1:12 |   5.7 |
| COMPLETED Investigate broken windows builds                                 |         |       | 0:32 |   2.5 |
| COMPLETED Refactor path derivatives factory for usage in formatters         |         |       | 5:14 |  24.7 |
| COMPLETED Move file path generation to formatters                           |         |       | 1:58 |   9.3 |
| CANCELLED Path derivatives factory generates all possible includes          |         |       | 3:07 |  14.7 |
| COMPLETED Analysis on inclusion derivatives and path derivatives            |         |       | 1:04 |   5.0 |
| STARTED Split path factory from provider factory                            |         |       | 2:31 |  11.9 |
| STARTED Remove formattable origin type                                      |         |       | 0:16 |   1.3 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-09-15 Thu 08:48]--[2016-09-15 Thu 09:01] =>  0:13
    CLOCK: [2016-09-13 Tue 20:09]--[2016-09-13 Tue 20:50] =>  0:41
    CLOCK: [2016-09-12 Mon 21:57]--[2016-09-12 Mon 22:03] =>  0:06
    CLOCK: [2016-09-12 Mon 12:23]--[2016-09-12 Mon 12:26] =>  0:03
    CLOCK: [2016-09-12 Mon 10:40]--[2016-09-12 Mon 11:02] =>  0:22
    CLOCK: [2016-09-12 Mon 09:28]--[2016-09-12 Mon 09:41] =>  0:13
    CLOCK: [2016-09-12 Mon 09:10]--[2016-09-12 Mon 09:20] =>  0:10
    CLOCK: [2016-09-12 Mon 08:15]--[2016-09-12 Mon 08:40] =>  0:25

Updates to sprint and product backlog.

*** COMPLETED Fix chocolatey warning                                  :story:
    CLOSED: [2016-09-12 Mon 09:28]
    CLOCK: [2016-09-12 Mon 09:20]--[2016-09-12 Mon 09:28] =>  0:08

We have a strange warning on our windows builds:

: cinst cmake -version 3.4.3
: Parsing -version resulted in exception:
: Cannot bundle unregistered option '-e'.

This doesn't appear to be fatal but its annoying.

Its covered by this issue:

[[https://github.com/chocolatey/choco/issues/842][#842: Parsing "-version" results in a warning message (instead of
"--version")]]

Fixed by using =--version=.

*** COMPLETED Edit release notes for previous sprint                  :story:
    CLOSED: [2016-09-12 Mon 08:55]
    CLOCK: [2016-09-12 Mon 08:56]--[2016-09-12 Mon 09:09] =>  0:13
    CLOCK: [2016-09-12 Mon 08:41]--[2016-09-12 Mon 08:55] =>  0:14

We should really start adding some kind of text with the
release. GitHub supports release notes so we should use them.

Text:

#+begin_src markdown
Dogen v0.87.0, "Cambongue"
==========================

This release is still mainly focused on internal refactorings of both the yarn and quilt.cpp models, but added a couple of user visible features:

- **Support for cross-model inheritance**: it is now possible to inherit types from referenced models. In addition, if the parent type was visitable, an "augmented" visitor is generated that takes into account the new derived types.
- **Performance improvements**: due to the changes required for cross-model inheritance, the overall performance of the code generator has gone up a bit; finger in the air measurements reveal its taking 60-50% of the time to generate the dogen models.
- **Visitor's accept methods have been moved to the cpp file**: in the past, adding a new descendant to a visitable parent resulted in large rebuilds because the parent included the visitor and the visitor had to change to accommodate the new descendant. Thus, all code that depended on the parent would get rebuilt. To avoid this, the accept methods have now been moved to the cpp file, resulting in smaller builds. We are also now using forward declarations in the visitor.

For more details see the [sprint log](https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_87.org).
#+end_src

*** COMPLETED Analysis on current state of file path generation       :story:
    CLOSED: [2016-09-12 Mon 10:39]
    CLOCK: [2016-09-12 Mon 09:42]--[2016-09-12 Mon 10:39] =>  0:57

File path generation is closely related to the conceptual model of
formatting.

One of the problems we've had with CMakeLists is that they don't
really follow the established structure. Up to now the conceptual
model for formatters had the notion of facets; each facet could map to
its own folder. All facets were thought of as conceptual entities at
the same hierarchical level. However, this breaks down with
CMakeLists:

- we have one at the top of the project, containing the install
  instructions for the include files; it may also include the ODB
  targets.
- we have another in =src=, with the details of the target.
- we should probably also have a final one under =tests=, but we are
  not generating it at present. Or perhaps the whole of tests is just
  material for dart with simpler templates.

A similar situation occurs with ODB and its =options.odb= file, placed
under =src=.

One possible update to the formatters conceptual model is this: a
facet may be composed of facets and/or formatting functions. Projects
all have a "root" facet called the "project facet". That is then made
up of the "source" and "include" facets, which are then made up of the
traditional facets (e.g. types, serialisation and so on). The problem
with this approach is that, at present, source/include are orthogonal
to the facets - i.e. a formatter belongs to say types, but it does not
belong to =src=. We infer =src= from the fact that the formatter is a
=cpp_header= or =cpp_implmentation= (which in itself is wrong).

Another approach is to think of the formatting functions as living in
a space (formatting function space), each with their own unique
id. The id maps to a list of strings, which is the path to the
formatting function in formatting function space. Lets call this the
"formatter path". The formatter path must be unique. The formatter
path is then mapped to a filesystem path when the formatting function
is applied to an element from modeling space. Each formatter must know
its formatter path, albeit they can rely on some top-level helpers
since there are only two or three kinds of paths.

One important consideration is that the formatter path is a function
that takes in:

- options (project, source and include directories);
- model name: model modules, external modules.
- facet directory.

Actually this is not the right way to look at this. The formatter path
should be static for all models since formatting functions live in
formatting function space and these are not sensitive to the model the
user is supplying. However, file paths are. Thus we just need to get
the formatters to compute the file paths. We should obtain the path
settings as we are doing now, but then supply them to the
formatters. We should also compute the path derivatives for all
elements in modeling space, not just c++ headers and implementation.

To cater for the elements which do not map to a facet we should
introduce the concept of the empty facet in the conceptual model.

*** CANCELLED Remove inclusion dependencies builder factory           :story:
    CLOSED: [2016-09-12 Mon 19:08]
    CLOCK: [2016-09-12 Mon 18:54]--[2016-09-12 Mon 19:08] =>  0:14

Its not entirely clear why we need a factory to instantiate a builder
when the factory does very little other than forward arguments. Try
removing it and see what breaks.

Actually the reason why is that without a factory we'd have to pass in
the builder by non-const ref since the builder needs to mutate its
state in order to build. Added documentation for this.

*** COMPLETED Analysis on formatters, elements and extensibility      :story:
    CLOSED: [2016-09-12 Mon 21:47]
    CLOCK: [2016-09-12 Mon 21:15]--[2016-09-12 Mon 21:47] =>  0:32
    CLOCK: [2016-09-12 Mon 20:27]--[2016-09-12 Mon 20:32] =>  0:05
    CLOCK: [2016-09-12 Mon 19:45]--[2016-09-12 Mon 20:26] =>  0:41

At present if one adds a new formatter dynamically which formats a new
(injected) modeling type, it will either be totally ignored by dogen
or it will break (still to be proved which). This is because we use a
container of formatters mapping to well defined modeling elements; we
loop through those to format. The modeling elements must be defined on
either yarn or quilt.cpp - not by the user.

This approaches has advantages such as avoiding having to dispatch
both the element and the formatter but it seems a bit of a problem
that we cannot add formatters with new modeling types due to this.

For this use case to work we would need to somehow be able to resolve
the element type to a concrete type, and then be able to get all the
formatters and include providers etc for that concrete element. We
could start creating maps by [[http://en.cppreference.com/w/cpp/types/type_index][type index]] (see example below). All the
consumer of derived elements would register themselves against that
type id. When called, they can statically or dynamically cast the
element to the expected type. Using formatters an example:

- get rid of formatters container and have a simple list of
  formatters.
- at registration time, register against the derived element's type
  id/index.
- change model to have a map of type id to element instead of a list.
- during formatting, for each element request all formatters for that
  type id.

Actually perhaps we should look at this slightly differently: the
extensibility points are not around modeling elements but around
formatters. The system is not designed to allow users to add new
element types; this would mean, for example, that the computations
around properties would have to also be extensbile and so
forth. However, given a fixed set of modeling elements, users can
freely add new formatters (belonging to new or existing facets). If we
declare these to be the extensibility points, then we no longer have
problems with hard-coding.

Papers and assorted links read:

- [[http://sebox.cs.iupui.edu/PDF/visitor-survey-2013.pdf][A Survey Report of Enhancements to the Visitor Software Design
  Pattern]]
- [[http://www.cs.loyola.edu/~binkley/722/src/visitors/doc/p270-visser.pdf][Visitor Combination and Traversal Control]]
- [[http://www.stroustrup.com/multimethods.pdf][Open Multi-Methods for C++]]
- [[http://codereview.stackexchange.com/questions/84176/proper-use-of-type-info-in-relation-to-mapping-components-to-a-type][Proper use of type_info in relation to mapping components to a type]]

*** COMPLETED Refactor =inclusion_dependencies_provider_interface=    :story:
    CLOSED: [2016-09-13 Tue 09:57]
    CLOCK: [2016-09-13 Tue 08:45]--[2016-09-13 Tue 09:57] =>  1:12

We need to generalise this interface to cope with path derivatives.

Tasks:

- rename to =provider_interface=
- add containers for all elements, including injected ones.
- add methods:
  - =provide_inclusion_dependencies=
  - =provide_path_derivatives=: actually lets add this when we
    implement it.

*** COMPLETED Investigate broken windows builds                       :story:
    CLOSED: [2016-09-14 Wed 09:37]
    CLOCK: [2016-09-14 Wed 09:21]--[2016-09-14 Wed 09:37] =>  0:16
    CLOCK: [2016-09-14 Wed 08:05]--[2016-09-14 Wed 08:21] =>  0:16

Opened issue with Conan [[https://github.com/conan-io/conan/issues/481][#481]]:

#+begin_src markdown
Hi guys,

My dogen windows builds started failing since last night[1] with the following error:

```
echo "Downloading conan..."
"Downloading conan..."
wget http://downloads.conan.io/latest_windows -OutFile conan_installer.exe
conan_installer.exe /VERYSILENT
set PATH=%PATH%;C:\Program Files (x86)\Conan\conan
conan --version
Error loading Python DLL: C:\Program Files (x86)\Conan\conan\python27.dll (error code 14001)
Command exited with code -1
```

Any ideas what could be causing this? I've done a couple just to check if its an environmental problem, to no avail. [2],[3]

Cheers

Marco

[1] https://ci.appveyor.com/project/mcraveiro/dogen/build/2.2.361/job/yglufvdim4xa19bi for Debug and https://ci.appveyor.com/project/mcraveiro/dogen/build/2.2.361/job/wqukii4wcspel7cm for Release
[2] https://ci.appveyor.com/project/mcraveiro/dogen/build/2.2.361/job/yglufvdim4xa19bi for Debug and https://ci.appveyor.com/project/mcraveiro/dogen/build/2.2.361/job/wqukii4wcspel7cm for Release
[3] https://ci.appveyor.com/project/mcraveiro/dogen/build/2.2.363/job/m2a76xq0qe8qkvou for Debug and
https://ci.appveyor.com/project/mcraveiro/dogen/build/2.2.363/job/m98mj8nl1sf26xg4 for Release
#+end_src

Solved with the workaround proposed by memsharded, documented in ticket.

*** COMPLETED Refactor path derivatives factory for usage in formatters :story:
    CLOSED: [2016-09-14 Wed 21:09]
    CLOCK: [2016-09-14 Wed 10:54]--[2016-09-14 Wed 11:01] =>  0:07
    CLOCK: [2016-09-14 Wed 10:40]--[2016-09-14 Wed 10:53] =>  0:13
    CLOCK: [2016-09-14 Wed 10:31]--[2016-09-14 Wed 10:39] =>  0:08
    CLOCK: [2016-09-14 Wed 10:15]--[2016-09-14 Wed 10:30] =>  0:15
    CLOCK: [2016-09-14 Wed 09:51]--[2016-09-14 Wed 10:14] =>  0:23
    CLOCK: [2016-09-14 Wed 09:38]--[2016-09-14 Wed 09:51] =>  0:13
    CLOCK: [2016-09-14 Wed 08:40]--[2016-09-14 Wed 09:20] =>  0:40
    CLOCK: [2016-09-13 Tue 12:00]--[2016-09-13 Tue 12:24] =>  0:24
    CLOCK: [2016-09-13 Tue 11:38]--[2016-09-13 Tue 11:59] =>  0:21
    CLOCK: [2016-09-13 Tue 11:26]--[2016-09-13 Tue 11:37] =>  0:11
    CLOCK: [2016-09-13 Tue 11:06]--[2016-09-13 Tue 11:25] =>  0:19
    CLOCK: [2016-09-13 Tue 10:36]--[2016-09-13 Tue 11:05] =>  0:29
    CLOCK: [2016-09-13 Tue 09:58]--[2016-09-13 Tue 10:35] =>  0:37
    CLOCK: [2016-09-12 Mon 18:35]--[2016-09-12 Mon 18:54] =>  0:19
    CLOCK: [2016-09-12 Mon 11:26]--[2016-09-12 Mon 12:01] =>  0:35

At present the path derivatives factory is designed to generate paths
internally. In an ideal world, it should be used by the formatters to
generate paths. Generate an API for this.

Use cases:

- c++ header file in include.
- c++ implementation file in src.
- cmakelists at project level.
- cmakelists, odb options at src level.

Kinds of paths:

- elements in facets: relative facet path? facet path? common to src
  and include.
- include path: relative facet path plus external and model
  modules. Include only.
- full path: made up of the base (project directory and model module)
  plus either nothing (project level items) or a directory (source or
  include) plus the relative facet path or the include path.

We could create the following methods:

- make full path: takes in the relative path (either a relative facet
  path or the include path), the directory (either empty, source or
  include). Produces a full path.
- make facet path: takes in a name, an extension and the path settings
  and produces the facet path.
- make include path: takes in a name, a file extension and the path
  settings; calls make facet path and augments the result.
- make cpp header: calls above functions to generate the path
  derivatives for the c++ header. Takes in a name, formatter name.
- make cpp implementation: calls above functions to generate the
  path derivatives for the c++ implementation.
- make project level item: cmakelists at project level.
- make source level item: cmakelists at source level.

We should consider caching parts of the path that are const for all
elements.

Tasks:

- refactor factory to use the API defined above for the current use
  cases.

*** COMPLETED Move file path generation to formatters                 :story:
    CLOSED: [2016-09-14 Wed 21:09]
    CLOCK: [2016-09-13 Tue 22:18]--[2016-09-13 Tue 22:27] =>  0:09
    CLOCK: [2016-09-13 Tue 21:57]--[2016-09-13 Tue 22:17] =>  0:20
    CLOCK: [2016-09-13 Tue 20:51]--[2016-09-13 Tue 21:56] =>  1:05
    CLOCK: [2016-09-12 Mon 12:02]--[2016-09-12 Mon 12:22] =>  0:20
    CLOCK: [2016-09-12 Mon 11:21]--[2016-09-12 Mon 11:25] =>  0:04

Tasks:

- create a helper class that knows how to generate paths for headers,
  implementation etc.
- add a method in the formatter interface that takes in the options,
  path settings, model name, element name and generates the path
  derivatives for the formatter.
- update the path derivatives repository factory to take in the
  formatters' container. When making, create a container with a pair
  of formatter and path settings. Then, for each element, loop through
  the pairs; call the formatter with the element name and path
  settings to generate the path derivatives. Continue the anti-pattern
  of generating a path derivatives set that is the cross-product of
  all elements and formatters even though we know this is not right
  (backlogged as "Path derivatives factory generates all possible
  includes").
- remove visitation in path derivatives repository factory.
- remove =file_types=.

Merged stories:

*File extension is hard-coded against file type*

At present we are choosing the C++ extension based on the file type:

:    if (ps.file_type() == formatters::file_types::cpp_header)
:       stream << dot << ps.header_file_extension();
:    else if (ps.file_type() == formatters::file_types::cpp_implementation)
:        stream << dot << ps.implementation_file_extension();

It would make more sense to have a formatter group - e.g. header or
implementation - and to associate the extension with the group.

*** CANCELLED Path derivatives factory generates all possible includes :story:
    CLOSED: [2016-09-14 Wed 21:09]
    CLOCK: [2016-09-14 Wed 20:11]--[2016-09-14 Wed 21:09] =>  0:58
    CLOCK: [2016-09-14 Wed 11:02]--[2016-09-14 Wed 12:27] =>  1:25
    CLOCK: [2016-09-12 Mon 21:48]--[2016-09-12 Mon 21:56] =>  0:08
    CLOCK: [2016-09-12 Mon 19:09]--[2016-09-12 Mon 19:45] =>  0:36

At present we are generating all possible includes for all
formatters. The problem is that we do not have a way to map a yarn type
to a set of  C++ formatters, so to make our life easier we simply
generate them all. This has another (lucky) side-effect: when we are
doing the includes, we do not know what formatter the qname belongs to
so we just default to the class header formatter. As it happens this
is not a problem (as explained [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_68.org#inclusion-relies-on-knowing-sml-to-cpp-mapping][here]]).

We need a proper solution for this:

- only generate includes for the formatters that need them;
- find a way to look for the right formatter given a qname.

This last bit requires a bit of thinking. From a certain angle, we
don't particularly care about formatters - we are simply asking for
"the types header for this type" or the "serialisation header for this
type". It seems we need a higher level concept that formatters can
belong to (similar to the formatter groups). This concept should allow
one and only one formatter to exist for a given qname - we can't have
both an enumeration header and a class header.

Actually the solution for this is quite simple:

- start by mapping elements to facets and formatters: for a given id
  and a given facet, there is a formatter responsible for providing
  the header file. This could be done in the builder factory at
  construction. The map must have a pair of (header, forward
  declaration).
- change builder to take in a facet name rather than a formatter name
  and a flag to indicate whether to use forward declarations or
  not. For each addition, resolve the formatter name and then use the
  formatter name to resolve the path settings (or alternatively map
  them all at the start).

This is not ideal because sometimes we do want to supply a specific
formatter (forward declarations, visitor). What we need is some kind
of resolver, used where necessary. For a given facet and element id,
it returns its main header.

This could be achieved in exactly the same fashion as we did for
includes: we register types against a parameterised interface, which
is implemented by the formatter. We could even rename
=inclusion_dependencies_provider_interface= to just
=provider_interface= and then have two methods:

- =provide_inclusion_dependencies=
- =provide_path_derivatives=

This would fit in nicely with the refactor where providers are
statically registered against the workflow.

Tasks:

- add "supports inclusion" and "is default element facet
  inclusion". Names to be (greatly) improved upon.
- in inclusion directories repository factory, for each element,
  compute the list of relevant formatters and the map of default
  formatters for facet and element type (i.e. given a formatter name,
  if it is the default for a facet, returns the facet name). The list
  is computed by going to the formatter container for the element in
  question.
- supply the list to directives settings. Ignore all formatters that
  are not relevant.
- in inclusion directories factory, if a formatter is the default
  formatter, inject a new entry into the directives map against the
  facet.
- on all formatters where we do not know the specific formatter name,
  use the facet name.

Use cases:

- system types do not need anything because in most cases we just need
  the inclusion directive and this has been overridden in settings.
- reference models need only the include directive. However we are
  also computing the file path and header guard.
- target model types need all three.

*** COMPLETED Analysis on inclusion derivatives and path derivatives  :story:
    CLOSED: [2016-09-15 Thu 08:48]
    CLOCK: [2016-09-15 Thu 08:38]--[2016-09-15 Thu 08:47] =>  0:09
    CLOCK: [2016-09-15 Thu 08:23]--[2016-09-15 Thu 08:38] =>  0:15
    CLOCK: [2016-09-14 Wed 21:09]--[2016-09-14 Wed 21:49] =>  0:40

Originally we did an artificial separation between path derivatives
and inclusion directives. The idea was that we'd calculate up front
all of the path derivatives:

- full path
- header guard
- inclusion directive

As these were all related to the file path (in this general view of
the world). We would then, separately, have heuristics to compute the
_actual_ include directive. This would have to take into account a few
more factors:

- not all types have include directives for all facets; some haven't
  got them at all, some have them for some facets.
- some types need to override their includes for certain/all facets.

However, this causes some problems:

- we are computing the path derivatives for all model elements,
  including referenced models and system models. This makes no sense.
- we are generating path derivatives for the cross-product between
  elements and formatters, when in reality only a small subset of this
  cross-product needs it.
- for referenced models, we do not always need to compute the
  inclusion directive, since it could have been overridden.

Ideas:

- merge the work of path derivatives and inclusion directives into a
  single class. Its not easy to name the class. It will continue to
  capture the path derivatives and inclusion directives in separate
  repositories, but it will populate them both at the same time. This
  means we don't have to generate "fake" path derivatives for types
  that just need an inclusion directive. For this we will have to
  extend the provider with a method to provide just the include path.
- this means we can drop the include directive from path derivatives.
- we need to compute up front the list of the formatters per element
  type which can contribute to inclusion directives. We then need to
  setup the settings factory to only look at fields from those
  formatters.
- we need to add a default inclusion which is the facet name to the
  inclusion directives map, against each name.
- formatter properties should just iterate through the generatable
  types and pick up their properties. We are generating a lot more
  formatter properties than needed at the moment.

Final thoughts on this: the above is still to complicated. Instead:

- lets remove inclusion path from path derivatives and perform it
  directly in inclusion directives. This means regenerating the path
  and having to supply providers and so on.
- add flags to formatters interface and group them by flags. This is
  only required for inclusion directives.

*** COMPLETED Consider creating a "locator" like class for path management :story:
    CLOSED: [2016-09-15 Thu 09:37]

*Rationale*: done as part of the path directives refactor.

At present we are using path settings to compute paths in several
places. Most of these exist because of hacks but it still seems that
it needs to be done in more than one place. We should consider
something like we had in =sml_to_cpp::locator= that is initialised
with the path settings and can then be used to create paths.

*** STARTED Split path factory from provider factory                  :story:
    CLOCK: [2016-09-15 Thu 10:12]--[2016-09-15 Thu 11:34] =>  1:22
    CLOCK: [2016-09-15 Thu 10:00]--[2016-09-15 Thu 10:11] =>  0:11
    CLOCK: [2016-09-15 Thu 09:01]--[2016-09-15 Thu 09:59] =>  0:58

Tasks:

- create a path factory class that takes on all the responsibilities
  related to paths from path derivatives factory - basically all
  methods except header guard generation. Call this class locator to
  avoid confusion (too many classes with "path" in the name).
- generate the factory in the properties workflow and supply it to the
  repository factory.
- update provider interface to use factory.
- Remove path derivatives factory and implement the remaining logic
  directly in the repository factory, including header guard
  generation.

*** Use providers when building inclusion directives                  :story:

Tasks:

- supply providers to inclusion directives repository factory instead
  of path derivatives;
- compute the inclusion directive on the fly.
- remove inclusion directive from path settings.
- remove inclusion directive factory; perform all the work in the
  repository factory.

*** Do not merge containers for formatter properties                  :story:

We only need to generate the formatter properties for elements in the
target model. Start from those instead of merging.

*** STARTED Remove formattable origin type                            :story:
    CLOCK: [2016-09-12 Mon 11:11]--[2016-09-12 Mon 11:20] =>  0:09
    CLOCK: [2016-09-12 Mon 11:03]--[2016-09-12 Mon 11:10] =>  0:07

This should not be in use any longer so remove it. Actually this
cannot be done until we handle cmakelists and odb options via
fabric. This is because path settings will not be computed correctly.

Tasks:

- remove enumeration
- remove container of internal and external formatters in formatter
  container.

*** Move registration of inclusion dependencies to initialiser        :story:

At present we are iterating through the formatters list in properties
and manually registering all include providers via the interface. This
is not ideal because the formatter interface needs to know of include
providers, meaning we can't move it away from =quilt.cpp=.

When we register a formatter we should also register the include
provider too.

Tasks:

- add provider support directly to the formatters instead of another
  class and remove registration from formatter interface.
- add a static registrar for the include providers in workflow.
- change initialiser to register the include providers from the same
  shared pointer.

*** Move =cmakelists_info= to fabric                                  :story:

Add the generation of CMakeLists to fabric and remove the legacy
formattable.

*** Move =odb_options_info= to fabric                                 :story:

Add the generation of ODB options to fabric and remove the legacy
formattable.

*** Add a file formatter interface to formatters                      :story:

It probably makes sense to have a top-level interface for file
formatting in the formatters model. At present we have a lot of
=quilt.cpp= specific things in there. Maybe we should just extract the
common attributes and use them to create the generic interface.

*** Formatters with duplicate names result in non-intuitive errors    :story:

We added two formatters to io with the same name by mistake and the
resulting error was not particularly enlightening:

: std::exception::what: Qualified name defined more than once: cpp.io.enum_header_formatter.inclusion_required

We should have a very early on validation to ensure formatters have
distinct names.

Merged stories:

*Check for duplicate formatter names in formatter registrar*

At present it is possible to register a formatter name more than
once. Registrar should keep track of the names and throw if the name
is duplicated.

*** Implement all formatter interfaces                                :story:

We still have a couple of skeleton interfaces:

- primitve
- concepts

*** Document the conceptual model                                     :story:

We seem to be pretty close to the end of the conceptual model for
dogen. We should write it up whilst its still fresh. We should try to
use mathematical notation where possible to practice it. We should
also get it reviewed.

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

*** Generate formatter interfaces                                      :epic:

We should create another template language, in addition to stitch:
"wale". Wale is a very simple language that has templates that just do
token replacement. The tokens must have a special format:
={{{TOKEN}}}=. We receive a map of keys to values and do a blind
replacement to the keys on the wale document.

This links to stitch as follows:

- create a single file implementation of a formatter. It will
  implement both the provider interface and the appropriate formatter
  interface. It will call the stitch method to start off with. There
  are no headers, just cpp. It does the formatter registration.
- add support in stitch for "named sections": its possible to start a
  section and assign it a name. A stitch template will have two
  sections: inclusion provision and formatting.
- add support in stitch for "wale variables". These are just kvp's
  defined at the top:

: <#@ wale.variable="formatter_name=abcd" #>

  wale variables and sections are converted into a kvp container for
  wale input. Examples: facet, formatter name, etc.
- convert the formatter code into a wale template, adding wale
  variables as required.
- update stitch to detect wale usage and to call wale in those
  cases. This could be done by supplying a wale template:

: <#@ wale.template="abcd.wale" #>

- note that wale could be useful outside of stitch, for example for
  dart: we could wale-lise utility and then instantiate it for a given
  project.

*Previous Understanding*

It should be possible to generate some trivial types such as formatter
interfaces, formatter container, registrar and so on. For this we
need:

- a mustache type template;
- a set of fields from yarn types to be exposed to mustache;
- a list of types to iterate through.

Once we got this we could instantiate the templates. To integrate this
with knit we would need some way of specifying which types the
iteration would be over. We could mark a specific type with a given
stereotype, and then supply say the base class ("all leaf descendants
of xyz"). Dogen would then locate the descendants and for each call
the template.

For registrar and container its a bit trickier because we want a
collection of types in one go.

We also need a way to keep these templates away from the main (user
visible) code, since they are useful only for dogen.

See also [[https://github.com/cierelabs/boostache/tree/develop][boostache]].

Notes:

- we will need some "special" tags for copyright, includes
  etc. Includes will be particularly special because we need to
  augment the include list with additional includes. However, we may
  not even need to be aware of this.

*** Remove =optional<list>=                                           :story:

We should not really be using optional<list>. The empty list is
sufficient for this.

Uses:

- include provider. Fixed with other story.

*** Run tests that are passing on windows                             :story:

At present we have a release build on windows but we are not running
any tests. This is because some of the tests are failing at the
moment. We should run all test suites that are green to ensure we
don't regress without noticing.

*** Consider renaming settings to annotations                         :story:

Whilst its pretty clear now that settings are a strongly-typed
representation of the meta-data and properties are the post-processed
version, the names "settings" and "properties" still sound far too
similar. It would be nicer to have something more meta-data-like for
settings such as annotations. Read up the past discussions on
naming. One possible reason not to use annotations was because we used
it already in the formatters model. Perhaps that could be renamed to
something else, freeing up the name?

*** Consider removing the overwrite flag in =formatters::file=        :story:

Investigate if the overwrite flag makes sense in file; it seems we
only use it in two scenarios: force overwrite requested by user or
file contents have changed, both of which can be done in the
file_writer.

Actually this flag is needed. It is required to handle the case where
we do not code-generate files, unless they do not exist. For example,
for service headers and implementation we should create the files, but
then subsequently not touch them. The overwrite flag should be set to
false. We need to figure out how to implement this and remove the
hacks around file writing.

For now we have abused this flag to allow legacy files overrides of
the new world formatters. This is just until we move totally to new
world though.

*** Vistor is only supported at the base class level                  :story:

Due to implementation constraints, we only support visitable at the
base class level. Add an exception if users attempt to use visitable
stereotype in a class that has parents.

Note: is this true? We are using derived visitable in C++ model.

*** Add test model sanitizer to test models target                    :story:

At present if we build test models we don't seem to build the
sanitizer.

*** Remove =formattable_origin_type=                                  :story:

We seem to distinguish between "internal" and "external"
formattables. This probably won't make sense after the injection
refactor.

*** Model should contain set of primitive id's                        :story:

We are computing the set of all primitive id's in quilt but this
should really be part of yarn.

*** Implement formattables in terms of yarn types                     :epic:

At present formattables are just a shadow copy of yarn types plus
additional =cpp= specific types. In practice:

- for the types that are shadow copies, we could have helper utilities
  that do the translation on the fly (e.g. for names).
- for additional information which cannot be translated, we could have
  containers indexed by qualified name and query those just before we
  call the transformer. This is the case with formatter properties. We
  need something similar to house "type properties" such as
  =requires_stream_manipulators=. These could be moved into aspect
  settings.
- for types that do not exist in yarn, we could inherit from element;
  this is the case for registrar, forward declarations, cmakelists and
  odb options. Note that with this we are now saying that element
  space contains anything which can be modeled, regardless of if they
  are part of the programming language type system, or build system,
  etc. This is not ideal, but its not a problem just yet. We could
  update the factory to generate these types and then take a copy of
  the model and inject them in it.

*** Handle "special includes" correctly                              ::story:

We did a quick hack to handle "special includes": we simply "detected"
them in include builder and then did the appropriate action in each of
the include providers. In order to make this work dynamically, we need
somehow to have "associated includes" on a per type basis. For
example:

- type =x= requires include =y= in formatter =f=.

This can easily be achieved via an "additional inclusion directive"
which is a container. For example:

:        "extensions" : {
:                "quilt.cpp.helper.family" : "Dereferenceable",
:                "quilt.cpp.types.class_header_formatter.inclusion_directive" : "<boost/weak_ptr.hpp>",

Could have:

:                "quilt.cpp.types.class_header_formatter.additional_inclusion_directive" : "<some_include.hpp>",

If multiple are provided then they are all added. This highlights an
important point: we need a way to inject type specific includes from a
formatter. It makes no sense to declare all of these up front in a
library since we do not know what all possible formatters are, nor
what requirements they may have for inclusion. At the same time,
formatters cannot be expected to declare types. The solution is to be
able to "inject" these dependencies from a JSON file associated with
the formatter. We could supply the qualified name and the properties
to inject. This problem can be solved later on - create a separate
story for this.

*** Supply model references via meta-data rather than command line    :story:

It doesn't make any sense to have model dependencies in the command
line. After all, the model cannot be interpreted without them. A
better way to do this would be to split this functionality into two:

- command line supplies "import directories", that is, directories
  to search when looking for models. By default the system directory
  is already in the path.
- model supplies "import statements". The problem here is that we need
  to also supply the file name of the model. We could perhaps omit the
  extension and then load all files that match (e.g. =.dia=, =.json=,
  etc). If more than one matches we should error. Actually we should
  just supply the full filename, as well as keep the current notation
  for the external project path.

This is also a nice way to avoid loading system models unnecessary;
users still need to declare the models they depend on, regardless if
system or user.

Each model should also supply the external module path as meta-data.

This is particularly painful since cross-model inheritance was
introduced because it means references are now transitive (we need to
know of the references of any model we reference).

Merged stories

*External module path and references as meta-data*

It actually does not make a lot of sense to allow users to supply
external module paths and references as command line options. This is
because the model will fail to build unless we provide the correct
ones; these are not configurable items in this sense. The project
path, etc are - and so should remain command line options.

We need to move these two into the meta-data. This would also mean we
no longer need to pass in external module paths for references, which
is much cleaner.

*** Allow logging during initialisation                               :story:

At present we assume the log has not been initialised during
initialisation. The only reason for this is with unit testing because
each test initialises the log differently. However, one simple way
around this is to have a log file for the entire test suite and
separate log files for each test as we have now. Initialisation
logging would go in this main file.

** Deprecated
*** CANCELLED Consider renaming formatters                            :story:
    CLOSED: [2016-09-12 Mon 09:29]

*Rationale*: Actually, we don't want users to think of the
presentation model when looking at formatters. It is a good analogy if
you understand what it is that we are trying to do, but its probably
confusing for someone new to code generation. We'll stick to
formatters and use formatting functions in our description of the
conceptual model.

After reading the [[http://martinfowler.com/eaaDev/PresentationModel.html][Presentation Model]] pattern a bit more carefully, it
seems it provides a good approach for formatters. If one thinks of the
file as the view, then the formatters are the presenters and the model
representing all presentation logic (e.g. =cpp=) is the presentation
model. We could:

- create a top-level folder called =presentation=;
- rename =formatters= to =core= and move it to =presentation=;
- move =cpp= to =presentation=;
- in =cpp=:
  - rename =formattables= to =presentables=;
  - rename =formatters= to =presenters=;
- in this light, =backend= is really the "meta-workflow" for all
  possible presentations. It should really live under presentation. It
  would make more sense to merge it with =core=, if it were not that
  core contains all sorts of loose bits that are useful only in the
  guts of presentation. We could call it =orchestration= or some such
  name. Or we could leave it as =presentation::backends=.
- move =file= to =backends=. We don't really want external clients to
  have to know about =core= just to obtain a single type. Also,
  backends shouldn't really have any dependencies.
- grep for formatting, formattables, formatter, format, etc. and
  ensure all usages have been replaced with present*.

We should wait until the "great refactoring" is done so that we do not
have to rename the legacy models too.

*Merged with duplicate*

These are not really formatters; not sure what the right name should
be though; templates?
