#+title: Release Notes for Sprint 29
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED
#+tags: story(s) epic(e) task(t) note(n) spike(p)

* Release Notes

This file contains all stories that were closed during sprint 29.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2013-06-22 Sat 14:08]

| Headline                                                         | Time   |      |      |
|------------------------------------------------------------------+--------+------+------|
| *Total time*                                                     | *3:44* |      |      |
|------------------------------------------------------------------+--------+------+------|
| Development Stories Implemented                                  |        | 3:44 |      |
| IMPLEMENTATION Release notes and backlog grooming                |        |      | 0:24 |
| IMPLEMENTATION Design the inheritance tree of DDD classes in SML |        |      | 1:25 |
| IMPLEMENTATION Implement concepts in SML                         |        |      | 1:55 |
#+end:

*** IMPLEMENTATION Release notes and backlog grooming                  :task:
    CLOCK: [2013-06-17 Mon 08:07]--[2013-06-17 Mon 08:20] =>  0:13
    CLOCK: [2013-06-17 Mon 07:56]--[2013-06-17 Mon 08:07] =>  0:11

*** Add content to the introduction in manual                         :story:
*** IMPLEMENTATION Design the inheritance tree of DDD classes in SML  :story:

In S28 as part of "Improve modeling of domain driven concepts in SML",
we have started making SML look a lot more like a model of
DDD. However, a number of limitations became apparent in terms of the
inheritance tree:

- value objects had too many attributes to model primitives and
  enumerations properly
- typed_element was too broad for a root of the object based parts of
  the tree

A better approach is to create base classes that are less well-defined
and a larger number of derived classes. This is the objective of this
story.

**** COMPLETED List of SML concepts                                    :note:
     CLOSED: [2013-06-20 Thu 08:08]
     CLOCK: [2013-06-20 Thu 08:00]--[2013-06-20 Thu 08:15] =>  0:15

- =Nameable=: type has can be uniquely identified by its qualified name.
- =Documentable=: type can be documented.
- =Parameterisable=: type supports pass-through parameters
  (implementation specific parameters).
- =Generatable=: type has properties related to code generation.
- =Element=: A unit of modeling. Refinement of =Namable=,
  =Documentable=, =Parameterisable=.
- GeneratableElement: A unit of modeling that can be code
  generated. Refinement of =Element= and =Generatable=. Modeled by
  "special" value types such as =sml::enumeration= and
  =sml::primitive=; modeled by =sml::model=, =sml::concept= and
  =sml::module=.
- =Inheritable=: type provides support for inheritance.
- =Stateful=: type has properties.
- =Operatable=: type has methods (operations).
- =Object=: refinement of =GeneratableElement=, =Stateful= and
  =Operatable=. Modeled by =sml::abstract_entity=, =sml::value_object=,
  =sml::service=, =sml::factory= and =sml::repository=.

**** ANALYSIS Why is the current design wrong?                         :task:
     CLOCK: [2013-06-20 Thu 08:24]--[2013-06-20 Thu 08:38] =>  0:14
     CLOCK: [2013-06-20 Thu 07:46]--[2013-06-20 Thu 08:00] =>  0:14
     CLOCK: [2013-06-18 Tue 18:13]--[2013-06-18 Tue 18:19] =>  0:06
     CLOCK: [2013-06-18 Tue 08:16]--[2013-06-18 Tue 08:24] =>  0:08
     CLOCK: [2013-06-18 Tue 07:48]--[2013-06-18 Tue 08:16] =>  0:28

There is a great deal of confusion when choosing between concepts and
inheritance. Both provide a way to factor out similar characteristics
(behaviour and state) and to reuse them. Inheritance is to be used
when:

- the thing modeled by the base class naturally exists in the domain
  as a type and is recognisable by domain experts;
- the base class should be used by other types in the domain on its
  own - e.g. its not there just to provide functionality or behaviour
  and is otherwise never used in the domain; the only exception is
  when we need to comply with MEC-33.
- there is a strong is-a relationship between parent and children; one
  should be able to look at the inheritance tree and see consistent
  ontological work rather than a hodgepodge of unrelated classes.

Concepts are to be used when types have similar characteristics but
the packaging of those characteristics is not obviously attributable
to a common ancestor. In this case one needs to package the
characteristics in cohesive units and give names that reflect
them.

In this light we can see a lot of modeling errors, that explain the
current confusion:

- model element: basic unit of modeling. this is not a type as there
  is no such thing as a model element in terms of the domain. no other
  domain type will refer to it directly.
- typed element: this is too broad as a base type; for instance it
  provides attributes that make no sense in the context of a primitive
  or an enumeration.

What we need is a an inheritance tree that reflects a fundamental type
hierarchy (prefix =abstract_= used when there is a need for MEC-33
compliance):

- =concept=, =module=, =type=: totally unrelated entities at the
  inheritance level. Models of GeneratableElement concept. =type= as a
  base class is justified because we may have some code which can
  process types generically. For instance, the model could have a
  container of =type=.
- =primitive=, =enumeration=, =abstract_object= derive from =type=.
- =object= derives from =abstract_object= and has a =object_types=
  enum: =value=, =service=, =factory= or =repository=. Has an optional
  =version= property.
- =abstract_entity= derives from =abstract_object=, and provides a set
  of properties that make its identity function.
- =entity= and =keyed_entity= descend from =abstract_entity=.

**** Convert pods into entities, values or services                   :story:
*** Model name should be a qname                                      :story:

We already have most of the qname properties in the model anyway, so
might as well just use a qname.

*** IMPLEMENTATION Implement concepts in SML                          :story:
     CLOCK: [2013-06-22 Sat 12:26]--[2013-06-22 Sat 12:59] =>  0:33

In S28 we added the initial support for concepts to SML. We now need
to start making use of them.

**** COMPLETED Add support for multiple inheritance in graph builder   :task:
     CLOSED: [2013-06-22 Sat 13:58]
     CLOCK: [2013-06-22 Sat 13:58]--[2013-06-22 Sat 14:07] =>  0:09
     CLOCK: [2013-06-22 Sat 13:04]--[2013-06-22 Sat 13:58] =>  0:54
     CLOCK: [2013-06-22 Sat 12:07]--[2013-06-22 Sat 12:26] =>  0:19

- graph builder to allow building graph with multiple
  inheritance. we're still a DAG so this should not be a problem.
- context to have a list of parents rather than just one parent.
- transformer to throw when transforming pod if it has more than one
  parent.

**** Add support for concepts to the dia to sml transformer            :task:

- add meta-type of concept.
- pod to have a list of modeled concepts.
- push unknown stereotypes into a list in object profile
  when transforming pod
- convert this list into qnames that belong to current model and have
  a meta type of concept
- merger to check that all such concepts exist in model.

**** When transforming a pod, copy across properties from concept      :task:

- in CPP model's transformer, traverse concepts and add properties.

**** Add test to stereotypes model                                     :task:

- stand-alone concept
- concept with single-inheritance
- concept with multiple-inheritance
- non-existing concept (using mock model)

*** Update SML to make use of concepts                                :story:

In S28 as part of "Break down SML into concepts at the design level"
we have defined all of the main concepts that SML types should be
using. Attempt to make use of these to simplify the model.

*** Rename implementation specific parameters                         :story:

These should really be called back end specific parameters at the SML
level. At the dia level, if a parameter is passed in which has a
representation at the SML level it should simply be converted to this
representation instead of being added to the KVP.

Actually, these are more like generic parameters:

- at the dia level they are used to fill in gaps in dia (e.g. packages
  and diagrams do not have comments)
- at the SML level, they are used to add information which does not
  make sense for it to be in dia: is property key.
- at the backend level, they are used to provide information which
  does not make sense to live in SML: for example the ODB parameters.

Also, when the string table support has been added, we need to create
a string table with all valid values for the parameter keys.

Name choices:

- opaque parameters
- untyped parameters

*** Rename nested qname to composite qname                            :story:

We should just follow the composite pattern in the naming.

*** Visitor as an injected system type                                :story:

The current implementation of visitor relies on creating a view model
without a corresponding type. In reality we should do as we did for
keys and create a category type of visitor. This is really a SML
concept, not a backend specific concept.

*** Use explicit casting for versioned to unversioned conversions     :story:

Continuing from previous iteration, see description in Sprint 26.

*** Add =extract_key= function                                        :story:

Continuing from previous iteration, see description in Sprint 26.

*** Consider not creating unversioned keys for single property        :story:

If a key is made up of a single property, its a bit nonsensical to
create an unversioned key. We should only generate the versioned
key. However, it does make life easier. Wait for real world use cases
to decide.

*** Injection framework

We need a more generic way of handling system types injection into
models. This is because there is a number of things that can be
derived from the existing model types:

- keys
- diff support
- reflection
- cache code
- etc.

So we need to:

- make injector a composite of injectors that do the real work such as
  =key_injector=. internally =injector= just delegates the work to
  these classes.
- injector decides which internal injectors to use based on options
  passed in.
- in the IoC spirit, we should probably create a =injector_interface=.

** Deprecated Development Stories
