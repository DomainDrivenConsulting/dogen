#+title: Sprint Backlog 80
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- finish implementing quilt.cpp formatters using yarn types;

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-02-01 Mon 20:53]
| <75>                                                                        |        |      |      |       |
| Headline                                                                    | Time   |      |      |     % |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| *Total time*                                                                | *0:12* |      |      | 100.0 |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| Stories                                                                     | 0:12   |      |      | 100.0 |
| Active                                                                      |        | 0:12 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |        |      | 0:12 | 100.0 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-02-01 Mon 20:40]--[2016-02-01 Mon 20:52] =>  0:12

Updates to sprint and product backlog.

*** Update manual                                                     :story:

Updates to manual.

*** Add an helper method interface                                    :story:

We should also investigate on the need for the nested type info
assistant.

Tasks:

- create interface.
- create a registrar for interface with family and formatter name.
- update all helpers to implement interface and to register
  themselves.
- it seems we have two use cases here: the formatter helper interface
  for formatting purposes and the helper family interface that tells
  us what formatter this helper belongs to. We do not want to leak
  details of formatting into formattables. We need to find a name for
  such an interface in formattables, a bit like the inclusion
  dependencies provider. Formatter helper details provider? We can
  then extend the existing formattables registrar and container to
  store this interface; the formatter helper interface can extend this
  interface; the main workflow returns all registered formatter
  helpers in terms of the formatter helper details provider interface.
- problem: we need additional properties related to the helper which
  have been hard-coded:
  - requires generic string; in a general form "string conversion
    method";
  - requires quoting;
  - requires tidying up; in a general form "remove unprintable
    characters";
  - requires hashing helper method; in a general form: we need a way
    to query the helper settings to figure out if a given type has an
    associated helper method for a given formatter, and if we need to
    call it implicitly or explicitly; and, if explicitly, we need to
    ask the helper method formatter for the name of the helper method.
  - requires dereferencing; for pointer types.
- seems like yet again we found the wrong solution for this
  problem. We need to create a top-level set of helper settings for
  each type with all additional properties; propagate those into
  formatters via context; and then use the assistant to loop through
  the nested name (nested info for now) and pick the helper
  settings. It should also consult the registrar to see if there are
  any helpers available for this formatter and family.

*** Update assistant to use new helper information                    :story:

Once all the pieces are in place, the assistant can then use the
formatter properties to find out which helpers are required for each
type; call those helpers and populate the file with the generate
code. We can remove all previous helper support.

*** Remove nested type info                                           :story:

Once all of the infrastructure is in place, we should not need this
class any more. Remove code from transformer and remove object types
and anything else that was used to dispatch based on type.

*** Make context non-generatable                                      :story:

We need to extend context in a few ways dogen does not yet support:

- make formatter properties and bundles by reference since we do not
  need to copy them.
- create a context generator that merges the containers and generates
  a map of type to context. Supply this context to the formatters
  workflow and to the formatters.

** Deprecated
