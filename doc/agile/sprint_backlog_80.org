#+title: Sprint Backlog 80
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- start implementing helper methods dynamically and using yarn types.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-02-12 Fri 16:51]
| <75>                                                                        |         |       |      |       |
| Headline                                                                    | Time    |       |      |     % |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| *Total time*                                                                | *20:22* |       |      | 100.0 |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| Stories                                                                     | 20:22   |       |      | 100.0 |
| Active                                                                      |         | 20:22 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |         |       | 3:30 |  17.2 |
| COMPLETED Make context non-generatable                                      |         |       | 0:49 |   4.0 |
| COMPLETED Setup logging syntax highlighting on emacs                        |         |       | 2:32 |  12.4 |
| COMPLETED Create next interesting blog post                                 |         |       | 0:37 |   3.0 |
| COMPLETED Rename =yarn::nested_name= to =yarn::name_tree=                   |         |       | 1:05 |   5.3 |
| COMPLETED Rename =type= to =parsed_type=                                    |         |       | 0:14 |   1.1 |
| COMPLETED Add index support for =yarn::name_tree=                           |         |       | 1:56 |   9.5 |
| COMPLETED Create a context factory                                          |         |       | 1:13 |   6.0 |
| STARTED Help conan with strange warning                                     |         |       | 1:30 |   7.4 |
| STARTED Add an helper method interface                                      |         |       | 6:56 |  34.0 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-02-10 Wed 23:15]--[2016-02-10 Wed 23:24] =>  0:09
    CLOCK: [2016-02-09 Tue 22:16]--[2016-02-09 Tue 22:51] =>  0:35
    CLOCK: [2016-02-06 Sat 13:45]--[2016-02-06 Sat 14:15] =>  0:30
    CLOCK: [2016-02-06 Sat 12:40]--[2016-02-06 Sat 13:05] =>  0:25
    CLOCK: [2016-02-06 Sat 12:35]--[2016-02-06 Sat 12:39] =>  0:04
    CLOCK: [2016-02-06 Sat 12:09]--[2016-02-06 Sat 12:34] =>  0:25
    CLOCK: [2016-02-06 Sat 11:15]--[2016-02-06 Sat 12:08] =>  0:53
    CLOCK: [2016-02-06 Sat 10:10]--[2016-02-06 Sat 10:27] =>  0:17
    CLOCK: [2016-02-01 Mon 20:40]--[2016-02-01 Mon 20:52] =>  0:12

Updates to sprint and product backlog.

*** Update manual                                                     :story:

Updates to manual.

*** COMPLETED Make context non-generatable                            :story:
    CLOSED: [2016-02-02 Tue 22:44]
    CLOCK: [2016-02-02 Tue 21:55]--[2016-02-02 Tue 22:44] =>  0:49

We need to extend context in a few ways dogen does not yet support:

- make formatter properties and bundles by reference since we do not
  need to copy them.
- create a context generator that merges the containers and generates
  a map of type to context. Supply this context to the formatters
  workflow and to the formatters. Actually we left the generation code
  as it is pretty trivial.

*** COMPLETED Setup logging syntax highlighting on emacs              :story:
    CLOSED: [2016-02-06 Sat 11:14]
    CLOCK: [2016-02-06 Sat 10:28]--[2016-02-06 Sat 11:14] =>  0:46
    CLOCK: [2016-02-05 Fri 23:38]--[2016-02-05 Fri 23:52] =>  0:14
    CLOCK: [2016-02-05 Fri 22:05]--[2016-02-05 Fri 23:37] =>  1:32

The Log4J mode is not highlighting syntax for a while now. It would be
good to move to [[https://github.com/doublep/logview][LogView]], which is actively maintained. However, our
log files do not work out of the box for some reason.

- opened ticket in LogView: [[https://github.com/doublep/logview/issues/3][Problem detecting log file using boost log format]]
- updated conventions to match SLF4J (removed FINE, using TRACE, etc).

It is not easy to update boost to have milisecond timestamps:

- [[http://stackoverflow.com/questions/27870064/how-to-truncate-boost-log-format-expression][How to truncate boost log format expression]]
- [[http://stackoverflow.com/questions/5947018/how-to-customize-timestamp-format-of-boost-log][how to customize "TimeStamp" format of Boost.Log]]

PR raised: [[https://github.com/doublep/logview/pull/4][Add support for timestamps with microseconds]]

*** COMPLETED Create next interesting blog post                       :story:
    CLOSED: [2016-02-08 Mon 22:29]
    CLOCK: [2016-02-08 Mon 21:51]--[2016-02-08 Mon 22:28] =>  0:37

Ship the latest links.

*** COMPLETED Rename =yarn::nested_name= to =yarn::name_tree=         :story:
    CLOSED: [2016-02-10 Wed 23:10]
    CLOCK: [2016-02-10 Wed 22:36]--[2016-02-10 Wed 23:14] =>  0:38
    CLOCK: [2016-02-09 Tue 22:52]--[2016-02-09 Tue 23:19] =>  0:27

After a lot of faffing around with the naming for nested names, it is
now obvious we should call it a "name tree". In effect, that is what
it is: a tree structure of the names it contains. It also means we now
have consistent terms for things such as index and height. Previous
attempts to name this type were focused on the similarities with the
composite pattern or with the main use for it (instantiated types). We
now take the approach of naming it after the data structure it models.

This rename will ripple across (builder, etc).

See also the [[https://en.wikipedia.org/wiki/Tree_(data_structure)#Terminologies_used_in_Trees][related terminology]].

*** COMPLETED Rename =type= to =parsed_type=                          :story:
    CLOSED: [2016-02-10 Wed 23:38]
    CLOCK: [2016-02-10 Wed 23:24]--[2016-02-10 Wed 23:38] =>  0:14

For consistency purposes - since we already have a =unparsed_type= in
=yarn::property= - we should rename =type= to =parsed_type=.

*** COMPLETED Add index support for =yarn::name_tree=                 :story:
    CLOSED: [2016-02-11 Thu 22:43]
    CLOCK: [2016-02-11 Thu 21:59]--[2016-02-11 Thu 22:43] =>  0:44
    CLOCK: [2016-02-11 Thu 21:38]--[2016-02-11 Thu 21:58] =>  0:20
    CLOCK: [2016-02-11 Thu 21:05]--[2016-02-11 Thu 21:37] =>  0:32
    CLOCK: [2016-02-11 Thu 20:44]--[2016-02-11 Thu 21:04] =>  0:20

Add an index to =yarn::name_tree= and add a heigth too. Compute it as
part of the existing yarn infrastructure - name tree builder is the
best place. The index starts at zero for the root and increments by
one as we walk the tree. We can go for depth first but it doesn't
really matter what approach we use for naming provided the names are
unique (for a given property) and go from 0 to the height of the tree.

*** COMPLETED Create a context factory                                :story:
    CLOSED: [2016-02-12 Fri 16:51]
    CLOCK: [2016-02-12 Fri 16:15]--[2016-02-12 Fri 16:51] =>  0:36
    CLOCK: [2016-02-11 Thu 22:44]--[2016-02-11 Thu 23:21] =>  0:37

We should have a class responsible for generating the context given
all the required inputs, doing filtering, etc.

*** STARTED Help conan with strange warning                           :story:
    CLOCK: [2016-02-10 Wed 22:17]--[2016-02-10 Wed 22:35] =>  0:18
    CLOCK: [2016-02-10 Wed 21:55]--[2016-02-10 Wed 22:16] =>  0:21
    CLOCK: [2016-02-09 Tue 21:50]--[2016-02-09 Tue 22:15] =>  0:25
    CLOCK: [2016-02-05 Fri 23:53]--[2016-02-06 Sat 00:19] =>  0:26

We are getting a CMake warning on our builds:

: CMake Warning (dev) in build/output/conanbuildinfo.cmake:
:  Syntax Warning in cmake code at
:    /home/travis/build/DomainDrivenConsulting/dogen/build/output/conanbuildinfo.cmake:142:88
:  Argument not separated from preceding token by whitespace.
: Call Stack (most recent call first):
:  CMakeLists.txt:30 (include)
: This warning is for project developers.  Use -Wno-dev to suppress it.

Report it to conan.

Actually, this is a bit trickier than expected, and the fix is now
breaking the build:

- [[https://github.com/conan-io/conan/issues/138][Warning in CMake file created by conan]]

We will wait until conan comes up with a fix.

*** STARTED Add an helper method interface                            :story:
    CLOCK: [2016-02-06 Sat 09:10]--[2016-02-06 Sat 10:09] =>  0:59
    CLOCK: [2016-02-04 Thu 21:45]--[2016-02-04 Thu 23:19] =>  1:34
    CLOCK: [2016-02-04 Thu 18:39]--[2016-02-04 Thu 19:27] =>  0:48
    CLOCK: [2016-02-04 Thu 06:29]--[2016-02-04 Thu 07:16] =>  0:47
    CLOCK: [2016-02-03 Wed 21:16]--[2016-02-03 Wed 22:57] =>  1:41
    CLOCK: [2016-02-03 Wed 21:03]--[2016-02-03 Wed 21:15] =>  0:12
    CLOCK: [2016-02-02 Tue 22:45]--[2016-02-02 Tue 23:40] =>  0:55

We should also investigate on the need for the nested type info
assistant.

Tasks:

- create interface.
- add interface to registrar.
- implement interface in at least one helper.
- update assistant to query registrar for helpers based on type family
  in context. Performs a recursive descent on nested name.
- problem: io helpers in types should only be enabled if io is enabled
  and if type is in an inheritance relationship. For this we need to
  have access to formatter properties (potentially via assistant) but
  we also need to have access to the type that owns the properties. We
  could augment helper interface with the assistant - easy as we
  already have it on the format method - and the element - harder; we
  need to supply the object as part of helper method creation.
- problem: we need to ask for complete and identifiable name N times
  for a given formatter. It is not a good idea to dynamically compute
  it or to store it in an associative container - it somehow needs to
  be next to the nested name.

*Previous Understanding*

- create a registrar for interface with family and formatter name.
- update all helpers to implement interface and to register
  themselves.
- it seems we have two use cases here: the formatter helper interface
  for formatting purposes and the helper family interface that tells
  us what formatter this helper belongs to. We do not want to leak
  details of formatting into formattables. We need to find a name for
  such an interface in formattables, a bit like the inclusion
  dependencies provider. Formatter helper details provider? We can
  then extend the existing formattables registrar and container to
  store this interface; the formatter helper interface can extend this
  interface; the main workflow returns all registered formatter
  helpers in terms of the formatter helper details provider interface.
- problem: we need additional properties related to the helper which
  have been hard-coded:
  - requires generic string; in a general form "string conversion
    method";
  - requires quoting;
  - requires tidying up; in a general form "remove unprintable
    characters";
  - requires hashing helper method; in a general form: we need a way
    to query the helper settings to figure out if a given type has an
    associated helper method for a given formatter, and if we need to
    call it implicitly or explicitly; and, if explicitly, we need to
    ask the helper method formatter for the name of the helper method.
  - requires dereferencing; for pointer types.
- seems like yet again we found the wrong solution for this
  problem. We need to create a top-level set of helper settings for
  each type with all additional properties; propagate those into
  formatters via context; and then use the assistant to loop through
  the nested name (nested info for now) and pick the helper
  settings. It should also consult the registrar to see if there are
  any helpers available for this formatter and family.

*** Split dispatcher from formatters workflow and rename it           :story:

The dispatcher should be better named: element formatter perhaps? It
is a class responsible for taking a =yarn::element= and generating all
files it can generate. File factory? File list builder so it can have
internal state? File collection factory? We could add the concept of a
=fileset= to formatters and then have a =fileset_builder=. We could
call it a group, but then we won't be able to follow the [[https://en.wikipedia.org/wiki/Group_(mathematics)][mathematical
definition]] since we do not have the need for operation associated with
it.

This class can hide all of the dispatching logic in the cpp, providing
a nice clean interface to clients (=make(context, yarn::element) :
list<file>=).

*** Implement formatters workflow in terms of new classes             :story:

Update the workflow to use =context_factory= and =fileset_buider=.

*** Add properties for =yarn::name_tree=                              :story:

We need to store the identifiable name of the nested name, as well as
the language specific representation of the type. The container should
make use of the index - e.g. use a vector. The only problem is that we
do not know what the size of the container is without doing look
ups. We could have a property nested name size in stateful. Naming it
is not easy though. Nested name cardinality?

*Previous Understanding*

We need to store the identifiable name of the nested name, as well as
the language specific representation of the type. These are properties
at the level of the =yarn::property=. The container should make use of
the index - e.g. use a vector of size of properties list.

Note that these are not properties of the property, but instead
properties of the property type.

Actually this is not correct; we need the properties for each nested
name and for each particular nested name structure, possibly unique to
each property. An alternative is then to come up with an index that
takes into account the nesting (effectively flattens the nested
structure). The index starts at zero for a type and increments for
every property for every level of nesting. Each nested name has an
index. Then, nested name properties is a flat container for each name
with the required properties. With this the helpers can continue to
rely on just the nested name (plus the nested name properties via the
assistant).

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

*** Update assistant to use new helper information                    :story:

Once all the pieces are in place, the assistant can then use the
formatter properties to find out which helpers are required for each
type; call those helpers and populate the file with the generate
code. We can remove all previous helper support.

*** Remove nested type info                                           :story:

Once all of the infrastructure is in place, we should not need this
class any more. Remove code from transformer and remove object types
and anything else that was used to dispatch based on type.

*** Consider renaming =yarn::property= to attribute                   :story:

Since we use properties quite a lot in =quilt.cpp= - and more so when
we rename formattables to properties - we should probably avoid the
need to overload the term in yarn. We could rename it to attribute.

Or perhaps the problem is with formatter properties. After all these
are not "properties of the formatter"; these are inputs into the
formatting process (and so are settings).

We need to add properties for =yarn::property= so it cannot stay as
property. We cannot think of a better name other than "properties" for
formatters so yarn will have to be renamed.

Actually this is no longer urgent so the story can go back to backlog.

*** Consider using indices rather than associative containers         :story:

Once we generate the final model the model becomes constant; this
means we can easily assign an [[https://en.wikipedia.org/wiki/Ordinal_number][ordinal number]] to each model
element. These could be arranged so that we always start with
generatable types first; this way we always generate dense
containers - there are some cases where we need both generatable types
and non-generatable types; in other cases we just need generatable
types; we never need just non-generatable types. We also need to know
the position of the first non-generatable type (or alternatively, the
size of the generatable types set).

Once we have this, we can start creating vectors with a fixed size
(either total number of elements or just size of generatable
types). We can also make it so that each name has an id which is the
ordinal (another model post-processing activity). Actually we should
call it "type index" or some other name because its a transient
id. This means both properties and settings require no lookups at all
since all positions are known beforehand (except in cases where the
key of the associative container must be the =yarn::name= because we
use it for processing).

In theory, a similar approach can be done for formatters too. We know
upfront what the ordinal number is for each formatter because they are
all registered before we start processing. If formatters obtained
their ordinal number at registration, wherever we are using a map of
formatter name to a resource, we could use a fixed-size
vector. However, formatters may be sparse in many cases (if not all
cases?). For example, we do not have formatter properties for all
formatters for every =yarn::name= because many (most) formatters don't
make sense for every yarn type. Thus this is less applicable, at least
for formatter properties. We need to look carefully at all use cases
and see if there is any place where this approach is applicable.

** Deprecated
