#+title: Sprint Backlog 80
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- finish implementing quilt.cpp formatters using yarn types.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-02-04 Thu 23:19]
| <75>                                                                        |        |      |      |       |
| Headline                                                                    | Time   |      |      |     % |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| *Total time*                                                                | *6:58* |      |      | 100.0 |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| Stories                                                                     | 6:58   |      |      | 100.0 |
| Active                                                                      |        | 6:58 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |        |      | 0:12 |   2.9 |
| COMPLETED Make context non-generatable                                      |        |      | 0:49 |  11.7 |
| STARTED Add an helper method interface                                      |        |      | 5:57 |  85.4 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-02-01 Mon 20:40]--[2016-02-01 Mon 20:52] =>  0:12

Updates to sprint and product backlog.

*** Update manual                                                     :story:

Updates to manual.

*** COMPLETED Make context non-generatable                            :story:
    CLOSED: [2016-02-02 Tue 22:44]
    CLOCK: [2016-02-02 Tue 21:55]--[2016-02-02 Tue 22:44] =>  0:49

We need to extend context in a few ways dogen does not yet support:

- make formatter properties and bundles by reference since we do not
  need to copy them.
- create a context generator that merges the containers and generates
  a map of type to context. Supply this context to the formatters
  workflow and to the formatters. Actually we left the generation code
  as it is pretty trivial.

*** STARTED Add an helper method interface                            :story:
    CLOCK: [2016-02-04 Thu 21:45]--[2016-02-04 Thu 23:19] =>  1:34
    CLOCK: [2016-02-04 Thu 18:39]--[2016-02-04 Thu 19:27] =>  0:48
    CLOCK: [2016-02-04 Thu 06:29]--[2016-02-04 Thu 07:16] =>  0:47
    CLOCK: [2016-02-03 Wed 21:16]--[2016-02-03 Wed 22:57] =>  1:41
    CLOCK: [2016-02-03 Wed 21:03]--[2016-02-03 Wed 21:15] =>  0:12
    CLOCK: [2016-02-02 Tue 22:45]--[2016-02-02 Tue 23:40] =>  0:55

We should also investigate on the need for the nested type info
assistant.

Tasks:

- create interface.
- add interface to registrar.
- implement interface in at least one helper.
- update assistant to query registrar for helpers based on type family
  in context. Performs a recursive descent on nested name.
- problem: io helpers in types should only be enabled if io is enabled
  and if type is in an inheritance relationship. For this we need to
  have access to formatter properties (potentially via assistant) but
  we also need to have access to the type that owns the properties. We
  could augment helper interface with the assistant - easy as we
  already have it on the format method - and the element - harder; we
  need to supply the object as part of helper method creation.

*Previous Understanding*

- create a registrar for interface with family and formatter name.
- update all helpers to implement interface and to register
  themselves.
- it seems we have two use cases here: the formatter helper interface
  for formatting purposes and the helper family interface that tells
  us what formatter this helper belongs to. We do not want to leak
  details of formatting into formattables. We need to find a name for
  such an interface in formattables, a bit like the inclusion
  dependencies provider. Formatter helper details provider? We can
  then extend the existing formattables registrar and container to
  store this interface; the formatter helper interface can extend this
  interface; the main workflow returns all registered formatter
  helpers in terms of the formatter helper details provider interface.
- problem: we need additional properties related to the helper which
  have been hard-coded:
  - requires generic string; in a general form "string conversion
    method";
  - requires quoting;
  - requires tidying up; in a general form "remove unprintable
    characters";
  - requires hashing helper method; in a general form: we need a way
    to query the helper settings to figure out if a given type has an
    associated helper method for a given formatter, and if we need to
    call it implicitly or explicitly; and, if explicitly, we need to
    ask the helper method formatter for the name of the helper method.
  - requires dereferencing; for pointer types.
- seems like yet again we found the wrong solution for this
  problem. We need to create a top-level set of helper settings for
  each type with all additional properties; propagate those into
  formatters via context; and then use the assistant to loop through
  the nested name (nested info for now) and pick the helper
  settings. It should also consult the registrar to see if there are
  any helpers available for this formatter and family.

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

*** Update assistant to use new helper information                    :story:

Once all the pieces are in place, the assistant can then use the
formatter properties to find out which helpers are required for each
type; call those helpers and populate the file with the generate
code. We can remove all previous helper support.

*** Remove nested type info                                           :story:

Once all of the infrastructure is in place, we should not need this
class any more. Remove code from transformer and remove object types
and anything else that was used to dispatch based on type.

** Deprecated
