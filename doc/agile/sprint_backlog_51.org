#+title: Sprint Backlog 51
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED POSTPONED
#+tags: story(s) epic(e) task(t) note(n) spike(p)

* Stories

This file contains all stories that were closed during sprint 51.

The *Mission Statement* for this sprint is to implement the core of
the meta-data processing, in both SML and the formatters. We also want
to improve the communication with the outside world.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2014-09-17 Wed 17:57]

| Headline                                                         | Time    |       |      |
|------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                     | *26:33* |       |      |
|------------------------------------------------------------------+---------+-------+------|
| Development Stories Implemented                                  |         | 26:33 |      |
| IMPLEMENTATION Sprint and product backlog grooming               |         |       | 1:56 |
| IMPLEMENTATION Updates to the manual and readme files            |         |       | 1:39 |
| COMPLETED Fix windows continuous build                           |         |       | 0:22 |
| COMPLETED Create a sub-system for meta-data                      |         |       | 3:46 |
| COMPLETED Add static registration to meta-data workflow          |         |       | 0:19 |
| COMPLETED Move the root enricher to formatters                   |         |       | 0:49 |
| COMPLETED Implement a grapher in meta_data                       |         |       | 1:51 |
| COMPLETED Link types and concepts to their containing module     |         |       | 0:57 |
| COMPLETED Enrichment as a two-stage process                      |         |       | 0:07 |
| COMPLETED Create an SML grapher                                  |         |       | 7:02 |
| COMPLETED Implement the enricher interface in formatters         |         |       | 1:42 |
| COMPLETED Create the global "namespace" module                   |         |       | 1:48 |
| COMPLETED Populate containing module in JSON hydrator            |         |       | 3:42 |
| COMPLETED C++ formatters use of =headers_for_facet_=             |         |       | 0:05 |
| COMPLETED Move formatters meta-data types to meta-data namespace |         |       | 0:25 |
| IMPLEMENTATION Implement the enricher interface in the CPP model |         |       | 0:03 |
#+end:

*** IMPLEMENTATION Sprint and product backlog grooming                 :task:
    CLOCK: [2014-09-17 Wed 08:03]--[2014-09-17 Wed 08:21] =>  0:18
    CLOCK: [2014-09-15 Mon 07:51]--[2014-09-15 Mon 08:04] =>  0:13
    CLOCK: [2014-09-14 Sun 18:10]--[2014-09-14 Sun 18:16] =>  0:06
    CLOCK: [2014-09-12 Fri 19:33]--[2014-09-12 Fri 19:37] =>  0:04
    CLOCK: [2014-09-11 Thu 07:51]--[2014-09-11 Thu 08:01] =>  0:10
    CLOCK: [2014-09-09 Tue 17:50]--[2014-09-09 Tue 17:55] =>  0:05
    CLOCK: [2014-09-09 Tue 07:51]--[2014-09-09 Tue 08:05] =>  0:14
    CLOCK: [2014-09-08 Mon 17:52]--[2014-09-08 Mon 18:04] =>  0:12
    CLOCK: [2014-09-08 Mon 08:01]--[2014-09-08 Mon 08:35] =>  0:34

Updates to sprint and product backlog.

*** IMPLEMENTATION Updates to the manual and readme files              :task:
    CLOCK: [2014-09-16 Tue 08:25]--[2014-09-16 Tue 08:40] =>  0:15
    CLOCK: [2014-09-14 Sun 23:04]--[2014-09-14 Sun 23:35] =>  0:31
    CLOCK: [2014-09-14 Sun 23:01]--[2014-09-14 Sun 23:04] =>  0:03
    CLOCK: [2014-09-14 Sun 22:52]--[2014-09-14 Sun 23:01] =>  0:09
    CLOCK: [2014-09-14 Sun 22:41]--[2014-09-14 Sun 22:51] =>  0:10
    CLOCK: [2014-09-12 Fri 08:22]--[2014-09-12 Fri 08:36] =>  0:14
    CLOCK: [2014-09-11 Thu 22:34]--[2014-09-11 Thu 22:51] =>  0:17

Use downtime to update the manual and / or readme file.

*** COMPLETED Manual: fix Fundamental Building Blocks section         :story:
    CLOSED: [2014-09-08 Mon 08:14]

We allowed this section to evolve as a collage of different ideas, but
now it is no longer making sense as a whole. We need to go back to the
drawing board and create a structure for it.

*** CANCELLED Refactor hello world example to make it simpler         :story:
    CLOSED: [2014-09-14 Sun 23:05]

*Rationale*: actually, an hello world kind of has to have the string
 "hello world" so we can't really get away with it. Leave it as it is.

Whilst we started adding a section on dia in the manual, we noticed
that the hello world example makes use of =std::string= making it
unsuitable for a basic example. We need to refactor it to use only
int.

- change manual sections on hello world
- change sanity

*** COMPLETED Fix windows continuous build                            :story:
    CLOSED: [2014-09-10 Wed 18:47]
    CLOCK: [2014-09-08 Mon 21:45]--[2014-09-08 Mon 22:07] =>  0:22

Ever since we refactored the test models into their own folder, the
windows build stopped working. This is because we are too deep in the
directory tree, resulting in paths longer that the maximum supported
path. We need to move the build to a top-level folder somewhere.

Of course we still have the linking issue but that will be addressed
later.

Actions:

- hacked scripts to point to root build directory to see if this fixes
  the issue.

*** COMPLETED Create a sub-system for meta-data                       :story:
    CLOSED: [2014-09-10 Wed 20:01]

We need to create a simple interface that takes a ptree and a model
and updates the tags on the ptree. We also need a way to register
against the meta-data tagger.

**** COMPLETED Rename tagger to processor                              :task:
     CLOSED: [2014-09-08 Mon 23:20]
     CLOCK: [2014-09-08 Mon 22:56]--[2014-09-08 Mon 23:20] =>  0:24
     CLOCK: [2014-09-08 Mon 18:04]--[2014-09-08 Mon 18:37] =>  0:33

As per analysis story, we need to rename =meta_data_tagger= to
=meta_data_processor=. May be a good time to remove all the existing
tagging code. We need to re-add it later on in the right places.

Actions:

- created scratch pad for saving this kind of code snippets;
- copied across the tagger code;
- renamed the type in the model and regenerated;
- fixed code in workflow.

**** COMPLETED Design and implement the interface                      :task:
     CLOSED: [2014-09-08 Mon 23:21]

- add interface to model;
- add some tests to make sure the interface is usable.

*interface*

: name: meta_data_populator_interface
: identity: string
: dependencies: list of string
: populate(const model, const parent module, concept)
: populate(const model, const parent module, module)
: populate(const model, const parent module, type)

**** COMPLETED Update SML diagram and generate code                    :task:
     CLOSED: [2014-09-10 Wed 20:01]
     CLOCK: [2014-09-10 Wed 18:12]--[2014-09-10 Wed 18:48] =>  0:36
     CLOCK: [2014-09-10 Wed 07:51]--[2014-09-10 Wed 08:40] =>  0:49
     CLOCK: [2014-09-09 Tue 17:55]--[2014-09-09 Tue 18:39] =>  0:44
     CLOCK: [2014-09-09 Tue 08:06]--[2014-09-09 Tue 08:46] =>  0:40

As the names of the meta-data classes became more and more unwieldy,
it became obvious that they need their own namespace. Move all of them
there and get rid of the =meta_data= prefixes.

Also, we should take this opportunity to rename =populator= to
=enricher= as it enriches the meta-data.

*** COMPLETED Add static registration to meta-data workflow           :story:
    CLOSED: [2014-09-10 Wed 22:30]
    CLOCK: [2014-09-10 Wed 22:11]--[2014-09-10 Wed 22:30] =>  0:19

- create a static method to register instances of the interface and a
  static container to hold them;
- add a simple list of shared pointers to keep track of the registered
  expanders.

*** COMPLETED Move the root enricher to formatters                    :story:
    CLOSED: [2014-09-12 Fri 07:56]
    CLOCK: [2014-09-11 Thu 08:05]--[2014-09-11 Thu 08:54] =>  0:49

We originally envisioned a root enricher in formatters just to make
sure the graph had a root. In reality this is a conceptual error: SML
cannot by definition have any meta-data since it has the type system
to express itself. If there is anything that needs to be expressed in
SML it must be expressed as a type.

However, there is indeed an enricher that all enrichers depend on: the
formatters enricher.

- move the root enricher to formatters;
- add a way to distinguish the root enricher from other enrichers
  during registration.

*** COMPLETED Implement a grapher in meta_data                        :story:
    CLOSED: [2014-09-12 Fri 08:21]
    CLOCK: [2014-09-12 Fri 07:51]--[2014-09-12 Fri 08:21] =>  0:30
    CLOCK: [2014-09-10 Wed 22:30]--[2014-09-10 Wed 23:51] =>  1:21

- create a grapher in meta_data that represents the dependencies
  between instances of the interface
- once the enricher has been instantiated we need to loop through the
  list of expanders and build a graph.
- on execute, iterate through the graph executing all instances of the
  interface.

*** COMPLETED Link types and concepts to their containing module      :story:
    CLOSED: [2014-09-12 Fri 20:53]
    CLOCK: [2014-09-12 Fri 19:00]--[2014-09-12 Fri 19:05] =>  0:05

Instead of keeping track of the previous vertex in the graph we should
really express the containment relationship via the type system in SML
since that is exactly its job. Then we can query the model to look for
the module's qname during enrichment. Suggested name for the property:
=parent_module=.

**** COMPLETED Add properties to manage these relationships            :task:
     CLOSED: [2014-09-12 Fri 19:36]
     CLOCK: [2014-09-12 Fri 19:19]--[2014-09-12 Fri 19:32] =>  0:13
     CLOCK: [2014-09-12 Fri 19:06]--[2014-09-12 Fri 19:12] =>  0:06

We need to change the affected types, most likely via a concept, to
keep track of the parent package.

**** COMPLETED Populate the new properties                             :task:
     CLOSED: [2014-09-12 Fri 19:44]
     CLOCK: [2014-09-12 Fri 19:32]--[2014-09-12 Fri 19:44] =>  0:12

During transformation we need some kind of way to determine the parent
package for any given entity.

**** COMPLETED Rename package to module                               :spike:
     CLOSED: [2014-09-12 Fri 20:49]
     CLOCK: [2014-09-12 Fri 20:35]--[2014-09-12 Fri 20:48] =>  0:13

By mistake we named the new methods "package", a UML term, rather than
"module" - the corresponding SML term.

**** COMPLETED Remove parent package from the enricher interface       :task:
     CLOSED: [2014-09-12 Fri 20:53]
     CLOCK: [2014-09-12 Fri 20:49]--[2014-09-12 Fri 20:53] =>  0:04

We no longer need to pass in the parent package; it can be queried
from the model. Remove it from interface.

**** COMPLETED Make parent package optional                           :spike:
     CLOSED: [2014-09-12 Fri 21:12]
     CLOCK: [2014-09-12 Fri 21:08]--[2014-09-12 Fri 21:12] =>  0:04

The model module won't have a parent package, so it has to be
optional.

*** COMPLETED Enrichment as a two-stage process                       :story:
    CLOSED: [2014-09-12 Fri 21:01]
    CLOCK: [2014-09-12 Fri 20:54]--[2014-09-12 Fri 21:01] =>  0:07

We originally thought the graph would allow us to process types in a
single pass. This is not the case because of circular dependencies. In
C++ these can be done provided one uses forward declarations; however,
in SML they are still circular (from the point of view of the
graph). This means that in addition to a graph we also need to split
the process into two stages:

- stage 1: entity specific enrichment
- stage 2: relationship enrichment

*** COMPLETED Create an SML grapher                                   :story:
    CLOSED: [2014-09-14 Sun 03:10]
    CLOCK: [2014-09-14 Sun 00:57]--[2014-09-14 Sun 03:10] =>  2:13
    CLOCK: [2014-09-13 Sat 22:09]--[2014-09-13 Sat 22:22] =>  0:13
    CLOCK: [2014-09-13 Sat 22:08]--[2014-09-13 Sat 22:09] =>  0:01
    CLOCK: [2014-09-13 Sat 02:03]--[2014-09-13 Sat 02:34] =>  0:31
    CLOCK: [2014-09-12 Fri 23:10]--[2014-09-13 Sat 02:03] =>  2:53
    CLOCK: [2014-09-12 Fri 22:13]--[2014-09-12 Fri 22:59] =>  0:46
    CLOCK: [2014-09-12 Fri 22:03]--[2014-09-12 Fri 22:12] =>  0:09
    CLOCK: [2014-09-12 Fri 21:14]--[2014-09-12 Fri 21:30] =>  0:16

We need a class responsible for building a graph of SML qnames, and
associating these with a ptree.

In order to do this we need to make sure we have a module for the
model.

The main reason why we need a grapher is because of the relationship
between modules and types - e.g. we want to make sure a type is
processed after it's module and a module after its parent module. This
is so that we can copy over tags. However, the same could be achieved
by recursing the module graph.

*** COMPLETED Implement the enricher interface in formatters          :story:
    CLOSED: [2014-09-15 Mon 08:02]

We should start implementing the interface on a few formatters to
prove that the approach actually works.

**** COMPLETED Create a local traits class                             :task:
     CLOSED: [2014-09-14 Sun 19:05]
     CLOCK: [2014-09-14 Sun 18:47]--[2014-09-14 Sun 19:04] =>  0:17
     CLOCK: [2014-09-14 Sun 18:18]--[2014-09-14 Sun 18:47] =>  0:29

We need to move all the tags that belong to formatters from the tags
class into the local formatters' traits. We also need to create
formatter settings.

**** COMPLETED Populate all of the default traits in enricher         :story:
     CLOSED: [2014-09-14 Sun 20:01]
     CLOCK: [2014-09-14 Sun 19:05]--[2014-09-14 Sun 20:01] =>  0:56

Move across all the code from taggers that belongs in formatters'
enricher. Formatters only has first stage enrichment.

*** COMPLETED Create the global "namespace" module                    :story:
    CLOSED: [2014-09-15 Mon 22:23]
    CLOCK: [2014-09-15 Mon 08:05]--[2014-09-15 Mon 08:19] =>  0:14

Originally we thought the SML containment graph would have a natural
root: the target model being generated. On hindsight this is not the
case. We have a number of models that will all be at the same level as
the target model such as for instance =std=, =boost= and any user
model we may depend on. However, all of these models do have a natural
root: the global namespace (as we call it in C++). In addition, models
may require placing types directly in the global namespace; that is
the case with the hardware model. We need to:

- create a module representation of the global namespace;
- make all model namespaces depend on it;
- allow the hardware model to place types directly on it.

**** COMPLETED Add global module to injector                           :task:
     CLOSED: [2014-09-15 Mon 19:34]
     CLOCK: [2014-09-15 Mon 18:06]--[2014-09-15 Mon 18:49] =>  0:43
     CLOCK: [2014-09-15 Mon 17:56]--[2014-09-15 Mon 18:03] =>  0:07
     CLOCK: [2014-09-15 Mon 08:19]--[2014-09-15 Mon 08:41] =>  0:22

Injector needs to create a module with a blank qname, and make all
modules, concepts and types that do not have a containing module
depend on it.

**** COMPLETED Add support for modules in merger                       :task:
     CLOSED: [2014-09-15 Mon 22:23]
     CLOCK: [2014-09-15 Mon 22:23]--[2014-09-15 Mon 22:35] =>  0:12
     CLOCK: [2014-09-15 Mon 22:13]--[2014-09-15 Mon 22:23] =>  0:10

At present we do not merge modules in merger. We need to do so. In
addition, we need to locate the global module and merge it only once.

*** COMPLETED Populate containing module in JSON hydrator             :story:
    CLOSED: [2014-09-17 Wed 00:31]
     CLOCK: [2014-09-14 Sun 22:31]--[2014-09-14 Sun 22:41] =>  0:10

We only added support for this in the dia to sml workflow, so the
enricher is breaking. Add it to JSON workflow too. We should consider
adding modules directly to the JSON: the user must define the modules
in JSON, and if they are missing, the model will fail to import.

For the hardware model, we need to somehow detect that the types are
on the global module. This could be done via a module flag in the
JSON.

**** COMPLETED Rename references to value object and types            :spike:
     CLOSED: [2014-09-15 Mon 23:02]
     CLOCK: [2014-09-15 Mon 22:35]--[2014-09-15 Mon 23:02] =>  0:27

It seems the JSON still has some remnants of the value object
days. Rename them to the new terms and fix JSON files. We also need to
rename the top-level container from =types= to =elements=. This is not
the greatest of names but at least it avoids confusion with the =type=
descendants in SML.

**** COMPLETED Add post-processing logic for module generation         :task:
     CLOSED: [2014-09-17 Wed 00:07]
     CLOCK: [2014-09-16 Tue 23:44]--[2014-09-17 Wed 00:07] =>  0:23
     CLOCK: [2014-09-16 Tue 17:52]--[2014-09-16 Tue 18:38] =>  0:46
     CLOCK: [2014-09-16 Tue 07:53]--[2014-09-16 Tue 08:25] =>  0:32
     CLOCK: [2014-09-15 Mon 23:04]--[2014-09-16 Tue 00:04] =>  1:00

Once the JSON file has been loaded into an SML model, we should go
through the model and generate all of the inferred modules given the
qnames. If a module already exists we should skip this. We should also
do the containment logic as part of the post processing.

- origin type and generation type are still invalid for some reason.

**** COMPLETED Remove hacks in root enricher                           :task:
     CLOSED: [2014-09-17 Wed 00:31]
     CLOCK: [2014-09-17 Wed 00:07]--[2014-09-17 Wed 00:31] =>  0:24

Once we are populating the containing module, we need to remove the
commented out code and FIXME code.

*** COMPLETED C++ formatters use of =headers_for_facet_=              :story:
    CLOSED: [2014-09-17 Wed 00:36]
    CLOCK: [2014-09-17 Wed 00:31]--[2014-09-17 Wed 00:36] =>  0:05

We seem to be creating a local variable =headers_for_facet_= in
function =format_file_infos_activity= but not really making use of
it. We need to investigate what was that we were trying to do here,
the name of the variable seems to imply it should have been a member
variable. Probably a remnant from some old refactoring.

*** COMPLETED Move formatters meta-data types to meta-data namespace  :story:
    CLOSED: [2014-09-17 Wed 17:57]
    CLOCK: [2014-09-17 Wed 08:25]--[2014-09-17 Wed 08:50] =>  0:25

We should follow the SML pattern across other domain models and create
a specific namespace for all the meta-data related classes.

*** IMPLEMENTATION Implement the enricher interface in the CPP model  :story:
    CLOCK: [2014-09-17 Wed 08:22]--[2014-09-17 Wed 08:25] =>  0:03

The CPP model needs to register a top-level enricher that expands all
of the C++ specific tags. This has to be done before the formatter
enrichers kick in. We need to remove all of the =cpp= related code
from enricher and add it to =cpp= model. For now we should get
details from settings.

We should declare all of the traits at the model level, at least those
that are common to all formatters. Perhaps a traits class or some
such. SML should also declare the proper global traits such as
=enabled= and so on.

We should consider if we should declare the formatters this way too,
since they may depend on each other. This would be in the formatters
model.

*** Remove unnecessary properties from model                          :story:

The model should be just dumb container of types. We have a few legacy
properties left behind from the days where the model was also used in
the transformation process. Remove all the concepts from the model
(=Element= etc) and deal with the fall out. This is required in order
to simplify the graph in enricher.

*** Add cycle detection to grapher                                    :story:

We need to move the cycle dectector code from dia to sml into
utilities so that we can make use of it in the meta-data grapher.

*** Remove dependency of writer on tags                               :story:

We seem to be using the tags to detect containers. We need to get rid
of this dependency.

*** All model items traversal should resolve types                    :story:

This traversal was designed for tagger but yet it does not resolve
=type= into one of the sub-classes, forcing tagger to implement
visitation to resolve the types. We should improve the traversal.

*** Delete tags class in SML                                          :story:

This class does not make sense any more as each model will be
responsible for their own tags.

*** Move flat name builder to CPP model                               :story:

It seems this class is used only for tagging so we should have one in
each model. It may even make more sense in the c++ formatters model.

*** Remove all of the config settings that are in meta-data           :story:

We have a number of settings in the =config= model that won't be used
any longer:

- =formatting_settings=
- =annotation_settings=
- =cpp_settings=
- =code_generation_marker_settings=

These should all be removed, with the corresponding command line
arguments.

*** Manually generate packages for previous sprint                    :story:

We should manually generate packages for sprint 50 and upload them to
Google drive. To do this we should log in to each build agent, git
clone the repo from scratch, =git checkout= the tag and then do a full
build. We should also upload the docs too. Ideally we should do this
for all platforms.

*** Create a demo of installing dogen and generating hello world      :story:

We need to start creating a series of quick videos demoing dogen. The
script for the first video of the series is as follows:

- download packages from Google Drive and install them.
- obtain the hello world model from git.
- generate the hello world model.
- create a hello world main with make files and compile it.
- give a quick overview of the available facilities.

*** Version number relies on latest commit in master                  :story:

When trying to build off of a tag, we noticed that the version number
is always of the latest commit in master. This means that trying to
generate packages for tag =v0.50.2410= results in packages with a
version after that like say =v0.50.2415=. We should look at the
current commit in master rather than the latest one.

*** Write next interesting instalment in blog                         :story:

We have a number of links backlogged and we need to offload them in an
"interesting..." post.

** Deprecated Development Stories

Stories that do not make sense any longer.

*** CANCELLED Move includes and header guard into entity              :story:
    CLOSED: [2014-09-08 Mon 08:10]

*Rationale*: This will be supplied by the meta-data.

With this a formatter can now rely only on entities rather than
requiring a file.
