#+title: Sprint Backlog 91
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) }

* Mission Statement

- implement wale;
- integrate wale and stitch with knit;
- implement dart.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-10-24 Mon 17:59]
| <75>                                                                        |        |      |      |       |
| Headline                                                                    | Time   |      |      |     % |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| *Total time*                                                                | *2:23* |      |      | 100.0 |
|-----------------------------------------------------------------------------+--------+------+------+-------|
| Stories                                                                     | 2:23   |      |      | 100.0 |
| Active                                                                      |        | 2:23 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |        |      | 0:58 |  40.6 |
| COMPLETED Edit release notes for previous sprint                            |        |      | 0:22 |  15.4 |
| COMPLETED Improve bintray support                                           |        |      | 0:35 |  24.5 |
| COMPLETED Add logo with white background                                    |        |      | 0:14 |   9.8 |
| STARTED Consider renaming =diagrams= to =models=                            |        |      | 0:14 |   9.8 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-10-24 Mon 11:32]--[2016-10-24 Mon 11:46] =>  0:14
    CLOCK: [2016-10-24 Mon 11:12]--[2016-10-24 Mon 11:31] =>  0:19
    CLOCK: [2016-10-24 Mon 10:55]--[2016-10-24 Mon 11:11] =>  0:16
    CLOCK: [2016-10-24 Mon 10:01]--[2016-10-24 Mon 10:10] =>  0:09

Updates to sprint and product backlog.

*** COMPLETED Edit release notes for previous sprint                  :story:
    CLOSED: [2016-10-24 Mon 10:24]
    CLOCK: [2016-10-24 Mon 10:31]--[2016-10-24 Mon 10:39] =>  0:08
    CLOCK: [2016-10-24 Mon 10:10]--[2016-10-24 Mon 10:24] =>  0:14

Add github release notes for previous sprint.

Title: Dogen v0.90.0, "Aida"

#+begin_src markdown
Overview
========
One more sprint of internal refactorings, leading us close to the end result. The focus continued on the ```quilt.cpp``` model.

There were still a number of user visible changes:

- **introduction of profiles**: meaning its no longer necessary to setup each facet's configuration on each diagram; users can create or reuse profiles.
- **integration of stereotypes with profiles**: it's now possible to annotate a type with a stereotype and, if a profile with the same name exists, dogen will apply the profile to the type.
- **deprecation of the ```service``` stereotype**: it has been replaced by ```handcrafted```. With this change we now generate class skeletons for hand-crafted code.
- **mixing of hand-crafted and generated code code is now possible at the element level**: if a hand-crafted type declares a number of attributes and marks the IO facet as overwrittable, dogen will generate IO support (and serialisation and so forth) for this element.
- **rename of a lot of the meta-data tags**: removed the postfix ```_formatter```.

For more details see the [sprint log](https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_90.org).
#+end_src

*** COMPLETED Improve bintray support                                 :story:
    CLOSED: [2016-10-24 Mon 10:31]
    CLOCK: [2016-10-24 Mon 17:30]--[2016-10-24 Mon 17:59] =>  0:29
    CLOCK: [2016-10-24 Mon 10:25]--[2016-10-24 Mon 10:31] =>  0:06

As with every end of sprint, try to massage bintray a bit more and see
if we can fix some of the errors of the previous sprint.

- fixed the path to bintray descriptor.

*** COMPLETED Add logo with white background                          :story:
    CLOSED: [2016-10-24 Mon 10:54]
    CLOCK: [2016-10-24 Mon 10:40]--[2016-10-24 Mon 10:54] =>  0:14

Now we started tweeting releases we need a version of the logo that
has a background.

*** STARTED Consider renaming =diagrams= to =models=                  :story:
    CLOCK: [2016-10-24 Mon 18:02]
    CLOCK: [2016-10-24 Mon 16:43]--[2016-10-24 Mon 16:57] =>  0:14

The name "diagrams" is a bit misleading. These are not just diagrams,
they are specifically Dogen inputs. We need a name that is a bit more
meaningful. For example, if we start creating models in JSON, it would
render the directory name meaningless. We should call the directory
=models=.

In addition, models are really part of projects.

*** Implement wale templates                                          :story:

- manually create wale templates for header and implementation and do
  a mental dry-run to ensure it will work. Do also a stitch template
  manually for this exercise.
- create projects, library and binary.
- implement library with a simple transformer that takes in a path to
  template and a set of kvps. Add the ability to obtain all the keys
  for a given template.

*** Add region support to stitch                                      :story:

- extend stitch to allow injecting external kvps such as
  decoration. This can probably be done manually but needs to be
  investigated.
- extend stitch to support named regions; the text template will
  preserve the names after template instantiation.
- note: regions are a property of the artefact. knit will also have to
  support regions. Perhaps we should start having well-defined regions
  such as =decoration.preamble=, =decoration.postamble=, etc.

*** Add artefact source properties support                            :story:

- add properties to artefact properties, with enumeration for source:
  stock formatter (current), wale formatter, wale and stitch
  formatter. Other possible types: null formatter, copy formatter.
- add new expander.
- hook it in with formattables workflow.

Examples:

: quilt.cpp.serialization.class_header.formatting_style=stock
: quilt.cpp.serialization.class_header.formatting_input=a/b/c.wale

*** Add new formatter types                                           :story:

- add new kinds of formatters to process wale templates, etc.
- Each formatter should check for its required data. They can be
  mainly stubs for now.
- change the formatters workflow to dispatch to the correct formatter
  type.
- implement the new formatters by calling stitch and wale as required.
- for stitch formatter, inject the stitch template into the
  housekeeping files so we don't delete it.

*** Integration of stitch and dogen                                   :story:

Tasks:

- create wale templates for formatter header and implementation;
- go through all formatters and: a) update the stitch template with
  the code from implementation, adding regions b) change the source
  type to wale and stitch and deal with the fallout.
- when all formatters are done, remove regexes for stitch templates.

*Previous Understanding*

Now that we have implemented stitch and proved it works (more or
less), we need to think how we can make using stitch from dogen
easier. At present there is not integration at all:

- users need to create regexes to ensure dogen does not trample on
  stitch files:

:    --ignore-files-matching-regex .*stitch
:    --ignore-files-matching-regex .*_stitch.hpp
:    --ignore-files-matching-regex .*_stitch.cpp

- users need to manually create a header file for each stitch
  template.
- users need to create stitch targets and run them to ensure the
  templates have been expanded. This means its possible to get dogen
  and stitch out of sync (but for now not a big problem).

In the ideal world, when we knit a model it would be nice if it could
also stitch as required. This could be achieved as follows:

- Create a meta-data tag that tells dogen a type has an associated
  stitch template with it.
- Create =cpp= types that represent the stitch header and
  implementation.
- Transformer needs to look for the meta-data tag and instantiate the
  =cpp= types.
- Create a =cpp= formatter for the header, as per regular
  formatters. The slight challenge here is that the formatter needs to
  be instantiable across facets, which we do not support at the
  moment.
- Create a cpp formatter for the implementation which instantiates
  stitch with the template and uses it to create a file. Same
  challenge as with the header.

Random notes:

- change artefact to have named regions; by default there is only one
  region, with a name like "global". This is the output of a stock
  formatter. Regions are stored in a vector and have name and
  content.
- in default stitch, the named regions are: 1) boilerplate preamble 2)
  body. We will then introduce other named regions: inclusion function,
  formatting function.
- the wale and stitch artefact formatter will use the named regions as
  inputs to the wale kvps.

*Previous Understanding*

- stitch can still be integrated with dogen. We could use meta-data to
  link a formatter (well, any class that needs stitch really, but at
  present just a formatter) with a stitch template. For example, a
  =class_header_formatter= could have a "is stitchable" flag set to
  on. This would then mean that dogen would look for a
  =class_header_formatter.stitch= file in the same directory as the
  CPP file. It would then use that to create a
  =class_header_formatter_stitch.cpp= file. It would also
  ignore/generate a =class_header_formatter_stitch.hpp= file and
  automatically add it to the inclusion dependencies of
  =class_header_formatter.cpp=. These are injected into stitch as we
  instantiate the template since stitch supports meta-data (we do need
  a way to inject the meta-data from dogen into the meta-data in the
  template; perhaps a kvp container passed in to the stitch workflow
  which could then be handed over to the parser). All these files are
  automatically added to the list of "exceptions" for housekeeping so
  that they do not get deleted. However, stitch would not know
  anything at all about any of this; this is all knitter's
  functionality. The problem is at present we haven't got a good place
  to perform the stitching as part of knitter's workflows. Perhaps as
  part of the expansion, we could set a number of stitch fields which
  would then be picked up by some knit-specific workflow classes.

*** Stitch not writing when template has changed                      :story:

It seems we can change a text template but not get stitch to update
the cpp file. We must have made a mistake on the binary diffing of the
files.

*** Generate formatter interfaces                                      :epic:

We should create another template language, in addition to stitch:
"wale". Wale is a very simple language that has templates that just do
token replacement. The tokens must have a special format:
={{{TOKEN}}}=. We receive a map of keys to values and do a blind
replacement to the keys on the wale document.

This links to stitch as follows:

- create a single file implementation of a formatter. It will
  implement both the provider interface and the appropriate formatter
  interface. It will call the stitch method to start off with. There
  are no headers, just cpp. It does the formatter registration.
- add support in stitch for "named sections": its possible to start a
  section and assign it a name. A stitch template will have two
  sections: inclusion provision and formatting.
- add support in stitch for "wale variables". These are just kvp's
  defined at the top:

: <#@ wale.variable="formatter_name=abcd" #>

  wale variables and sections are converted into a kvp container for
  wale input. Examples: facet, formatter name, etc.
- convert the formatter code into a wale template, adding wale
  variables as required.
- update stitch to detect wale usage and to call wale in those
  cases. This could be done by supplying a wale template:

: <#@ wale.template="abcd.wale" #>

- note that wale could be useful outside of stitch, for example for
  dart: we could wale-lise utility and then instantiate it for a given
  project.

*Previous Understanding*

It should be possible to generate some trivial types such as formatter
interfaces, formatter container, registrar and so on. For this we
need:

- a mustache type template;
- a set of fields from yarn types to be exposed to mustache;
- a list of types to iterate through.

Once we got this we could instantiate the templates. To integrate this
with knit we would need some way of specifying which types the
iteration would be over. We could mark a specific type with a given
stereotype, and then supply say the base class ("all leaf descendants
of xyz"). Dogen would then locate the descendants and for each call
the template.

For registrar and container its a bit trickier because we want a
collection of types in one go.

We also need a way to keep these templates away from the main (user
visible) code, since they are useful only for dogen.

See also [[https://github.com/cierelabs/boostache/tree/develop][boostache]].

Notes:

- we will need some "special" tags for copyright, includes
  etc. Includes will be particularly special because we need to
  augment the include list with additional includes. However, we may
  not even need to be aware of this.

*Stitch meta-templates*

*Note*: re-read story [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_64.org#code-generating-formatters-as-text-templates][Code-generating formatters as text templates]] as
some of these ideas were already there. Also: see [[https://github.com/no1msd/mstch][mstch]].

In the quest for defining a single stitch template which then becomes
a formatter - without any additional infrastructure required at all -
we hit on an idea: stitch meta-templates. Basically we would have two
different kinds of inputs to stitch: the template itself and the
meta-template. Meta-template is a provisional name. The meta-template
would define the formatter layout:

- class definition, using a stitch variable for the yarn element type
- registration of the formatter
- definition of a method for the includes
- definition of a method for the stitching

These last two would result in the creation of "regions". These
regions must then be "instantiated" in the template. This could easily
be achieved with some kind of new element:

: <#% region "includes">

Or some such stitch construct. All lines after this line are part of
the region "includes" until a new region is defined. The region is
stitched and then transposed to the place in the meta-template where
it was defined, for example:

: int f(int a, int b) {
: <#% region "includes">
: }

Would result in copying across the region into these brackets. This
will make defining multiple functions very easy, without having to
supply command line arguments, etc.

Notes:

- meta-templates are supplied as command line arguments.
- potential extension: =meta.stitch=
- stitch should still work on non-meta-template mode.
- some of these ideas had already been covered on another story but
  can't find it in backlog. It could be part of the original stitch
  epic. We need to revisit it to see if it contains additional
  insights.
- when an error occurs, it would be great if we could pin point the
  error to the template or to the meta-template. This is more of a
  concern when we add clang compilation support.

Further thoughts:

- there are two approaches for this: we could integrate stitch tighter
  with knit and have it return "chunks" of processed code instead of
  files. As per story "Integration of stitch and dogen", dogen would
  then be responsible for writing the header file as per methods
  defined in the class diagram. Each method would be marked as a
  region. Meta-data in the class associates a template with the
  class. Knitter uses stitch to convert the template into regions, and
  then takes these regions and inserts them into a generated
  file. This approach is very clever and requires a lot of machinery.
- the easier approach uses meta-templates. Class diagram associates
  both meta-template and template with class via meta-data. We could
  possibly also have a stitch stereotype to make it clearer. Yarn has
  a stitch class with attributes of these parameters. Dogen
  instantiates stitch (probably within quilt) with the parameters and
  generates the file. Actually we probably can't have this in quilt
  because we still need formatter properties.

*** Supply model references via meta-data rather than command line    :story:

It doesn't make any sense to have model dependencies in the command
line. After all, the model cannot be interpreted without them. A
better way to do this would be to split this functionality into two:

- command line supplies "import directories", that is, directories
  to search when looking for models. By default the system directory
  is already in the path.
- model supplies "import statements". The problem here is that we need
  to also supply the file name of the model. We could perhaps omit the
  extension and then load all files that match (e.g. =.dia=, =.json=,
  etc). If more than one matches we should error. Actually we should
  just supply the full filename, as well as keep the current notation
  for the external project path.

This is also a nice way to avoid loading system models unnecessary;
users still need to declare the models they depend on, regardless if
system or user.

Each model should also supply the external module path as meta-data.

This is particularly painful since cross-model inheritance was
introduced because it means references are now transitive (we need to
know of the references of any model we reference). Once we add them to
the model, we should also load referenced models' references so that
the process is automatic.

Merged stories

*External module path and references as meta-data*

It actually does not make a lot of sense to allow users to supply
external module paths and references as command line options. This is
because the model will fail to build unless we provide the correct
ones; these are not configurable items in this sense. The project
path, etc are - and so should remain command line options.

We need to move these two into the meta-data. This would also mean we
no longer need to pass in external module paths for references, which
is much cleaner.

*** Create a tool to generate product skeletons                       :story:

Now that dogen is evolving to a MDSD tool, it would be great to be
able to create a complete product skeleton from a tool. This would
entail:

- directory structure. We should document our standard product
  directory structure as part of this exercise. Initial document added
  to manual as "project_structure.org".
- licence: user can choose one.
- copyright: input by user, used in CMakeFiles, etc. added to the
  licence.
- CI support: travis, appveyor
- EDE support:
- CMake support: top-level CMakefiles, CPack. versioning
  templates, valgrind, doxygen. For CTest we should also generate a
  "setup cron" and "setup windows scheduler" scripts. User can just
  run these from the build machine and it will start running CTest.
- conan support: perhaps with just boost for now
- agile with first sprint
- README with emblems.

Name for the tool: dart.

Tool should have different "template sets" so that we could have a
"standard dogen product" but users can come up with other project
structures.

Tool should add FindODB if user wants ODB support. Similar for EOS
when we support it again. We should probably have HTTP links to the
sources of these packages and download them on the fly.

Tool should also create git repo and do first commit (optional).

For extra bonus points, we should create a project in GitHub, Travis
and AppVeyor from dart.

We should also generate a RPM/Deb installation script for at least
boost, doxygen, build essentials, clang.

We should also consider a "refresh" or "force" statement, perhaps on a
file-by-file basis, which would allow one to regenerate all of these
files. This would be useful to pick-up changes in travis files, etc.

One problem with travis files is that each project has its own
dependencies. We should move these over to a shell script and call
these. The script is not generated or perhaps we just generate a
skeleton. This also highlights the issue that we have different kinds
of files:

- files that we generate and expect the user to modify;
- files that we generate but don't expect user modifications;
- files that the user generates.

We need a way to classify these.

Dart should use stitch templates to generate files.

We may need some options such as "generate boost test ctest
integration", etc.

Notes:

- [[https://github.com/elbeno/skeleton][Skeleton]]: project to generate c++ project skeletons.

*** Consider adding =artefact_set= to formatters' model               :story:

We are using collections of artefacts quite a bit, and it makes sense
to create an abstraction for it such as a =artefact_set=. However, for
this to work properly we need to add at least one basic behaviour: the
ability to merge two artefact sets. Or else we will end up having to
unpack the artefacts, then merging them, then creating a new artefact
set.

Problem is, we either create the artefact set as a non-generatable
type - not ideal - or we create it as generatable and need to add this
as a free function. We need to wait until dogen has support for
merging code generation.

*** Consider supplying element configuration as a parameter           :story:

Figure out if element configuration is context or if it is better
expressed as a stand alone formatting parameter.

*** Formatters' repository should be created in quilt                 :story:

At present we are creating the formatters' repository in
=quilt.cpp=. However it will be shared by all backends in the
kernel. Move it up to =quilt= level and supply it as a paramter to the
backends.

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

** Deprecated
*** CANCELLED Consider moving dia diagrams to their own project       :story:
    CLOSED: [2016-10-24 Mon 11:30]

*Rationale*: its handy having all diagrams in one place.

We originally create a diagrams top-level directory for all of the
diagrams that generate dogen models. However it may make more sense to
have the diagrams closer to the project they generate; for example a
folder within the project. The downside of this approach is that we
now have to make references across projects; we could use relative
paths for this but the targets will still look verbose.
