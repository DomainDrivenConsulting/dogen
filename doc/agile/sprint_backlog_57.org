#+title: Sprint Backlog 57
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Commentary

** Mission

Complete the picture for settings and start making use of them in
anger; start moving across some of the formatting code for the class
formatter.

** Retrospective

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2014-12-01 Mon 18:29]

| Headline                                                        | Time   |      |      |
|-----------------------------------------------------------------+--------+------+------|
| *Total time*                                                    | *1:35* |      |      |
|-----------------------------------------------------------------+--------+------+------|
| Active                                                          |        | 1:35 |      |
| STARTED Sprint and product backlog grooming                     |        |      | 0:15 |
| COMPLETED Refactor tags and todos in sprint and product backlog |        |      | 0:34 |
| COMPLETED Traits to use static methods                          |        |      | 0:46 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2014-12-01 Mon 17:48]--[2014-12-01 Mon 17:53] =>  0:05
    CLOCK: [2014-12-01 Mon 08:30]--[2014-12-01 Mon 08:35] =>  0:05
    CLOCK: [2014-12-01 Mon 07:51]--[2014-12-01 Mon 07:56] =>  0:05

Updates to sprint and product backlog.

*** COMPLETED Refactor tags and todos in sprint and product backlog   :story:
    CLOSED: [2014-12-01 Mon 08:26]
    CLOCK: [2014-12-01 Mon 08:08]--[2014-12-01 Mon 08:30] =>  0:22
    CLOCK: [2014-12-01 Mon 07:56]--[2014-12-01 Mon 08:08] =>  0:12

*Analysis*

We have been messing around with org mode tags on backlogs for a bit,
trying to figure out what is the best way to make use of them. We now
have a lot of tags:

: #+tags: { story(s) epic(e) task(t) note(n) spike(p) }
: #+tags: { refactor(r) bug(b) feature(f) vision(v) }
: #+tags: { meta_data(m) tests(a) packaging(q) media(h) build(u) validation(x) diagrams(w) frontend(c) backend(g) }
: #+tags: dia(y) sml(l) cpp(k) config(o) formatters(d)

In reality, we don't really make proper use of any of these other than
=vision=. It is useful to distinguish between the stories that are
almost ready for implementation from the stories that won't be for a
long while. We should probably remove all tags all leave =vision= and
=task= or =story=. The problem with =story= is that we then feel like
we always have to provide the story text, which is not always
possible. Task is suitable vague.

In the future if we do find a use for tags like =dia=, etc, we should
implement them as properties.

In effect, we just want to distinguish between two cases:

- stories that are small enough that can be tackled within a sprint
  (where we thin the analysis has been done, sufficiently to start
  working on them)
- stories that are still too vague to be worked on.

We need to find two names that fit these descriptions.

*Action Items*

- remove all tags except for story and spike in sprint backlog, and
  story and epic in product backlog.
- add section for retrospective.
- remove all statuses except for started, completed, cancelled and
  postponed.

*** COMPLETED Traits to use static methods                            :story:
    CLOSED: [2014-12-01 Mon 18:29]
    CLOCK: [2014-12-01 Mon 18:10]--[2014-12-01 Mon 18:28] =>  0:18
    CLOCK: [2014-12-01 Mon 17:53]--[2014-12-01 Mon 18:10] =>  0:17
    CLOCK: [2014-12-01 Mon 08:36]--[2014-12-01 Mon 08:47] =>  0:11

As per analysis in the previous sprint, we need to start using static
methods in traits rather than static variables. We had forgotten about
the static variable initialisation fiasco. In order to fix this we
should add methods to the structs that contain static variables
internally. This should ensure the correct order of initialisation. We
should also do a bit of a refresher on the fiasco to refresh it.

*** Travis deployment of tags fails                                   :story:

As per issue 2577 in travis, it does not support wildcards at the
moment. We need to find another way to upload packages into GitHub
without using wildcards.

*** Global settings factory must produce settings by formatter        :story:

We seem to be returning settings by facet. In the new world of
formatter settings this is a problem.

*** Add support for opaque formatter settings                         :story:

- create an empty opaque formatter settings class. Create a opaque
  formatter settings factory interface class. Formatter interface to
  return an opaque formatter settings factory interface.
- add opaque formatter settings to global settings.
- when formatting, cast additional formatter settings (if available)
  and throw if cast fails. For formatters without opaque settings,
  throw if any supplied.

*** Add support for local settings                                    :story:

- create a local settings class that is made up of file settings,
  opaque settings and formatter settings. Entity to have a container
  of local settings (map of formatter id to local settings).
- create a local settings factory that takes on the work from workflow
  in generating the file settings. It also takes on a container of
  opaque settings factory by formatter id to generate the opaque
  settings. Finally, it uses the formatter settings factory for the
  overrides. These should be optional. If populated, they should take
  on the global settings as defaults so that we don't have to worry
  about global settings for formatters any more. This means the local
  settings factory must have access to the global settings.

*** Create a settings class                                           :story:

- create a settings class that has a map of formatter id to global
  settings. It could also have a map of c++ entity name (produced with
  name builder to include namespaces), to formatter id to local
  settings. With this we can now move the settings away from entity
  because we no longer require the qname.
- pass the settings class to the includes builder.

*** Consider using an abstract factory in formatters                  :story:

At present we have a number of interfaces (or quasi-interfaces) coming
out of formatter:

- file name generation
- includes generation
- opaque settings generation
- opaque settings validator

Perhaps it makes more sense to aggregate them all into a factory of
factories. We should look into the abstract factory pattern as it
seems particularly suitable for this. The factory should remember the
id of the formatter it comes from.

In terms of names, it is difficult to find a name for such an
aggregate:

- formatter components, e.g. =formatter_components_factory_interface=
- formatter properties
- formatter parts

*** Capture settings validation rules                                 :story:

Once all settings have been built (global and local) we must pass them
to a validator class that makes sure they all make sense. This story
captures all the rules we need to check for. We must also check the
SML validator story in backlog for rules that apply to settings.

- integrated IO must not be enabled if IO is enabled and vice-versa
  (opaque settings validator). actually it seems this is possible, we
  need to investigate the current implementation.
- types must be enabled
- if serialisation is enabled, types forward declaration of the
  serialisation classes must be enabled (opaque settings validator)

*** Implement include generation for class header formatter           :story:

Now that we have finished generating the path spec details, we need to
make sure includes generation works as expected. Add both formatter
level includes as well as model level includes.

We also need to deal with:

- exposing formatter id as a static property so we can create
  dependencies between formatters;
- includes overrides via meta-data, so we can start using STL, Boost
  etc classes.
- includes of STL, Boost etc that are formatter level dependencies -
  this needs to be handled via traits.

*** Consider renaming general settings                                :story:

A while ago we came up with this name for the settings of the generic
formatter model. This is the model with basic infrastructure to be
reused by the more specialised formatters. However, now that we have
many (many) settings classes, general settings may not be the most
appropriate name. We need to look a bit more deeply into the role of
this class and see if a better name is not available.

*** Create a transformation and formatting sub-workflow               :story:

At present we have two template functions in the main workflow,
linking the different steps of transformation and formatting. However,
it may make more sense to plug in to the all types traversal. For this
we need a sub-workflow that owns the model and the transformer and
which overloads =operator()=. It produces files.

It can receive a formatter dispatcher and a transformer on
construction and keep references these. Execute returns the list of
files.

*** Implement class header formatter                                  :story:

- look at the old =om= types formatter implementation to see if there
  is any code to scavenge. This model was deleted around commit
  10157ad.

**** Tidy-up =types_main_header_file_formatter=                        :task:

Clean up internal functions in file and add documentation.

**** Copy across documentation from =om=                               :task:

We did a lot of doxygen comments that are readily applicable, copy
them across.

**** Make use of indenting stream                                      :task:

Remove uses of old indenter.

**** Copy across =om= types formatter tests                            :task:

Not sure how applicable this would be, but we may be able to scavenge
some tests.

** Deprecated
