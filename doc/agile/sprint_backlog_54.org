#+title: Sprint Backlog 54
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) task(t) note(n) spike(p) }
#+tags: { refactor(r) bug(b) feature(f) vision(v) }
#+tags: { meta_data(m) tests(a) packaging(q) media(h) build(u) validation(x) diagrams(w) frontend(c) backend(g) }
#+tags: dia(y) sml(l) cpp(k) config(o) formatters(d)

* Stories

This file contains all stories that were closed during sprint 54.

The *Mission Statement* for this sprint is to continue to implement
the backend model, finish hooking it up to the C++ model and implement
at least one formatter in the C++ model.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2014-11-01 Sat 00:00]

| Headline                                                            | Time   |      |      |
|---------------------------------------------------------------------+--------+------+------|
| *Total time*                                                        | *7:28* |      |      |
|---------------------------------------------------------------------+--------+------+------|
| Development Stories Implemented                                     |        | 7:28 |      |
| IMPLEMENTATION Sprint and product backlog grooming                  |        |      | 0:16 |
| IMPLEMENTATION Updates to the manual and readme files               |        |      | 0:13 |
| COMPLETED Remove map from backend interface                         |        |      | 0:09 |
| COMPLETED Generate all backends in workflow                         |        |      | 0:14 |
| COMPLETED Add registrar to =cpp= with class formatter support       |        |      | 1:13 |
| COMPLETED Add formatter dispatcher to =cpp= model                   |        |      | 0:40 |
| COMPLETED Models that share sub-package names fail to resolve types |        |      | 0:59 |
| COMPLETED Add transformer to =cpp= workflow                         |        |      | 1:10 |
| COMPLETED Change list of files to forward list                      |        |      | 2:03 |
| COMPLETED Module generation type is invalid for library models      |        |      | 0:31 |
#+end:

*** IMPLEMENTATION Sprint and product backlog grooming                 :task:
    CLOCK: [2014-10-29 Wed 23:01]--[2014-10-29 Wed 23:10] =>  0:09
    CLOCK: [2014-10-21 Tue 22:55]--[2014-10-21 Tue 23:02] =>  0:07

Updates to sprint and product backlog.

*** IMPLEMENTATION Updates to the manual and readme files        :task:media:
    CLOCK: [2014-10-22 Wed 22:55]--[2014-10-22 Wed 23:08] =>  0:13

Use downtime to update the manual and / or readme file.

*** COMPLETED Remove map from backend interface               :task:refactor:
    CLOSED: [2014-10-29 Wed 23:19]
    CLOCK: [2014-10-29 Wed 23:10]--[2014-10-29 Wed 23:19] =>  0:09

We still have a map in the backend interface for general settings even
though we decided to simplify things and only allow a single general
settings for a project. Update interface.

*** COMPLETED Generate all backends in workflow                       :story:
    CLOSED: [2014-10-29 Wed 23:34]
    CLOCK: [2014-10-29 Wed 23:21]--[2014-10-29 Wed 23:34] =>  0:13
    CLOCK: [2014-10-29 Wed 23:20]--[2014-10-29 Wed 23:21] =>  0:01

Even though the backends don't actually do anything at the moment, we
need to make sure we have an end-to-end pipeline.

*** COMPLETED Add registrar to =cpp= with class formatter support     :story:
    CLOSED: [2014-10-30 Thu 08:17]
    CLOCK: [2014-10-30 Thu 07:30]--[2014-10-30 Thu 08:17] =>  0:47
    CLOCK: [2014-10-29 Wed 23:34]--[2014-10-30 Thu 00:00] =>  0:26

Add the basic skeleton of the registrar in =cpp= model with only
support for class formatters.

*** COMPLETED Add formatter dispatcher to =cpp= model                 :story:
    CLOSED: [2014-10-30 Thu 18:46]
    CLOCK: [2014-10-30 Thu 18:06]--[2014-10-30 Thu 18:46] =>  0:40

Create a class to dispatch to the correct formatters and retrieve a
list of files. Plug it to the workflow.

*** COMPLETED Models that share sub-package names fail to resolve types :spike:bug:
    CLOSED: [2014-10-30 Thu 23:01]
    CLOCK: [2014-10-30 Thu 22:02]--[2014-10-30 Thu 23:01] =>  0:59

The =cpp= model has a formatters package, which is also present in the
formatters model (it is the model package). Due to this, we do not
seem to be able to resolve types in the formatters model such as
=general_settings=. We need to tweak resolution code to deal with this scenario.

*** COMPLETED Add transformer to =cpp= workflow               :task:refactor:
    CLOSED: [2014-10-31 Fri 19:05]
    CLOCK: [2014-10-31 Fri 18:58]--[2014-10-31 Fri 19:04] =>  0:06
    CLOCK: [2014-10-31 Fri 18:08]--[2014-10-31 Fri 18:56] =>  0:48
    CLOCK: [2014-10-30 Thu 18:48]--[2014-10-30 Thu 19:04] =>  0:16

We need to copy across the transformer into the C++ model in order to
start working on formatter code.

*** COMPLETED Change list of files to forward list            :task:refactor:
    CLOSED: [2014-10-31 Fri 23:29]
    CLOCK: [2014-10-31 Fri 23:25]--[2014-10-31 Fri 23:27] =>  0:02
    CLOCK: [2014-10-31 Fri 21:23]--[2014-10-31 Fri 23:24] =>  2:01

We are paying the cost of a full list for no reason. Use a forward
list instead.

*** COMPLETED Module generation type is invalid for library models :spike:bug:
    CLOSED: [2014-11-01 Sat 00:00]
    CLOCK: [2014-10-31 Fri 23:53]--[2014-11-01 Sat 00:00] =>  0:07
    CLOCK: [2014-10-31 Fri 23:29]--[2014-10-31 Fri 23:53] =>  0:24

We are relying on generation types to filter in the new workflow but
it seems the library modules all have an invalid generation types.

*** Refactor types header formatter            :task:refactor:formatters:cpp:

Make the main types header formatters look like the =om= types
formatter. This model was deleted around commit 10157ad.

This is still not quite right. We need to drive the formatting from
two things:

- user options
- available formatters

**** Tidy-up =types_main_header_file_formatter=                        :task:

Clean up internal functions in file and add documentation.

**** Make use of boilerplate                                           :task:

Generate the licence, etc using boilerplate formatter.

**** Copy across documentation from =om=                               :task:

We did a lot of doxygen comments that are readily applicable, copy
them across.

**** Make use of indenting stream                                      :task:

Remove uses of old indenter.

**** Copy across =om= types formatter tests                            :task:

Not sure how applicable this would be, but we may be able to scavenge
some tests.

*** Add include files at the formatter level    :task:refactor:meta_data:cpp:

We need to remove all the include files from =includer= which are
related to formatter specific code. We need to inject these
dependencies inside of the formatters.

- implement includer in terms of json files
- get includer to work off of object relationships
- remove relationships from transformer
- remove helper models boost and std

*** Includer generation should be done from meta-data         :task:refactor:

It would be nice if we could determine which includer files to create
by looking at the meta-data. For this we need a notion of an inclusion
group, defined at the model level:

- =cpp.types.includers.general=
- =cpp.types.includers.value_objects=
- ...

Under each of these one would configure the aspect:

- =cpp.types.includers.general.generate=: =true=
- =cpp.types.includers.general.file_name=: =a/b/c=
- =cpp.types.includers.general.is_system=: =false=

Then, each type, module etc would declare its membership (as a list):

- =cpp.includers.member=: =cpp.types.includers.general=
- =cpp.includers.member=: =cpp.types.includers.value_objects=
- ...

*Previous understanding*

We should simply go through all the types in the SML model and for
each type and each facet create the corresponding inclusion
path. locator can be used to generate standard paths, and a model
specific mapping is required for other models such as std.

Include then takes the relationships extracted by extractor, the
mappings generated by this mapper and simply appends to the inclusion
list the file names. it also appends the implementation specific
headers.

*** Support "cross-facet interference"                         :task:feature:

In a few cases its useful to disable bits of a facet when another
facet is switched off because those bits do not belong to the main
facet the formatter is working on. At present this happens in the
following cases:

- Forward declaration of serialisation in domain when serialisation is
  off
- Friend of serialisation in domain when serialisation is
  off
- declaration and implementation of to_stream when IO is off
- declaration and implementation of inserter when IO is off and
  integrated IO is on.

We need a way of accessing the on/off state of all facets from any
formatter so that they can make cross facet decisions. A quick hack
was to add yet another flag: =disable_io= which is disabled when the
IO facet is not present and passed on to the relevant formatters. This
needs to be replaced by a more general approach.

*** Add frontends and backends to =info= command line option  :story:feature:

#+begin_quote
*Story*: As a dogen user, I want to know what frontends and backends
are available in my dogen version so that I don't try to use features
that are not present.
#+end_quote

With the static registration of frontends and backends, we should add
some kind of mechanism to display whats on offer in the command line,
via the =--info= option. This is slightly tricky because the
=frontend= and =backend= models do not know of the command line. We
need a method in the frontends that returns a description and a method
in the workflow that returns all descriptions. These must be
static. The knitter can then call these methods and build the info
text.

*** Rename the include tags and add them to CPP model          :task:bug:sml:

Update all the JSON files with names in the form
=cpp.include.types.header_file=. Add properties in =cpp= to capture
these.

While we're at it, add support for =family= too.

** Deprecated Development Stories

Stories that do not make sense any longer.
