#+title: Release Notes for Sprint 28
#+options: date:nil toc:nil author:nil num:nil
#+todo: ANALYSIS IMPLEMENTATION TESTING | COMPLETED CANCELLED
#+tags: story(s) epic(e) task(t) note(n) spike(p)

* Release Notes

This file contains all stories that were closed during sprint 28.

** Development Stories Implemented

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2013-06-08 Sat 14:20]

| Headline                                                         | Time   |      |      |
|------------------------------------------------------------------+--------+------+------|
| *Total time*                                                     | *9:51* |      |      |
|------------------------------------------------------------------+--------+------+------|
| Development Stories Implemented                                  |        | 9:51 |      |
| COMPLETED Update README                                          |        |      | 1:04 |
| COMPLETED Whiteboarding on the role of SML                       |        |      | 1:45 |
| COMPLETED Leaf types do not have a virtual destructor            |        |      | 0:26 |
| IMPLEMENTATION Release notes and backlog grooming                |        |      | 1:04 |
| IMPLEMENTATION Improve modeling of domain driven concepts in SML |        |      | 3:25 |
| Add support for concepts at the SML level                        |        |      | 0:12 |
| ANALYSIS Break down SML into concepts                            |        |      | 1:27 |
| Refactor top level concepts in SML                               |        |      | 0:22 |
| IMPLEMENTATION Move services into their own type                 |        |      | 0:06 |
#+end:

*** COMPLETED Update README
    CLOSED: [2013-06-04 Tue 08:37]
    CLOCK: [2013-06-04 Tue 08:30]--[2013-06-04 Tue 08:37] =>  0:07
    CLOCK: [2013-06-04 Tue 07:49]--[2013-06-04 Tue 08:18] =>  0:48
    CLOCK: [2013-06-03 Mon 18:16]--[2013-06-03 Mon 18:42] =>  0:26
    CLOCK: [2013-06-03 Mon 18:03]--[2013-06-03 Mon 18:05] =>  0:02

The [[https://github.com/Neverlord/libcppa][C++ actor library]] has a nice README layout, most of which is
applicable to Dogen. Copy the appropriate parts.

*** COMPLETED Whiteboarding on the role of SML                         :task:
    CLOSED: [2013-06-06 Thu 07:57]
    CLOCK: [2013-06-05 Wed 20:30]--[2013-06-05 Wed 22:15] =>  1:45

*** COMPLETED Leaf types do not have a virtual destructor             :spike:
    CLOSED: [2013-06-08 Sat 14:13]
    CLOCK: [2013-06-08 Sat 14:14]--[2013-06-08 Sat 14:17] =>  0:03
    CLOCK: [2013-06-08 Sat 14:02]--[2013-06-08 Sat 14:13] =>  0:11
    CLOCK: [2013-06-08 Sat 13:50]--[2013-06-08 Sat 14:02] =>  0:12

For some reason we are not generating a virtual destructor for the
leaf types.

*** IMPLEMENTATION Release notes and backlog grooming                  :task:
    CLOCK: [2013-06-06 Thu 07:50]--[2013-06-06 Thu 08:15] =>  0:25
    CLOCK: [2013-06-05 Wed 19:19]--[2013-06-05 Wed 19:24] =>  0:05
    CLOCK: [2013-06-05 Wed 07:54]--[2013-06-05 Wed 07:58] =>  0:04
    CLOCK: [2013-06-05 Wed 07:46]--[2013-06-05 Wed 07:54] =>  0:08
    CLOCK: [2013-06-04 Tue 23:54]--[2013-06-04 Tue 23:59] =>  0:05
    CLOCK: [2013-06-04 Tue 19:06]--[2013-06-04 Tue 19:12] =>  0:06
    CLOCK: [2013-06-04 Tue 18:55]--[2013-06-04 Tue 19:06] =>  0:11

*** IMPLEMENTATION Improve modeling of domain driven concepts in SML   :epic:
    CLOCK: [2013-06-08 Sat 12:49]--[2013-06-08 Sat 12:51] =>  0:02
    CLOCK: [2013-06-08 Sat 12:10]--[2013-06-08 Sat 12:49] =>  0:39
    CLOCK: [2013-06-06 Thu 08:52]--[2013-06-06 Thu 09:03] =>  0:11
    CLOCK: [2013-06-06 Thu 08:18]--[2013-06-06 Thu 08:48] =>  0:30

Its becoming obvious that SML is largely trying to model part of the
domain driven design model - the part that is closer to code and
further away from the higher-level design processes. However, we
introduced DDD features into SML in a somewhat haphazard fashion,
which obscured this. The objective of this story is to bring to the
fore all parts of SML which are representations of DDD concepts, and
to make sure these are modeled as closely as possible to DDD.

**** COMPLETED Create a base class for types                          :story:
     CLOSED: [2013-06-08 Sat 14:30]
     CLOCK: [2013-06-08 Sat 14:22]--[2013-06-08 Sat 14:30] =>  0:08
     CLOCK: [2013-06-08 Sat 14:18]--[2013-06-08 Sat 14:22] =>  0:04
     CLOCK: [2013-06-08 Sat 12:59]--[2013-06-08 Sat 13:50] =>  0:51
     CLOCK: [2013-06-05 Wed 08:37]--[2013-06-05 Wed 09:27] =>  0:50
     CLOCK: [2013-06-05 Wed 08:29]--[2013-06-05 Wed 08:32] =>  0:03
     CLOCK: [2013-06-05 Wed 07:58]--[2013-06-05 Wed 08:17] =>  0:19

New understanding:

- create a base class call =model_element=. =thing= seems to be the
  only other name for this type according to DDD book, but the eCore
  name seems a bit more sensible.
- create a derived class of =model_element= called =object=. entities,
  services and values derive from object.

Old understanding:

Refactoring for concepts would be made a lot easier if only we had a
base class that contained all the type features. We need two levels of
inheritance:

- a =type=: this is the base class for things such as =module=,
  =enumeration=, =string_table=, etc. It has a =qname=, implementation
  specific parameters and documentation. For now, it should also have
  generation type (but this needs to be revisited).
- an =object_type= (see naming rationale below)which derives from type
  and adds properties and operations to it.

***** COMPLETED Find the correct name for object base class
      CLOSED: [2013-06-08 Sat 13:47]

Final results:

- we are going to use a variation of eCore names: =model_element= and
  =typed_element=.

Investigation:

In SML, entities, services and values are all "types of objects". The
book is never very clear about their relationship, but a few
inferences can be made:

- "value objects": these are objects which have no identity;
- services: these contain functions that would otherwise be
  stand-alone but in a OO world must be packaged inside of objects. in
  SML, due to code generation limitations we take this further and
  consider a service anything which has behaviour. This is not a DDD
  view though.
- entities: these are objects with identity.

Now, a type used to describe objects is traditionally called a class
(e.g. a meta object, or the object that models objects), so it would
make sense for the base class to be called =class=. However DDD
terminology seems to focus more on run time aspects. One could
conceivably call it =object=.

eCore and UML derived ideas:

- =typed_element=: not very clear; a model type with a type?
- =classifier=: "A classifier is a discrete concept in the model,
  having identity, state, behavior, and relationships."

XML schema derived ideas:

- =type=: parent; has a name
- =simple_type=: primitives; child of type.
- =complex_type=: pods; child of type.
- =enumeration=: child of simple type.

***** COMPLETED Update the SML diagram and code generate it
      CLOSED: [2013-06-08 Sat 14:28]

Make the type visitable

***** CANCELLED Update model to be a container of the base type
      CLOSED: [2013-06-08 Sat 14:29]

- Consider using boost pointer container, although this would mean
  adding support for it in dogen. Maybe for now we could start with
  =boost::shared_ptr=.
- Change transformer to become a visitor of type
- Change C++ transformer


No need for this, will cause a lot of breakage for no reason.

**** Rename package to module                                         :story:

Preferred name in DDD. Also more language neutral.

***** Rename class in SML
***** Update qname

- external package path;
- package path

***** Update method names

**** keys and visitor                                                  :note:

At the meta-model level, keys are actually just an instance of a value
object with properties. The injector will create them. An entity
should have a special association with its keys.

Visitors are injected as services. They have operations with the visit
methods.

**** Create class to model entity                                     :story:

We should have an entity class with an identity. Identity is just a
set of properties which are used to uniquely identify the object. The
entity class should also have associated with it the set of versioned
and unversioned keys, if such exist (e.g. if the class is keyed and/or
versioned). Potentially =boost::optional=?

**** Create classes to model service, factory and repository          :story:

For practical purposes (and for now) these classes are all identical:
they can have properties and operations. They have different names to
keep in sync with DDD. We could of course create a common type with a
not-so-clear-name (e.g. =object_with_behaviour=) and then stick an
enumeration in it for the three different types. However, it appears
much more meaningful to have the correct DDD names, even it if means a
few identical classes with different names.

We need to add stereotypes for factory and repository to the
transformer.

**** Remove generation types                                          :story:

SML knows not of code generation so we shouldn't have a generation
type in it. What we should have instead is a way of identifying a type
as belonging to the target model or not. In a way, its qname already
does that.

Partial generation is actually a c++ model decision based on how much
features it supports.

**** Create a value types enumeration                                 :story:

All these types are actually types of values:

- enumeration
- string table
- key (versioned and unversioned)
- exception
- user defined values
- smart pointer
- associative container
- sequence container

We should create an enumeration, say =value_types= which only values
have and then collapse all these types into value. These concepts
don't really exist at the SML level.

**** Models should have types                                         :story:

Consider creating an enumeration for model types:

- relational model
- core domain model
- generic sub-domain model
- segregated core model

This still requires a lot of analysis work around the DDD book.

**** Change Transformation code to use a type visitor                 :story:

Now we have a base type, we could probably simplify some of the
transformation code:

- dia to sml
- sml to c++
- potentially merger

*** Model name should be a qname                                      :story:

We already have most of the qname properties in the model anyway, so
might as well just use a qname.

*** Add support for concepts at the SML level                         :story:
    CLOCK: [2013-05-08 Wed 07:47]--[2013-05-08 Wed 07:59] =>  0:12

A concept is just like a pod, except its stereotype is
=concept=. Types can then "model" a given concept by having it as
their stereotype. This effectively results in merging all the
properties of the concept into the type. The concept has no
representation in code, its only a diagram/SML thing.

Concepts will solve the problems in SML with pods, etc where we didn't
want to use inheritance to avoid tight coupling - but at the same time
its annoying to have to repeat the same properties in lots of
different places: name, documentation, implementation specific
parameters, etc. We could create concepts for these: =named=,
=documented=, etc. and then use them as stereotypes in the affected
types, removing the need for duplication.

Conceivably one could imagine defining boost concept check rules for
these concepts but at present there is no need for this.

In terms of implementation, we need a string container for these
concepts and a way of resolving the stereotype into a qname.

**** Create a new class called concept which mirrors pod
**** Add support for multiple inheritance in concepts
**** Add concepts to model
**** Add concepts to pod
**** When transforming a pod, copy across properties from concept

Must traverse inheritance.

**** Add test to inheritance model
*** ANALYSIS Break down SML into concepts                              :epic:
    CLOCK: [2013-06-04 Tue 23:09]--[2013-06-04 Tue 23:54] =>  0:45
    CLOCK: [2013-06-04 Tue 22:29]--[2013-06-04 Tue 23:09] =>  0:40
    CLOCK: [2013-06-04 Tue 20:33]--[2013-06-04 Tue 20:35] =>  0:02

We should use the types in eCore as a starting point for breaking down
the model into concepts. We should have a hierarchy of concepts where
applicable. Things that need to be modeled as concepts:

- UniquelyIdentifiable: type has can be uniquely identified by its
  qualified name.
- Documentable: type can be documented.
- Parameterisable: type supports opaque parameters (implementation
  specific parameters).
- Generatable: type has different properties with respect to
  generation.
- Inheritable: type provides support for inheritance.
- Stateful: type has properties.
- Operatable: type has methods (operations).
- ModelElement: refinement of UniquelyIdentifiable, Documentable,
  Parameterisable. Modeled by =sml::model=.
- GeneratableModelElement: refinement of ModelElement and
  Generatable. Modeled by =sml::enumeration=, =sml::exception=, etc.
- ClassifiableModelElement: refinement of GeneratableModelElement,
  Stateful and Operatable. At present modeled by =sml::pod=. In the
  future: =sml::value=, =sml::entity=, =sml::service=,
  =sml::repository=, =sml::factory=. =sml::versioned_key=,
  =sml::unversioned_key=, =sml::concept=.

*** Refactor top level concepts in SML                                :story:
    CLOCK: [2013-06-04 Tue 18:40]--[2013-06-04 Tue 19:02] =>  0:22

SML is in many ways the domain model of domain driven development
(DDD). Due to this, DDD concepts should be first class citizens:

- entity
- value
- service
- aggregate root
- factory
- repository

This will be a good chance to fix =pod= which was incorrectly named
due to of a lack of understanding of what a C++ pod type [[http://en.wikipedia.org/wiki/Plain_old_data_structure][really is]].

*** Rename implementation specific parameters                         :story:

These should really be called back end specific parameters at the SML
level. At the dia level, if a parameter is passed in which has a
representation at the SML level it should simply be converted to this
representation instead of being added to the KVP.

Actually, these are more like generic parameters:

- at the dia level they are used to fill in gaps in dia (e.g. packages
  and diagrams do not have comments)
- at the SML level, they are used to add information which does not
  make sense for it to be in dia: is property key.
- at the backend level, they are used to provide information which
  does not make sense to live in SML: for example the ODB parameters.

Also, when the string table support has been added, we need to create
a string table with all valid values for the parameter keys.

Name choices:

- opaque parameters
- untyped parameters

*** Rename nested qname to composite qname                            :story:

We should just follow the composite pattern in the naming.

*** Visitor as an injected system type                                :story:

The current implementation of visitor relies on creating a view model
without a corresponding type. In reality we should do as we did for
keys and create a category type of visitor. This is really a SML
concept, not a backend specific concept.

*** IMPLEMENTATION Move services into their own type                  :story:
    CLOCK: [2013-06-04 Tue 18:32]--[2013-06-04 Tue 18:38] =>  0:06

Continuing from previous iteration, see description in Sprint 26.

**** IMPLEMENTATION Move all of the existing pod code to use new type

*** IMPLEMENTATION Use explicit casting for versioned to unversioned conversions :story:

Continuing from previous iteration, see description in Sprint 26.

*** IMPLEMENTATION Add =extract_key= function                         :story:

Continuing from previous iteration, see description in Sprint 26.

*** Consider not creating unversioned keys for single property        :story:

If a key is made up of a single property, its a bit nonsensical to
create an unversioned key. We should only generate the versioned
key. However, it does make life easier. Wait for real world use cases
to decide.

*** Injection framework

We need a more generic way of handling system types injection into
models. This is because there is a number of things that can be
derived from the existing model types:

- keys
- diff support
- reflection
- cache code
- etc.

So we need to:

- make injector a composite of injectors that do the real work such as
  =key_injector=. internally =injector= just delegates the work to
  these classes.
- injector decides which internal injectors to use based on options
  passed in.
- in the IoC spirit, we should probably create a =injector_interface=.

** Deprecated Development Stories
