#+title: Sprint Backlog 73
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- Continue the yarn refactors.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75
#+CAPTION: Clock summary at [2015-11-06 Fri 23:53]
| <75>                                                                        |         |       |      |
| Headline                                                                    | Time    |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                                | *24:25* |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| Stories                                                                     | 24:25   |       |      |
| Active                                                                      |         | 24:25 |      |
| STARTED Sprint and product backlog grooming                                 |         |       | 2:12 |
| COMPLETED Split "full" models from "partial" models                         |         |       | 8:37 |
| COMPLETED Frontend model refactor                                           |         |       | 1:39 |
| COMPLETED Improve references management                                     |         |       | 1:02 |
| COMPLETED Move property type generation to expander                         |         |       | 0:50 |
| COMPLETED Yarn refactor around partial model construction                   |         |       | 2:24 |
| STARTED Compute qualified name                                              |         |       | 6:31 |
| STARTED Create a "final model" class                                        |         |       | 0:19 |
| STARTED Model should not be an element                                      |         |       | 0:18 |
| STARTED Rename nested qname to composite qname                              |         |       | 0:33 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-11-01 Sun 23:31]--[2015-11-01 Sun 23:45] =>  0:14
    CLOCK: [2015-11-01 Sun 22:49]--[2015-11-01 Sun 23:30] =>  0:41
    CLOCK: [2015-10-31 Sat 22:01]--[2015-10-31 Sat 22:37] =>  0:36
    CLOCK: [2015-10-27 Tue 19:01]--[2015-10-27 Tue 19:08] =>  0:07
    CLOCK: [2015-10-27 Tue 07:59]--[2015-10-27 Tue 08:22] =>  0:23
    CLOCK: [2015-10-22 Thu 08:44]--[2015-10-22 Thu 08:50] =>  0:06
    CLOCK: [2015-10-21 Wed 17:51]--[2015-10-21 Wed 17:56] =>  0:05

Updates to sprint and product backlog.

*** COMPLETED Consider renaming module path to internal module path   :story:
    CLOSED: [2015-10-27 Tue 18:58]

Since we have got a external module path, it would make sense for the
other to be the internal module path. This may be taking the symmetry
too far, so we need to have a think.

*** COMPLETED Split "full" models from "partial" models               :story:
    CLOSED: [2015-10-31 Sat 22:04]
    CLOCK: [2015-10-31 Sat 17:47]--[2015-10-31 Sat 18:35] =>  0:48
    CLOCK: [2015-10-31 Sat 17:41]--[2015-10-31 Sat 17:46] =>  0:05
    CLOCK: [2015-10-31 Sat 17:15]--[2015-10-31 Sat 17:40] =>  0:25
    CLOCK: [2015-10-31 Sat 14:14]--[2015-10-31 Sat 16:15] =>  2:01
    CLOCK: [2015-10-31 Sat 00:13]--[2015-10-31 Sat 00:33] =>  0:20
    CLOCK: [2015-10-30 Fri 23:11]--[2015-10-31 Sat 00:12] =>  1:01
    CLOCK: [2015-10-30 Fri 14:01]--[2015-10-30 Fri 16:00] =>  1:59
    CLOCK: [2015-10-27 Tue 22:43]--[2015-10-27 Tue 23:30] =>  0:47
    CLOCK: [2015-10-27 Tue 22:11]--[2015-10-27 Tue 22:42] =>  0:31
    CLOCK: [2015-10-27 Tue 19:09]--[2015-10-27 Tue 19:22] =>  0:13
    CLOCK: [2015-10-27 Tue 18:33]--[2015-10-27 Tue 19:00] =>  0:27

This story is a new take on an old idea covered in [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_70.org#split-a-fully-formed-model-from-partial-models][sprint 70]]. For a
ideas on naming etc see that story. However this time round we will
just concern ourselves with the top-level model type rather than the
name look-ups etc. We just want to have two distinct types:

- full model: the model that is outputted from the SML workflow
- partial model: model obtained from the importers.

Tasks:

- create and element base class.
- create a model with a single hash map of element.
- rename existing model to =partial_model=.
- update =cpp= to use new model.

Notes:

- create a full yarn workflow that takes a list of resource locations
  and produces a final model. This is the current front end to middle
  end workflow, minus the input description generation - this stays in
  knit - plus the assembly work.
- input descriptor: resource location (locator? see URL).
- file importer: frontend; produces an intermediate model.
- importer: frontend workflow; produces a list of intermediate moddels.
- file importer registrar: frontend registrar.
- nested name: instantiated type? instantiated name? children:
  parameters, type parameters. type: name. is pointer: instance type,
  kind?  enumeration of pointer, reference, stack.

*** COMPLETED Frontend model refactor                                 :story:
    CLOSED: [2015-11-02 Mon 21:15]
    CLOCK: [2015-11-02 Mon 21:01]--[2015-11-02 Mon 21:13] =>  0:12
    CLOCK: [2015-10-31 Sat 22:59]--[2015-11-01 Sun 00:04] =>  1:05
    CLOCK: [2015-10-31 Sat 22:37]--[2015-10-31 Sat 22:59] =>  0:22

*New understanding*:

Actually, we can't call it a frontend model because it is not specific
to just frontend processes; we still need this representation for the
assembly workflow or else we will have to sort objects by type etc.

*Previous Understanding*

Incredibly enough we still didn't get the models in the right shape
after the full/partial refactor. The correct shape is:

- create frontend model. This is used only by the frontends and the
  merger. Ensure it has a single element collection, keyed by
  qualified ID (string).
- merger takes a frontend model and generates a model. All other
  processes in yarn work off of this model.

*** COMPLETED Improve references management                           :story:
    CLOSED: [2015-11-05 Thu 23:05]
    CLOCK: [2015-11-05 Thu 22:03]--[2015-11-05 Thu 23:05] =>  1:02

At present, we compute model references as follows:

- in dia to sml we first loop through all types and figure out the
  distinct model names. This is done by creating a "shallow" qname
  with just the model name and setting its origin type to unknown.
- when we merge, we take the references of target - the only ones we
  care about - and then we check that against the list of the models
  we are about to merge. If there are any missing models we complain
  (see comments below). We then loop through the list of references
  and "resolve" the origin type of the model.

Note: We could actually also complain if there are too many models, or
more cleverly avoid merging those models which are not required. Or
even more cleverly, we could avoid loading them in the first place, if
only we could load target first.

A slightly better way of doing this would be:

- in SML create a references updater that takes a model and computes
  its reference requirements. It could also receive a list of "other"
  models from which to get their origin types to avoid using =unknown=
  at all, and checks that all reference requirements have been met.
- the current step =update_references= is just a call to the
  references updater, prior to merging, with the target model.

Note:

It seems that the references are incorrect at present; on rebuild, we
see serialisation's registrar moving for no reason:

: -    dogen::config::register_types(ar);
:      dogen::sml::register_types(ar);
: -    dogen::dynamic::schema::register_types(ar);
: +    dogen::config::register_types(ar);

The references have not changed at all in the dogen invocation:

:    --reference ${CMAKE_SOURCE_DIR}/diagrams/config.dia,dogen
:    --reference ${CMAKE_SOURCE_DIR}/diagrams/sml.dia,dogen
:    --reference ${CMAKE_SOURCE_DIR}/diagrams/formatters.dia,dogen
:    --reference ${CMAKE_SOURCE_DIR}/diagrams/schema.dia,dogen::dynamic

We need to fix this with the refactor.

*** COMPLETED Move property type generation to expander               :story:
    CLOSED: [2015-11-06 Fri 22:29]
    CLOCK: [2015-11-06 Fri 21:38]--[2015-11-06 Fri 22:28] =>  0:50

- add unparsed name to nested name.
- update frontends to read the unparsed name and not expand it.
- create a "property expander" that parses the unparsed name and
  expands it to a proper nested name.

*** COMPLETED Yarn refactor around partial model construction         :story:
    CLOSED: [2015-11-06 Fri 22:51]
    CLOCK: [2015-11-06 Fri 22:30]--[2015-11-06 Fri 22:51] =>  0:21
    CLOCK: [2015-11-02 Mon 17:01]--[2015-11-02 Mon 18:16] =>  1:15
    CLOCK: [2015-10-21 Wed 20:50]--[2015-10-21 Wed 21:38] =>  0:48

There are a number of activities done in the frontends which really
belong to the main meta-model. We should create a single workflow for
"post-processing" with these activities and move them away from the
importers.

Notes:

- add a module post processor that computes owner (containing
  module?), members, is top level. Seems like we already have a
  top-level module: containing module is null.
- reference expander to compute references.
- add some enumeration post-processing that assigns it a underlying
  type. Should be done with merged model (look for a primitive type with
  property =is_default_enumeration_type=).

*** STARTED Compute qualified name                                    :story:
    CLOCK: [2015-11-06 Fri 23:21]--[2015-11-06 Fri 23:53] =>  0:32
    CLOCK: [2015-11-06 Fri 22:52]--[2015-11-06 Fri 23:20] =>  0:28
    CLOCK: [2015-11-06 Fri 21:21]--[2015-11-06 Fri 21:38] =>  0:17
    CLOCK: [2015-11-04 Wed 21:24]--[2015-11-04 Wed 22:07] =>  0:43
    CLOCK: [2015-11-03 Tue 22:28]--[2015-11-04 Wed 00:07] =>  1:39
    CLOCK: [2015-11-03 Tue 21:01]--[2015-11-03 Tue 22:27] =>  1:26
    CLOCK: [2015-11-02 Mon 21:36]--[2015-11-02 Mon 23:02] =>  1:26

We added qualified name to name but never populated it. This is also a
good time to clean up the usage of name as a hash. We could use
qualified name as the key for all of the containers in intermediate
model. The resolve then has to compute the possible qualified names:

- use the properties of the owning type to create the fully qualified
  name, including internal module path - trying all values of internal
  module path;
- use every model's properties to create qualified names, starting
  with target then references.

This is all made much easier by having a single container of
element. In fact, at present, we do not have any use cases for
multiple containers by type.

Notes:

- all names must be constructed via the name builder.
- model names appear to be different from all other names in that the
  simple name and module path have the model name. It may make more
  sense to have the model name empty. However, do we even need this at
  all? The model name is useful for references.
- we should not update references inside the transformer. It is not
  possible to tell if something is a reference to a model or to a
  model's module, e.g. =yarn::dia= is this the model =yarn.dia= or a
  =dia= module inside of the model =yarn=? The resolver can handle
  this. This wasn't a problem before because we relied on top-level
  modules to determine if a reference was to a module in current model
  or to another model.
- FIXME: we broke serialisation registrar with merger change - need to
  see how qualified name impacts this.
- internal module path -> must be current model
- model path -> must be reference

*** STARTED Create a "final model" class                              :story:
    CLOCK: [2015-11-02 Mon 21:24]--[2015-11-02 Mon 21:35] =>  0:11
    CLOCK: [2015-11-02 Mon 21:17]--[2015-11-02 Mon 21:23] =>  0:06
    CLOCK: [2015-11-02 Mon 21:14]--[2015-11-02 Mon 21:16] =>  0:02

We should create a model that has a single container of elements
rather than elements by type.

*** STARTED Model should not be an element                            :story:
    CLOCK: [2015-10-27 Tue 08:22]--[2015-10-27 Tue 08:40] =>  0:18

We need to move all functionality from the model into the model module
such that the model no longer needs to be an element (documentation,
etc). It can remain as a nameable.

- keep the concepts; they are still telling the truth.

*** STARTED Rename nested qname to composite qname                    :story:
    CLOCK: [2015-10-22 Thu 08:10]--[2015-10-22 Thu 08:43] =>  0:33

*New understanding*:

This story requires further analysis. Blindly following the composite
pattern was tried but it resulted in a lot of inconsistencies because
we then had to follow MEC-33 and create =abstract_qname=; however, the
nested qname does not really behave like a composite qname; its more
like the difference between a type in isolation and a type
instantiated as an argument of a function. For example, whilst the
type in isolation may have unknown template parameters, presumably, as
an argument of a function these have been instantiated with real
types.

One way to solve this is just to make the type name a bit more
explicit rather than try to imply the composite pattern
(e.g. "nested"). We need a name that signifies "instantiated
type". Look at the C++ standard for the difference between defining a
generic type and instantiating a generic type.

No good names yet (type reference, type instantiation, instantiated
name). What are we trying to represent: an identifier which points to
a complete definition of a name such that the name can be instantiated
as a type in the underlying language. By "instantiated" we mean used
to define variables of this type. In this light: instantiable name,
definable name? If we choose instantiable name, we could then rename
"children" to type arguments.

*Previous understanding*:

We should just follow the composite pattern in the naming.

*** Refactor code around model origination                            :story:

- remove origin types and generation types, replacing it with just a
  boolean for is target.
- at present we are using origin type to determine whether to create a
  registrar, etc in cpp model. There is no other use case for
  this. This is done in several places due to the bad handling of C++
  specific types. Grep for =references= in =cpp= to find all
  locations.
- we should also replace has generatable types with something more
  like "target model has types" or "is target model empty". The idea
  we are trying to capture is that the target model contained at least
  one type. This could be set by the merger when it processes the
  target model.

*Previous Understanding*

In the past we added a number of knobs around generation, all with
their own problems:

- =origin_types=: was the model/type created by the user or the
  system. in reality this means did the model come from Dia or
  JSON. this is confusing as the user can also add JSON files (their
  own model library) and in the future the user can use JSON
  exclusively without needed Dia at all.

- =generation_types=: if the model is target, all types are to be
  generated /unless/ they are not properly supported, in which case
  they are to be "partially" generated (as is the case with
  services). This is a formatter decision and SML should not know
  anything about it.

These can be replaced by a single enumeration that indicates if the
type/model is target or not.

This work should be integrated with the model types story.

*** Filter out unused types from final model                          :story:

When we finished assembling the model we should be able to determine
which supporting types are in use and drop those that are not. This
can be done just before building the final model (or as part of that
task).

We should have a class responsible for removing all types from a model
which are not in use. This could be done as part of model assembly.

One way this could be achieved is by adding a "usages" property,
computed during resolution. Resolver could keep track of the
non-target names that are in use and return those.

*** STARTED Update copyright notices                                  :story:

We need to update all notices to reflect personal ownership until DDC
was formed, and then ownership by DDC.

- first update to personal ownership has been done, but we need to
  test if multiple copyright entries is properly supported.

*** Handle enumeration type dynamically                               :story:

- add some enumeration post-processing that assigns it a underlying
  type. Should be done with merged model (look for a primitive type with
  property =is_default_enumeration_type=).

*** Copyright holders is scalar when it should be an array            :story:

At present its only possible to specify a single copyright holder. It
should be handled the same was as odb parameters, but because that is
done with a massive hack, we are not going to extend the hack to
copyright holders.

*** Add support for composite model names in name                     :story:

Split qname into name and location; location is made up of model name,
external module path, model path, internal module path.

Notes:

- populate model path as module name by default unless supplied by
  field.
- deal with the fallout in terms of file paths creation, etc.
- fix hardware model to supply model name but to have a blank model
  path.
- split model names with dots into multiple model paths.
- do not populate model path and qualified until resolution is done -
  these properties do not add any value. After resolution - perhaps
  as a last pass of the resolver - go through every single qname and
  compute these properties. This means that all calls to qualified
  prior to this need to be replaced to direct calls to qualified name
  builder.

More notes:

- within a partial model, there are two stages of processing: an
  initial pass in which we can identify all of the names of the
  elements declared in a model; and a second pass in which we can
  resolve all properties that belong to that model. By "resolve" we
  mean we can figure out if a property is referring to an element in a
  module inside the model or if its referring to an element in a
  different model. This can only be done when we have all the names of
  all the modules in the model.
- there is such a thing as a location: an object which allows one to
  figure out where a type is located in an imaginary "element
  space". In addition to the location, the element space has another
  dimension, given by the element "simple" name (from now on just
  name). The pair =(location, name)= corresponds to a unique point in
  the element space.
- there is such a thing as a unique element identifier: it is a string
  representation of the pair =(location, name)= according to a
  well-defined syntax.
- the pair =(location, name)= is an element identifier, because it
  uniquely identifies elements in the element space.
- the external module path is required to allow us to represent
  external containment; that is, cases where the model is contained in
  one or more namespaces, but we do not want to represent these inside
  the model.
- the internal module path is required to allow us to represent
  internal containment; that is, the element is contained in one or
  more modules, represented in the model.
- the model path represents containment inferred from the model name
  itself; that is, a composite model name such as =a.b.c=.
- the model name does not always contribute to the model path. For
  models such as hardware, the model has to have a name (it cannot be
  in a nameless file) but the types are in the global space. This
  means that we need to switch on/off the ability to have the model
  name contribute to the model namespace.
- model names are only relevant initially. We could store them in
  model class, but they will be thrown away during merging.
- references are used for several purposes: a) to determine that we
  have loaded all required models. b) to generate code dependencies
  against dependent models: at present just linking and registrar in
  serialisation. In order to figure out what to do with the reference
  we need to know its "kind". For dogen models, we need to generate
  registrars; for non-dogen models we do not. We always need to
  link. At present this is done via the origin types property. A
  better way of modeling this may be "is dogen model" or something
  along these lines.
- one model may have more than one set of link instructions. These are
  more related to the types than with the model itself. For example,
  in boost we need to link potentially against multiple
  libraries. This could be modeled by a dynamic property at the type
  level or model level. For dogen models it would be model level. The
  property may be empty (hardware, std).
- from a element identifier it is not possible to determine its model
  name. It may or may not be reconstructible from the model
  path. However, if one were to have a map of location to model name,
  one could at least figure out if the type is on any of the loaded
  models. We could keep track of all locations which are not within
  the model. Those must match the referenced models or else there is a
  type resolution failure.
- there is such a thing as a element instance identifier. We call it
  nested name at present. The element instance identifier identifies
  instantiations of types. It models two cases: for the case where the
  type has no type parameters, the instance identifier is equal to the
  element identifier; for all other cases, it is a hierarchical
  collection of element identifiers, modeling the type parameter
  structure.
- a model should have: an element identifier which is identical to the
  root module (the module that represents the model). A model is
  itself an element.

 a location; a name (meaning the original,
  possibly composite, model name); a

the
  types pace is hierarchical: its made up of the global namespace at
  the top (where types in the hardware model live), and then followed
  by all other namespaces "declared" at the top-level.
- there are four distinct cases of locations in the type space

Merged stories:

*Consider renaming qname*

As part of dynamic we came up with a better way of modeling names:
type is name, fields:

- simple
- qualified

This is a better way of modeling, as opposed to the SML way with a
=qname= which then contains a =simple_name=. We should use this
approach in SML to.

*Split model name from "contributing model name" in qname*

We need to find a way to model qnames such that there are two model
names: one which contributes to the namespaces and another which
doesn't. The specific use case is the primitives model where the model
has to have a name but we don't want the type names to have the model
name. Perhaps we need some kind of flag: model name contributes to
namespacing.

With this we can then remove the numerous hacks around the primitives
model name such as:

- // FIXME: mega hack to handle primitive model.

See comment in 'dot' story - we can have a model name and a model
package.

*** Remove primitive model handling in yarn dia transformer           :story:

We seem to be doing some handling for primitives which is no longer
required. The handling of current model is also very dodgy. All in
transformer's update model reference.

Actually this is nothing at all to do with the primitive model but all
to do with computing the correct name. We need to start using the
builder here.

*** Add =operator<= for names                                         :story:

We seem to redefine this all over the place. Create a utility class
somewhere.

*** Services and leaves are not properly handled                      :story:

We are manually ignoring services when calculating leaves.

*** Add support for model names with dots                             :story:

It is quite annoying to have to create folders and sub-folders for the
main projects. This is not too bad right now because we don't really
make use of nesting that much, other than with test models. However,
now that the architecture is clear and we need to make use of nesting,
it becomes more of a concern. For example:

: / a
:   / b
:   / c
: / d
:   / e
:   / f

This is clearer as:

: / a
: / a.b
: / a.c
: / d.e
: / d.f

However, in order to implement this we need a bit of cleverness:

- for the purposes of files, the dot represents a dot;
- for the purposes of namespaces, we must create several namespaces
  (e.g. yarn::core).

This is also inline with the idea that the model name does not always
contribute to the namespaces as required by primitives. We basically
need a cleverer version of qname to handle all of these scenarios.

It may also be worth taking into account the other story on this topic
where we considered using underscores instead of folders for facet
names. It may be nicer to have dots for this,
e.g. =types.my_class.hpp=.

Idea:

=qnames= should have a model name and a model package; only the model
package contributes to the namespaces. The model name is unpacked into
multiple model packages (e.g. "a.b" => a::b). The file name uses the
model name, not the model package.

*** Use dots in data files extensions                                 :story:

At the moment we use extensions such as =xmlyarn=. It should really be
=.xml.yarn= or something of the kind.

*** Refactor ownership hierarchy                                      :story:

Start implementing the archetype logic. Basically there is a artefact
unique identifier

- rename it to =artefact_descriptor=.
- remove all dia fields; these are now file importer specific and
  never reach dynamic.
- add =kernel= field. This is set to =stitch= or =quilt=.
- rename formatter field to =kind=

Merged stories:

*Consider adding "application" to ownership hierarchy*

Not all fields make sense to all tools in the dogen suite; some are
knit specific, some are stitch specific and some are shared. At
present this is not a problem because stitch loads up all of knit's
fields and assumes users won't make use of them. If they do, nothing
bad "should" happen. But a better way to solve this may be to only
load fields that belong to an application. We could add "application"
to ownership hierarchy, and filter on that. Note though that we would
need some way of saying "all applications" (e.g. at present, leave the
field blank).

*Consider renaming =ownership_hierarchy=*

We came up with the name =ownership_hierarchy= because we could not
think of anything else. However, it is not a particularly good name,
and it is increasingly so now that we need to use it across models. We
need a better name for this value type.

This work must be integrated with the [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_69.org#thoughts-on-cpp-refactoring][archetype work]].

*Split knitting from stitching settings*

*Rationale*: with "kernel" we will have quilt and stitch.

At present we only have a single common directory with all of the
available fields. Not all fields apply to both stitching and
knitting - but some do. We need a way to filter these. One possibility
is to use an approach similar to the formatter groups in the ownership
hierarchy. For now we simply have fields that have no meaning in
stitching but can be supplied by users.

*** Split formatter properties and associated classes from formattables :story:

We have two kinds of data: the formattables themselves (mapped from
yarn) and associated data (formatter properties). The latter is
totally independent. We should create a namespace for all of these
classes and a workflow that produces the data ready for consumption. A
tentative name is =manifest=.

*** Consider renaming includers                                       :story:

Its very confusing to have header files that include lots of other
header files called "includers". There is too much overloading. We
should consider calling them "master header files" as per Schaling
terminology in the [[http://theboostcpplibraries.com/boost.spirit][boost book]].

*** Replace qname with id's in yarn                                   :story:

*New Understanding*

This is a new spin on that old chestnut of splitting partial models
from full models. We probably got enough to do this. The

*Previous Understanding*

We don't really need qname in it's current form for the purposes of
yarn. We should:

- create a base class for all types in model called element.
- add a property called id to element. Compute id on the basis of
  hashing name and location. Change all model containers,
  relationships etc to use id instead of qname.

*** Rename types in =yarn= using MOF/eCore terms                      :story:

Rename the types in =yarn= to make them a bit more inline with
MOF/eCore. As much as possible but without going overboard. Ensure we
do not pick up meta-meta-model concepts by mistake. Rename nested
qname to something more sensible from MOF/eCore. Review all concept
names in this light.

*** Create a set of definitions for tagging and meta-data             :story:

We still use these terms frequently. We should define them in dynamic
to have specific meanings.

*** Rename yarn's object                                              :story:

We start off by trying to follow the DDD naming but that has now been
changed in favour of more traditional meta-model names. In this sense,
object is not a good name as it evokes M0 rather than M1 or
higher. Perhaps =structure=?

** Deprecated
