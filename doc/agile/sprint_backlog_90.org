#+title: Sprint Backlog 90
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) }

* Mission Statement

- refactor dyamic and implement profiles
- fix services
- implement wale templates

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2016-10-14 Fri 21:36]
| <75>                                                                        |         |       |       |       |
| Headline                                                                    | Time    |       |       |     % |
|-----------------------------------------------------------------------------+---------+-------+-------+-------|
| *Total time*                                                                | *40:53* |       |       | 100.0 |
|-----------------------------------------------------------------------------+---------+-------+-------+-------|
| Stories                                                                     | 40:53   |       |       | 100.0 |
| Active                                                                      |         | 40:53 |       | 100.0 |
| STARTED Sprint and product backlog grooming                                 |         |       |  0:22 |   0.9 |
| COMPLETED Edit release notes for previous sprint                            |         |       |  0:19 |   0.8 |
| COMPLETED Improve bintray support                                           |         |       |  0:26 |   1.1 |
| COMPLETED Refactor opaque infrastructure                                    |         |       |  1:17 |   3.1 |
| COMPLETED Remove any remnants of annotations from quilt                     |         |       |  0:05 |   0.2 |
| COMPLETED Solve the issue of too many "configurations"                      |         |       |  4:01 |   9.8 |
| COMPLETED Merge decoration configuration and annotations factories          |         |       |  0:18 |   0.7 |
| COMPLETED Move annotation factories into expander in yarn                   |         |       |  1:11 |   2.9 |
| COMPLETED Clean up terminology in dynamic                                   |         |       | 15:12 |  37.2 |
| COMPLETED Minor tidy-up of the quilt.cpp diagram                            |         |       |  0:29 |   1.2 |
| COMPLETED Create a ownership hierarchy repository                           |         |       |  1:43 |   4.2 |
| COMPLETED Use vector of elements in model                                   |         |       |  0:10 |   0.4 |
| COMPLETED Rewrite profile support                                           |         |       | 11:50 |  28.9 |
| COMPLETED Merge annotation type and profile folders                         |         |       |  0:20 |   0.8 |
| COMPLETED Push stereotypes processing into yarn                             |         |       |  1:51 |   4.5 |
| COMPLETED Implement defaulting within the profiler                          |         |       |  1:13 |   3.0 |
| STARTED Finish overwriting support                                          |         |       |  0:06 |   0.2 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-10-10 Mon 08:40]--[2016-10-10 Mon 09:02] =>  0:22

Updates to sprint and product backlog.

*** COMPLETED Edit release notes for previous sprint                  :story:
    CLOSED: [2016-10-10 Mon 09:34]
    CLOCK: [2016-10-10 Mon 09:35]--[2016-10-10 Mon 09:48] =>  0:13
    CLOCK: [2016-10-10 Mon 09:28]--[2016-10-10 Mon 09:34] =>  0:06

Add github release notes for v88.

Title: Dogen v0.89.0, "Cubal"

#+begin_src markdown
Overview
========
The refactorings continue, mainly focusing on the ```quilt.cpp``` model but with changes all over the code base. The only user visible change is:

- improvement on visitor inclusions for descendants.

For more details see the [sprint log](https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_89.org).
#+end_src

*** COMPLETED Improve bintray support                                 :story:
    CLOSED: [2016-10-10 Mon 09:46]
    CLOCK: [2016-10-10 Mon 09:02]--[2016-10-10 Mon 09:28] =>  0:26

As with every end of sprint, try to massage bintray a bit more and see
if we can fix some of the errors of the previous sprint.

*** COMPLETED Refactor opaque infrastructure                          :story:
    CLOSED: [2016-10-10 Mon 11:06]
    CLOCK: [2016-10-10 Mon 11:00]--[2016-10-10 Mon 11:06] =>  0:06
    CLOCK: [2016-10-10 Mon 09:48]--[2016-10-10 Mon 10:59] =>  1:11

We seem to have created a mini-cottage-industry around opaqueness. The
original idea was to provide some infrastructure for formatters to
have their own settings in a way that is transparent to quilt.cpp. In
practice:

- we just have the odb formatter using them and it doesn't require
  opacity (any more than any other formatter does). We just need to
  ensure this configuration is not mandatory.
- we are not sure this will really work for other formatters; we may
  have hacked things for the odb formatter.

We should wait for a proper external use case of this
functionality. In the mean time, get rid of all of this paraphernalia
and implement this just like we do all other formatters.

Tasks:

- create odb configuration and odb expander.
- remove all opaque stuff.

*Previous understanding*

In addition we need to move all the other code (registrar, etc) into
formattables.

*** COMPLETED Remove any remnants of annotations from quilt           :story:
    CLOSED: [2016-10-10 Mon 11:10]
    CLOCK: [2016-10-10 Mon 11:07]--[2016-10-10 Mon 11:12] =>  0:05

Grep the project for anyone still using this term and remove it.

*** COMPLETED Rename properties to attributes in opaque configuration :story:
    CLOSED: [2016-10-10 Mon 11:19]

This was missed in rename.

*** COMPLETED Solve the issue of too many "configurations"            :story:
    CLOSED: [2016-10-10 Mon 21:37]
    CLOCK: [2016-10-10 Mon 20:51]--[2016-10-10 Mon 21:36] =>  0:45
    CLOCK: [2016-10-10 Mon 20:23]--[2016-10-10 Mon 20:50] =>  0:27
    CLOCK: [2016-10-10 Mon 19:50]--[2016-10-10 Mon 20:22] =>  0:32
    CLOCK: [2016-10-10 Mon 13:16]--[2016-10-10 Mon 13:32] =>  0:16
    CLOCK: [2016-10-10 Mon 12:43]--[2016-10-10 Mon 13:15] =>  0:32
    CLOCK: [2016-10-10 Mon 12:21]--[2016-10-10 Mon 12:42] =>  0:19
    CLOCK: [2016-10-10 Mon 12:01]--[2016-10-10 Mon 12:20] =>  0:19
    CLOCK: [2016-10-10 Mon 11:11]--[2016-10-10 Mon 12:00] =>  0:49

We need a name for the "transient" configuration which is used inside
factories and expanders to generate the "main" configuration. This is
a common problem in quilt.cpp which we chose to ignore, but needs to
be addressed as it is confusing to have so many classes with the
postfix "configuration".

One possible setup:

- properties: data that is inferred from yarn and augmented in
  formatter space. It is a "property" of the original data.
- configuration: data used by the expander/factory internally in order
  to do its work. It may come from meta-data/annotations, but it may
  also come from other sources.

With these definitions the ubiquitous language becomes clear for all
four related terms: properties, configuration, attributes and
annotations.

Tasks:

- rename all classes using configuration that should be using
  properties.

*** COMPLETED Merge decoration configuration and annotations factories :story:
    CLOSED: [2016-10-10 Mon 21:56]
    CLOCK: [2016-10-10 Mon 21:37]--[2016-10-10 Mon 21:55] =>  0:18

As with quilt, get rid of the separation between annotations and
configuration.

*** COMPLETED Move annotation factories into expander in yarn         :story:
    CLOSED: [2016-10-10 Mon 23:12]
    CLOCK: [2016-10-10 Mon 22:43]--[2016-10-10 Mon 23:12] =>  0:29
    CLOCK: [2016-10-10 Mon 22:33]--[2016-10-10 Mon 22:42] =>  0:09
    CLOCK: [2016-10-10 Mon 22:18]--[2016-10-10 Mon 22:32] =>  0:14
    CLOCK: [2016-10-10 Mon 21:58]--[2016-10-10 Mon 22:17] =>  0:19

There were a couple of instances left out in the configuration
refactor, in yarn.

*** COMPLETED Clean up terminology in dynamic                         :story:
    CLOSED: [2016-10-12 Wed 12:04]
    CLOCK: [2016-10-12 Wed 12:30]--[2016-10-12 Wed 12:35] =>  0:05
    CLOCK: [2016-10-12 Wed 12:01]--[2016-10-12 Wed 12:04] =>  0:03
    CLOCK: [2016-10-12 Wed 11:30]--[2016-10-12 Wed 12:00] =>  0:30
    CLOCK: [2016-10-12 Wed 10:39]--[2016-10-12 Wed 11:09] =>  0:30
    CLOCK: [2016-10-12 Wed 10:29]--[2016-10-12 Wed 10:38] =>  0:09
    CLOCK: [2016-10-12 Wed 10:19]--[2016-10-12 Wed 10:28] =>  0:09
    CLOCK: [2016-10-12 Wed 10:14]--[2016-10-12 Wed 10:18] =>  0:04
    CLOCK: [2016-10-12 Wed 09:53]--[2016-10-12 Wed 10:13] =>  0:20
    CLOCK: [2016-10-12 Wed 09:46]--[2016-10-12 Wed 09:52] =>  0:06
    CLOCK: [2016-10-12 Wed 09:39]--[2016-10-12 Wed 09:45] =>  0:06
    CLOCK: [2016-10-12 Wed 09:21]--[2016-10-12 Wed 09:38] =>  0:17
    CLOCK: [2016-10-12 Wed 08:20]--[2016-10-12 Wed 09:20] =>  1:00
    CLOCK: [2016-10-11 Tue 23:48]--[2016-10-12 Wed 00:30] =>  0:42
    CLOCK: [2016-10-11 Tue 22:38]--[2016-10-11 Tue 23:47] =>  1:09
    CLOCK: [2016-10-11 Tue 22:29]--[2016-10-11 Tue 22:37] =>  0:08
    CLOCK: [2016-10-11 Tue 20:44]--[2016-10-11 Tue 22:28] =>  1:44
    CLOCK: [2016-10-11 Tue 19:45]--[2016-10-11 Tue 20:43] =>  0:58
    CLOCK: [2016-10-11 Tue 17:06]--[2016-10-11 Tue 17:13] =>  0:07
    CLOCK: [2016-10-11 Tue 17:04]--[2016-10-11 Tue 17:05] =>  0:01
    CLOCK: [2016-10-11 Tue 16:49]--[2016-10-11 Tue 17:03] =>  0:14
    CLOCK: [2016-10-11 Tue 15:52]--[2016-10-11 Tue 16:48] =>  0:56
    CLOCK: [2016-10-11 Tue 15:31]--[2016-10-11 Tue 15:51] =>  0:20
    CLOCK: [2016-10-11 Tue 15:05]--[2016-10-11 Tue 15:30] =>  0:25
    CLOCK: [2016-10-11 Tue 14:40]--[2016-10-11 Tue 14:42] =>  0:02
    CLOCK: [2016-10-11 Tue 14:31]--[2016-10-11 Tue 14:39] =>  0:08
    CLOCK: [2016-10-11 Tue 13:39]--[2016-10-11 Tue 14:30] =>  0:51
    CLOCK: [2016-10-11 Tue 12:58]--[2016-10-11 Tue 13:38] =>  0:40
    CLOCK: [2016-10-11 Tue 12:45]--[2016-10-11 Tue 12:57] =>  0:12
    CLOCK: [2016-10-11 Tue 09:30]--[2016-10-11 Tue 12:44] =>  3:14
    CLOCK: [2016-10-10 Mon 21:56]--[2016-10-10 Mon 21:58] =>  0:02

We have to do a number of renames to make space for profilers:

- rename object aggregates to something slightly more sensible as it
  clashes with previous uses of the term aggregation in dynamic.
- rename property scope type to attribute in dynamic
- rename fields to field_definitions in data;
- rename definition types to instantiation types;
- hydration workflow is field definition factory
- json hydrator is field definition hydrator
- repository is field definition repository
- repository factory should be merged into field definition factory
- repository selector is field definition selector

Actually this rename is a bit more profound than we originally
anticipated. The objective of dynamic is to provide a way to annotate
objects in yarn (well, anywhere in theory). Interpreting some
[[https://en.wikipedia.org/wiki/Text_annotation][annotation terminology]] fairly liberally we have:

Done:

- dynamic -> annotations
- fields folder renamed to annotations. Note: it is annotations and
  not annotation_types because we will also store profiles
  here. However, we will need a way to figure out which ones are
  profiles and which are annotation types. Perhaps the extension could
  become =annotation_types.json=.
- raw aggregate: scribbles, scribble group?
- object aggregate: annotation group (and top level container
  annotation groups). In annotation group we have parent and
  children. Also add a flag for is master/root.
- object -> annotation. The marker for the annotation is the linkage
  between the annotation and the yarn element it annotates. Fields
  become the body of the annotation.
- workflow: annotation groups factory. Takes in scribble groups.
- field instance -> merge this with value; there is no reason to have
  two classes. We need to look at the factories and see if we can
  merge them together.
- repository ->  type_repository
- json_hydrator -> type_hydrator
- repository workflow: merge repository factory, repository workflow,
  hydration workflow into a type repository factory.
- field instance definition -> entry type.
- field definition -> split into type and type template. JSON file can
  contain both. Add some kind of meta-data to figure out the type.
- field definition types: template types
- scopes: remove unused scopes. Rest of the scopes should be root,
  top-level, child (avoid references to yarn concepts). All in use.

Large renames:

- field definition -> type
- repository -> type repository
- repository selector -> type repository selector
- workflow -> type repository workflow

Sound on compilations:

: && ogg123 -q  /usr/share/sounds/gnome/default/alerts/glass.ogg
: || ogg123 -q  /usr/share/sounds/gnome/default/alerts/drip.ogg

*** COMPLETED Minor tidy-up of the quilt.cpp diagram                  :story:
    CLOSED: [2016-10-13 Thu 11:20]
    CLOCK: [2016-10-13 Thu 10:40]--[2016-10-13 Thu 11:09] =>  0:29

We need to do a minor cosmetic tidy-up of diagram after all the
shuffling around we did on the previous sprint.

*** COMPLETED Create a ownership hierarchy repository                 :story:
    CLOSED: [2016-10-13 Thu 13:32]
    CLOCK: [2016-10-13 Thu 12:18]--[2016-10-13 Thu 13:32] =>  1:14
    CLOCK: [2016-10-13 Thu 11:33]--[2016-10-13 Thu 11:40] =>  0:07
    CLOCK: [2016-10-13 Thu 11:10]--[2016-10-13 Thu 11:32] =>  0:22

At present we are recomputing the available facets etc in a few
places. In reality we could just have a repository with all of these
queries pre-computed.

*** COMPLETED Use vector of elements in model                         :story:
    CLOSED: [2016-10-13 Thu 13:43]
    CLOCK: [2016-10-13 Thu 13:33]--[2016-10-13 Thu 13:43] =>  0:10

Since we already know the size of the model up front we should just
use a vector instead of a list.

After the change, performance did not move very much.

*** COMPLETED Rewrite profile support                                 :story:
    CLOSED: [2016-10-14 Fri 12:19]
    CLOCK: [2016-10-14 Fri 12:17]--[2016-10-14 Fri 12:19] =>  0:02
    CLOCK: [2016-10-14 Fri 11:53]--[2016-10-14 Fri 12:16] =>  0:23
    CLOCK: [2016-10-14 Fri 11:07]--[2016-10-14 Fri 11:53] =>  0:46
    CLOCK: [2016-10-14 Fri 09:16]--[2016-10-14 Fri 11:06] =>  1:50
    CLOCK: [2016-10-13 Thu 23:25]--[2016-10-13 Thu 23:50] =>  0:25
    CLOCK: [2016-10-13 Thu 22:45]--[2016-10-13 Thu 23:24] =>  0:39
    CLOCK: [2016-10-13 Thu 21:24]--[2016-10-13 Thu 22:44] =>  1:20
    CLOCK: [2016-10-13 Thu 20:29]--[2016-10-13 Thu 21:23] =>  0:54
    CLOCK: [2016-10-13 Thu 20:23]--[2016-10-13 Thu 20:28] =>  0:05
    CLOCK: [2016-10-13 Thu 20:08]--[2016-10-13 Thu 20:22] =>  0:14
    CLOCK: [2016-10-13 Thu 16:40]--[2016-10-13 Thu 17:16] =>  0:36
    CLOCK: [2016-10-13 Thu 14:43]--[2016-10-13 Thu 14:50] =>  0:07
    CLOCK: [2016-10-13 Thu 13:44]--[2016-10-13 Thu 14:42] =>  0:58
    CLOCK: [2016-10-13 Thu 09:38]--[2016-10-13 Thu 10:39] =>  1:01
    CLOCK: [2016-10-12 Wed 21:41]--[2016-10-12 Wed 22:31] =>  0:50
    CLOCK: [2016-10-12 Wed 20:43]--[2016-10-12 Wed 21:41] =>  0:58
    CLOCK: [2016-10-12 Wed 20:20]--[2016-10-12 Wed 20:42] =>  0:22
    CLOCK: [2016-10-12 Wed 12:35]--[2016-10-12 Wed 12:40] =>  0:05
    CLOCK: [2016-10-12 Wed 12:15]--[2016-10-12 Wed 12:30] =>  0:20

Our first stab at implementing profiles was a valiant effort but sadly
it was not the right approach. Profiles need to be implemented
directly into dynamic, and they must be totally transparent to the
layers above.

The profile structure is very similar to what we did in v1, but we
must implement it in terms of dynamic infrastructure:

- we need to make use of dynamic templates to expand facets and
  formatters, and to refer to instances;

Tasks:

- implement all of the new dynamic classes
- remove profiles in quilt.cpp and ensure the code works with the
  profile expansion. Update models to make use of global profiles.
- we need to supply a list of stereotypes to dynamic workflow, against
  the id's that have them. If we can find a profile with the
  stereotype name, apply it.

Notes:

- clean up names in knit workflow (repository, method name)
  - supply ownership hierarchy to yarn workflow and to pre-merge workflow;
- plug in profiler within annotation group factory.
- we are not enabling cmake in types+io etc profiles. We
  probably should. The names are becoming a bit large though.

*** COMPLETED Merge annotation type and profile folders               :story:
    CLOSED: [2016-10-14 Fri 12:41]
    CLOCK: [2016-10-14 Fri 12:40]--[2016-10-14 Fri 12:41] =>  0:01
    CLOCK: [2016-10-14 Fri 12:32]--[2016-10-14 Fri 12:40] =>  0:08
    CLOCK: [2016-10-14 Fri 12:20]--[2016-10-14 Fri 12:31] =>  0:11

At present we split "annotations" that is types from profiles. In
reality this is all annotation data.

Tasks:

- rename all files in annotations to annotations.types.*
  - rename all files in profiles to annotations.profiles.*
- merge all files under annotations
- change hydrators to look for files with the correct prefixes.

*** COMPLETED Push stereotypes processing into yarn                   :story:
    CLOSED: [2016-10-14 Fri 17:15]
    CLOCK: [2016-10-14 Fri 17:01]--[2016-10-14 Fri 17:14] =>  0:13
    CLOCK: [2016-10-14 Fri 15:26]--[2016-10-14 Fri 15:41] =>  0:15
    CLOCK: [2016-10-14 Fri 14:42]--[2016-10-14 Fri 15:25] =>  0:43
    CLOCK: [2016-10-14 Fri 14:10]--[2016-10-14 Fri 14:41] =>  0:31
    CLOCK: [2016-10-14 Fri 13:40]--[2016-10-14 Fri 13:49] =>  0:09

At present we have stereotypes as an enum, and the frontends are
responsible for resolving the stereotypes. This is not ideal:

- we assume unknown stereotypes are concepts;
- we map visitable to a flag to map it to a stereotype;
- we map fluent to a flag;
- we had to hack in the profile stereotype binding;
- the same work will have to be done in other frontends (e.g. JSON).

The right thing is:

- make stereotypes a string container;
- frontend simply populates the container and does no judgement;
- all stereotypes are put in the container, except those which are
  used to dispatch the yarn type;
- stereotypes expander figures out if the stereotype is one that is
  actionable within yarn (immutable, visitor, modeled concepts) or one
  to pass-through (binding stereotypes).
- during dynamic expansion, we supply a list of the remaining
  stereotypes against ids. If there is a match, they are used as
  profiles.

Merged stories:

*Link profiles to stereotypes*

Once we have profiles, we need to have a way to link them to
stereotypes. At present we only have two use cases:

- hand-crafted
- formatter

When we spot one of these, we should then automatically look for a
profile with this name. If found apply it locally.

*Previous Understanding*

An element can be marked with the stereotype of handcrafted. We then
have several things to determine for this element:

- which formatters are disabled due to handcraft mode (e.g. all facets
  other than types);
- which formatters are enabled, but should only generate if there
  isn't a file already in the file system (e.g. class header and class
  implementation in types)
- which formatters are enabled and should generate as usual
  (e.g. forward declarations in types).

We must also allow users to override these settings so that:

- they can disable the types facet if required;
- they can provide their own implementations for other facets;
- they can ask the code generator to generate one for them
  (serialisation, io).

Finally, for the common case, we do not want users to have to set lots
of meta-data; we need a sensible default behaviour.

Actually, from a purely functional perspective, what is handcrafting?
It is a shorthand for:

- disable a set of formatters;
- enable another set of formatters;
- for a subset of the enabled formatters, generate only if there is no
  file in the filesystem, otherwise do nothing;
- for another subset of the enabled formatters, generate as usual.
- do not add leaves to the registrar (unless asked to).

One can conceive the notion of an enablement profile. These can be
global or local. We can also have overwritting profiles. These can
only be local. A sub-set of the enabled formatters can be set to
overwrite=false. Examples:

- default enablement profile: "enable all". Enables all facets and
  formatters.
- types and a facet profiles: "types and serialisation", "types and
  io" etc.
- "types class only": generates class header and implementation.
- default overwrite profile: "overwrite all". Overwrites all
  artefacts.

Now handcrafting becomes much easier:

- add meta-data to quilt: a) a way of specifying profiles for
  overwriting and enabling b) a way of specifying if leaves contribute
  to registration or not.
- define a set of profiles in data for overwriting and enabling. Users
  can provide their own profile directories.
- Link the overwriting and enabling with stereotypes: given a
  stereotype, we could map to a default profile. Actually this is more
  of a profile group. We could then state that a stereotype maps to a
  profile group.

Note: we don't need to do leaf management:

#+begin_quote
- add a flag for leaf management. It defaults to true, unless
  handcrafted. Add meta-data to allow overriding flag (or create story
  for it as we don't yet have a use case).
#+end_quote

We just need to enable/disable serialisation and the code will work.

- add a stereotype of handcrafted with a default profile.

*** COMPLETED Implement defaulting within the profiler                :story:
    CLOSED: [2016-10-14 Fri 21:36]
    CLOCK: [2016-10-14 Fri 21:29]--[2016-10-14 Fri 21:36] =>  0:07
    CLOCK: [2016-10-14 Fri 20:59]--[2016-10-14 Fri 21:28] =>  0:29
    CLOCK: [2016-10-14 Fri 17:16]--[2016-10-14 Fri 17:39] =>  0:23
    CLOCK: [2016-10-14 Fri 13:56]--[2016-10-14 Fri 14:10] =>  0:14

We tried to do defaulting via the type's default value, but this is
not ideal as it defaults for all scopes. Ideally we need a root level
default, and no entity level defaults.

Tasks:

- remove scope types from profile
- remove default value from profile type
- create the notion of "scoped labels",
  e.g. "default.root_module". If no profile is supplied, look for the
  scope default. If none is found do nothing.
- allow users to supply labels. These are checked after profile field.

*** STARTED Finish overwriting support                                :story:
    CLOCK: [2016-10-14 Fri 13:49]--[2016-10-14 Fri 13:55] =>  0:06

With profiles we have all the pieces in place to support overwrites,
but there is some linkage missing:

- global/local configuration needs to have an overwrite flag;
- need to populate formatter configuration on the back of that;
- need to read flag from formatter configuration and set it on file.

*** Add binding of stereotypes with profiles                          :story:

During annotation expansion, we need to supply a list of the remaining
stereotypes against ids. If there is a match, they are used as
profiles.

*** Generate formatter interfaces                                      :epic:

We should create another template language, in addition to stitch:
"wale". Wale is a very simple language that has templates that just do
token replacement. The tokens must have a special format:
={{{TOKEN}}}=. We receive a map of keys to values and do a blind
replacement to the keys on the wale document.

This links to stitch as follows:

- create a single file implementation of a formatter. It will
  implement both the provider interface and the appropriate formatter
  interface. It will call the stitch method to start off with. There
  are no headers, just cpp. It does the formatter registration.
- add support in stitch for "named sections": its possible to start a
  section and assign it a name. A stitch template will have two
  sections: inclusion provision and formatting.
- add support in stitch for "wale variables". These are just kvp's
  defined at the top:

: <#@ wale.variable="formatter_name=abcd" #>

  wale variables and sections are converted into a kvp container for
  wale input. Examples: facet, formatter name, etc.
- convert the formatter code into a wale template, adding wale
  variables as required.
- update stitch to detect wale usage and to call wale in those
  cases. This could be done by supplying a wale template:

: <#@ wale.template="abcd.wale" #>

- note that wale could be useful outside of stitch, for example for
  dart: we could wale-lise utility and then instantiate it for a given
  project.

*Previous Understanding*

It should be possible to generate some trivial types such as formatter
interfaces, formatter container, registrar and so on. For this we
need:

- a mustache type template;
- a set of fields from yarn types to be exposed to mustache;
- a list of types to iterate through.

Once we got this we could instantiate the templates. To integrate this
with knit we would need some way of specifying which types the
iteration would be over. We could mark a specific type with a given
stereotype, and then supply say the base class ("all leaf descendants
of xyz"). Dogen would then locate the descendants and for each call
the template.

For registrar and container its a bit trickier because we want a
collection of types in one go.

We also need a way to keep these templates away from the main (user
visible) code, since they are useful only for dogen.

See also [[https://github.com/cierelabs/boostache/tree/develop][boostache]].

Notes:

- we will need some "special" tags for copyright, includes
  etc. Includes will be particularly special because we need to
  augment the include list with additional includes. However, we may
  not even need to be aware of this.

*Stitch meta-templates*

*Note*: re-read story [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_64.org#code-generating-formatters-as-text-templates][Code-generating formatters as text templates]] as
some of these ideas were already there. Also: see [[https://github.com/no1msd/mstch][mstch]].

In the quest for defining a single stitch template which then becomes
a formatter - without any additional infrastructure required at all -
we hit on an idea: stitch meta-templates. Basically we would have two
different kinds of inputs to stitch: the template itself and the
meta-template. Meta-template is a provisional name. The meta-template
would define the formatter layout:

- class definition, using a stitch variable for the yarn element type
- registration of the formatter
- definition of a method for the includes
- definition of a method for the stitching

These last two would result in the creation of "regions". These
regions must then be "instantiated" in the template. This could easily
be achieved with some kind of new element:

: <#% region "includes">

Or some such stitch construct. All lines after this line are part of
the region "includes" until a new region is defined. The region is
stitched and then transposed to the place in the meta-template where
it was defined, for example:

: int f(int a, int b) {
: <#% region "includes">
: }

Would result in copying across the region into these brackets. This
will make defining multiple functions very easy, without having to
supply command line arguments, etc.

Notes:

- meta-templates are supplied as command line arguments.
- potential extension: =meta.stitch=
- stitch should still work on non-meta-template mode.
- some of these ideas had already been covered on another story but
  can't find it in backlog. It could be part of the original stitch
  epic. We need to revisit it to see if it contains additional
  insights.
- when an error occurs, it would be great if we could pin point the
  error to the template or to the meta-template. This is more of a
  concern when we add clang compilation support.

Further thoughts:

- there are two approaches for this: we could integrate stitch tighter
  with knit and have it return "chunks" of processed code instead of
  files. As per story "Integration of stitch and dogen", dogen would
  then be responsible for writing the header file as per methods
  defined in the class diagram. Each method would be marked as a
  region. Meta-data in the class associates a template with the
  class. Knitter uses stitch to convert the template into regions, and
  then takes these regions and inserts them into a generated
  file. This approach is very clever and requires a lot of machinery.
- the easier approach uses meta-templates. Class diagram associates
  both meta-template and template with class via meta-data. We could
  possibly also have a stitch stereotype to make it clearer. Yarn has
  a stitch class with attributes of these parameters. Dogen
  instantiates stitch (probably within quilt) with the parameters and
  generates the file. Actually we probably can't have this in quilt
  because we still need formatter properties.

*** Fix transformer tests and hydrator tests                          :story:

A number of tests got disabled as part of the dynamic refactor. Fix
them.

*** Clean up annotations and configuration in stitch                  :story:

We deliberately skipped stitch on the clean up exercise for
configuration/annotations, so we could look at it when doing wale
templates.

*** Remove object types in yarn                                       :story:

We need to figure out if this enumeration is still in use and if not
what needs to be done to remove it.

*** Order of headers is hard-coded                                    :story:

In inclusion expander, we have hacked the sorting:

:        // FIXME: hacks for headers that must be last
:        const bool lhs_is_gregorian(
:            lhs.find_first_of(boost_serialization_gregorian) != npos);
:        const bool rhs_is_gregorian(
:            rhs.find_first_of(boost_serialization_gregorian) != npos);
:        if (lhs_is_gregorian && !rhs_is_gregorian)
:            return true;

This could be handled via meta-data, supplying some kind of flag (sort last?).

*** Registrar in quilt is not being generated                         :story:

We don't seem to change the contents of this file when regenerating.

*** Investigate helper generation in formattables                     :story:

We seem to be generating an helper for every node of every name tree,
regardless of whether the name needs a helper or not. Intuitively, we
should check the family and the streaming settings; if both of these
are empty then there should not be a need for a helper. But maybe
there is more to it.

*** Document the conceptual model                                     :story:

We seem to be pretty close to the end of the conceptual model for
dogen. We should write it up whilst its still fresh. We should try to
use mathematical notation where possible to practice it. We should
also get it reviewed.

*** Perform the archetype / artefact renames                          :story:

As per analysis story, we need to tidy-up terminology.

Renames:

- file: artefact
- file formatter: artefact formatter, artefact generator? factory?
- ownership_hierarchy: archetype_location, model_name becomes kernel,
  facet name becomes facet and formatter name archetype. Add
  sub-kernel.
- Element concept becomes Entity.

*** Refactor ownership hierarchy                                      :story:

Start implementing the archetype logic. Basically the ownership
hierarchy is an archetype address in archetype space. It should also
contain the type index for the underlying modeling type, since all
points in archetype space map to a point in modeling space. With this
we can now bucket addresses by type index in annotations' ownership
hierarchy repository, which means that the expanders using the
formatter container just for bucketing purposes can now rely on
annotations. However, a few actually need access to the formatters
(inclusion, canoncial formatter expander, etc).

- rename it to =artefact_descriptor=. Actually archetype address as it
  is a point (or set of points) in archetype space.
- remove all dia fields; these are now file importer specific and
  never reach dynamic.
- add =kernel= field. This is set to =stitch= or =quilt=.
- rename formatter field to =kind=

Merged stories:

*Consider adding "application" to ownership hierarchy*

Not all fields make sense to all tools in the dogen suite; some are
knit specific, some are stitch specific and some are shared. At
present this is not a problem because stitch loads up all of knit's
fields and assumes users won't make use of them. If they do, nothing
bad "should" happen. But a better way to solve this may be to only
load fields that belong to an application. We could add "application"
to ownership hierarchy, and filter on that. Note though that we would
need some way of saying "all applications" (e.g. at present, leave the
field blank).

*Consider renaming =ownership_hierarchy=*

We came up with the name =ownership_hierarchy= because we could not
think of anything else. However, it is not a particularly good name,
and it is increasingly so now that we need to use it across models. We
need a better name for this value type.

This work must be integrated with the [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_69.org#thoughts-on-cpp-refactoring][archetype work]].

*Split knitting from stitching settings*

*Rationale*: with "kernel" we will have quilt and stitch.

At present we only have a single common directory with all of the
available fields. Not all fields apply to both stitching and
knitting - but some do. We need a way to filter these. One possibility
is to use an approach similar to the formatter groups in the ownership
hierarchy. For now we simply have fields that have no meaning in
stitching but can be supplied by users.

*** Implement qualified name efficiently                              :story:

We should move qualified names to quilt. We can create a simple map of
id to qualified name and add that to the formattables model.

*Previous Understanding*

We used a =std::map= to store qualified names. In practice, we don't
need something this expensive.

- instead of mapping names to languages, we could map them to
  "styles". There are only a few "styles" across all programming
  languages (e.g. =.= separated, =::= separated and so on).
- we can also create an array of these styles. We know up front how
  many styles there are.
- finally we can create a enumeration to access the array. At present
  this is not possible because we cannot disable invalid, nor is it
  possible to move it to a different position (e.g. last). Also we
  will have to static cast the enum to access the int, which is not
  very pretty.

Once all of this is done we can simply do, at O(1):

: name.qualified[static_cast<unsigned int>(styles::double_colon_separated_style)]

We can prettify it a bit: [[http://stackoverflow.com/questions/8357240/how-to-automatically-convert-strongly-typed-enum-into-int][How to automatically convert strongly typed
enum into int?]]

: template <typename E>
: constexpr typename std::underlying_type<E>::type to_underlying(E e) {
:     return static_cast<typename std::underlying_type<E>::type>(e);
: }
:
: std::cout << foo(to_underlying(b::B2)) << std::endl;

Giving us:

: name.qualified[to_underlying(styles::double_colon_separated_style)]

*** Integration of stitch and dogen                                   :story:

Now that we have implemented stitch and proved it works (more or
less), we need to think how we can make using stitch from dogen
easier. At present there is not integration at all:

- users need to create regexes to ensure dogen does not trample on
  stitch files:

:    --ignore-files-matching-regex .*stitch
:    --ignore-files-matching-regex .*_stitch.hpp
:    --ignore-files-matching-regex .*_stitch.cpp

- users need to manually create a header file for each stitch
  template.
- users need to create stitch targets and run them to ensure the
  templates have been expanded. This means its possible to get dogen
  and stitch out of sync (but for now not a big problem).

In the ideal world, when we knit a model it would be nice if it could
also stitch as required. This could be achieved as follows:

- Create a meta-data tag that tells dogen a type has an associated
  stitch template with it.
- Create =cpp= types that represent the stitch header and
  implementation.
- Transformer needs to look for the meta-data tag and instantiate the
  =cpp= types.
- Create a =cpp= formatter for the header, as per regular
  formatters. The slight challenge here is that the formatter needs to
  be instantiable across facets, which we do not support at the
  moment.
- Create a cpp formatter for the implementation which instantiates
  stitch with the template and uses it to create a file. Same
  challenge as with the header.

*Previous Understanding*

- stitch can still be integrated with dogen. We could use meta-data to
  link a formatter (well, any class that needs stitch really, but at
  present just a formatter) with a stitch template. For example, a
  =class_header_formatter= could have a "is stitchable" flag set to
  on. This would then mean that dogen would look for a
  =class_header_formatter.stitch= file in the same directory as the
  CPP file. It would then use that to create a
  =class_header_formatter_stitch.cpp= file. It would also
  ignore/generate a =class_header_formatter_stitch.hpp= file and
  automatically add it to the inclusion dependencies of
  =class_header_formatter.cpp=. These are injected into stitch as we
  instantiate the template since stitch supports meta-data (we do need
  a way to inject the meta-data from dogen into the meta-data in the
  template; perhaps a kvp container passed in to the stitch workflow
  which could then be handed over to the parser). All these files are
  automatically added to the list of "exceptions" for housekeeping so
  that they do not get deleted. However, stitch would not know
  anything at all about any of this; this is all knitter's
  functionality. The problem is at present we haven't got a good place
  to perform the stitching as part of knitter's workflows. Perhaps as
  part of the expansion, we could set a number of stitch fields which
  would then be picked up by some knit-specific workflow classes.

*** Consider adding =fileset= to formatters' model                    :story:

We are using collections of files quite a bit, and it makes sense to
create an abstraction for it such as a =fileset=. However, for this to
work properly we need to add at least one basic behaviours: the
ability to merge two file sets. Or else we will end up having to
unpack the files, then merging them, then creating a new fileset.

Problem is, we either create the fileset as a non-generatable type -
not ideal - or we create it as generatable and need to add this as a
free function. We need to wait until dogen has support for merging
code generation.

*** Consider supplying element configuration as a parameter           :story:

Figure out if element configuration is context or if it is better
expressed as a stand alone formatting parameter.

*** Formatter repository should be created in quilt                   :story:

At present we are creating the formatter repository in
=quilt.cpp=. However it will be shared by all backends in the
kernel. Move it up to =quilt= level and supply it as a paramter to the backends.

*** Tidy-up of inclusion terminology                                  :story:

Random notes:

- imports and exports
- some types support both (headers)
- some support imports only (cpp)
- some support neither (cmakelists, etc).

*** Initialise formatters in the formatter's translation unit         :story:

At present we are initialising the formatters in each of the facet
initialisers. However, it makes more sense to initialise them on the
translation unit for each formatter. This will also make life easier
when we move to a mustache world where there may not be a formatter
header file at all.

*** Move odb options file into odb folder                             :story:

There is not particularly good reason for this file to exist at the
src level.

In order to implement this story we need to have a working odb setup
to test it and ensure we didn't break anything.

*** Split annotation expansion from parsing in stitch                 :story:

At present we are doing both the parsing and the annotation expansion
within the parser. It makes more sense to keep the parser clean and do
the expansion somewhere else.

** Deprecated
