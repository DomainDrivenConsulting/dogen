#+title: Sprint Backlog 62
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission

Make dynamic reflect the use cases we have found so far in formatters,
implement inclusion for types header files and start implementing the
header file formatter.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree
Clock summary at [2015-02-16 Mon 22:03]

| Headline                                       | Time   |      |      |
|------------------------------------------------+--------+------+------|
| *Total time*                                   | *2:05* |      |      |
|------------------------------------------------+--------+------+------|
| Active                                         |        | 2:05 |      |
| STARTED Sprint and product backlog grooming    |        |      | 0:06 |
| STARTED Consider creating a rules based engine |        |      | 1:59 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-02-15 Sun 23:36]--[2015-02-15 Sun 23:42] =>  0:06

Updates to sprint and product backlog.

*** STARTED Updates to the manual and readme files                    :story:

Use downtime to update the manual and / or readme file.

*** STARTED Consider creating a rules based engine                    :story:
    CLOCK: [2015-02-16 Mon 20:03]--[2015-02-16 Mon 22:02] =>  1:59

*New Understanding*

After a considerable amount of thought, it became apparent that the
current approach will not be particularly scalable. The fundamental
requirements are:

- a formatter must be supplied with all the data it requires to
  format (and only the data it requires to format);
- the data must be provided in a strongly typed form, such that the
  formatter has the least amount of boiler plate code to access it
  (casting, handling incorrect values, etc - but see next point);
- formatters may have data that is specific to them and know one knows
  about it (opaque settings); when the data is passed in, the
  formatter will simply cast it to the expected type.

At present we are failing on a number of these. The current settings
implementation pushes a lot of the selection logic to the formatter,
resulting on a lot of boiler plate just to access a flag, and more
complex items require quite a lot of logic in the formatter.

What we really need is a general settings engine that can be fed rules
and then produces a =dynamic::object= with all the values populated
for each formatter; we then have a settings class that is populated
off of that dynamic object but does not require any knowledge about
global and local settings, facet/formatter overrides, etc. It has a
single "enabled" flag for the formatter, which may have been produced
as a result of the model being enabled, the facet being enabled, the
formatter being enabled, etc. Settings does not care (because the
formatter does not care either).

In this sense we split dynamic into two:

- schema: what we currently call dynamic. Basically the strong types
  around the dynamic extensions.
- expansion: the rules engine that expands the basic dynamic object
  populated by the user.

For schema, very few changes are required:

- rename dynamic model into dynamic/schema.
- we need to load field definitions from file. Creating these manually
  in code is a pain in the backside. Many of them are really similar
  so copy and paste of text would increase productivity. We just need
  to have the "traits" for the field name (as this is how we will
  access the fields) but everything else can become data; a JSON
  representation living in library.
- we need to review infrastructure created for settings access; some
  of it may no longer make sense (mainly indexer).

Notes on how expansion will work:

- it receives an SML model as input and produces an SML model with the
  dynamic object expanded such that each object contains all the
  required data.
- it provides a registrar for client models to register their specific
  operations. An operation is how we expand the dynamic object.
- it will handle the includes, via operations provided by client
  models.
- it will handle file naming, via operations provided by client
  models.
- it will have dependencies between operations (or fixed order of
  execution as supplied by client).
- it will provide predicates and conditional operations; a conditional
  operation will only execute if the predicate is true. It may also
  provide an "else" for the predicate is false case.
- operations are organised into a "transformation" sub-system because
  we are transforming the dynamic object. However we always return a
  new object rather than mutate the existing one.
- as an example, the c++ model will supply a "create includes"
  operation. This operation is instantiated by each formatter via a
  data file. It is a composite operation made up of a set of
  sub-operations. We need to break down each rule we use to determine
  in includes and then provide a way to represent it as data. This is
  the input for the operation. The output will be the set of includes
  for the formatter. It will be slotted into the dynamic object.
- we will also have an operation to create file paths. It will query
  properties of the dynamic object to build up the ingredients. It
  will then produce the final path.
- each model will have its own "workflow" describing the order of
  operations. Expander will execute each workflow in order. The
  dynamic object will have the cumulative result of these
  workflows.
- a few operations are provided out of the box - copy global settings
  locally (once upon a time called "merger"), etc. Perhaps we could
  have a top-level workflow that executes these operations before the
  model-specific workflows kick in.

*Previous Understanding*

It may be possible to reduce the relationships between models, facets,
formatters and aspects to a set of rules, parsed by a rules engine:

- objective: formatter is enabled; aspect is enabled.
- aspect: streaming_operator
- field definition: cpp.types.use_streaming_operator
- implementation_includes: a, b, c
- requires: io disabled

This seems extremely complex but its worth starting a thought
experiment.

*** Clean-up hierarchical support in dynamic                          :story:

At present there are a number of limitations on how we have
implemented hierarchical support:

- fields from one model will get mixed up with other models;
- fields from one formatter in one facet will get mixed up with fields
  from other formatters in other facets with the same name.

We need to improve on the indexer. While we're at it, we should do a
few other assorted clean-ups:

- rename workflow (since we now have two);
- rename content extensions since this is a selector in disguise;

*** Implement include generation for class header formatter           :story:

Now that we have finished generating the path spec details, we need to
make sure includes generation works as expected. Add both formatter
level includes as well as model level includes.

We also need to deal with:

- exposing formatter id as a static property so we can create
  dependencies between formatters;
- includes overrides via dynamic extensions, so we can start using
  STL, Boost etc classes.
- includes of STL, Boost etc that are formatter level dependencies -
  this needs to be handled via traits.

Notes:

- rename header file to file name override or something else quite
  distinct. We need to ensure it is obvious that this property is only
  used for non-dogen models. Actually we can now just call it include
  path.
- however we still have a problem: when we compute the include path we
  do not know if it is a system or user path. We need to change file
  properties to take this into account. We need a include path class
  with a include type: user or system. we could then use this.
- add field definition =no_inclusion_required= and populate all
  relevant primitives.

We need to add the notion of aspects. This is because a lot of things
we have dealt with individually are really all related to aspects. An
aspect is a part of a formatter that can be enabled or disabled. For
example:

- manual move constructor
- manual default constructor
- inserter operator
- swap function
- etc.

We could simply create aspect settings; local and global formatters
would have a map of =aspect_settings= against an =aspect_name=. We
need to remove the integrated facet approach and implement it in terms
of this. We should go through the types formatter and figure out which
aspects it has. For now we shall ignore relationships between aspects
and facets (and any other kind of switching logic). For example, it is
the responsibility of the user to ensure that if integrated io is
used, the io facet is switched off. This is because it is very
complicated to build in the generic logic of such dependencies. We
have a story to handle this properly in the backlog, but it will
require a lot of work.

*** Create a list of valid values for field definitions               :story:

In addition to default values, it should be possible to supply a list
of possible values for a field definition - a domain. When processing
the values we can then check that it is part of the domain and if not
throw. This is required for the include types and for the family
types. At present this is only applicable to string fields.

In this sense, =boolean= is just a special case where the list is know
up front. We should re-implement =boolean= this way. Possibly even add
synonyms (e.g. =true=, =false=, =0=, =1=)?

*** Add dynamic consistency validation                                :story:

We need to check that the default values supplied for a field are
consistent with the field's type. This could be done with a
=validate()= method in workflow.

*** Rename name builder to name factory                               :story:

The name builder is just a factory so make the name reflect it.

*** Create settings expander and switcher                             :story:

We need a class responsible for copying over all settings that exist
both locally and globally. The idea is that, for those settings, the
selector should be able to just query by formatter name locally and
get the right values. This could be the expander.

We also need a more intelligent class that determines what formatters
are enabled and disabled. This is due to:

- lack of support for a given formatter/facet by a type in the graph;
  it must be propagated to all dependent types. We must be careful
  with recursion (for example in the composite pattern).
- a facet has been switched off. This must be propagated to all
  formatters in that facet.
- user has switched off a formatter. As with lack of support, this
  must be propagated through the graph.

This could be done by the switcher. We should first expand the
settings then switch them.

In some ways we can think of the switcher as a dependency
manager. This may inform the naming of this class.

One thing to take into account is the different kinds of behaviours
regarding enabling facets and formatters:

- for serialisation we want it to be on and if its on, all types
  should be serialisable.
- for hashing we want it to be off (most likely) and if the user makes
  use of a hashing container we want the type that is the key of the
  container to have hashing on; no other types should have it on. We
  also may want the user to manually switch hashing on for a type.
- for forward declarations: if another formatter requires it for a
  type, we want it on; if no one requires it we want it off. The user
  may want to manually switch it on for a type.

*** Create a base formatter                                           :story:

We could implement most of the formatter interface in a common base
class and then only have the descendants override what they need.

In reality we need probably more than one base formatter: one for c++
types, etc. We could handle all of the path and include generation
here. Name: =cpp_base_formatter=?

*** Add support for opaque formatter settings                         :story:

- create an empty opaque formatter settings class. Create a opaque
  formatter settings factory interface class. Formatter interface to
  return an opaque formatter settings factory interface.
- add opaque formatter settings to local settings.
- when formatting, cast additional formatter settings (if available)
  and throw if cast fails. For formatters without opaque settings,
  throw if any supplied.
- we need multiple opaque settings (more than one formatter will need
  them).
- move provider and provider selector to top-level namespace and add a
  provide opaque settings method to it.

*** Read =generate_preamble= from dynamic object                      :story:

We need to generate the field definitions and update the general
settings factory.

*** Implement class header formatter                                  :story:

- look at the old =om= types formatter implementation to see if there
  is any code to scavenge. This model was deleted around commit
  10157ad.

**** Tidy-up =types_main_header_file_formatter=                        :task:

Clean up internal functions in file and add documentation.

**** Copy across documentation from =om=                               :task:

We did a lot of doxygen comments that are readily applicable, copy
them across.

**** Make use of indenting stream                                      :task:

Remove uses of old indenter.

**** Copy across =om= types formatter tests                            :task:

Not sure how applicable this would be, but we may be able to scavenge
some tests.

*** Improve formatters code generation marker                         :story:

Things the marker can/should have:

- model level version;
- the dogen version too. However, this will make all our tests break
  every time there is a new commit so perhaps we need to have this
  switched off by default.

*** Copyright holders is scalar when it should be an array            :story:

At present its only possible to specify a single copyright holder. It
should be handled the same was as odb parameters, but because that is
done with a massive hack, we are not going to extend the hack to
copyright holders.

*** C++ workflow should perform a consistency check                   :story:

We should ensure that all facets and formatters available in the
registrar have corresponding field definitions and vice-versa. This
was originally to be done by some kind of "feature graph" class, but
since we need to use this data for other purposes, the main workflow
could take on this responsibility - or we could create some kind of
"validator" class to which the workflow delegates.

*** Add "model types"                                                 :story:

At present we have a number of dynamic extensions that exist purely to
deal with non-dogen models:

- supported: is the facet supported by the external model
- file_name: what is the external model naming for files for this
  facet
- is_system: is the file name a system include file or not?

In reality, all of this could be avoided if we had a way of
distinguishing between models that follow dogen conventions and those
who do not; a "model type" of sorts such as "external" and "dogen" -
naming needs more thought. With this we could infer the rest: if no
file name is supplied then a given formatter/facet is not supported;
if the model is_system then all types are system and so on.

We should also have a flag in field definitions that verify that a
parameter is only present if the model is a non-dogen model. For
example, it makes no sense to supply =cpp.type.family= in a dogen
model but it may make sense to do so in an external model. However,
this would mean that if a user manually adds a type to a dogen model
it cannot be extended. Requires a bit of thinking.

*** Consider renaming general settings                                :story:

A while ago we came up with this name for the settings of the generic
formatter model. This is the model with basic infrastructure to be
reused by the more specialised formatters. However, now that we have
many (many) settings classes, general settings may not be the most
appropriate name. We need to look a bit more deeply into the role of
this class and see if a better name is not available.

We could call it preamble settings because all settings are related to
the file preamble; annoyingly, we also generate a post-amble from
it. There doesn't seem to be any good names for the pair (preamble,
post-amble). In networking this would be called frame markers perhaps.

Now that we are not using =meta_data= any more, perhaps we could
re-purpose it for this (=meta_data_settings=). In a way, preambles and
post-ambles are meta-data, as opposed to the real file
contents. Having said that, one could say the same about any kind of
comments.

We could also use [[http://www1.appstate.edu/~yaleread/typographichierarchy.pdf][typography terminology]]: headers and footers.

*** Populate the "new" =class_info= properties                        :story:

We need a way of populating the class aspects via the type settings
and via information obtained in the SML model. We may want to create a
class to handle this logic or maybe it can be done in transformer.

*** Includer generation should be done from dynamic extensions        :story:

*New Understanding*

The true use case of this story is not to allow users to add includes
at random; it is actually only useful in one scenario:

- *merging code generation*: users add code which requires additional
  includes. Without support for this, merging code generation would
  have limited usefulness.

*Previous Understanding*

It would be nice if we could determine which includer files to create
by looking at the dynamic extensions. For this we need a notion of an
inclusion group, defined at the model level:

- =cpp.types.includers.general=
- =cpp.types.includers.value_objects=
- ...

Under each of these one would configure the aspect:

- =cpp.types.includers.general.generate=: =true=
- =cpp.types.includers.general.file_name=: =a/b/c=
- =cpp.types.includers.general.is_system=: =false=

Then, each type, module etc would declare its membership (as a list):

- =cpp.includers.member=: =cpp.types.includers.general=
- =cpp.includers.member=: =cpp.types.includers.value_objects=
- ...

*Previous understanding*

We should simply go through all the types in the SML model and for
each type and each facet create the corresponding inclusion
path. locator can be used to generate standard paths, and a model
specific mapping is required for other models such as std.

Include then takes the relationships extracted by extractor, the
mappings generated by this mapper and simply appends to the inclusion
list the file names. it also appends the implementation specific
headers.

*** Consider creating constants for common fields                     :story:

Fields such as =enabled=, =postfix= etc are common to all formatters
and facets. It may make more sense to define some string constants for
them, perhaps in =traits=?

** Deprecated
