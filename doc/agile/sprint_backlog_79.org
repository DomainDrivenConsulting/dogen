#+title: Sprint Backlog 79
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- start implementing quilt.cpp formatters using yarn types;
- try to enable coverage support.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75
#+CAPTION: Clock summary at [2016-01-23 Sat 00:20]
| <75>                                                                        |         |       |      |
| Headline                                                                    | Time    |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                                | *12:25* |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| Stories                                                                     | 12:25   |       |      |
| Active                                                                      |         | 12:25 |      |
| STARTED Sprint and product backlog grooming                                 |         |       | 0:59 |
| COMPLETED Merge all formatter assistants into one                           |         |       | 2:20 |
| COMPLETED Name builder should take only model name                          |         |       | 0:48 |
| COMPLETED Generate exceptions using yarn types                              |         |       | 2:21 |
| COMPLETED Generate modules using yarn types                                 |         |       | 0:32 |
| COMPLETED Delete all =quilt::cpp::formattable= types not in use             |         |       | 0:19 |
| COMPLETED Use dots to separate namespaces in binary names                   |         |       | 1:52 |
| COMPLETED Refactor resolver class                                           |         |       | 0:19 |
| COMPLETED Handle enumeration type dynamically                               |         |       | 1:05 |
| COMPLETED Generate enumerations using yarn types                            |         |       | 1:07 |
| COMPLETED Generate visitors using yarn types                                |         |       | 0:31 |
| STARTED Create a debug build for clang in travis                            |         |       | 0:12 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-01-22 Fri 13:11]--[2016-01-22 Fri 13:49] =>  0:38
    CLOCK: [2016-01-19 Tue 23:27]--[2016-01-19 Tue 23:30] =>  0:03
    CLOCK: [2016-01-18 Mon 21:55]--[2016-01-18 Mon 22:13] =>  0:18

Updates to sprint and product backlog.

*** Update manual                                                     :story:

Updates to manual.

*** COMPLETED Merge all formatter assistants into one                 :story:
    CLOSED: [2016-01-19 Tue 22:24]
    CLOCK: [2016-01-19 Tue 20:36]--[2016-01-19 Tue 22:24] =>  1:48
    CLOCK: [2016-01-18 Mon 23:09]--[2016-01-18 Mon 23:31] =>  0:22
    CLOCK: [2016-01-18 Mon 22:30]--[2016-01-18 Mon 22:40] =>  0:10

As part of the "yarnification" of the formatters, we need to be able
to use most of the entity formatter assistant properties over to the
base formatter assistant. We should get rid of the trivial formatting
assistant and entity formatting assistant and move all the code to the
base. The two methods that require an entity should receive it as an
input parameter.

*** COMPLETED Name builder should take only model name                :story:
    CLOSED: [2016-01-20 Wed 21:05]
    CLOCK: [2016-01-20 Wed 21:46]--[2016-01-20 Wed 22:04] =>  0:18
    CLOCK: [2016-01-20 Wed 20:35]--[2016-01-20 Wed 21:05] =>  0:30

At present name builder requires an entire model just to get the name
out of it.

*** COMPLETED Generate exceptions using yarn types                    :story:
    CLOSED: [2016-01-21 Thu 07:15]
    CLOCK: [2016-01-21 Thu 18:19]--[2016-01-21 Thu 18:26] =>  0:07
    CLOCK: [2016-01-21 Thu 18:10]--[2016-01-21 Thu 18:16] =>  0:06
    CLOCK: [2016-01-21 Thu 06:30]--[2016-01-21 Thu 07:15] =>  0:45
    CLOCK: [2016-01-20 Wed 22:05]--[2016-01-20 Wed 22:33] =>  0:28
    CLOCK: [2016-01-20 Wed 21:06]--[2016-01-20 Wed 21:45] =>  0:39
    CLOCK: [2016-01-19 Tue 23:11]--[2016-01-19 Tue 23:27] =>  0:16

Tasks completed:

- delete the quilt exception type;
- remove transformation support for exception;
- create a yarn element based assistant;
- update the formatter interfaces to use yarn types;
- update the yarn formatting workflow to process yarn exceptions;
- update the stitch templates to make use of yarn exceptions.
- cannot find formatter properties for
  quilt.cpp.types.exception_header_formatter

*** COMPLETED Generate modules using yarn types                       :story:
    CLOSED: [2016-01-21 Thu 18:51]
    CLOCK: [2016-01-21 Thu 18:52]--[2016-01-21 Thu 19:00] =>  0:08
    CLOCK: [2016-01-21 Thu 18:27]--[2016-01-21 Thu 18:51] =>  0:24

Tasks:

- delete the quilt formattable;
- remove transformation support;
- update the formatter interfaces to use yarn types;
- update the yarn formatting workflow to process yarn modules;
- update the stitch templates to make use of yarn modules.

*** COMPLETED Delete all =quilt::cpp::formattable= types not in use   :story:
    CLOSED: [2016-01-21 Thu 20:27]
    CLOCK: [2016-01-21 Thu 20:17]--[2016-01-21 Thu 20:27] =>  0:10
    CLOCK: [2016-01-21 Thu 19:01]--[2016-01-21 Thu 19:10] =>  0:09

We seem to have created a number of formattable types but not actually
used them in formatters. Remove them all.

*** COMPLETED Use dots to separate namespaces in binary names         :story:
    CLOSED: [2016-01-21 Thu 23:06]
    CLOCK: [2016-01-21 Thu 22:57]--[2016-01-21 Thu 23:16] =>  0:19
    CLOCK: [2016-01-21 Thu 21:23]--[2016-01-21 Thu 22:56] =>  1:33

Originally we started using underscores to separate namespaces in
binary names. However, since we added support for composite model
names, we also started using dots for this. We should use dots in
binary names as well, for consistency.

We should do the same for log file names too, e.g.:

: dogen_knitter_yarn.json.log

*** COMPLETED Improve resolution of partial types in resolver         :story:
    CLOSED: [2016-01-22 Fri 21:52]

*Rationale*: the current state of the code is more or less according
to this story.

At present the code in =resolve_partial_type= is one big hack. We
should create a "lookup" routine that given a qname, tries it on all
containers and returns true or false. Then we should have different
"attempt" routines that try modifying the qname according to a rule
and call the "lookup" routine to see if it worked or not. We should
then continue to the next rule until we exhaust all rules or we find a
match. Each rule should provide some logging.

*** COMPLETED Refactor resolver class                                 :story:
    CLOSED: [2016-01-22 Fri 21:54]
    CLOCK: [2016-01-22 Fri 21:35]--[2016-01-22 Fri 21:54] =>  0:19

We are supplying the model in the constructor and then modifying it
internally. We should use the same pattern as other yarn services and
supply the model on the main method.

*** COMPLETED Handle enumeration type dynamically                     :story:
    CLOSED: [2016-01-22 Fri 22:43]
    CLOCK: [2016-01-22 Fri 21:55]--[2016-01-22 Fri 22:42] =>  0:47
    CLOCK: [2016-01-22 Fri 21:16]--[2016-01-22 Fri 21:34] =>  0:18

Add some enumeration post-processing that assigns it a underlying
type. Should be done with merged model (look for a primitive type with
property =is_default_enumeration_type=).

This should be done as part of resolution perhaps; user provides a raw
type, we expand it during expansion and resolve it during
resolution. If the string is empty, we should use the default
enumeration type. It is chosen from the collection of
primitives. There can only be one type marked as
default. =is_enumeration_default_type=? Read from JSON file.

Merged stories:

*Set enumeration underlying type in yarn*

In cpp transformer we have hacked the underlying type of the
enumeration. Remove this hack and set it in SML. Still a hack, but
a tad better.

Actually this could be the first case where LAM/PIM is used: we could
call this something like integer.

This is also hacked in yarn_dia's transformer.

*** COMPLETED Generate enumerations using yarn types                  :story:
    CLOSED: [2016-01-22 Fri 23:48]
    CLOCK: [2016-01-22 Fri 22:54]--[2016-01-22 Fri 23:48] =>  0:54
    CLOCK: [2016-01-21 Thu 21:09]--[2016-01-21 Thu 21:22] =>  0:13

Tasks:

- handle enumeration type assignment within yarn (was done in quilt
  before).
- delete the quilt formattable;
- remove transformation support;
- update the formatter interfaces to use yarn types;
- update the yarn formatting workflow to process yarn enumerations;
- update the stitch templates to make use of yarn enumerations.

*** COMPLETED Generate visitors using yarn types                      :story:
    CLOSED: [2016-01-23 Sat 00:18]
    CLOCK: [2016-01-22 Fri 23:49]--[2016-01-23 Sat 00:20] =>  0:29

Tasks:

- delete the quilt formattable;
- remove transformation support;
- update the formatter interfaces to use yarn types;
- update the yarn formatting workflow to process yarn visitors;
- update the stitch templates to make use of yarn visitors.

*** Access model name from within formatters workflow                 :story:

In order for the assistant to build names, it will need to be able to
access the yarn model name.

*** Fix windows errors on boost test                                  :story:

Boost test warning:

: C:\Users\appveyor\.conan\data\Boost\1.60.0\lasote\stable\package\7569deb7626b9f88e03d1b57f5ad4b34f8383a6f\include\boost/test/impl/test_tools.ipp(369): warning C4273: 'boost::test_tools::tt_detail::format_assertion_result': inconsistent dll linkage [C:\proj
: ects\dogen\build\output\projects\config\spec\config_spec.vcxproj]
:   C:\Users\appveyor\.conan\data\Boost\1.60.0\lasote\stable\package\7569deb7626b9f88e03d1b57f5ad4b34f8383a6f\include\boost/test/tools/detail/fwd.hpp(96): note: see previous definition of 'format_assertion_result'

Boost test errors:

: C:\Users\appveyor\.conan\data\Boost\1.60.0\lasote\stable\package\7569deb7626b9f88e03d1b57f5ad4b34f8383a6f\include\boost/test/impl/test_tools.ipp(396): error C2491: 'boost::test_tools::tt_detail::prod_report_format': definition of dllimport function not all
: owed [C:\projects\dogen\build\output\projects\config\spec\config_spec.vcxproj]

: C:\Users\appveyor\.conan\data\Boost\1.60.0\lasote\stable\package\7569deb7626b9f88e03d1b57f5ad4b34f8383a6f\include\boost/test/tools/old/impl.hpp(118): error C2264: 'boost::test_tools::tt_detail::equal_impl': error in function definition or declaration; func
: tion not called [C:\projects\dogen\build\output\projects\config\spec\config_spec.vcxproj]

It may be due to this:

[[http://boost.2283326.n4.nabble.com/Test-Thread-Regression-since-9-December-td4670920.html][Regression since 9 December?]]

*** STARTED Create a debug build for clang in travis                  :story:
    CLOCK: [2016-01-18 Mon 22:14]--[2016-01-18 Mon 22:26] =>  0:12

In order to enable code coverage we need to have a debug build. For
this we need to setup travis with a build matrix, with two build types
for clang (debug and release).

Example YML: [[https://github.com/Microsoft/GSL/blob/master/.travis.yml][GSL]]

*** ODB options file is generated to incorrect location               :story:

Models with composite names seem to have their ODB options file
generated under the =projects= directory, e.g.:

: projects/vtk/geometry/src/options.odb

*** Add support for coveralls                                         :story:

Seems like all we need to do to have code coverage from travis is to
enable it in the YML file.

*Direct use of Coveralls failed*

We had to remove coveralls:

: - coveralls --gcov "$GCOV" --gcov-options '\-lp' -e /usr

This was generating over 10 MB of logging so the build got terminated.

We also add to remove debug builds:

: -DWITH_DEBUG=on -DWITH_PROFILING=on

We were getting a lot of internal compiler errors:

: FAILED: /usr/bin/g++-4.9   -DBOOST_ALL_DYN_LINK -g -O0 -Wall -Wextra -pedantic -Werror -Wno-system-headers -Woverloaded-virtual -Wwrite-strings -fprofile-arcs -ftest-coverage -std=c++11 -frtti -fvisibility-inlines-hidden -fvisibility=default -isystem /usr/include/libxml2 -Istage/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/dia/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/dia_to_sml/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/frontend/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/backend/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/sml/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/config/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/cpp/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/cpp_formatters/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/sml_to_cpp/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/formatters/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/utility/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/knit/include -I/home/travis/build/DomainDrivenConsulting/dogen/projects/knitter/include -MMD -MT projects/sml_to_cpp/src/CMakeFiles/sml_to_cpp.dir/types/transformer.cpp.o -MF "projects/sml_to_cpp/src/CMakeFiles/sml_to_cpp.dir/types/transformer.cpp.o.d" -o projects/sml_to_cpp/src/CMakeFiles/sml_to_cpp.dir/types/transformer.cpp.o -c /home/travis/build/DomainDrivenConsulting/dogen/projects/sml_to_cpp/src/types/transformer.cpp
: g++-4.9: internal compiler error: Killed (program cc1plus)
: Please submit a full bug report,
: with preprocessed source if appropriate.
: See <file:///usr/share/doc/gcc-4.9/README.Bugs> for instructions.

Finally note also that we must add coverage _after_ the script
executes or else we risk doing coverage whilst the build is taking
place. Hopefully this is the reason for these errors:

: /home/travis/build/DomainDrivenConsulting/output/projects/test_models/class_without_attributes/src/CMakeFiles/class_without_attributes.dir/io/package_1/class_1_io.cpp.gcda:cannot open data file, assuming not executed
: File '/usr/include/c++/4.9/bits/basic_ios.h'
: No executable lines

We should read up on the [[http://docs.travis-ci.com/user/build-lifecycle/][life-cycle]] properly.

*Travis Examples*

Seems like all we need to do to have code coverage from travis is to
enable it in the YML file. We should look into copying it from the
[[https://github.com/apolukhin/Boost.DLL][Boost.DLL]] [[https://raw.githubusercontent.com/apolukhin/Boost.DLL/master/.travis.yml][example]]. We also need to enable coverage on all builds,
separately from nightlies. The key parts appear to be these:

:  - ../../../b2 cxxflags="--coverage -std=$CXX_STANDARD" linkflags="--coverage"

and

: after_success:
:    - find ../../../bin.v2/ -name "*.gcda" -exec cp "{}" ./ \;
:    - find ../../../bin.v2/ -name "*.gcno" -exec cp "{}" ./ \;
:    - sudo apt-get install -qq python-yaml lcov
:    - lcov --directory ./ --base-directory ./ --capture --output-file coverage.info
:    - lcov --remove coverage.info '/usr*' '*/filesystem*' '*/container*' '*/core/*' '*/exception/*' '*/intrusive/*' '*/smart_ptr/*' '*/move/*' '*/fusion/*' '*/io/*' '*/function/*' '*/iterator/*' '*/preprocessor/*' '*/system/*' '*/boost/test/*' '*/boost/detail/*' '*/utility/*' '*/dll/example/*' '*/dll/test/*' '*/pe_info.hpp' '*/macho_info.hpp' -o coverage.info
:    - gem install coveralls-lcov
:    - cd .. && coveralls-lcov test/coverage.info

Another way seems to be using gcov, as per [[https://github.com/fabianschuiki/Maxwell][Maxwell]] [[https://raw.githubusercontent.com/fabianschuiki/Maxwell/master/.travis.yml][travis.yml]]:

: - if [ "$CXX" = "g++" ]; then sudo apt-get install -qq g++-4.8; export CXX="g++-4.8" CC="gcc-4.8" GCOV="gcov-4.8"; fi
:  - sudo pip install cpp-coveralls

and

: script:
:  - export CTEST_OUTPUT_ON_FAILURE=1
:  - cmake -DCMAKE_BUILD_TYPE=gcov . && make && make test
: after_success:
:  - coveralls --gcov "$GCOV" --gcov-options '\-lp' -e CMakeFiles -E ".*/test/.*" -E ".*/mock/.*" -e maxwell/gen -e language -e thirdparty -e maxwell/ast/nodes -e maxwell/driver/gramdiag.c -e maxwell/driver/Parser.cpp -e maxwell/driver/Parser.hpp -e maxwell/driver/Scanner.cpp -e maxwell/driver/position.hh -e maxwell/driver/stack.hh -e maxwell/driver/location.hh

Yet another way seems to be creating a script to do coverage, as per
[[https://github.com/BoostGSoC13/boost.afio][boost.afio]] [[https://raw.githubusercontent.com/BoostGSoC13/boost.afio/master/.travis.yml][travis.yml]]. The script is available [[https://raw.githubusercontent.com/BoostGSoC13/boost.afio/master/test/update_coveralls.sh][here]].

Another example from [[https://github.com/boostorg/dll/blob/develop/.travis.yml][Boost.Dll]].

*** Attach helper methods to types dynamically                        :story:

In order to cope with the removal of nested type info, we need a way
to determine what helper methods are required for a given yarn type.

For this we need a way to allow helper methods to bind dynamically to
types. This can be done by using meta-data. The helper method
registers a name and the type uses that name it its key for helper
method. Where possible the helper method should use the name of the
STL concept it is binding to. We need settings support for reading
this field, and registration support for helper methods (registrar,
etc).

We should also find a nicer way to package helper methods, maybe
aligned to a model and type or concept.

Once this is done we need to remove the =object_types= that exist in
yarn just to figure out what helper methods to use.

*** Implement formattables in terms of yarn types                     :story:

At present formattables are just a shadow copy of yarn types plus
additional =cpp= specific types. In practice:

- for the types that are shadow copies, we could have helper utilities
  that do the translation on the fly (e.g. for names).
- for additional information which cannot be translated, we could have
  containers indexed by qualified name and query those just before we
  call the transformer. This is the case with formatter properties. We
  need something similar to house "type properties" such as
  =requires_stream_manipulators=. These could be moved into aspect
  settings.
- for types that do not exist in yarn, we could inherit from element;
  this is the case for registrar, forward declarations, cmakelists and
  odb options. Note that with this we are now saying that element
  space contains anything which can be modeled, regardless of if they
  are part of the programming language type system, or build system,
  etc. This is not ideal, but its not a problem just yet. We could
  update the factory to generate these types and then take a copy of
  the model and inject them in it.

*** Create a settings class for the "requires" settings               :story:

We need to populate these in a settings workflow of some kind.

*** Move all properties in =cpp= to a properties namespace            :story:

Once all formattables are gone, we should have only properties left in
the formattables namespace. We should then rename it to
properties. Thus we have two kinds of things: settings, which are a
direct translation of meta-data without any further processing and
properties which require processing.

Merged stories:

*Split formatter properties and associated classes from formattables*

We have two kinds of data: the formattables themselves (mapped from
yarn) and associated data (formatter properties). The latter is
totally independent. We should create a namespace for all of these
classes and a workflow that produces the data ready for consumption. A
tentative name is =manifest=.

*** Investigate slow down                                             :story:

With commit 7e89ddb we introduced a set of hacks to inject settings
and formatter properties into the repositories. This seems to have had
a very negative impact in performance. We need to ensure performance
goes back to normal after the hacks have been removed.

*** Tidy-up master include generation                                 :story:

At present we have one humongous hack in the factory to generate the
master includers. How to do this properly:

- wait until we start using yarn types.
- loop through the yarn model instead of the path derivatives.
- use a visitor to dispatch the types.
- do not filter out services?
- filter registrars etc based on type dispatching.

*** Create a UML profile to formalise yarn concepts                   :story:

Profile should include the hashable, etc changes.

*** Create a map between UML/MOF terminology and yarn                 :story:

It would be helpful to know what a yarn type means in terms of
UML/MOF, and perhaps even explain why we have chosen certain names
instead of the UML ones. We should also cover the modeling of
relationships and the relation between yarn concepts and UML/MOF
classes. This will form a chapter in the manual.

The UML specification is available [[http://www.omg.org/spec/UML/2.5/][here]] and MOF specification is
available [[http://www.omg.org/spec/MOF/2.5][here]].

We need a way to uniquely identify a property. This could be done by
appending the containing type's qualified name to the property name.

See also [[http://www.uml-diagrams.org/][The Unified Modeling Language]] for a more accessible treatment.

*** Remove =service= stereotype                                       :story:

This really just means non-generatable, or do not generate. We already
have a stereotype for this. Remove =service= and any other stereotype
which is not being used such as =value_object= etc.

Actually, non-generatable is not a stereotype really. We should
instead have some meta-data that can affect generation:

- do not generate: do nothing at all. For references only. If a file
  exists with this file name, it will be deleted as part of
  housekeeping.
- generate blank file if it doesn't exist: we don't even want a
  template.
- generate with content if it doesn't exist, do not touch otherwise:
  what we call services at the moment. Generate a "template" that then
  gets filled in manually.
- generate and merge: merge the contents of the generated file with
  the current contents in the file system. When we support merging.
- generate and overwrite: generate the file and overwrite whatever
  exists in the file system.

This could be called "generation policy".

The second behaviour we get for free with services is that we disable
all facets except for types. A few points:

- we may want to have io, serialisation, etc. This is not possible at
  present. If a state of a service is made up of supported types, we
  could even use existing code generation.
- in order for this to be implemented correctly we need to hook in to
  the enablement management somehow. In addition, it seems each facet
  can have its own generation policy. For example we may want to
  manually create types but automatically generate io.
- the best way to handle this may be to setup "enablement profiles"
  that the user can hook up to. For example we could have a "default"
  profile that enables all facets (or uses facet defaults), a second
  "service" profile that enables types with partial generation and io
  with full generation and so on. We probably also need "generation
  profiles" to go with "enablement profiles".

** Deprecated
*** CANCELLED Consider renaming nested name                           :story:
    CLOSED: [2016-01-07 Thu 20:18]

*Rationale*: the final conclusion on this was that nested name is the
best of a bad bunch. See Sprint 77 stories on renames for details.

*New understanding*:

This story requires further analysis. Blindly following the composite
pattern was tried but it resulted in a lot of inconsistencies because
we then had to follow MEC-33 and create =abstract_qname=; however, the
nested qname does not really behave like a composite qname; its more
like the difference between a type in isolation and a type
instantiated as an argument of a function. For example, whilst the
type in isolation may have unknown template parameters, presumably, as
an argument of a function these have been instantiated with real
types.

One way to solve this is just to make the type name a bit more
explicit rather than try to imply the composite pattern
(e.g. "nested"). We need a name that signifies "instantiated
type". Look at the C++ standard for the difference between defining a
generic type and instantiating a generic type.

No good names yet (type reference, type instantiation, instantiated
name). What are we trying to represent: an identifier which points to
a complete definition of a name such that the name can be instantiated
as a type in the underlying language. By "instantiated" we mean used
to define variables of this type. In this light: instantiable name,
definable name? If we choose instantiable name, we could then rename
"children" to type arguments.

Other notes:

- there is such a thing as a element instance identifier. We call it
  nested name at present. The element instance identifier identifies
  instantiations of types. It models two cases: for the case where the
  type has no type parameters, the instance identifier is equal to the
  element identifier; for all other cases, it is a hierarchical
  collection of element identifiers, modeling the type parameter
  structure.

*Previous understanding*:

We should just follow the composite pattern in the naming.
*** CANCELLED ODB options file is generated even when disabled        :story:
    CLOSED: [2016-01-20 Wed 20:39]

*Rationale*: this was due to incorrect key name for
=yarn.dia.comment=. We already have a story for better validation.

At present it seems the file is always generated regardless of the
meta-data. This is probably due to a typo in the field name.
