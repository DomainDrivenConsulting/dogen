#+title: Sprint Backlog 79
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- start implementing quilt.cpp formatters using yarn types;
- try to enable coverage support.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75
#+CAPTION: Clock summary at [2016-01-27 Wed 23:32]
| <75>                                                                        |         |       |      |
| Headline                                                                    | Time    |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                                | *23:53* |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| Stories                                                                     | 23:53   |       |      |
| Active                                                                      |         | 23:53 |      |
| STARTED Sprint and product backlog grooming                                 |         |       | 3:14 |
| COMPLETED Merge all formatter assistants into one                           |         |       | 2:20 |
| COMPLETED Name builder should take only model name                          |         |       | 0:48 |
| COMPLETED Generate exceptions using yarn types                              |         |       | 2:21 |
| COMPLETED Generate modules using yarn types                                 |         |       | 0:32 |
| COMPLETED Delete all =quilt::cpp::formattable= types not in use             |         |       | 0:19 |
| COMPLETED Use dots to separate namespaces in binary names                   |         |       | 1:52 |
| COMPLETED Refactor resolver class                                           |         |       | 0:19 |
| COMPLETED Handle enumeration type dynamically                               |         |       | 1:05 |
| COMPLETED Generate enumerations using yarn types                            |         |       | 1:07 |
| COMPLETED Generate visitors using yarn types                                |         |       | 0:31 |
| COMPLETED Add initial support for MinGW and OSX                             |         |       | 2:28 |
| POSTPONED Create a debug build for clang in travis                          |         |       | 0:12 |
| COMPLETED How to attach helper methods to types dynamically                 |         |       | 1:16 |
| COMPLETED How to handle composition and pointers                            |         |       | 1:18 |
| COMPLETED Rename hash container to associative container                    |         |       | 0:42 |
| COMPLETED Clean up usage of is pointer in yarn                              |         |       | 2:03 |
| COMPLETED Rename aspect settings to element settings                        |         |       | 0:26 |
| COMPLETED Remove support for integrated io                                  |         |       | 0:37 |
| CANCELLED Implement io for inheritance in the io facet                      |         |       | 0:09 |
| STARTED Add a field for =quilt.cpp.family=                                  |         |       | 0:14 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2016-01-27 Wed 21:20]--[2016-01-27 Wed 21:37] =>  0:17
    CLOCK: [2016-01-24 Sun 23:19]--[2016-01-24 Sun 23:26] =>  0:07
    CLOCK: [2016-01-24 Sun 15:10]--[2016-01-24 Sun 15:28] =>  0:18
    CLOCK: [2016-01-23 Sat 20:40]--[2016-01-23 Sat 21:56] =>  1:16
    CLOCK: [2016-01-23 Sat 20:05]--[2016-01-23 Sat 20:22] =>  0:17
    CLOCK: [2016-01-22 Fri 13:11]--[2016-01-22 Fri 13:49] =>  0:38
    CLOCK: [2016-01-19 Tue 23:27]--[2016-01-19 Tue 23:30] =>  0:03
    CLOCK: [2016-01-18 Mon 21:55]--[2016-01-18 Mon 22:13] =>  0:18

Updates to sprint and product backlog.

*** Update manual                                                     :story:

Updates to manual.

*** COMPLETED Merge all formatter assistants into one                 :story:
    CLOSED: [2016-01-19 Tue 22:24]
    CLOCK: [2016-01-19 Tue 20:36]--[2016-01-19 Tue 22:24] =>  1:48
    CLOCK: [2016-01-18 Mon 23:09]--[2016-01-18 Mon 23:31] =>  0:22
    CLOCK: [2016-01-18 Mon 22:30]--[2016-01-18 Mon 22:40] =>  0:10

As part of the "yarnification" of the formatters, we need to be able
to use most of the entity formatter assistant properties over to the
base formatter assistant. We should get rid of the trivial formatting
assistant and entity formatting assistant and move all the code to the
base. The two methods that require an entity should receive it as an
input parameter.

*** COMPLETED Name builder should take only model name                :story:
    CLOSED: [2016-01-20 Wed 21:05]
    CLOCK: [2016-01-20 Wed 21:46]--[2016-01-20 Wed 22:04] =>  0:18
    CLOCK: [2016-01-20 Wed 20:35]--[2016-01-20 Wed 21:05] =>  0:30

At present name builder requires an entire model just to get the name
out of it.

*** COMPLETED Generate exceptions using yarn types                    :story:
    CLOSED: [2016-01-21 Thu 07:15]
    CLOCK: [2016-01-21 Thu 18:19]--[2016-01-21 Thu 18:26] =>  0:07
    CLOCK: [2016-01-21 Thu 18:10]--[2016-01-21 Thu 18:16] =>  0:06
    CLOCK: [2016-01-21 Thu 06:30]--[2016-01-21 Thu 07:15] =>  0:45
    CLOCK: [2016-01-20 Wed 22:05]--[2016-01-20 Wed 22:33] =>  0:28
    CLOCK: [2016-01-20 Wed 21:06]--[2016-01-20 Wed 21:45] =>  0:39
    CLOCK: [2016-01-19 Tue 23:11]--[2016-01-19 Tue 23:27] =>  0:16

Tasks completed:

- delete the quilt exception type;
- remove transformation support for exception;
- create a yarn element based assistant;
- update the formatter interfaces to use yarn types;
- update the yarn formatting workflow to process yarn exceptions;
- update the stitch templates to make use of yarn exceptions.
- cannot find formatter properties for
  quilt.cpp.types.exception_header_formatter

*** COMPLETED Generate modules using yarn types                       :story:
    CLOSED: [2016-01-21 Thu 18:51]
    CLOCK: [2016-01-21 Thu 18:52]--[2016-01-21 Thu 19:00] =>  0:08
    CLOCK: [2016-01-21 Thu 18:27]--[2016-01-21 Thu 18:51] =>  0:24

Tasks:

- delete the quilt formattable;
- remove transformation support;
- update the formatter interfaces to use yarn types;
- update the yarn formatting workflow to process yarn modules;
- update the stitch templates to make use of yarn modules.

*** COMPLETED Delete all =quilt::cpp::formattable= types not in use   :story:
    CLOSED: [2016-01-21 Thu 20:27]
    CLOCK: [2016-01-21 Thu 20:17]--[2016-01-21 Thu 20:27] =>  0:10
    CLOCK: [2016-01-21 Thu 19:01]--[2016-01-21 Thu 19:10] =>  0:09

We seem to have created a number of formattable types but not actually
used them in formatters. Remove them all.

*** COMPLETED Use dots to separate namespaces in binary names         :story:
    CLOSED: [2016-01-21 Thu 23:06]
    CLOCK: [2016-01-21 Thu 22:57]--[2016-01-21 Thu 23:16] =>  0:19
    CLOCK: [2016-01-21 Thu 21:23]--[2016-01-21 Thu 22:56] =>  1:33

Originally we started using underscores to separate namespaces in
binary names. However, since we added support for composite model
names, we also started using dots for this. We should use dots in
binary names as well, for consistency.

We should do the same for log file names too, e.g.:

: dogen_knitter_yarn.json.log

*** COMPLETED Improve resolution of partial types in resolver         :story:
    CLOSED: [2016-01-22 Fri 21:52]

*Rationale*: the current state of the code is more or less according
to this story.

At present the code in =resolve_partial_type= is one big hack. We
should create a "lookup" routine that given a qname, tries it on all
containers and returns true or false. Then we should have different
"attempt" routines that try modifying the qname according to a rule
and call the "lookup" routine to see if it worked or not. We should
then continue to the next rule until we exhaust all rules or we find a
match. Each rule should provide some logging.

*** COMPLETED Refactor resolver class                                 :story:
    CLOSED: [2016-01-22 Fri 21:54]
    CLOCK: [2016-01-22 Fri 21:35]--[2016-01-22 Fri 21:54] =>  0:19

We are supplying the model in the constructor and then modifying it
internally. We should use the same pattern as other yarn services and
supply the model on the main method.

*** COMPLETED Handle enumeration type dynamically                     :story:
    CLOSED: [2016-01-22 Fri 22:43]
    CLOCK: [2016-01-22 Fri 21:55]--[2016-01-22 Fri 22:42] =>  0:47
    CLOCK: [2016-01-22 Fri 21:16]--[2016-01-22 Fri 21:34] =>  0:18

Add some enumeration post-processing that assigns it a underlying
type. Should be done with merged model (look for a primitive type with
property =is_default_enumeration_type=).

This should be done as part of resolution perhaps; user provides a raw
type, we expand it during expansion and resolve it during
resolution. If the string is empty, we should use the default
enumeration type. It is chosen from the collection of
primitives. There can only be one type marked as
default. =is_enumeration_default_type=? Read from JSON file.

Merged stories:

*Set enumeration underlying type in yarn*

In cpp transformer we have hacked the underlying type of the
enumeration. Remove this hack and set it in SML. Still a hack, but
a tad better.

Actually this could be the first case where LAM/PIM is used: we could
call this something like integer.

This is also hacked in yarn_dia's transformer.

*** COMPLETED Generate enumerations using yarn types                  :story:
    CLOSED: [2016-01-22 Fri 23:48]
    CLOCK: [2016-01-22 Fri 22:54]--[2016-01-22 Fri 23:48] =>  0:54
    CLOCK: [2016-01-21 Thu 21:09]--[2016-01-21 Thu 21:22] =>  0:13

Tasks:

- handle enumeration type assignment within yarn (was done in quilt
  before).
- delete the quilt formattable;
- remove transformation support;
- update the formatter interfaces to use yarn types;
- update the yarn formatting workflow to process yarn enumerations;
- update the stitch templates to make use of yarn enumerations.

*** COMPLETED Generate visitors using yarn types                      :story:
    CLOSED: [2016-01-23 Sat 00:18]
    CLOCK: [2016-01-22 Fri 23:49]--[2016-01-23 Sat 00:20] =>  0:29

Tasks:

- delete the quilt formattable;
- remove transformation support;
- update the formatter interfaces to use yarn types;
- update the yarn formatting workflow to process yarn visitors;
- update the stitch templates to make use of yarn visitors.

*** COMPLETED Move code to C++ 14                                     :story:
    CLOSED: [2016-01-23 Sat 21:28]

*Rationale*: We are building in C++ 14.

#+begin_quote
*Story*: As a dogen user or developer, I want to make use of C++-14
features so that I can generate more modern code.
#+end_quote

Now that the standard is out, we should move to it. Both clang and gcc
have some kind of support at present, so it should be a matter of
compiling on this mode. However, as we have gcc 4.7 on OSX and
Windows, we would have to upgrade these compilers first.

We have already proven that the code builds out of the box in
sprint 50.

*** COMPLETED Add initial support for MinGW and OSX                   :story:
    CLOSED: [2016-01-24 Sun 00:29]
    CLOCK: [2016-01-23 Sat 23:25]--[2016-01-24 Sun 00:27] =>  0:56
    CLOCK: [2016-01-23 Sat 22:23]--[2016-01-23 Sat 23:25] =>  1:02
    CLOCK: [2016-01-23 Sat 22:14]--[2016-01-23 Sat 22:22] =>  0:08
    CLOCK: [2016-01-23 Sat 21:57]--[2016-01-23 Sat 22:13] =>  0:16

It seems its possible to build using MinGW on windows:

- [[http://help.appveyor.com/discussions/questions/372-build-setup-for-a-c-program][Build setup for a C program]]
- [[https://github.com/imazen/libpng/blob/master/appveyor.yml][libpng appveyor.yml]]
- [[https://github.com/jibsen/brieflz/blob/0c6fb73984f11e697dfaade5cdc5e291c1655c67/appveyor.yml][Removing Git's sh from the path]]. See also
- [[https://www.appveyor.com/updates/2015/05/30][Appveyor adds support for MinGW]]
- [[http://altrepo.eu/matyapiro31/mingw-w64-thrift/blob/master/appveyor.yml][mingw-w64-thrift]]

We should probably enable this on our AppVeyor build matrix.

We can also start adding support for OSX.

For now the objective of this story is just to explore these builds;
we will address errors later on.

*** COMPLETED Treat shared pointers as JSON objects                   :story:
    CLOSED: [2016-01-24 Sun 22:45]

*Rationale*: this has been implemented some time ago.

At present we are not treating shared pointers as objects:

:         s << "\"shared_ptr\": \"empty shared pointer\"";

We need to start outputting them as JSON objects, just like we do for
containers, with a name for the "pointee".

*** POSTPONED Create a debug build for clang in travis                :story:
    CLOSED: [2016-01-24 Sun 15:23]
    CLOCK: [2016-01-18 Mon 22:14]--[2016-01-18 Mon 22:26] =>  0:12

In order to enable code coverage we need to have a debug build. For
this we need to setup travis with a build matrix, with two build types
for clang (debug and release).

Example YML: [[https://github.com/Microsoft/GSL/blob/master/.travis.yml][GSL]]

We almost made this work, but now we have a problem: using BUILD_TYPE
seems to disable the stage folder in travis (though it works
locally). We probably shouldn't use the stage folder since its not a
CMake idiom.

*** COMPLETED How to attach helper methods to types dynamically       :story:
    CLOSED: [2016-01-24 Sun 16:39]
    CLOCK: [2016-01-24 Sun 16:40]--[2016-01-24 Sun 16:46] =>  0:06
    CLOCK: [2016-01-24 Sun 15:29]--[2016-01-24 Sun 16:39] =>  1:10

In order to cope with the removal of nested type info, we need a way
to determine what helper methods are required for a given yarn type.

For this we need a way to allow helper methods to bind dynamically to
types. This can be done by using meta-data. The helper method
registers a name and the type uses that name it its key for helper
method. Where possible the helper method should use the name of the
STL concept it is binding to. We need settings support for reading
this field, and registration support for helper methods (registrar,
etc).

We should also find a nicer way to package helper methods, maybe
aligned to a model and type or concept.

Once this is done we need to remove the =object_types= that exist in
yarn just to figure out what helper methods to use.

This must be implemented as follows:

- aspect settings need an additional optional property: formatter
  class. This is just a string. We read them in with the bundle. We
  need to associate this helper name with a non-qualified formatter
  name (e.g. =class_implementation_formatter=). Simple map of string
  to string (helper class to formatter "class"). This should be doable
  from the existing dynamic fields infrastructure, but we may not have
  the required expansion yet.
- formattables workflow need an additional repository: helpers. This
  contains the helpers by name, by formatter name. It is constructed
  by iterating through the model and asking each type for their aspect
  settings and collecting the helper classes per formatter.
- formatter properties needs to store the helpers for a given
  formatter, read out from the repository above.
- formatters need a helper interface and a helper registrar. Each
  helper template needs to call the registrar and register itself
  using the helper and formatter class.
- formatter helper needs to ask the registrar for all helpers given
  current formatter class (ownership hierarchy, formatter name) and
  helper class. If none are found it errors.
- once this infrastructure is in place, we need to remove nested type
  info and make sure everything still works.

Actually, we can get away with just a "type family" because the type
itself need not care about which formatters bind to which
helpers. This means we can simply say =cpp.type_family= is
=smart_pointer= and then ask for all helpers for this formatter class
(the helper must know its formatter class) which bind to this type
family. Resurrecting notes on type families:

- =cpp.type_family=: string, to convert to enum. e.g.:
  =smart_pointer=. note: do not convert to enum.
- =cpp.type.family=: we need a "choice" value type for this. note: use
  of dot instead of underscore is better.
- re-read prior (detailed) analysis in [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_67.org#implement-io-helper-method-generator][Implement io helper method
  generator]].

In this view, we then do:

- rename aspect settings to type settings since they are no longer at
  the aspect level.
- add family type to aspect settings.
- create a new settings class to contain all of the dependent type
  families. We need a good name for this.
- update formattables workflow to generate this new class and append
  it to bundle, adding repository etc as required.
- in formatters: create registrar, interface etc and update all helper
  methods to register themselves.
- make context more efficient by using references and create all
  contexts up front, supplying the formatting workflow with just a
  container of name to context. Context should also have a container
  of helper methods performatter, created by querying the registrar.
- assistant has a method to generate all helpers.

Note: when time comes to support includes in helper methods, we can
take a similar approach as we do for formatters now. The helper method
implements some kind of include provider interface, which is then used
by the inclusion dependencies builder. The only slight snag is that we
need to first resolve the type into a type family and then go to the
helper interface.

*** COMPLETED How to handle composition and pointers                  :story:
    CLOSED: [2016-01-24 Sun 23:26]
    CLOCK: [2016-01-24 Sun 23:08]--[2016-01-24 Sun 23:18] =>  0:10
    CLOCK: [2016-01-24 Sun 21:59]--[2016-01-24 Sun 23:07] =>  1:08

At present we manually detect composition via a bit of a hack (string
comparisons) and then use a helper to break the infinite cycle. When
we move to a world of dynamic helpers this is no longer possible.

In addition, we are also relying on knowing if an instance of a type
is a pointer or not. This works because we rely on knowing if our
containing type is a smart pointer or not.

This points to two more general problem: detecting cycles and
determining when to forward declare. Whenever there is a cycle we need
to forward declare. In addition, whenever we have a pointer we can
forward declare. Since we always use pointers for cycles, this means
detecting a pointer is sufficient. However, a pointer is a C/C++
concept so we need to map it to a language agnostic concept that
exists at the yarn level.

Another problem is that we capture hash container keys. This is
required so we can tell types to include hash. However we do this by
marking a type as =object_types::hash_container=. This can be renamed
to associative container to make it a bit more generic. We could have
a boolean =is_container= followed by an enumeration =container_type=:

- associative
- sequence
- ordered

We need to look at the STL concepts for these to make sure we are at
the right level. Ideally there should also be a concept for a smart
pointer as a container of one or zero. Couldn't find any. We need to
find a good name such as "resource manager", "resource holder"? This
would mean that "is pointer" then becomes something akin to "is
potentially weak relationship" - some kind of language agnostic
version of "can use forward declaration".

The final conclusion of all of this is that we need to refactor object
types slightly to make it language neutral and to remove hacks such as
service etc, but on the main we can't get away from it. Further, we
need "is pointer" to become "is weak", and for it to be populated in
three cases:

- if the owning class is also part of the nested type;
- if a resource holder is holding on to a type;
- if a type has a pointer or reference to a type (when we do support
  c++ syntax). The parser would be responsible for setting the
  property in the front end and we'd have to not set it in yarn if it
  has already been set. This can be ignored for now.

In C++ "is weak" means a forward declaration. For the first case we
also need an additional property at the nested type level: is self
referencing. If true, this means we found a cycle.

With this clean up we can also use object types to make some
validation on the nested type instantiations (e.g. resource holder
must have one and only one type parameter, etc). Add this to validator
story.

Merged stories:

*Move language-specific object types to meta-data*

There are a number of object types that exist solely to provide the
method helpers with information:

- smart_pointer
- hash_container
- sequence_container
- ordered_container

These should be conveyed using the meta-data.

*Test data generator does not detect cycles in object graph*

At present we handle composition correctly, but not other forms of
cycles in the object graph.

Let model M be composed of class A with a member of type class B, and
class B with a member of type =shared_ptr= to class A. The test data
generated for such model will contain an infinite loop. We need a way
to detect such loops, potentially in SML, and then generate code which
breaks the loop.

This could be done by explicitly checking if the type of any member
variable loops back into the type itself. Of course one could conceive
cycles that involve many edges in the object graph, and for these we'd
still generate invalid code.

Another approach would be to have an unordered map of type
association; the map would have the IDs of every type as we go further
into the association graph. It would be pushed and popped as we go in
and out of branches; at the same time we need to have a look back
capacity to see the few elements in the stack. When a pattern emerges
that involved types of a certain ID, they would stop creating any
further associations.

*** COMPLETED Rename hash container to associative container          :story:
    CLOSED: [2016-01-26 Tue 23:12]
    CLOCK: [2016-01-26 Tue 22:30]--[2016-01-26 Tue 23:12] =>  0:42

As part of the yarn tidy-up to avoid C++'isms, rename hash container
to associative container and all associated names such as hash
container keys, etc.

Remove ordered container as we seem to use it for sets and maps but
there is no difference in handling between these and the hash
versions.

*** COMPLETED Clean up usage of is pointer in yarn                    :story:
    CLOSED: [2016-01-27 Wed 22:12]
    CLOCK: [2016-01-27 Wed 21:39]--[2016-01-27 Wed 22:13] =>  0:34
    CLOCK: [2016-01-26 Tue 23:13]--[2016-01-26 Tue 23:27] =>  0:14
    CLOCK: [2016-01-26 Tue 20:45]--[2016-01-26 Tue 22:00] =>  1:15

We need to make our usage of is pointer more language neutral. In
reality what we really mean is "can I use an incomplete class
declaration for this type?". See [[http://www-01.ibm.com/support/knowledgecenter/SSPSQF_9.0.0/com.ibm.xlcpp111.aix.doc/language_ref/cplr060.html][Incomplete class declarations]]. We
need to leave object types as is (e.g. with =smart_pointer=) because
we won't be changing nested type info just now, but we should at least
tidy up yarn properly.

There are three moving parts to this task:

- the association types in =Associatable=: we must not use the word
  "weak" to avoid confusion with UML terminology. We can use one of
  the following: opaque, incomplete, partial. In addition, "regular"
  is also a bad word. The opposites would then be: transparent,
  complete, full.
- the type instantiation in =nested_name=: are children opaque?
- the type itself: provides opaqueness? is opaqueness provider?

Tasks:

- create a property at object level: allows_incomplete

*Previous Understanding*

Tasks:

- rename hash container to associative container and all associated
  names such as hash container keys, etc.
- rename smart pointer to resource holder.
- investigate the usage of ordered container, and if not used, remove
  it.

We need to update all JSON documents, parser etc. Do not address the
"user defined" entries at this point.

Merged stories:

*Improve handling of weak relationships in nested name*

Tasks:

- rename is pointer to is weak;
- add a is self referencing property which is true if the nested name
  refers to the owning object.
- propagate these changes to nested type info and remove the composite
  vs domain type distinction in test data.

*** COMPLETED Rename aspect settings to element settings              :story:
    CLOSED: [2016-01-27 Wed 22:28]
    CLOCK: [2016-01-27 Wed 22:14]--[2016-01-27 Wed 22:28] =>  0:14
    CLOCK: [2016-01-24 Sun 21:46]--[2016-01-24 Sun 21:58] =>  0:12

These will no longer be confined to aspects so need to be
renamed. Actually =element= makes more sense than =type=, so it maps
back to =yarn::element= (at least conceptually).

*** COMPLETED Remove support for integrated io                        :story:
    CLOSED: [2016-01-27 Wed 23:22]
    CLOCK: [2016-01-27 Wed 22:44]--[2016-01-27 Wed 23:21] =>  0:37

We've been carrying this feature since the early days of dogen but we
don't really have a good use case for it now and it does add a lot of
complexity - its the only case where a feature can either be part of a
facet (types) or exist as its own facet (io). Remove it, and leave
just the io facet.

*** CANCELLED Implement io for inheritance in the io facet            :story:
    CLOSED: [2016-01-27 Wed 23:31]
    CLOCK: [2016-01-27 Wed 23:22]--[2016-01-27 Wed 23:31] =>  0:09

*Rationale*: this cannot be done; it is a limitation of how resolution
works in the presence of inheritance. See [[http://stackoverflow.com/questions/4164902/overloading-and-in-inherited-classes][Overloading << and >> in
inherited classes]].

At present we use the types facet to implement io when in
inheritance. This causes unnecessary complexity in the formatter
helpers. We need to try to implement it purely in the io facet.

*** STARTED Add a field for =quilt.cpp.family=                        :story:
    CLOCK: [2016-01-27 Wed 22:29]--[2016-01-27 Wed 22:43] =>  0:14

We need to:

- determine all of the required values given the existing helper
  methods.
- add the field.
- add a =family= property in =element= settings.

One interesting point: the helper methods represent either a concept
(i.e. smart pointer) or a concrete type (i.e. boost date time).

To avoid confusion we should probably use concept-like naming
(e.g. =SmartPointer=).

Names:

- AssociativeContainer
- SequenceContainer
- BoostDateTime
- Optional
- Pair
- BoostPath
- BoostPtime
- BoostPtree
- SmartPointer (to be merged with Optional into Pointer?)
- BoostTimeDuration
- BoostVariant
- String
- Bool
- Char
- Int

*** Stitcher log file names look weird                                :story:

At present we are writing files with names like:

: dogen.stitcher...log

*** Add an helper method interface                                    :story:

We should also investigate on the need for the nested type info
assistant.

Tasks:

- create interface.
- create a registrar for interface with family and formatter name.
- update all helpers to implement interface and to register
  themselves.

*** Create new settings class to represent dependent type families   :story:

We need a place to store all of the type families a given type is
associated with. This includes all of the processing required in
settings to attach this container to the bundle.

*** Make context non-generatable                                      :story:

We need to extend context in a few ways dogen does not yet support:

- make formatter properties and bundles by reference since we do not
  need to copy them.
- create a context generator that merges the containers and generates
  a map of type to context. Supply this context to the formatters
  workflow and to the formatters.

*** Add helper methods to context                                     :story:

Tasks:

- add a container of helper method interface to the context, by
  formatter name;
- add an activity to the formattables workflow that populates this
  container using the new settings class and the helper registrar.
- populate helper methods from context, removing all of the existing
  scaffolding code for helper methods.

*** Remove nested type info                                           :story:

Once all of the infrastructure is in place, we should not need this
class any more. Remove code from transformer and remove object types
and anything else that was used to dispatch based on type.

*** Add more types to =quilt::cpp= canned tests                       :story:

Originally we used the =*_info= types in the canned tests, but these
are all about to be removed. We need to hunt for types in the
=quilt::cpp= model and add those to the canned tests.

*** Implement formattables in terms of yarn types                     :epic:

At present formattables are just a shadow copy of yarn types plus
additional =cpp= specific types. In practice:

- for the types that are shadow copies, we could have helper utilities
  that do the translation on the fly (e.g. for names).
- for additional information which cannot be translated, we could have
  containers indexed by qualified name and query those just before we
  call the transformer. This is the case with formatter properties. We
  need something similar to house "type properties" such as
  =requires_stream_manipulators=. These could be moved into aspect
  settings.
- for types that do not exist in yarn, we could inherit from element;
  this is the case for registrar, forward declarations, cmakelists and
  odb options. Note that with this we are now saying that element
  space contains anything which can be modeled, regardless of if they
  are part of the programming language type system, or build system,
  etc. This is not ideal, but its not a problem just yet. We could
  update the factory to generate these types and then take a copy of
  the model and inject them in it.

*** Create a settings class for the "requires" settings               :story:

We need to populate these in a settings workflow of some kind.

*** Move all properties in =cpp= to a properties namespace            :story:

Once all formattables are gone, we should have only properties left in
the formattables namespace. We should then rename it to
properties. Thus we have two kinds of things: settings, which are a
direct translation of meta-data without any further processing and
properties which require processing.

Merged stories:

*Split formatter properties and associated classes from formattables*

We have two kinds of data: the formattables themselves (mapped from
yarn) and associated data (formatter properties). The latter is
totally independent. We should create a namespace for all of these
classes and a workflow that produces the data ready for consumption. A
tentative name is =manifest=.

*** Investigate slow down                                             :story:

With commit 7e89ddb we introduced a set of hacks to inject settings
and formatter properties into the repositories. This seems to have had
a very negative impact in performance. We need to ensure performance
goes back to normal after the hacks have been removed.

*** Tidy-up master include generation                                 :story:

At present we have one humongous hack in the factory to generate the
master includers. How to do this properly:

- wait until we start using yarn types.
- loop through the yarn model instead of the path derivatives.
- use a visitor to dispatch the types.
- do not filter out services?
- filter registrars etc based on type dispatching.

*** Create a UML profile to formalise yarn concepts                   :story:

Profile should include the hashable, etc changes.

*** Create a map between UML/MOF terminology and yarn                 :story:

It would be helpful to know what a yarn type means in terms of
UML/MOF, and perhaps even explain why we have chosen certain names
instead of the UML ones. We should also cover the modeling of
relationships and the relation between yarn concepts and UML/MOF
classes. This will form a chapter in the manual.

The UML specification is available [[http://www.omg.org/spec/UML/2.5/][here]] and MOF specification is
available [[http://www.omg.org/spec/MOF/2.5][here]].

We need a way to uniquely identify a property. This could be done by
appending the containing type's qualified name to the property name.

See also [[http://www.uml-diagrams.org/][The Unified Modeling Language]] for a more accessible
treatment.

See [[http://www-01.ibm.com/support/knowledgecenter/SS5JSH_9.1.2/com.ibm.xtools.transform.uml2.cpp.doc/topics/rucppprofile.html][Stereotypes of the UML-to-C++ transformation profile]] for ideas.

*** Remove =service= stereotype                                       :story:

This really just means non-generatable, or do not generate. We already
have a stereotype for this. Remove =service= and any other stereotype
which is not being used such as =value_object= etc.

Actually, non-generatable is not a stereotype really. We should
instead have some meta-data that can affect generation:

- do not generate: do nothing at all. For references only. If a file
  exists with this file name, it will be deleted as part of
  housekeeping.
- generate blank file if it doesn't exist: we don't even want a
  template.
- generate with content if it doesn't exist, do not touch otherwise:
  what we call services at the moment. Generate a "template" that then
  gets filled in manually.
- generate and merge: merge the contents of the generated file with
  the current contents in the file system. When we support merging.
- generate and overwrite: generate the file and overwrite whatever
  exists in the file system.

This could be called "generation policy".

The second behaviour we get for free with services is that we disable
all facets except for types. A few points:

- we may want to have io, serialisation, etc. This is not possible at
  present. If a state of a service is made up of supported types, we
  could even use existing code generation.
- in order for this to be implemented correctly we need to hook in to
  the enablement management somehow. In addition, it seems each facet
  can have its own generation policy. For example we may want to
  manually create types but automatically generate io.
- the best way to handle this may be to setup "enablement profiles"
  that the user can hook up to. For example we could have a "default"
  profile that enables all facets (or uses facet defaults), a second
  "service" profile that enables types with partial generation and io
  with full generation and so on. We probably also need "generation
  profiles" to go with "enablement profiles".

** Deprecated
*** CANCELLED Consider renaming nested name                           :story:
    CLOSED: [2016-01-07 Thu 20:18]

*Rationale*: the final conclusion on this was that nested name is the
best of a bad bunch. See Sprint 77 stories on renames for details.

*New understanding*:

This story requires further analysis. Blindly following the composite
pattern was tried but it resulted in a lot of inconsistencies because
we then had to follow MEC-33 and create =abstract_qname=; however, the
nested qname does not really behave like a composite qname; its more
like the difference between a type in isolation and a type
instantiated as an argument of a function. For example, whilst the
type in isolation may have unknown template parameters, presumably, as
an argument of a function these have been instantiated with real
types.

One way to solve this is just to make the type name a bit more
explicit rather than try to imply the composite pattern
(e.g. "nested"). We need a name that signifies "instantiated
type". Look at the C++ standard for the difference between defining a
generic type and instantiating a generic type.

No good names yet (type reference, type instantiation, instantiated
name). What are we trying to represent: an identifier which points to
a complete definition of a name such that the name can be instantiated
as a type in the underlying language. By "instantiated" we mean used
to define variables of this type. In this light: instantiable name,
definable name? If we choose instantiable name, we could then rename
"children" to type arguments.

Other notes:

- there is such a thing as a element instance identifier. We call it
  nested name at present. The element instance identifier identifies
  instantiations of types. It models two cases: for the case where the
  type has no type parameters, the instance identifier is equal to the
  element identifier; for all other cases, it is a hierarchical
  collection of element identifiers, modeling the type parameter
  structure.

*Previous understanding*:

We should just follow the composite pattern in the naming.
*** CANCELLED ODB options file is generated even when disabled        :story:
    CLOSED: [2016-01-20 Wed 20:39]

*Rationale*: this was due to incorrect key name for
=yarn.dia.comment=. We already have a story for better validation.

At present it seems the file is always generated regardless of the
meta-data. This is probably due to a typo in the field name.

*** CANCELLED Access model name from within formatters workflow       :story:
    CLOSED: [2016-01-24 Sun 15:25]

*Rationale*: We removed the need for the model name when building
names.

In order for the assistant to build names, it will need to be able to
access the yarn model name.
