diff --git a/doc/agile/release_notes_sprint_39.org b/doc/agile/release_notes_sprint_39.org
index 6ebcfe6..b8d70dc 100644
--- a/doc/agile/release_notes_sprint_39.org
+++ b/doc/agile/release_notes_sprint_39.org
@@ -10,18 +10,19 @@ This file contains all stories that were closed during sprint 39.
 ** Development Stories Implemented
 
 #+begin: clocktable :maxlevel 3 :scope subtree
-Clock summary at [2013-11-19 Tue 18:24]
+Clock summary at [2013-11-19 Tue 21:50]
 
 | Headline                                                        | Time   |      |      |
 |-----------------------------------------------------------------+--------+------+------|
-| *Total time*                                                    | *1:22* |      |      |
+| *Total time*                                                    | *1:33* |      |      |
 |-----------------------------------------------------------------+--------+------+------|
-| Development Stories Implemented                                 |        | 1:22 |      |
-| IMPLEMENTATION Release notes and backlog grooming               |        |      | 0:06 |
+| Development Stories Implemented                                 |        | 1:33 |      |
+| IMPLEMENTATION Release notes and backlog grooming               |        |      | 0:17 |
 | IMPLEMENTATION Finish indexer class and plug it to SML workflow |        |      | 1:16 |
 #+end:
 
 *** IMPLEMENTATION Release notes and backlog grooming                  :task:
+    CLOCK: [2013-11-19 Tue 21:38]--[2013-11-19 Tue 21:49] =>  0:11
     CLOCK: [2013-11-19 Tue 07:56]--[2013-11-19 Tue 08:02] =>  0:06
 
 *** IMPLEMENTATION Finish indexer class and plug it to SML workflow   :story:
@@ -32,6 +33,7 @@ code from =extrator= and =transformer= (leaf processing) into
 =indexer=.
 
 **** IMPLEMENTATION Finish adding unit tests for  modeled concepts     :task:
+     CLOCK: [2013-11-19 Tue 21:50]
      CLOCK: [2013-11-19 Tue 17:42]--[2013-11-19 Tue 18:24] =>  0:42
      CLOCK: [2013-11-19 Tue 08:06]--[2013-11-19 Tue 08:40] =>  0:34
 
diff --git a/projects/sml/include/dogen/sml/types/indexer.hpp b/projects/sml/include/dogen/sml/types/indexer.hpp
index 480ea27..2b174cf 100644
--- a/projects/sml/include/dogen/sml/types/indexer.hpp
+++ b/projects/sml/include/dogen/sml/types/indexer.hpp
@@ -87,14 +87,6 @@ private:
         std::unordered_set<sml::qname>& processed_qnames, const model& m) const;
 
     /**
-     * @brief Given an initial qname and a list of concepts, it
-     * expands it to take into account all the refinement
-     * relationships these may be part of.
-     */
-    void expand_concept_hierarchy(const model& m, const qname& qn,
-        std::list<qname>& concepts) const;
-
-    /**
      * @brief Populates the all properties container.
      */
     void populate_all_properties(abstract_object& o, const model& m);
@@ -102,38 +94,48 @@ private:
 private:
     /**
      * @brief Populates the modeled concepts relationship of every
-     * type involved in modeling concepts.
+     * object that models one or more concepts.
      */
-    void index_modeled_concepts(model& m);
+    void expand_modeled_concepts(model& m);
 
     /**
-     * @brief Indexes inheritance information for the leaf and all of
-     * its parents.
+     * @brief Indexes a specific object.
+     *
+     * This amounts to:
+     *
+     * @li Indexing relationships with other objects in the model.
+     *
+     * @li Updating all of the computed property containers such as
+     * all properties and inherited properties for a given abstract
+     * objects.
      */
-    void index_inheritance(abstract_object& parent, abstract_object& leaf,
+    void index_object(abstract_object& parent, abstract_object& leaf,
         model& m);
 
     /**
-     * @brief Indexes information related to inheritance relationships
-     * across all objects in the model.
+     * @brief Indexes all objects in the model.
      */
-    void index_inheritance(model& m);
+    void index_objects(model& m);
 
     /**
-     * @brief Indexes information related to refinement relationships
-     * for a given concept.
+     * @brief Populates index information in a concept.
+     *
+     * This amounts to:
+     *
+     * @li Expanding the refined list of concepts taking into account
+     * the concept inheritance graph, and finding the final distinct
+     * list of concepts one is refining;
+     *
+     * @li Updating all of the computed property containers such as
+     * all properties and inherited properties for a given concept.
      */
-    void index_refinements(concept& c, model& m,
+    void index_concept(concept& c, model& m,
         std::unordered_set<sml::qname>& processed_qnames);
 
     /**
-     * @brief Indexes information related to refinement relationships
-     * across all concepts the model.
+     * @brief Indexes all concepts in the model.
      */
-    void index_refinements(model& m);
-
-private:
-    void index(abstract_object& o);
+    void index_concepts(model& m);
 
 public:
     /**
diff --git a/projects/sml/spec/indexer_spec.cpp b/projects/sml/spec/indexer_spec.cpp
index c205a49..c316e2a 100644
--- a/projects/sml/spec/indexer_spec.cpp
+++ b/projects/sml/spec/indexer_spec.cpp
@@ -230,7 +230,7 @@ BOOST_AUTO_TEST_CASE(model_with_one_level_of_concept_inheritance_results_in_expe
             BOOST_CHECK(o.local_properties().size() == 1);
             BOOST_CHECK(o.inherited_properties().empty());
             BOOST_CHECK(o.all_properties().size() == 3);
-            // BOOST_CHECK(o.modeled_concepts().size() == 2);
+            BOOST_CHECK(o.modeled_concepts().size() == 2);
         } else
             BOOST_FAIL("Unexpected object: " << qn);
     }
diff --git a/projects/sml/src/types/indexer.cpp b/projects/sml/src/types/indexer.cpp
index eb6b2c7..3d2ecad 100644
--- a/projects/sml/src/types/indexer.cpp
+++ b/projects/sml/src/types/indexer.cpp
@@ -21,6 +21,7 @@
 #include <set>
 #include <list>
 #include <unordered_map>
+#include <unordered_set>
 #include <boost/lexical_cast.hpp>
 #include "dogen/utility/log/logger.hpp"
 #include "dogen/sml/io/qname_io.hpp"
@@ -106,24 +107,6 @@ void indexer::properties_for_concept(const sml::qname& qn,
     properties.insert(properties.end(), cp.begin(), cp.end());
 }
 
-void indexer::expand_concept_hierarchy(const model& m, const qname& qn,
-    std::list<qname>& concepts) const {
-    const auto i(m.concepts().find(qn));
-    if (i == m.concepts().end()) {
-        std::ostringstream s;
-        s << orphan_concept << ". concept: "
-          << qn.simple_name() << " could not be found.";
-
-        BOOST_LOG_SEV(lg, error) << s.str();
-        BOOST_THROW_EXCEPTION(indexing_error(s.str()));
-    }
-
-    for (const auto& c : i->second.refines())
-        expand_concept_hierarchy(m, c, concepts);
-
-    concepts.push_back(qn);
-}
-
 void indexer::populate_all_properties(abstract_object& o, const model& m) {
     for (const auto& pair : o.inherited_properties()) {
         o.all_properties().insert(o.all_properties().end(),
@@ -144,7 +127,7 @@ void indexer::populate_all_properties(abstract_object& o, const model& m) {
 }
 
 void indexer::
-index_inheritance(abstract_object& parent, abstract_object& leaf, model& m) {
+index_object(abstract_object& parent, abstract_object& leaf, model& m) {
     const bool is_root(!parent.is_child());
 
     if (is_root) {
@@ -162,7 +145,7 @@ index_inheritance(abstract_object& parent, abstract_object& leaf, model& m) {
     const auto parents(find_relationships(relationship_types::parents, parent));
     for (auto& qn : parents) {
         auto& grand_parent(find_object(qn, m));
-        index_inheritance(grand_parent, leaf, m);
+        index_object(grand_parent, leaf, m);
         parent.inherited_properties().insert(
             std::make_pair(grand_parent.name(), grand_parent.all_properties()));
     }
@@ -170,7 +153,7 @@ index_inheritance(abstract_object& parent, abstract_object& leaf, model& m) {
     populate_all_properties(parent, m);
 }
 
-void indexer::index_inheritance(model& m) {
+void indexer::index_objects(model& m) {
     BOOST_LOG_SEV(lg, debug) << "Indexing inheritance. Objects: "
                              << m.objects().size();
 
@@ -193,13 +176,13 @@ void indexer::index_inheritance(model& m) {
         const auto parents(find_relationships(relationship_types::parents, o));
         for (auto& qn : parents) {
             auto& parent(find_object(qn, m));
-            index_inheritance(parent, o, m);
+            index_object(parent, o, m);
         }
     }
 }
 
-void indexer::index_modeled_concepts(model& m) {
-    BOOST_LOG_SEV(lg, debug) << "Indexing modeled concepts. Objects: "
+void indexer::expand_modeled_concepts(model& m) {
+    BOOST_LOG_SEV(lg, debug) << "Expanding modeled concepts. Objects: "
                              << m.objects().size();
 
     for (auto& pair : m.objects()) {
@@ -208,7 +191,7 @@ void indexer::index_modeled_concepts(model& m) {
         if (o.generation_type() == generation_types::no_generation)
             continue;
 
-        BOOST_LOG_SEV(lg, debug) << "Indexing concepts for type " << o.name();
+        BOOST_LOG_SEV(lg, debug) << "Expanding concepts for type " << o.name();
         const auto rt(relationship_types::modeled_concepts);
         const auto i(o.relationships().find(rt));
         if (i == o.relationships().end() || i->second.empty())
@@ -221,12 +204,25 @@ void indexer::index_modeled_concepts(model& m) {
          * with other concepts.
          */
         std::list<qname> expanded_modeled_concepts;
-        for (const auto& qn : i->second)
-            expand_concept_hierarchy(m, qn, expanded_modeled_concepts);
+        for (const auto& qn : i->second) {
+            const auto j(m.concepts().find(qn));
+            if (j == m.concepts().end()) {
+                std::ostringstream s;
+                s << orphan_concept << ". concept: "
+                  << qn.simple_name() << " could not be found.";
+
+                BOOST_LOG_SEV(lg, error) << s.str();
+                BOOST_THROW_EXCEPTION(indexing_error(s.str()));
+            }
+
+            expanded_modeled_concepts.insert(
+                expanded_modeled_concepts.begin(),
+                j->second.refines().begin(), j->second.refines().end());
+        }
 
         i->second.clear();
-        for (const auto& qn : expanded_modeled_concepts)
-            i->second.push_back(qn);
+        i->second.insert(i->second.begin(), expanded_modeled_concepts.begin(),
+            expanded_modeled_concepts.end());
     }
 
     /*
@@ -288,11 +284,7 @@ void indexer::index_modeled_concepts(model& m) {
     }
 }
 
-void indexer::index(abstract_object& /*o*/) {
-}
-
-
-void indexer::index_refinements(concept& c, model& m,
+void indexer::index_concept(concept& c, model& m,
     std::unordered_set<sml::qname>& processed_qnames) {
     if (processed_qnames.find(c.name()) != processed_qnames.end())
         return;
@@ -300,6 +292,8 @@ void indexer::index_refinements(concept& c, model& m,
     c.all_properties().insert(c.all_properties().end(),
         c.local_properties().begin(), c.local_properties().end());
 
+    std::list<qname> expanded_refines;
+    std::unordered_set<qname> expanded_unique_refines;
     for (auto& qn : c.refines()) {
         auto i(m.concepts().find(qn));
         if (i == m.concepts().end()) {
@@ -309,27 +303,40 @@ void indexer::index_refinements(concept& c, model& m,
         }
 
         auto& parent(i->second);
-        index_refinements(parent, m, processed_qnames);
+        index_concept(parent, m, processed_qnames);
+        expanded_unique_refines.insert(parent.refines().begin(),
+            parent.refines().end());
+        expanded_refines.insert(expanded_refines.end(),
+            parent.refines().begin(), parent.refines().end());
 
         c.inherited_properties().insert(std::make_pair(parent.name(),
-                parent.local_properties()));
+                parent.all_properties()));
 
         c.all_properties().insert(c.all_properties().end(),
-            parent.local_properties().begin(), parent.local_properties().end());
+            parent.all_properties().begin(), parent.all_properties().end());
+    }
+
+    c.refines().clear();
+    for (auto& qn : expanded_refines) {
+        const auto i(expanded_unique_refines.find(qn));
+        if (i != expanded_unique_refines.end()) {
+            c.refines().push_back(qn);
+            expanded_unique_refines.erase(i);
+        }
     }
     processed_qnames.insert(c.name());
 }
 
-void indexer::index_refinements(model& m) {
+void indexer::index_concepts(model& m) {
     std::unordered_set<sml::qname> processed_qnames;
     for (auto& pair : m.concepts())
-        index_refinements(pair.second, m, processed_qnames);
+        index_concept(pair.second, m, processed_qnames);
 }
 
 void indexer::index(model& m) {
-    index_refinements(m);
-    index_modeled_concepts(m);
-    index_inheritance(m);
+    index_concepts(m);
+    expand_modeled_concepts(m);
+    index_objects(m);
 }
 
 } }
