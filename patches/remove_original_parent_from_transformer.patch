--- a/projects/dia_to_sml/src/types/transformer.cpp
+++ b/projects/dia_to_sml/src/types/transformer.cpp
@@ -264,7 +264,6 @@ void transformer::update_abstract_object(sml::abstract_object& ao,
         BOOST_LOG_SEV(lg, debug) << "Setting parent for: "
                                  << ao.name().simple_name() << " as "
                                  << j->second.simple_name();
-        ao.parent_name(j->second);
         ao.is_child(true);
         using sml::relationship_types;
         ao.relationships()[relationship_types::parents].push_back(j->second);
@@ -277,54 +276,76 @@ void transformer::update_abstract_object(sml::abstract_object& ao,
     ao.is_parent(j != context_.parent_ids().end());
     context_.id_to_qname().insert(std::make_pair(o.id(), ao.name()));
 
-    if (!ao.parent_name()) {
+    if (!ao.is_child()) {
         ao.is_inheritance_root(ao.is_parent());
         context_.original_parent().insert(
             std::make_pair(ao.name(), ao.name()));
     } else {
-        const auto k(context_.original_parent().find(*ao.parent_name()));
-        if (k == context_.original_parent().end()) {
-            BOOST_LOG_SEV(lg, error) << "Could not find the original parent of "
+        using sml::relationship_types;
+        const auto k(ao.relationships().find(relationship_types::parents));
+        if (k == ao.relationships().end() && k->second.empty()) {
+            BOOST_LOG_SEV(lg, error) << "Object is child but has no parents "
                                      << ao.name().simple_name();
 
             BOOST_THROW_EXCEPTION(
-                transformation_error(original_parent_not_found +
+                transformation_error(parent_not_found +
                     ao.name().simple_name()));
         }
-        ao.original_parent_name(k->second);
-        context_.original_parent().insert(
-            std::make_pair(ao.name(), k->second));
-        using sml::relationship_types;
-        ao.relationships()[relationship_types::original_parents].push_back(
-            k->second);
+
+        for (const auto& parent_name : k->second) {
+            const auto j(context_.original_parent().find(parent_name));
+            if (j == context_.original_parent().end()) {
+                BOOST_LOG_SEV(lg, error)
+                    << "Could not find the original parent of "
+                    << ao.name().simple_name();
+
+                BOOST_THROW_EXCEPTION(
+                    transformation_error(original_parent_not_found +
+                        ao.name().simple_name()));
+            }
+            context_.original_parent().insert(
+                std::make_pair(ao.name(), j->second));
+            using sml::relationship_types;
+            ao.relationships()[relationship_types::original_parents].push_back(
+                j->second);
+        }
     }
 
     using sml::generation_types;
     // FIXME: massive hack
     const bool is_service(dynamic_cast<sml::service*>(&ao) != 0);
-    if (!ao.is_parent() && ao.parent_name() && !is_service) {
-        auto parent(ao.parent_name());
-        while (parent) {
-            auto k(context_.leaves().find(*parent));
-            if (k == context_.leaves().end()) {
+    if (!ao.is_parent() && ao.is_child() && !is_service) {
+        using sml::relationship_types;
+        const auto k(ao.relationships().find(relationship_types::parents));
+        if (k == ao.relationships().end() && k->second.empty()) {
+            BOOST_LOG_SEV(lg, error) << "Object is child but has no parents "
+                                     << ao.name().simple_name();
+
+            BOOST_THROW_EXCEPTION(
+                transformation_error(parent_not_found +
+                    ao.name().simple_name()));
+        }
+
+        for (const auto& parent : k->second) {
+            auto j(context_.leaves().find(parent));
+            if (j == context_.leaves().end()) {
                 const std::list<sml::qname> l { ao.name() };
-                context_.leaves().insert(std::make_pair(*parent, l));
+                context_.leaves().insert(std::make_pair(parent, l));
             } else
-                k->second.push_back(ao.name());
+                j->second.push_back(ao.name());
 
-            auto j(context_.model().objects().find(*parent));
-            if (j == context_.model().objects().end()) {
+            auto m(context_.model().objects().find(parent));
+            if (m == context_.model().objects().end()) {
                 BOOST_LOG_SEV(lg, error) << "Could not find the parent of "
-                                         << parent->simple_name();
+                                         << parent.simple_name();
                 BOOST_THROW_EXCEPTION(transformation_error(parent_not_found +
-                        parent->simple_name()));
+                        parent.simple_name()));
             }
-            parent = j->second->parent_name();
         }
     }
 
     ao.is_immutable(p.is_immutable());
-    if ((ao.is_parent() || ao.parent_name()) && p.is_immutable())  {
+    if ((ao.is_parent() || ao.is_child()) && p.is_immutable())  {
         BOOST_LOG_SEV(lg, error) << immutabilty_with_inheritance
                                  << ao.name().simple_name();
 
