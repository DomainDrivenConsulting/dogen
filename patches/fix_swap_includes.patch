diff --git a/doc/agile/release_notes_sprint_42.org b/doc/agile/release_notes_sprint_42.org
index b096047..e3027d4 100644
--- a/doc/agile/release_notes_sprint_42.org
+++ b/doc/agile/release_notes_sprint_42.org
@@ -10,13 +10,13 @@ This file contains all stories that were closed during sprint 42.
 ** Development Stories Implemented
 
 #+begin: clocktable :maxlevel 3 :scope subtree
-Clock summary at [2014-01-07 Tue 08:45]
+Clock summary at [2014-01-07 Tue 18:32]
 
 | Headline                                                                | Time    |       |       |
 |-------------------------------------------------------------------------+---------+-------+-------|
-| *Total time*                                                            | *35:11* |       |       |
+| *Total time*                                                            | *35:51* |       |       |
 |-------------------------------------------------------------------------+---------+-------+-------|
-| Development Stories Implemented                                         |         | 35:11 |       |
+| Development Stories Implemented                                         |         | 35:51 |       |
 | IMPLEMENTATION Release notes and backlog grooming                       |         |       |  1:48 |
 | COMPLETED Investigate availability of boost 1.55 for debian             |         |       |  0:18 |
 | COMPLETED Add more valgrind suppressions                                |         |       |  0:06 |
@@ -28,7 +28,7 @@ Clock summary at [2014-01-07 Tue 08:45]
 | COMPLETED Solve the new lines issue in formatters                       |         |       | 13:42 |
 | COMPLETED Add include file support to main type formatter               |         |       |  1:13 |
 | COMPLETED Design a cleaner meta-data API                                |         |       |  0:11 |
-| IMPLEMENTATION Update all tests to use =om= formatter                   |         |       |  5:29 |
+| IMPLEMENTATION Update all tests to use =om= formatter                   |         |       |  6:09 |
 | Includer generation should be done from meta-data                       |         |       |  0:18 |
 #+end:
 
@@ -493,13 +493,17 @@ We need to add includes via relationships to types formatter.
       CLOCK: [2014-01-07 Tue 07:10]--[2014-01-07 Tue 07:20] =>  0:10
 
 ***** IMPLEMENTATION Investigate the need for includes of =iosfwd= and =algorithm=
+      CLOCK: [2014-01-07 Tue 17:52]--[2014-01-07 Tue 18:32] =>  0:40
       CLOCK: [2014-01-07 Tue 08:35]--[2014-01-07 Tue 08:44] =>  0:09
 
 At present we seem to always be including these two headers if
 inheritance is present. Is this required?
 
-:-    if (o.all_properties().empty())
-:+    if (o.all_properties().empty() && !o.is_parent() && !o.is_child())
+: -    if (o.all_properties().empty())
+: +    if (o.all_properties().empty() && !o.is_parent() && !o.is_child())
+
+Actually, we need to split the swap meta-data into internal and
+external, and only add includes if external swap is required.
 
 *** Add tests for =flat_name_builder=                                 :story:
 
diff --git a/projects/om/src/types/cpp_types_main_header_file_formatter.cpp b/projects/om/src/types/cpp_types_main_header_file_formatter.cpp
index 7d19dc9..019bcd7 100644
--- a/projects/om/src/types/cpp_types_main_header_file_formatter.cpp
+++ b/projects/om/src/types/cpp_types_main_header_file_formatter.cpp
@@ -210,9 +210,6 @@ visit(const sml::object& o) {
         includes_.user().push_back(fn);
     }
 
-    if (o.all_properties().empty())
-        return;
-
     // associations
     using sml::relationship_types;
     includes_for_relationship(o, relationship_types::regular_associations);
@@ -222,10 +219,10 @@ visit(const sml::object& o) {
 
     // hard-coded includes
 
-    // algorithm: for the swap function.
-    includes_.system().push_back(algorithm_include);
+    using types = sml::tags::cpp::types;
+    if (reader.is_true(types::generate_external_swap))
+        includes_.system().push_back(algorithm_include);
 
-    // iosfwd: for the inserter operator
     using io = sml::tags::cpp::io;
     if (reader.is_true(io::enable_integrated_io))
         includes_.system().push_back(iosfwd_include);
@@ -302,8 +299,8 @@ external_equality(const sml::object& o) const {
 
 void cpp_types_main_header_file_formatter::
 external_swap(const sml::object& o) const {
-    // swap overload is only available in leaf classes - MEC++-33
-    if (o.all_properties().empty() || o.is_parent() || o.is_immutable())
+    sml::meta_data_reader reader(o.meta_data());
+    if (reader.is_false(sml::tags::cpp::types::generate_external_swap))
         return;
 
     {
@@ -316,7 +313,6 @@ external_swap(const sml::object& o) const {
                          << "inline void swap(" << std::endl;
         {
             positive_indenter_scope s(helper_->stream());
-            sml::meta_data_reader reader(o.meta_data());
             const auto n(reader.get(sml::tags::cpp::types::qualified_name));
             helper_->stream() << n << "& lhs," << std::endl
                              << n << "& rhs) ";
@@ -741,11 +737,7 @@ to_stream(const sml::object& o) const {
 void cpp_types_main_header_file_formatter::
 internal_swap(const sml::object& o) const {
     sml::meta_data_reader reader(o.meta_data());
-    if (reader.is_false(sml::tags::cpp::types::generate_swap))
-        return;
-
-    const auto props(o.all_properties());
-    if ((props.empty() && !o.is_parent()) || o.is_immutable())
+    if (reader.is_false(sml::tags::cpp::types::generate_internal_swap))
         return;
 
     // swap is only public in leaf classes - MEC++-33
diff --git a/projects/sml/include/dogen/sml/types/tags.hpp b/projects/sml/include/dogen/sml/types/tags.hpp
index c3a1521..62f7962 100644
--- a/projects/sml/include/dogen/sml/types/tags.hpp
+++ b/projects/sml/include/dogen/sml/types/tags.hpp
@@ -321,10 +321,16 @@ struct tags {
             static const std::string generate_accept;
 
             /**
-             * @brief If set to true, swap function will be
+             * @brief If set to true, external swap function will be
              * generated.
              */
-            static const std::string generate_swap;
+            static const std::string generate_external_swap;
+
+            /**
+             * @brief If set to true, internal swap function will be
+             * generated.
+             */
+            static const std::string generate_internal_swap;
 
             /**
              * @brief Parameters associated with the types header file.
diff --git a/projects/sml/src/test/mock_model_factory.cpp b/projects/sml/src/test/mock_model_factory.cpp
index 2ba785d..2d79950 100644
--- a/projects/sml/src/test/mock_model_factory.cpp
+++ b/projects/sml/src/test/mock_model_factory.cpp
@@ -53,6 +53,11 @@ const std::string unsigned_int("unsigned int");
 
 const std::string documentation("Some documentation");
 
+const std::string types_main_header("types_");
+const std::string types_forward_declaration("types_fwd_");
+const std::string serialization_main_header("serialization_");
+const std::string serialization_forward_declaration("serialization_fwd_");
+
 const std::string licence_name("gpl_v2");
 const std::string modeline_group_name("emacs");
 const std::string marker("SAMPLE_MARKER");
@@ -328,22 +333,6 @@ void insert_object(dogen::sml::model& m, const dogen::sml::object& o) {
     m.objects().insert(std::make_pair(o.name(), o));
 }
 
-std::string filename_for_qname(const dogen::sml::qname& qn) {
-    boost::filesystem::path r;
-    for (const auto& p : qn.external_module_path())
-        r /= p;
-
-    r /= qn.model_name();
-
-    if (qn.simple_name().empty())
-        r /= qn.model_name();
-    else
-        r /= qn.simple_name();
-
-    r.replace_extension(header_extension);
-    return r.generic_string();
-}
-
 template<typename Taggable>
 void add_test_tags(Taggable& t) {
     dogen::sml::meta_data_writer writer(t.meta_data());
@@ -352,7 +341,19 @@ void add_test_tags(Taggable& t) {
     writer.add(dogen::sml::tags::cpp::types::header_file::
         generate_header_guards, dogen::sml::tags::bool_true);
     writer.add(dogen::sml::tags::cpp::types::header_file::file_name,
-        filename_for_qname(t.name()));
+        types_main_header + t.name().simple_name());
+    writer.add(
+        dogen::sml::tags::cpp::types::forward_declarations_file::file_name,
+        types_forward_declaration + t.name().simple_name());
+
+    writer.add(
+        dogen::sml::tags::cpp::serialization::boost::header_file::file_name,
+        serialization_main_header + t.name().simple_name());
+    writer.add(
+        dogen::sml::tags::cpp::serialization::boost::
+        forward_declarations_file::file_name,
+        serialization_forward_declaration + t.name().simple_name());
+
     writer.add(dogen::sml::tags::licence_name, licence_name);
     writer.add(dogen::sml::tags::copyright_holder, copyright_holders);
     writer.add(dogen::sml::tags::modeline_group_name, modeline_group_name);
diff --git a/projects/sml/src/types/meta_data_tagger.cpp b/projects/sml/src/types/meta_data_tagger.cpp
index c7c3640..05f03d2 100644
--- a/projects/sml/src/types/meta_data_tagger.cpp
+++ b/projects/sml/src/types/meta_data_tagger.cpp
@@ -1060,15 +1060,23 @@ void meta_data_tagger::tag(object& o) const {
     writer.add_if_key_not_found(
         tags::cpp::types::generate_explicit_move_constructor, tags::bool_false);
 
-    if (!o.all_properties().empty() && !o.is_parent() && !o.is_immutable()) {
-        writer.add_if_key_not_found(tags::cpp::types::generate_swap,
-            tags::bool_true);
+    if (!o.all_properties().empty() && !o.is_immutable()) {
+        if (!o.is_parent()) {
+            // swap overload is only available in leaf classes - MEC++-33
+            writer.add_if_key_not_found(
+                tags::cpp::types::generate_external_swap,
+                tags::bool_true);
 
-        if (o.is_child()) {
-            // assignment is only available in leaf classes - MEC++-33
+            if (o.is_child()) {
+                // assignment is only available in leaf classes - MEC++-33
+                writer.add_if_key_not_found(
+                    tags::cpp::types::generate_explicit_assignment_operator,
+                    tags::bool_false);
+            }
+        } else {
             writer.add_if_key_not_found(
-                tags::cpp::types::generate_explicit_assignment_operator,
-                tags::bool_false);
+                tags::cpp::types::generate_internal_swap,
+                tags::bool_true);
         }
     }
 
diff --git a/projects/sml/src/types/tags.cpp b/projects/sml/src/types/tags.cpp
index 84bf17c..5fc488e 100644
--- a/projects/sml/src/types/tags.cpp
+++ b/projects/sml/src/types/tags.cpp
@@ -90,7 +90,10 @@ const std::string tags::cpp::types::generate_complete_constructor(
     "cpp.types.generate_complete_constructor");
 const std::string tags::cpp::types::generate_equality(
     "cpp.types.generate_equality");
-const std::string tags::cpp::types::generate_swap("cpp.types.generate_swap");
+const std::string tags::cpp::types::generate_internal_swap(
+    "cpp.types.generate_internal_swap");
+const std::string tags::cpp::types::generate_external_swap(
+    "cpp.types.generate_external_swap");
 const std::string tags::cpp::types::generate_friends(
     "cpp.types.generate_friends");
 const std::string tags::cpp::types::generate_to_stream(
