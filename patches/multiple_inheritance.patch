diff --git a/projects/input_models/yarn.dia b/projects/input_models/yarn.dia
index a5426b7..d7ab25e 100644
--- a/projects/input_models/yarn.dia
+++ b/projects/input_models/yarn.dia
@@ -15377,13 +15377,13 @@ This is used to break cycles where required.#</dia:string>
         <dia:point val="-176,-15"/>
       </dia:attribute>
       <dia:attribute name="obj_bb">
-        <dia:rectangle val="-176.05,-15.05;-161.975,-5.75"/>
+        <dia:rectangle val="-176.05,-15.05;-162.36,-5.75"/>
       </dia:attribute>
       <dia:attribute name="elem_corner">
         <dia:point val="-176,-15"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="13.975"/>
+        <dia:real val="13.59"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="9.2000000000000011"/>
@@ -15570,16 +15570,16 @@ This is used to break cycles where required.#</dia:string>
         </dia:composite>
         <dia:composite type="umlattribute">
           <dia:attribute name="name">
-            <dia:string>#root_parent#</dia:string>
+            <dia:string>#in_inheritance_relationship#</dia:string>
           </dia:attribute>
           <dia:attribute name="type">
-            <dia:string>#boost::optional&lt;name&gt;#</dia:string>
+            <dia:string>#bool#</dia:string>
           </dia:attribute>
           <dia:attribute name="value">
             <dia:string>##</dia:string>
           </dia:attribute>
           <dia:attribute name="comment">
-            <dia:string>#Top-most parent at the root of the inheritance hierarchy, if any.#</dia:string>
+            <dia:string>#True if the object is related to at least one other object as a parent or a child.#</dia:string>
           </dia:attribute>
           <dia:attribute name="visibility">
             <dia:enum val="0"/>
@@ -15593,16 +15593,16 @@ This is used to break cycles where required.#</dia:string>
         </dia:composite>
         <dia:composite type="umlattribute">
           <dia:attribute name="name">
-            <dia:string>#parent#</dia:string>
+            <dia:string>#root_parents#</dia:string>
           </dia:attribute>
           <dia:attribute name="type">
-            <dia:string>#boost::optional&lt;name&gt;#</dia:string>
+            <dia:string>#std::list&lt;name&gt;#</dia:string>
           </dia:attribute>
           <dia:attribute name="value">
             <dia:string>##</dia:string>
           </dia:attribute>
           <dia:attribute name="comment">
-            <dia:string>#Direct parent of this element, if any.#</dia:string>
+            <dia:string>#Top-most parents at the root of the inheritance hierarchy, if any.#</dia:string>
           </dia:attribute>
           <dia:attribute name="visibility">
             <dia:enum val="0"/>
@@ -15616,7 +15616,7 @@ This is used to break cycles where required.#</dia:string>
         </dia:composite>
         <dia:composite type="umlattribute">
           <dia:attribute name="name">
-            <dia:string>#leaves#</dia:string>
+            <dia:string>#parents#</dia:string>
           </dia:attribute>
           <dia:attribute name="type">
             <dia:string>#std::list&lt;name&gt;#</dia:string>
@@ -15625,7 +15625,7 @@ This is used to break cycles where required.#</dia:string>
             <dia:string>##</dia:string>
           </dia:attribute>
           <dia:attribute name="comment">
-            <dia:string>#Elements that are at the bottom of the inheritance tree.#</dia:string>
+            <dia:string>#Direct parent of this element, if any.#</dia:string>
           </dia:attribute>
           <dia:attribute name="visibility">
             <dia:enum val="0"/>
@@ -15639,16 +15639,16 @@ This is used to break cycles where required.#</dia:string>
         </dia:composite>
         <dia:composite type="umlattribute">
           <dia:attribute name="name">
-            <dia:string>#in_inheritance_relationship#</dia:string>
+            <dia:string>#leaves#</dia:string>
           </dia:attribute>
           <dia:attribute name="type">
-            <dia:string>#bool#</dia:string>
+            <dia:string>#std::list&lt;name&gt;#</dia:string>
           </dia:attribute>
           <dia:attribute name="value">
             <dia:string>##</dia:string>
           </dia:attribute>
           <dia:attribute name="comment">
-            <dia:string>#True if the object is related to at least one other object as a parent or a child.#</dia:string>
+            <dia:string>#Elements that are at the bottom of the inheritance tree.#</dia:string>
           </dia:attribute>
           <dia:attribute name="visibility">
             <dia:enum val="0"/>
@@ -15820,17 +15820,17 @@ This is used to break cycles where required.#</dia:string>
     </dia:object>
     <dia:object type="UML - Generalization" version="1" id="O119">
       <dia:attribute name="obj_pos">
-        <dia:point val="-169.012,-5.8"/>
+        <dia:point val="-169.205,-5.8"/>
       </dia:attribute>
       <dia:attribute name="obj_bb">
-        <dia:rectangle val="-178.657,-5.85;-168.162,13.05"/>
+        <dia:rectangle val="-178.657,-5.85;-168.355,13.05"/>
       </dia:attribute>
       <dia:attribute name="meta">
         <dia:composite type="dict"/>
       </dia:attribute>
       <dia:attribute name="orth_points">
-        <dia:point val="-169.012,-5.8"/>
-        <dia:point val="-169.012,9"/>
+        <dia:point val="-169.205,-5.8"/>
+        <dia:point val="-169.205,9"/>
         <dia:point val="-178.607,9"/>
         <dia:point val="-178.607,13"/>
       </dia:attribute>
diff --git a/projects/yarn/include/dogen/yarn/types/object.hpp b/projects/yarn/include/dogen/yarn/types/object.hpp
index 59b1d77..55c0599 100644
--- a/projects/yarn/include/dogen/yarn/types/object.hpp
+++ b/projects/yarn/include/dogen/yarn/types/object.hpp
@@ -80,10 +80,10 @@ public:
         const bool is_child,
         const bool is_leaf,
         const bool is_final,
-        const boost::optional<dogen::yarn::name>& root_parent,
-        const boost::optional<dogen::yarn::name>& parent,
-        const std::list<dogen::yarn::name>& leaves,
         const bool in_inheritance_relationship,
+        const std::list<dogen::yarn::name>& root_parents,
+        const std::list<dogen::yarn::name>& parents,
+        const std::list<dogen::yarn::name>& leaves,
         const std::list<dogen::yarn::name>& transparent_associations,
         const std::list<dogen::yarn::name>& opaque_associations,
         const boost::optional<dogen::yarn::name>& base_visitor,
@@ -202,23 +202,31 @@ public:
     /**@}*/
 
     /**
-     * @brief Top-most parent at the root of the inheritance hierarchy, if any.
+     * @brief True if the object is related to at least one other object as a parent or a child.
+     */
+    /**@{*/
+    bool in_inheritance_relationship() const;
+    void in_inheritance_relationship(const bool v);
+    /**@}*/
+
+    /**
+     * @brief Top-most parents at the root of the inheritance hierarchy, if any.
      */
     /**@{*/
-    const boost::optional<dogen::yarn::name>& root_parent() const;
-    boost::optional<dogen::yarn::name>& root_parent();
-    void root_parent(const boost::optional<dogen::yarn::name>& v);
-    void root_parent(const boost::optional<dogen::yarn::name>&& v);
+    const std::list<dogen::yarn::name>& root_parents() const;
+    std::list<dogen::yarn::name>& root_parents();
+    void root_parents(const std::list<dogen::yarn::name>& v);
+    void root_parents(const std::list<dogen::yarn::name>&& v);
     /**@}*/
 
     /**
      * @brief Direct parent of this element, if any.
      */
     /**@{*/
-    const boost::optional<dogen::yarn::name>& parent() const;
-    boost::optional<dogen::yarn::name>& parent();
-    void parent(const boost::optional<dogen::yarn::name>& v);
-    void parent(const boost::optional<dogen::yarn::name>&& v);
+    const std::list<dogen::yarn::name>& parents() const;
+    std::list<dogen::yarn::name>& parents();
+    void parents(const std::list<dogen::yarn::name>& v);
+    void parents(const std::list<dogen::yarn::name>&& v);
     /**@}*/
 
     /**
@@ -232,14 +240,6 @@ public:
     /**@}*/
 
     /**
-     * @brief True if the object is related to at least one other object as a parent or a child.
-     */
-    /**@{*/
-    bool in_inheritance_relationship() const;
-    void in_inheritance_relationship(const bool v);
-    /**@}*/
-
-    /**
      * @brief Elements that are involved in aggregation or composition relationships.
      */
     /**@{*/
@@ -352,10 +352,10 @@ private:
     bool is_child_;
     bool is_leaf_;
     bool is_final_;
-    boost::optional<dogen::yarn::name> root_parent_;
-    boost::optional<dogen::yarn::name> parent_;
-    std::list<dogen::yarn::name> leaves_;
     bool in_inheritance_relationship_;
+    std::list<dogen::yarn::name> root_parents_;
+    std::list<dogen::yarn::name> parents_;
+    std::list<dogen::yarn::name> leaves_;
     std::list<dogen::yarn::name> transparent_associations_;
     std::list<dogen::yarn::name> opaque_associations_;
     boost::optional<dogen::yarn::name> base_visitor_;
diff --git a/projects/yarn/src/hash/object_hash.cpp b/projects/yarn/src/hash/object_hash.cpp
index 2b3aa5d..2aa56af 100644
--- a/projects/yarn/src/hash/object_hash.cpp
+++ b/projects/yarn/src/hash/object_hash.cpp
@@ -50,6 +50,14 @@ inline std::size_t hash_std_unordered_map_dogen_yarn_name_std_list_dogen_yarn_at
     return seed;
 }
 
+inline std::size_t hash_std_list_dogen_yarn_name(const std::list<dogen::yarn::name>& v) {
+    std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i);
+    }
+    return seed;
+}
+
 inline std::size_t hash_boost_optional_dogen_yarn_name(const boost::optional<dogen::yarn::name>& v) {
     std::size_t seed(0);
 
@@ -60,14 +68,6 @@ inline std::size_t hash_boost_optional_dogen_yarn_name(const boost::optional<dog
     return seed;
 }
 
-inline std::size_t hash_std_list_dogen_yarn_name(const std::list<dogen::yarn::name>& v) {
-    std::size_t seed(0);
-    for (const auto i : v) {
-        combine(seed, i);
-    }
-    return seed;
-}
-
 }
 
 namespace dogen {
@@ -87,10 +87,10 @@ std::size_t object_hasher::hash(const object& v) {
     combine(seed, v.is_child());
     combine(seed, v.is_leaf());
     combine(seed, v.is_final());
-    combine(seed, hash_boost_optional_dogen_yarn_name(v.root_parent()));
-    combine(seed, hash_boost_optional_dogen_yarn_name(v.parent()));
-    combine(seed, hash_std_list_dogen_yarn_name(v.leaves()));
     combine(seed, v.in_inheritance_relationship());
+    combine(seed, hash_std_list_dogen_yarn_name(v.root_parents()));
+    combine(seed, hash_std_list_dogen_yarn_name(v.parents()));
+    combine(seed, hash_std_list_dogen_yarn_name(v.leaves()));
     combine(seed, hash_std_list_dogen_yarn_name(v.transparent_associations()));
     combine(seed, hash_std_list_dogen_yarn_name(v.opaque_associations()));
     combine(seed, hash_boost_optional_dogen_yarn_name(v.base_visitor()));
diff --git a/projects/yarn/src/serialization/object_ser.cpp b/projects/yarn/src/serialization/object_ser.cpp
index 6ecc748..3a9e20c 100644
--- a/projects/yarn/src/serialization/object_ser.cpp
+++ b/projects/yarn/src/serialization/object_ser.cpp
@@ -59,10 +59,10 @@ void save(Archive& ar,
     ar << make_nvp("is_child", v.is_child_);
     ar << make_nvp("is_leaf", v.is_leaf_);
     ar << make_nvp("is_final", v.is_final_);
-    ar << make_nvp("root_parent", v.root_parent_);
-    ar << make_nvp("parent", v.parent_);
-    ar << make_nvp("leaves", v.leaves_);
     ar << make_nvp("in_inheritance_relationship", v.in_inheritance_relationship_);
+    ar << make_nvp("root_parents", v.root_parents_);
+    ar << make_nvp("parents", v.parents_);
+    ar << make_nvp("leaves", v.leaves_);
     ar << make_nvp("transparent_associations", v.transparent_associations_);
     ar << make_nvp("opaque_associations", v.opaque_associations_);
     ar << make_nvp("base_visitor", v.base_visitor_);
@@ -91,10 +91,10 @@ void load(Archive& ar,
     ar >> make_nvp("is_child", v.is_child_);
     ar >> make_nvp("is_leaf", v.is_leaf_);
     ar >> make_nvp("is_final", v.is_final_);
-    ar >> make_nvp("root_parent", v.root_parent_);
-    ar >> make_nvp("parent", v.parent_);
-    ar >> make_nvp("leaves", v.leaves_);
     ar >> make_nvp("in_inheritance_relationship", v.in_inheritance_relationship_);
+    ar >> make_nvp("root_parents", v.root_parents_);
+    ar >> make_nvp("parents", v.parents_);
+    ar >> make_nvp("leaves", v.leaves_);
     ar >> make_nvp("transparent_associations", v.transparent_associations_);
     ar >> make_nvp("opaque_associations", v.opaque_associations_);
     ar >> make_nvp("base_visitor", v.base_visitor_);
diff --git a/projects/yarn/src/test/mock_intermediate_model_factory.cpp b/projects/yarn/src/test/mock_intermediate_model_factory.cpp
index a3b8cd0..be879a5 100644
--- a/projects/yarn/src/test/mock_intermediate_model_factory.cpp
+++ b/projects/yarn/src/test/mock_intermediate_model_factory.cpp
@@ -274,8 +274,8 @@ void parent_to_child(const bool attributes_indexed,
     dogen::yarn::object& root_parent,
     const bool add_leaf_relationship = true) {
 
-    child.parent(parent.name());
-    parent.root_parent(root_parent.name());
+    child.parents().push_back(parent.name());
+    parent.root_parents().push_back(root_parent.name());
 
     if (add_leaf_relationship)
         parent.leaves().push_back(child.name());
diff --git a/projects/yarn/src/test_data/object_td.cpp b/projects/yarn/src/test_data/object_td.cpp
index bdceae0..fd552f8 100644
--- a/projects/yarn/src/test_data/object_td.cpp
+++ b/projects/yarn/src/test_data/object_td.cpp
@@ -57,13 +57,6 @@ bool create_bool(const unsigned int position) {
     return (position % 2) == 0;
 }
 
-boost::optional<dogen::yarn::name>
-create_boost_optional_dogen_yarn_name(unsigned int position) {
-    boost::optional<dogen::yarn::name> r(
-        create_dogen_yarn_name(position));
-    return r;
-}
-
 std::list<dogen::yarn::name> create_std_list_dogen_yarn_name(unsigned int position) {
     std::list<dogen::yarn::name> r;
     for (unsigned int i(0); i < 4; ++i) {
@@ -72,6 +65,13 @@ std::list<dogen::yarn::name> create_std_list_dogen_yarn_name(unsigned int positi
     return r;
 }
 
+boost::optional<dogen::yarn::name>
+create_boost_optional_dogen_yarn_name(unsigned int position) {
+    boost::optional<dogen::yarn::name> r(
+        create_dogen_yarn_name(position));
+    return r;
+}
+
 dogen::yarn::type_parameters
 create_dogen_yarn_type_parameters(const unsigned int position) {
     return dogen::yarn::type_parameters_generator::create(position);
@@ -101,10 +101,10 @@ populate(const unsigned int position, result_type& v) {
     v.is_child(create_bool(position + 6));
     v.is_leaf(create_bool(position + 7));
     v.is_final(create_bool(position + 8));
-    v.root_parent(create_boost_optional_dogen_yarn_name(position + 9));
-    v.parent(create_boost_optional_dogen_yarn_name(position + 10));
-    v.leaves(create_std_list_dogen_yarn_name(position + 11));
-    v.in_inheritance_relationship(create_bool(position + 12));
+    v.in_inheritance_relationship(create_bool(position + 9));
+    v.root_parents(create_std_list_dogen_yarn_name(position + 10));
+    v.parents(create_std_list_dogen_yarn_name(position + 11));
+    v.leaves(create_std_list_dogen_yarn_name(position + 12));
     v.transparent_associations(create_std_list_dogen_yarn_name(position + 13));
     v.opaque_associations(create_std_list_dogen_yarn_name(position + 14));
     v.base_visitor(create_boost_optional_dogen_yarn_name(position + 15));
diff --git a/projects/yarn/src/types/concept_expander.cpp b/projects/yarn/src/types/concept_expander.cpp
index 9f5f48c..e6b2f16 100644
--- a/projects/yarn/src/types/concept_expander.cpp
+++ b/projects/yarn/src/types/concept_expander.cpp
@@ -133,7 +133,7 @@ void concept_expander::expand_object(object& o, intermediate_model& im,
      * First handle the simpler case of objects that do not have a
      * parent.
      */
-    if (!o.parent()) {
+    if (o.parents().empty()) {
         o.modeled_concepts(expanded_refines);
         BOOST_LOG_SEV(lg, debug) << "Object has no parent, using reduced set.";
         return;
@@ -149,7 +149,7 @@ void concept_expander::expand_object(object& o, intermediate_model& im,
     our_concepts.insert(expanded_refines.begin(), expanded_refines.end());
 
     std::set<name> their_concepts;
-    const auto& n(*o.parent());
+    const auto& n(o.parents().front());
     auto& parent(find_object(n, im));
     expand_object(parent, im, processed_names);
 
diff --git a/projects/yarn/src/types/generalization_expander.cpp b/projects/yarn/src/types/generalization_expander.cpp
index a998c78..8f61a5d 100644
--- a/projects/yarn/src/types/generalization_expander.cpp
+++ b/projects/yarn/src/types/generalization_expander.cpp
@@ -78,19 +78,25 @@ update_and_collect_parent_ids(intermediate_model& im) const {
         BOOST_LOG_SEV(lg, debug) << "Processing type: " << id;
 
         auto& o(pair.second);
-        if (!o.parent())
+        if (o.parents().empty())
             continue;
 
         /*
-         * Resolve the name of the parent. This is required because it
-         * may have been supplied via meta-data, and as such, it may
-         * not be complete. We can't wait for the resolution step
-         * because there is a circular dependency (resolution needs
+         * Resolve the parent names. This is required because they may
+         * have been supplied via meta-data, and as such, be
+         * incomplete. We can't wait for the resolution step proper
+         * because there is a circular dependency: resolution needs
          * injection and injection needs generalization, which needs
-         * resolution).
+         * resolution. So we must resolve here.
          */
-        o.parent(rs.resolve(im, o.name(), *o.parent()));
-        r.insert(o.parent()->id());
+        std::list<name> resolved_parents;
+        for (const auto& pn : o.parents()) {
+            const auto resolved_pn(rs.resolve(im, o.name(), pn));
+            r.insert(resolved_pn.id());
+            resolved_parents.push_back(resolved_pn);
+        }
+
+        o.parents(resolved_parents);
     }
     BOOST_LOG_SEV(lg, debug) << "Finished updating and collecting parent ids: "
                              << r;
@@ -109,10 +115,10 @@ void generalization_expander::populate_properties_up_the_generalization_tree(
         o.leaves().push_back(leaf);
 
     /*
-     * If we do not have a parent we have reached the top of the
+     * If we do not have any parents, we have reached the top of the
      * generalisation tree.
      */
-    if (!o.parent()) {
+    if (o.parents().empty()) {
         /*
          * If the leaf name belongs to the target model, add it to
          * the model's list of leaves. Ignore non-target leaves.
@@ -125,29 +131,30 @@ void generalization_expander::populate_properties_up_the_generalization_tree(
         return;
     }
 
-    const auto pid(o.parent()->id());
-    auto j(im.objects().find(pid));
-    if (j == im.objects().end()) {
-        BOOST_LOG_SEV(lg, error) << parent_not_found << pid;
-        BOOST_THROW_EXCEPTION(expansion_error(parent_not_found + pid));
-    }
-
-    auto& parent(j->second);
-    populate_properties_up_the_generalization_tree(tg, leaf, im, parent);
-
-    if (!parent.parent()) {
-        /*
-         * If our parent does not have a parent then it is our root
-         * parent.
-         */
-        o.root_parent(parent.name());
-    } else {
-        /*
-         * On all other cases, inherit the root parent properties for
-         * our direct parent; these would have been populated from the
-         * root parent as per above.
-         */
-        o.root_parent(parent.root_parent());
+    for (const auto& pn : o.parents()) {
+        auto i(im.objects().find(pn.id()));
+        if (i == im.objects().end()) {
+            BOOST_LOG_SEV(lg, error) << parent_not_found << pn.id();
+            BOOST_THROW_EXCEPTION(expansion_error(parent_not_found + pn.id()));
+        }
+
+        auto& parent(i->second);
+        populate_properties_up_the_generalization_tree(tg, leaf, im, parent);
+
+        if (parent.parents().empty()) {
+            /*
+             * If our parent does not have a parent, then it is our
+             * root parent.
+             */
+            o.root_parents().push_back(parent.name());
+        } else {
+            /*
+             * On all other cases, inherit the root parents property
+             * from our direct parent; these would have been populated
+             * from the root parent as per above.
+             */
+            o.root_parent(parent.root_parent());
+        }
     }
 }
 
diff --git a/projects/yarn/src/types/object.cpp b/projects/yarn/src/types/object.cpp
index f42c0ef..5b36517 100644
--- a/projects/yarn/src/types/object.cpp
+++ b/projects/yarn/src/types/object.cpp
@@ -60,6 +60,20 @@ inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<dogen:
 
 }
 
+namespace std {
+
+inline std::ostream& operator<<(std::ostream& s, const std::list<dogen::yarn::name>& v) {
+    s << "[ ";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << *i;
+    }
+    s << "] ";
+    return s;
+}
+
+}
+
 namespace boost {
 
 inline std::ostream& operator<<(std::ostream& s, const boost::optional<dogen::yarn::name>& v) {
@@ -75,20 +89,6 @@ inline std::ostream& operator<<(std::ostream& s, const boost::optional<dogen::ya
 
 }
 
-namespace std {
-
-inline std::ostream& operator<<(std::ostream& s, const std::list<dogen::yarn::name>& v) {
-    s << "[ ";
-    for (auto i(v.begin()); i != v.end(); ++i) {
-        if (i != v.begin()) s << ", ";
-        s << *i;
-    }
-    s << "] ";
-    return s;
-}
-
-}
-
 namespace dogen {
 namespace yarn {
 
@@ -117,10 +117,10 @@ object::object(object&& rhs)
       is_child_(std::move(rhs.is_child_)),
       is_leaf_(std::move(rhs.is_leaf_)),
       is_final_(std::move(rhs.is_final_)),
-      root_parent_(std::move(rhs.root_parent_)),
-      parent_(std::move(rhs.parent_)),
-      leaves_(std::move(rhs.leaves_)),
       in_inheritance_relationship_(std::move(rhs.in_inheritance_relationship_)),
+      root_parents_(std::move(rhs.root_parents_)),
+      parents_(std::move(rhs.parents_)),
+      leaves_(std::move(rhs.leaves_)),
       transparent_associations_(std::move(rhs.transparent_associations_)),
       opaque_associations_(std::move(rhs.opaque_associations_)),
       base_visitor_(std::move(rhs.base_visitor_)),
@@ -151,10 +151,10 @@ object::object(
     const bool is_child,
     const bool is_leaf,
     const bool is_final,
-    const boost::optional<dogen::yarn::name>& root_parent,
-    const boost::optional<dogen::yarn::name>& parent,
-    const std::list<dogen::yarn::name>& leaves,
     const bool in_inheritance_relationship,
+    const std::list<dogen::yarn::name>& root_parents,
+    const std::list<dogen::yarn::name>& parents,
+    const std::list<dogen::yarn::name>& leaves,
     const std::list<dogen::yarn::name>& transparent_associations,
     const std::list<dogen::yarn::name>& opaque_associations,
     const boost::optional<dogen::yarn::name>& base_visitor,
@@ -184,10 +184,10 @@ object::object(
       is_child_(is_child),
       is_leaf_(is_leaf),
       is_final_(is_final),
-      root_parent_(root_parent),
-      parent_(parent),
-      leaves_(leaves),
       in_inheritance_relationship_(in_inheritance_relationship),
+      root_parents_(root_parents),
+      parents_(parents),
+      leaves_(leaves),
       transparent_associations_(transparent_associations),
       opaque_associations_(opaque_associations),
       base_visitor_(base_visitor),
@@ -237,10 +237,10 @@ void object::to_stream(std::ostream& s) const {
       << "\"is_child\": " << is_child_ << ", "
       << "\"is_leaf\": " << is_leaf_ << ", "
       << "\"is_final\": " << is_final_ << ", "
-      << "\"root_parent\": " << root_parent_ << ", "
-      << "\"parent\": " << parent_ << ", "
-      << "\"leaves\": " << leaves_ << ", "
       << "\"in_inheritance_relationship\": " << in_inheritance_relationship_ << ", "
+      << "\"root_parents\": " << root_parents_ << ", "
+      << "\"parents\": " << parents_ << ", "
+      << "\"leaves\": " << leaves_ << ", "
       << "\"transparent_associations\": " << transparent_associations_ << ", "
       << "\"opaque_associations\": " << opaque_associations_ << ", "
       << "\"base_visitor\": " << base_visitor_ << ", "
@@ -268,10 +268,10 @@ void object::swap(object& other) noexcept {
     swap(is_child_, other.is_child_);
     swap(is_leaf_, other.is_leaf_);
     swap(is_final_, other.is_final_);
-    swap(root_parent_, other.root_parent_);
-    swap(parent_, other.parent_);
-    swap(leaves_, other.leaves_);
     swap(in_inheritance_relationship_, other.in_inheritance_relationship_);
+    swap(root_parents_, other.root_parents_);
+    swap(parents_, other.parents_);
+    swap(leaves_, other.leaves_);
     swap(transparent_associations_, other.transparent_associations_);
     swap(opaque_associations_, other.opaque_associations_);
     swap(base_visitor_, other.base_visitor_);
@@ -302,10 +302,10 @@ bool object::operator==(const object& rhs) const {
         is_child_ == rhs.is_child_ &&
         is_leaf_ == rhs.is_leaf_ &&
         is_final_ == rhs.is_final_ &&
-        root_parent_ == rhs.root_parent_ &&
-        parent_ == rhs.parent_ &&
-        leaves_ == rhs.leaves_ &&
         in_inheritance_relationship_ == rhs.in_inheritance_relationship_ &&
+        root_parents_ == rhs.root_parents_ &&
+        parents_ == rhs.parents_ &&
+        leaves_ == rhs.leaves_ &&
         transparent_associations_ == rhs.transparent_associations_ &&
         opaque_associations_ == rhs.opaque_associations_ &&
         base_visitor_ == rhs.base_visitor_ &&
@@ -421,36 +421,44 @@ void object::is_final(const bool v) {
     is_final_ = v;
 }
 
-const boost::optional<dogen::yarn::name>& object::root_parent() const {
-    return root_parent_;
+bool object::in_inheritance_relationship() const {
+    return in_inheritance_relationship_;
+}
+
+void object::in_inheritance_relationship(const bool v) {
+    in_inheritance_relationship_ = v;
 }
 
-boost::optional<dogen::yarn::name>& object::root_parent() {
-    return root_parent_;
+const std::list<dogen::yarn::name>& object::root_parents() const {
+    return root_parents_;
 }
 
-void object::root_parent(const boost::optional<dogen::yarn::name>& v) {
-    root_parent_ = v;
+std::list<dogen::yarn::name>& object::root_parents() {
+    return root_parents_;
 }
 
-void object::root_parent(const boost::optional<dogen::yarn::name>&& v) {
-    root_parent_ = std::move(v);
+void object::root_parents(const std::list<dogen::yarn::name>& v) {
+    root_parents_ = v;
 }
 
-const boost::optional<dogen::yarn::name>& object::parent() const {
-    return parent_;
+void object::root_parents(const std::list<dogen::yarn::name>&& v) {
+    root_parents_ = std::move(v);
 }
 
-boost::optional<dogen::yarn::name>& object::parent() {
-    return parent_;
+const std::list<dogen::yarn::name>& object::parents() const {
+    return parents_;
 }
 
-void object::parent(const boost::optional<dogen::yarn::name>& v) {
-    parent_ = v;
+std::list<dogen::yarn::name>& object::parents() {
+    return parents_;
 }
 
-void object::parent(const boost::optional<dogen::yarn::name>&& v) {
-    parent_ = std::move(v);
+void object::parents(const std::list<dogen::yarn::name>& v) {
+    parents_ = v;
+}
+
+void object::parents(const std::list<dogen::yarn::name>&& v) {
+    parents_ = std::move(v);
 }
 
 const std::list<dogen::yarn::name>& object::leaves() const {
@@ -469,14 +477,6 @@ void object::leaves(const std::list<dogen::yarn::name>&& v) {
     leaves_ = std::move(v);
 }
 
-bool object::in_inheritance_relationship() const {
-    return in_inheritance_relationship_;
-}
-
-void object::in_inheritance_relationship(const bool v) {
-    in_inheritance_relationship_ = v;
-}
-
 const std::list<dogen::yarn::name>& object::transparent_associations() const {
     return transparent_associations_;
 }
