diff --git a/doc/agile/release_notes_sprint_49.org b/doc/agile/release_notes_sprint_49.org
index cac449a..cc154c3 100644
--- a/doc/agile/release_notes_sprint_49.org
+++ b/doc/agile/release_notes_sprint_49.org
@@ -232,13 +232,15 @@ We haven't got any documentation at all in the new formatters
 morel. We need a small blurb about the language neutral formatting
 support the model is supposed to provide.
 
-*** IMPLEMENTATION Move all the configuration options into tags       :story:
-    CLOCK: [2014-05-06 Tue 07:47]--[2014-05-06 Tue 07:51] =>  0:08
+*** IMPLEMENTATION Split formatting settings from knitting settings   :story:
 
-Parameters as per analysis story.
+Since we have one set of settings which are read from the command
+line, and another set which are obtained from parsing the meta-data,
+we should split them. This would mean we can still have const settings
+instead of modifying them mid-way through the pipeline.
 
 **** COMPLETED Move the verbose option to top-level settings           :task:
-     CLOSED: [2014-05-06 Tue 18:40]
+     CLOSED: [2014-05-09 Fri 18:23]
      CLOCK: [2014-05-06 Tue 18:08]--[2014-05-06 Tue 18:47] =>  0:39
      CLOCK: [2014-05-06 Tue 08:19]--[2014-05-06 Tue 08:40] =>  0:21
 
@@ -272,22 +274,33 @@ Actually, these are just library specific settings:
 
 For now the C++ settings belong to both - until we fully transition.
 
-**** IMPLEMENTATION Tidy-up knit workflow                             :spike:
+**** IMPLEMENTATION Tidy-up knit workflow                              :task:
+     CLOCK: [2014-05-09 Fri 18:21]--[2014-05-09 Fri 18:57] =>  0:36
+     CLOCK: [2014-05-09 Fri 18:20]--[2014-05-09 Fri 18:21] =>  0:01
+     CLOCK: [2014-05-09 Fri 08:39]--[2014-05-09 Fri 09:20] =>  0:41
      CLOCK: [2014-05-08 Thu 08:33]--[2014-05-08 Thu 08:40] =>  0:07
 
 We need to make the method names resemble more the workflow
-terminology, with subworkflows, activities, etc.
+terminology, with subworkflows, activities, etc. Prepare the code to
+slot in the formatting settings.
 
-- there are two subworkflows: obtain the SML model and generate it.
-
-**** IMPLEMENTATION Merge provider into workflow in =knit=             :task:
+**** CANCELLED Merge provider into workflow in =knit=                  :task:
+     CLOSED: [2014-05-09 Fri 09:16]
      CLOCK: [2014-05-08 Thu 08:28]--[2014-05-08 Thu 08:32] =>  0:04
      CLOCK: [2014-05-07 Wed 07:56]--[2014-05-07 Wed 08:06] =>  0:10
 
+*Rationale*: this is not required, we can just extract the formatting
+ settings from the merged model.
+
 If we are going to override the settings we must make sure the code is
 as linear as possible. The provider is actually some kind of SML
 loading sub-workflow.
 
+*** IMPLEMENTATION Move all the configuration options into tags       :story:
+    CLOCK: [2014-05-06 Tue 07:47]--[2014-05-06 Tue 07:51] =>  0:08
+
+Parameters as per analysis story.
+
 **** Create a tags class in =config=                                   :task:
 
 We need to declare all the tags we're exporting.
diff --git a/projects/knit/include/dogen/knit/types/backends/backend.hpp b/projects/knit/include/dogen/knit/types/backends/backend.hpp
index b146e05..71fe5a0 100644
--- a/projects/knit/include/dogen/knit/types/backends/backend.hpp
+++ b/projects/knit/include/dogen/knit/types/backends/backend.hpp
@@ -59,7 +59,8 @@ public:
     /**
      * @brief Get all directories managed by this backend.
      */
-    virtual std::vector<boost::filesystem::path> managed_directories() const = 0;
+    virtual std::vector<boost::filesystem::path>
+    managed_directories() const = 0;
 };
 
 } } }
diff --git a/projects/knit/include/dogen/knit/types/workflow.hpp b/projects/knit/include/dogen/knit/types/workflow.hpp
index 752f6f8..fd31b91 100644
--- a/projects/knit/include/dogen/knit/types/workflow.hpp
+++ b/projects/knit/include/dogen/knit/types/workflow.hpp
@@ -33,6 +33,7 @@
 #include <boost/filesystem/path.hpp>
 #include "dogen/sml/types/model.hpp"
 #include "dogen/config/types/knitting_settings.hpp"
+#include "dogen/config/types/formatting_settings.hpp"
 #include "dogen/knit/types/backends/backend.hpp"
 #include "dogen/knit/types/outputters/outputter.hpp"
 #include "dogen/utility/serialization/archive_types.hpp"
@@ -77,17 +78,10 @@ public:
     typedef std::function<std::ostream& ()> output_fn;
 
 public:
-    workflow(workflow&& rhs) : settings_(std::move(rhs.settings_)) { }
+    workflow(workflow&& rhs);
     workflow(const config::knitting_settings& s);
     workflow(const config::knitting_settings& s, const output_fn& o);
 
-private:
-    /**
-     * @brief Outputs the pair file name and contents to its output
-     * destination.
-     */
-    void output(const outputters::outputter::value_type& o) const;
-
 public: // public section for testing purposes only
     /**
      * @brief Returns true if the housekeeping of generated files is
@@ -96,22 +90,48 @@ public: // public section for testing purposes only
     bool housekeeping_required() const;
 
     /**
-     * @brief Execute the SML sub-workflow and return a generatable
-     * model - or nothing, if no such model exists.
+     * @brief Performs a housekeeping run for the supplied directories.
+     */
+    void housekeep(const std::vector<boost::filesystem::path>& dirs) const;
+
+private:
+    /**
+     * @brief Outputs the pair file name and contents to its output
+     * destination.
      */
-    boost::optional<sml::model> make_generatable_model() const;
+    void output_file(const outputters::outputter::value_type& o) const;
 
     /**
      * @brief Transforms the model into generated code, according to
      * the backend passed in.
      */
-    void generate(backends::backend& b) const;
+    void create_files_for_backend(backends::backend& b) const;
+
+    /**
+     * @brief Returns true if we should execute the generation
+     * activity, false otherwise.
+     */
+    bool is_generation_required(const boost::optional<sml::model>& m) const;
+
+public:
+    /**
+     * @brief Execute the SML workflow and return a model that can be
+     * generated - or nothing, if no such model exists.
+     */
+    boost::optional<sml::model> obtain_model_activity() const;
+
+    /**
+     * @brief Extracts the formatting settings from the SML model.
+     */
+    config::formatting_settings
+    extract_formatting_settings_activity(const sml::model& m) const;
 
     /**
      * @brief Given a merged model, generates all of its
      * representations.
      */
-    void generate(const sml::model& m) const;
+    void generate_model_activity(const sml::model& m,
+        const config::formatting_settings& fs) const;
 
 public:
     /**
@@ -120,7 +140,7 @@ public:
     void execute() const;
 
 private:
-    const config::knitting_settings settings_;
+    const config::knitting_settings knitting_settings_;
     const output_fn output_;
 };
 
diff --git a/projects/knit/src/types/workflow.cpp b/projects/knit/src/types/workflow.cpp
index 5f0277b..1fe11f0 100644
--- a/projects/knit/src/types/workflow.cpp
+++ b/projects/knit/src/types/workflow.cpp
@@ -63,105 +63,112 @@ const std::string code_generation_failure("Code generation failure.");
 namespace dogen {
 namespace knit {
 
-workflow::workflow(const config::knitting_settings& s) : settings_(s) {
+workflow::workflow(workflow&& rhs)
+    : knitting_settings_(std::move(rhs.knitting_settings_)) { }
 
-    if (settings_.output().output_to_stdout()) {
+workflow::
+workflow(const config::knitting_settings& s) : knitting_settings__(s) {
+
+    if (knitting_settings_.output().output_to_stdout()) {
         BOOST_LOG_SEV(lg, error) << incorrect_stdout_config;
         BOOST_THROW_EXCEPTION(generation_failure(incorrect_stdout_config));
     }
-    config::knitting_settings_validator::validate(s);
+    config::knitting_settings_validator::validate(knitting_settings_);
 }
 
-workflow::
-workflow(const config::knitting_settings& s, const output_fn& o)
-    : settings_(s), output_(o) {
+workflow::workflow(const config::knitting_settings& s, const output_fn& o)
+    : knitting_settings_(s), output_(o) {
 
-    if (!settings_.output().output_to_stdout() || !output_) {
+    if (!knitting_settings_.output().output_to_stdout() || !output_) {
         BOOST_LOG_SEV(lg, error) << incorrect_stdout_config;
         BOOST_THROW_EXCEPTION(generation_failure(incorrect_stdout_config));
     }
-    config::knitting_settings_validator::validate(s);
+    config::knitting_settings_validator::validate(knitting_settings_);
 }
 
 bool workflow::housekeeping_required() const {
     return
-        !settings_.troubleshooting().stop_after_merging() &&
-        !settings_.troubleshooting().stop_after_formatting() &&
-        settings_.output().delete_extra_files() &&
-        settings_.output().output_to_file();
+        !knitting_settings_.troubleshooting().stop_after_merging() &&
+        !knitting_settings_.troubleshooting().stop_after_formatting() &&
+        knitting_settings_.output().delete_extra_files() &&
+        knitting_settings_.output().output_to_file();
+}
+
+void workflow::
+housekeep(const std::vector<boost::filesystem::path>& dirs) const {
+    using boost::adaptors::transformed;
+    using boost::filesystem::path;
+    std::set<path> expected_files;
+    boost::copy(dirs | transformed([&](std::pair<path, std::string> p) {
+                return p.first;
+            }),
+        std::inserter(expected_files, expected_files.end()));
+
+    const auto& ip(knitting_settings_.output().ignore_patterns());
+    housekeeper hk(ip, dirs, expected_files);
+    hk.tidy_up();
 }
 
-void workflow::output(const outputters::outputter::value_type& o) const {
-    if (settings_.troubleshooting().stop_after_formatting()) {
-        BOOST_LOG_SEV(lg, warn) << "Stopping after formatting so not outputting";
+void workflow::output_files(const outputters::outputter::value_type& o) const {
+    if (knitting_settings_.troubleshooting().stop_after_formatting()) {
+        BOOST_LOG_SEV(lg, warn) << "Stopping after formatting, so no output.";
         return;
     }
 
     if (o.empty()) {
-        BOOST_LOG_SEV(lg, warn) << "No files were generated, nothing to output.";
-
+        BOOST_LOG_SEV(lg, warn) << "No files were generated, so no output.";
         return;
     }
 
     const auto lambda([&](outputters::outputter::ptr p) { p->output(o); });
-    outputters::factory f(settings_.output(), output_);
+    outputters::factory f(knitting_settings_.output(), output_);
     boost::for_each(f.create(), lambda);
 }
 
-void workflow::generate(backends::backend& b) const {
-    const auto r(b.generate());
-    output(r);
+void workflow::create_files_for_backend(backends::backend& b) const {
+    const auto files(b.generate());
+    output_files(files);
 
     if (!housekeeping_required())
         return;
 
-    using boost::adaptors::transformed;
-    using boost::filesystem::path;
-    std::set<path> expected_files;
-    boost::copy(r | transformed([&](std::pair<path, std::string> p) {
-                return p.first;
-            }),
-        std::inserter(expected_files, expected_files.end()));
-
-    const auto& ip(settings_.output().ignore_patterns());
-    housekeeper hk(ip, b.managed_directories(), expected_files);
-    hk.tidy_up();
+    housekeep(b.managed_directories());
 }
 
-void workflow::generate(const sml::model& m) const {
-    try {
-        const auto lambda([&](backends::backend::ptr p) { generate(*p); });
-        backends::factory f(m, settings_);
-        boost::for_each(f.create(), lambda);
-    } catch(const dogen::cpp_formatters::formatting_error& e) {
-        BOOST_THROW_EXCEPTION(dogen::knit::generation_failure(e.what()));
-    } catch(const dogen::sml_to_cpp::workflow_failure& e) {
-        BOOST_THROW_EXCEPTION(dogen::knit::generation_failure(e.what()));
+bool workflow::
+is_generation_required(const boost::optional<sml::model>& m) const {
+    if (knitting_settings_.troubleshooting().stop_after_merging()) {
+        BOOST_LOG_SEV(lg, info) << "Stopping after merging.";
+        return false;
     }
+
+    if (!m)
+        return false;
+
+    return true;
 }
 
-boost::optional<sml::model> workflow::make_generatable_model() const {
-    bool is_target(false);
-    provider pro(settings_);
+boost::optional<sml::model> workflow::obtain_model_activity() const {
+    const bool is_target(true);
+    provider pro(knitting_settings_);
     std::list<sml::model> references;
-    for (const auto ref : settings_.input().references()) {
+    for (const auto ref : knitting_settings_.input().references()) {
         const auto path(ref.path());
         const auto epp(ref.external_module_path());
-        references.push_back(pro.provide(path, epp, is_target));
+        references.push_back(pro.provide(path, epp, !is_target));
     }
 
-    is_target = true;
-    const auto path(settings_.input().target());
-    const auto epp(settings_.input().external_module_path());
+    const auto path(knitting_settings_.input().target());
+    const auto epp(knitting_settings_.input().external_module_path());
     const sml::model target(pro.provide(path, epp, is_target));
 
     const bool add_system_models(true);
-    sml::workflow w(add_system_models, settings_);
+    sml::workflow w(add_system_models, knitting_settings_);
     const auto pair(w.execute(target, references));
     const auto& m(pair.second);
 
     BOOST_LOG_SEV(lg, debug) << "Merged model: " << m;
-    persister per(settings_);
+    persister per(knitting_settings_);
     per.persist(m, merged);
 
     BOOST_LOG_SEV(lg, debug) << "Totals: objects: " << m.objects().size()
@@ -177,19 +184,38 @@ boost::optional<sml::model> workflow::make_generatable_model() const {
     return boost::optional<sml::model>();
 }
 
+config:formatting_settings workflow::
+extract_formatting_settings_activity(const sml::model&) const {
+    config::formatting_settings r;
+    r.cpp(knitting_settings_.cpp());
+    return r;
+}
+
+void workflow::generate_model_activity(
+    const sml::model& m, const config::formatting_settings& fs) const {
+    try {
+        backends::factory f(m, knitting_settings_);
+        boost::for_each(f.create(), [](backends::backend::ptr p) {
+                create_files_for_backend(*p);
+            });
+    } catch(const dogen::cpp_formatters::formatting_error& e) {
+        BOOST_THROW_EXCEPTION(dogen::knit::generation_failure(e.what()));
+    } catch(const dogen::sml_to_cpp::workflow_failure& e) {
+        BOOST_THROW_EXCEPTION(dogen::knit::generation_failure(e.what()));
+    }
+}
+
 void workflow::execute() const {
     BOOST_LOG_SEV(lg, info) << "Workflow started.";
-    BOOST_LOG_SEV(lg, debug) << "Settings: " << settings_;
+    BOOST_LOG_SEV(lg, debug) << "Knitting settings: " << knitting_settings_;
 
     try {
-        const auto o(make_generatable_model());
-        if (settings_.troubleshooting().stop_after_merging()) {
-            BOOST_LOG_SEV(lg, info) << "Stopping after merging.";
+        const auto m(obtain_model_activity());
+        if (!is_generation_required(m))
             return;
-        }
 
-        if (o)
-            generate(*o);
+        auto fs(extract_formatting_settings_activity(*m));
+        generate_model_activity(*m, fs);
     } catch (boost::exception& e) {
         e << errmsg_workflow(code_generation_failure);
         throw;
