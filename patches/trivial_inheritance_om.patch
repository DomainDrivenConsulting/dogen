diff --git a/projects/om/include/dogen/om/types/cpp_types_main_header_file_formatter.hpp b/projects/om/include/dogen/om/types/cpp_types_main_header_file_formatter.hpp
index 1a39ac2..c796962 100644
--- a/projects/om/include/dogen/om/types/cpp_types_main_header_file_formatter.hpp
+++ b/projects/om/include/dogen/om/types/cpp_types_main_header_file_formatter.hpp
@@ -192,6 +192,13 @@ private:
     void destructor_implementation(const sml::object& o) const;
 
 private:
+    /**
+     * @brief Formats non-specialised objects such as entities, value
+     * objects, etc.
+     */
+    void format_non_specialised_object(const sml::object& o) const;
+
+private:
     using sml::type_visitor::visit;
     void visit(const sml::enumeration& e) const override;
     void visit(const sml::object& o) const override;
diff --git a/projects/om/src/types/cpp_types_main_header_file_formatter.cpp b/projects/om/src/types/cpp_types_main_header_file_formatter.cpp
index d91a7e3..e22ac08 100644
--- a/projects/om/src/types/cpp_types_main_header_file_formatter.cpp
+++ b/projects/om/src/types/cpp_types_main_header_file_formatter.cpp
@@ -219,8 +219,10 @@ visit(const sml::object& o) {
 
     // hard-coded includes
     using types = sml::tags::cpp::types;
-    if (reader.is_true(types::generate_external_swap))
-        includes_.system().push_back(algorithm_include);
+
+    // FIXME: hack just to get zero diffs with legacy
+    // if (reader.is_true(types::generate_external_swap))
+    includes_.system().push_back(algorithm_include);
 
     if (reader.is_true(types::generate_to_stream) ||
         reader.is_true(types::generate_external_inserter))
@@ -301,7 +303,19 @@ open_class(const sml::object& o) const {
         const std::string parent_simple_name(i->second.front().simple_name());
         helper_->stream() << " :";
         helper_->stream() << " public ";
-        helper_->stream() << parent_simple_name;
+
+        // FIXME: hack just to get zero diffs with legacy
+        // helper_->stream() << parent_simple_name;
+
+        const auto j(model_.objects().find(i->second.front()));
+        if (j == model_.objects().end()) {
+            BOOST_LOG_SEV(lg, error) << parent_not_found;
+            BOOST_THROW_EXCEPTION(formatting_error(parent_not_found));
+        }
+        sml::meta_data_reader reader(j->second.meta_data());
+        const auto pqn(reader.get(
+                sml::tags::cpp::types::qualified_name));
+        helper_->stream() << pqn;
     }
     helper_->stream() << " {" << std::endl;
 }
@@ -433,7 +447,8 @@ destructor(const sml::object& o) const {
     if (!reader.is_true(types::generate_explicit_destructor))
         return;
 
-    helper_->utility().public_access_specifier();
+    // FIXME: hack just to get zero diffs with legacy
+    // helper_->utility().public_access_specifier();
     const auto sn(o.name().simple_name());
     if (reader.is_true(types::destructor_is_pure_virtual)) {
         helper_->stream() << "virtual ~" << sn
@@ -577,6 +592,9 @@ member_variables(const sml::object& o) const {
     if (o.local_properties().empty())
         return;
 
+    // FIXME: hack just to get zero diffs with legacy
+    helper_->utility().blank_line();
+
     helper_->utility().private_access_specifier();
     for (const auto p : o.local_properties()) {
         sml::meta_data_reader reader(p.meta_data());
@@ -592,7 +610,7 @@ member_variables(const sml::object& o) const {
 void cpp_types_main_header_file_formatter::
 internal_equality(const sml::object& o) const {
     sml::meta_data_reader reader(o.meta_data());
-    if (reader.is_false(sml::tags::cpp::types::generate_equality))
+    if (!reader.is_true(sml::tags::cpp::types::generate_equality))
         return;
 
     const auto sn(o.name().simple_name());
@@ -620,7 +638,8 @@ internal_equality(const sml::object& o) const {
     if (!o.is_parent() && !o.is_child())
         return;
 
-    helper_->utility().blank_line();
+    // FIXME: hack just to get zero diffs with legacy
+    // helper_->utility().blank_line();
     helper_->utility().public_access_specifier();
     using types = sml::tags::cpp::types;
     if (o.is_parent() && !o.is_child()) {
@@ -645,7 +664,7 @@ internal_equality(const sml::object& o) const {
 void cpp_types_main_header_file_formatter::
 to_stream(const sml::object& o) const {
     sml::meta_data_reader reader(o.meta_data());
-    if (reader.is_false(sml::tags::cpp::types::generate_to_stream))
+    if (!reader.is_true(sml::tags::cpp::types::generate_to_stream))
         return;
 
     helper_->utility().public_access_specifier();
@@ -665,7 +684,7 @@ to_stream(const sml::object& o) const {
 void cpp_types_main_header_file_formatter::
 internal_swap(const sml::object& o) const {
     sml::meta_data_reader reader(o.meta_data());
-    if (reader.is_false(sml::tags::cpp::types::generate_internal_swap))
+    if (!reader.is_true(sml::tags::cpp::types::generate_internal_swap))
         return;
 
     // swap is only public in leaf classes - MEC++-33
@@ -699,7 +718,7 @@ internal_assignment(const sml::object& o) const {
 void cpp_types_main_header_file_formatter::
 visitor_method(const sml::object& o) const {
     sml::meta_data_reader reader(o.meta_data());
-    if (reader.is_false(sml::tags::cpp::types::generate_accept))
+    if (!reader.is_true(sml::tags::cpp::types::generate_accept))
         return;
 
     helper_->utility().public_access_specifier();
@@ -707,7 +726,7 @@ visitor_method(const sml::object& o) const {
     using types = sml::tags::cpp::types;
     const auto opn(reader.get(types::qualified_original_parent_name));
 
-    if (o.is_visitable()) {
+    if (reader.is_true(sml::tags::cpp::types::accept_is_pure_virtual)) {
         helper_->stream() << "virtual void accept(const " << sn
                          << "_visitor& v) const = 0;" << std::endl;
         helper_->stream() << "virtual void accept("
@@ -884,8 +903,9 @@ visit(const dogen::sml::enumeration& e) const {
     helper_->utility().managed_blank_line();
 }
 
+
 void cpp_types_main_header_file_formatter::
-visit(const dogen::sml::object& o) const {
+format_non_specialised_object(const sml::object& o) const {
     ensure_non_null_helper();
     {
         const auto ns(namespaces(o.name()));
@@ -908,6 +928,10 @@ visit(const dogen::sml::object& o) const {
             internal_assignment(o);
             member_variables(o);
         }
+        // FIXME: hack just to get zero diffs with legacy
+        if (o.local_properties().empty())
+            helper_->utility().blank_line();
+
         close_class();
         helper_->utility().blank_line();
         destructor_implementation(o);
@@ -919,6 +943,21 @@ visit(const dogen::sml::object& o) const {
     external_swap(o);
 }
 
+void cpp_types_main_header_file_formatter::
+visit(const dogen::sml::object& o) const {
+    using sml::object_types;
+    switch(o.object_type()) {
+    case object_types::entity:
+    case object_types::keyed_entity:
+    case object_types::user_defined_value_object:
+        format_non_specialised_object(o);
+        break;
+
+    default:
+        return;
+    }
+}
+
 bool cpp_types_main_header_file_formatter::
 generate(const boost::property_tree::ptree& meta_data) const {
     sml::meta_data_reader reader(meta_data);
diff --git a/projects/sml/include/dogen/sml/types/tags.hpp b/projects/sml/include/dogen/sml/types/tags.hpp
index 5fc44dc..8752772 100644
--- a/projects/sml/include/dogen/sml/types/tags.hpp
+++ b/projects/sml/include/dogen/sml/types/tags.hpp
@@ -327,6 +327,12 @@ struct tags {
             static const std::string generate_accept;
 
             /**
+             * @brief If set to true, the accept method will be pure
+             * virtual.
+             */
+            static const std::string accept_is_pure_virtual;
+
+            /**
              * @brief If set to true, external swap function will be
              * generated.
              */
diff --git a/projects/sml/src/types/meta_data_tagger.cpp b/projects/sml/src/types/meta_data_tagger.cpp
index 06f0fda..0422fef 100644
--- a/projects/sml/src/types/meta_data_tagger.cpp
+++ b/projects/sml/src/types/meta_data_tagger.cpp
@@ -1038,16 +1038,39 @@ void meta_data_tagger::tag(object& o) const {
         writer.add_if_key_not_found(tags::is_original_parent_visitable,
             i->second.is_visitable() ? tags::bool_true : tags::bool_false);
 
-        writer.add_if_key_not_found(tags::cpp::types::generate_accept,
-            i->second.is_visitable() ? tags::bool_true : tags::bool_false);
+        /*
+         * If your original parent is visitable and you are a leaf,
+         * you must generate a concrete accept method.
+         */
+        if (i->second.is_visitable() && !o.is_parent()) {
+            writer.add_if_key_not_found(tags::cpp::types::generate_accept,
+                tags::bool_true);
+        }
 
         writer.add_if_key_not_found(
             tags::cpp::types::qualified_original_parent_name,
             builder_.cpp_qualified_name(context_->model(), opn));
     }
 
-    writer.add_if_key_not_found(tags::cpp::types::generate_accept,
-        o.is_visitable() ? tags::bool_true : tags::bool_false);
+    /*
+     * If your are visitable, you must generate an accept method.
+     */
+    if (o.is_visitable()) {
+        writer.add_if_key_not_found(tags::cpp::types::generate_accept,
+            tags::bool_true);
+
+        /*
+         * If you are not a leaf, the accept method must be
+         * virtual. Since is visitable is only set for the base class
+         * of a hierarchy, you should always be a parent, really. But
+         * we check, just in case.
+         */
+        if (o.is_parent()) {
+            writer.add_if_key_not_found(
+                tags::cpp::types::accept_is_pure_virtual,
+                tags::bool_true);
+        }
+    }
 
     if (!o.is_parent())
         writer.add_if_key_not_found(tags::is_final, tags::bool_true);
@@ -1062,7 +1085,7 @@ void meta_data_tagger::tag(object& o) const {
     writer.add_if_key_not_found(
         tags::cpp::types::generate_explicit_move_constructor, tags::bool_false);
 
-    /**
+    /*
      * Types which are part of an inheritance relationship require
      * manually generated destructors.
      */
@@ -1084,14 +1107,14 @@ void meta_data_tagger::tag(object& o) const {
         }
     }
 
-    /**
+    /*
      * Types which are not immutable, have no properties or are not
      * parents in an inheritance relationship do not require swap
      * support or explicit assignment operators.
      */
     if (!o.is_immutable() && (!o.all_properties().empty() || o.is_parent())) {
 
-        /**
+        /*
          * All types which require swap support must have an internal
          * swap method since the external swap method uses it. In
          * addition, parents must supply it so that their children can
@@ -1101,7 +1124,7 @@ void meta_data_tagger::tag(object& o) const {
             tags::cpp::types::generate_internal_swap,
             tags::bool_true);
 
-        /**
+        /*
          * Classes that are parents in an inheritance relationship
          * should not overload the standard swap function. This is
          * because they are abstract classes (MEC++-33). For the same
@@ -1130,7 +1153,7 @@ void meta_data_tagger::tag(object& o) const {
         tags::bool_true);
 
     if (reader.is_true(tags::cpp::io::enabled)) {
-        /**
+        /*
          * Types which are involved in an inheritance relationship must
          * have an internal to stream method to allow for delegation
          * between parents and children.
@@ -1141,7 +1164,7 @@ void meta_data_tagger::tag(object& o) const {
                 tags::bool_true);
         }
 
-        /**
+        /*
          * If integrated IO is enabled we need to generate an
          * external inserter with the class.
          */
diff --git a/projects/sml/src/types/tags.cpp b/projects/sml/src/types/tags.cpp
index 6446bf2..c106247 100644
--- a/projects/sml/src/types/tags.cpp
+++ b/projects/sml/src/types/tags.cpp
@@ -104,6 +104,8 @@ const std::string tags::cpp::types::generate_to_stream(
     "cpp.types.generate_to_stream");
 const std::string tags::cpp::types::generate_accept(
     "cpp.types.generate_accept");
+const std::string tags::cpp::types::accept_is_pure_virtual(
+    "cpp.types.accept_is_pure_virtual");
 
 const std::string tags::cpp::types::header_file::generate(
     "cpp.types.header_file.generate");
