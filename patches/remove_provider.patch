diff --git a/projects/quilt.cpp/include/dogen/quilt.cpp/types/formattables/formatter_properties_repository_factory.hpp b/projects/quilt.cpp/include/dogen/quilt.cpp/types/formattables/formatter_properties_repository_factory.hpp
index c420ba5..ffcc142 100644
--- a/projects/quilt.cpp/include/dogen/quilt.cpp/types/formattables/formatter_properties_repository_factory.hpp
+++ b/projects/quilt.cpp/include/dogen/quilt.cpp/types/formattables/formatter_properties_repository_factory.hpp
@@ -68,10 +68,8 @@ private:
      * @brief Create the inclusion directives repository.
      */
     inclusion_directives_repository create_inclusion_directives_repository(
-        const dynamic::repository& srp,
-        const formatters::container& fc,
-        const registrar& rg, const locator& l,
-        const yarn::model& m) const;
+        const dynamic::repository& srp, const formatters::container& fc,
+        const locator& l, const yarn::model& m) const;
 
     /**
      * @brief Create the inclusion dependencies repository.
@@ -110,8 +108,7 @@ public:
         const dynamic::repository& srp,
         const dynamic::object& root_object,
         const std::unordered_map<std::string, std::string>& fdff,
-        const path_derivatives_repository& pdrp,
-        const registrar& rg, const locator& l,
+        const path_derivatives_repository& pdrp, const locator& l,
         const formatters::container& fc,
         const yarn::model& m) const;
 };
diff --git a/projects/quilt.cpp/include/dogen/quilt.cpp/types/formattables/inclusion_directives_repository_factory.hpp b/projects/quilt.cpp/include/dogen/quilt.cpp/types/formattables/inclusion_directives_repository_factory.hpp
index cdea9c5..461d535 100644
--- a/projects/quilt.cpp/include/dogen/quilt.cpp/types/formattables/inclusion_directives_repository_factory.hpp
+++ b/projects/quilt.cpp/include/dogen/quilt.cpp/types/formattables/inclusion_directives_repository_factory.hpp
@@ -29,9 +29,9 @@
 #include <unordered_map>
 #include "dogen/dynamic/types/repository.hpp"
 #include "dogen/yarn/types/model.hpp"
+#include "dogen/quilt.cpp/types/annotations/inclusion_directive_annotations_factory.hpp"
 #include "dogen/quilt.cpp/types/formatters/container.hpp"
 #include "dogen/quilt.cpp/types/formattables/locator.hpp"
-#include "dogen/quilt.cpp/types/formattables/registrar.hpp"
 #include "dogen/quilt.cpp/types/formattables/path_derivatives_repository.hpp"
 #include "dogen/quilt.cpp/types/formattables/inclusion_directives_repository.hpp"
 
@@ -44,15 +44,43 @@ namespace formattables {
  * @brief Creates the inclusion directives for an Yarn model.
  */
 class inclusion_directives_repository_factory {
+private:
+    typedef std::forward_list<
+        std::shared_ptr<formatters::file_formatter_interface>
+    > formatter_list_type;
+
+    formatter_list_type
+    filter_formatters(const formatter_list_type& formatters) const;
+
+    std::unordered_map<std::type_index, formatter_list_type>
+    filter_file_formatters_by_type_index(const formatters::container& fc) const;
+
+private:
+    /**
+     * @brief Inserts the inclusion directive.
+     */
+    void insert_inclusion_directive(const std::string& id,
+        const std::string& formatter_name, const std::string& directive,
+        inclusion_directives_repository& idrp) const;
+
+    /**
+     * @brief Converts a relative path to an inclusion directive.
+     */
+    std::string to_inclusion_directive(const boost::filesystem::path& p) const;
+
+public:
+    void populate_repository(const yarn::element& e,
+        const annotations::inclusion_directive_annotations_factory& factory,
+        const formatter_list_type& formatters,
+        const locator& locator, inclusion_directives_repository& idrp) const;
+
 public:
     /**
      * @brief Create the inclusion directives for an Yarn model.
      */
     inclusion_directives_repository make(
-        const dynamic::repository& drp,
-        const formatters::container& fc,
-        const registrar& rg, const locator& l,
-        const yarn::model& m) const;
+        const dynamic::repository& drp, const formatters::container& fc,
+        const locator& l, const yarn::model& m) const;
 };
 
 } } } }
diff --git a/projects/quilt.cpp/src/types/fabric/master_header_factory.cpp b/projects/quilt.cpp/src/types/fabric/master_header_factory.cpp
index 5a2cec0..ff50f6b 100644
--- a/projects/quilt.cpp/src/types/fabric/master_header_factory.cpp
+++ b/projects/quilt.cpp/src/types/fabric/master_header_factory.cpp
@@ -72,7 +72,7 @@ private:
         std::type_index,
         std::forward_list<
             std::shared_ptr<formatters::file_formatter_interface>>>
-    filter_file_formatters_by_type_index(const formatters::container& fc);
+    filter_file_formatters_by_type_index(const formatters::container& fc) const;
 
     void process_element(const yarn::element& e);
 
@@ -129,7 +129,7 @@ std::unordered_map<
     std::forward_list<
         std::shared_ptr<formatters::file_formatter_interface>>>
 generator::filter_file_formatters_by_type_index(
-    const formatters::container& fc) {
+    const formatters::container& fc) const {
     std::unordered_map<
         std::type_index,
         std::forward_list<
diff --git a/projects/quilt.cpp/src/types/formattables/formatter_properties_repository_factory.cpp b/projects/quilt.cpp/src/types/formattables/formatter_properties_repository_factory.cpp
index b5011c2..0461b9c 100644
--- a/projects/quilt.cpp/src/types/formattables/formatter_properties_repository_factory.cpp
+++ b/projects/quilt.cpp/src/types/formattables/formatter_properties_repository_factory.cpp
@@ -43,12 +43,10 @@ namespace formattables {
 
 inclusion_directives_repository formatter_properties_repository_factory::
 create_inclusion_directives_repository(
-    const dynamic::repository& srp,
-    const formatters::container& fc,
-    const registrar& rg, const locator& l,
-    const yarn::model& m) const {
+    const dynamic::repository& srp, const formatters::container& fc,
+    const locator& l, const yarn::model& m) const {
     inclusion_directives_repository_factory f;
-    return f.make(srp, fc, rg, l, m);
+    return f.make(srp, fc, l, m);
 }
 
 inclusion_dependencies_repository formatter_properties_repository_factory::
@@ -121,12 +119,11 @@ formatter_properties_repository_factory::create_formatter_properties(
 formatter_properties_repository formatter_properties_repository_factory::
 make(const dynamic::repository& srp, const dynamic::object& root_object,
     const std::unordered_map<std::string, std::string>& fdff,
-    const path_derivatives_repository& pdrp,
-    const registrar& rg, const locator& l,
+    const path_derivatives_repository& pdrp, const locator& l,
     const formatters::container& fc, const yarn::model& m) const {
 
     BOOST_LOG_SEV(lg, debug) << "Building formatter properties repository.";
-    const auto idrp(create_inclusion_directives_repository(srp, fc, rg, l, m));
+    const auto idrp(create_inclusion_directives_repository(srp, fc, l, m));
     const auto erp(create_enablement_repository(srp, root_object, fc, m));
 
     const inclusion_dependencies_builder_factory bf(erp, idrp);
diff --git a/projects/quilt.cpp/src/types/formattables/inclusion_directives_repository_factory.cpp b/projects/quilt.cpp/src/types/formattables/inclusion_directives_repository_factory.cpp
index 37d8b04..05d9bc8 100644
--- a/projects/quilt.cpp/src/types/formattables/inclusion_directives_repository_factory.cpp
+++ b/projects/quilt.cpp/src/types/formattables/inclusion_directives_repository_factory.cpp
@@ -31,7 +31,6 @@
 #include "dogen/quilt.cpp/types/fabric/element_visitor.hpp"
 #include "dogen/quilt.cpp/types/formattables/building_error.hpp"
 #include "dogen/quilt.cpp/io/formattables/inclusion_directives_repository_io.hpp"
-#include "dogen/quilt.cpp/types/annotations/inclusion_directive_annotations_factory.hpp"
 #include "dogen/quilt.cpp/types/formattables/inclusion_directives_repository_factory.hpp"
 
 namespace {
@@ -43,6 +42,8 @@ static logger lg(logger_factory(
 const std::string double_quote("\"");
 const std::string duplicate_name("Duplicate name: ");
 const std::string empty_include_directive("Include directive is empty.");
+const std::string formatter_not_found_for_type(
+    "Formatter not found for type: ");
 
 }
 
@@ -51,275 +52,41 @@ namespace quilt {
 namespace cpp {
 namespace formattables {
 
-namespace {
-
-/**
- * @brief Generates all inclusion directives.
- */
-class generator final : public fabric::element_visitor {
-public:
-    generator(const container& c, const locator& l,
-        const annotations::inclusion_directive_annotations_factory& f)
-        : container_(obtain_relevant_providers(c)), locator_(l), factory_(f) { }
-
-private:
-    /**
-     * @brief Filter out providers that do not support inclusion
-     * paths.
-     *
-     * Not all formatters support inclusion path. We are only
-     * interested in those which do.
-     */
-    container obtain_relevant_providers(const container& c) const;
-
-    /**
-     * @brief Inserts the inclusion directive.
-     */
-    void insert_inclusion_directive(const std::string& id,
-        const std::string& formatter_name, const std::string& directive);
+inclusion_directives_repository_factory::formatter_list_type
+inclusion_directives_repository_factory::
+filter_formatters(const formatter_list_type& formatters) const {
+    formatter_list_type r;
 
-    /**
-     * @brief Converts a relative path to an inclusion directive.
+    /*
+     * We are only interested in formatters that generate
+     * header files.
      */
-    std::string to_inclusion_directive(const boost::filesystem::path& p) const;
-
-private:
-    template<typename YarnEntity>
-    void generate(const std::forward_list<
-        boost::shared_ptr<provider_interface<YarnEntity>>>& providers,
-        const YarnEntity& e) {
-
-        const auto& n(e.name());
-        const auto id(n.id());
-
-        /*
-         * First we extract the configuration for the generation of
-         * include directives for this element. Note that we generate
-         * this setting for _all elements_ even if the user did not
-         * specify any meta-data (we do so via defaults).
-         *
-         * The question we are asking is: "does this element require
-         * any inclusion directives at all, across all facets?". Not
-         * all elements do; for example bool, int and so on don't
-         * require any inclusions at all across all facets. If the
-         * user did not override this, we default it to true because
-         * normally elements require inclusion.
-         */
-        const auto& o(e.extensions());
-        const bool required(factory_.make_top_level_inclusion_required(o));
-        if (!required) {
-            BOOST_LOG_SEV(lg, debug) << "Inclusion not required for element.";
-            return;
-        }
-
-        if (providers.empty()) {
-            BOOST_LOG_SEV(lg, debug) << "No providers found.";
-            return;
-        }
-
-        /*
-         * Now we start working at the formatter level.
-         */
-        for (const auto& p : providers) {
-            const auto fmt_n(p->formatter_name());
-            BOOST_LOG_SEV(lg, debug) << "Formatter: " << fmt_n;
-
-            /*
-             * Does the type require an inclusion directive for this
-             * specific formatter? Some types require inclusion
-             * directives for some formatters, but not for others. For
-             * example, we may need an include for serialising a
-             * std::list, but in test data we make use of helpers and
-             * thus do not require an include.
-             *
-             * Again, we default this to true.
-             */
-            const auto s(factory_.make_inclusion_directive_annotations(fmt_n, o));
-            if (!s.inclusion_required()) {
-                BOOST_LOG_SEV(lg, debug) << "Inclusion directive not required "
-                                         << " for formatter: " << fmt_n;
-                continue;
-            }
-
-            /*
-             * Do the annotations provide a "hard-coded" inclusion directive?
-             * That is, the type had an hard-coded incantation for its
-             * include. This is the case for system models such as boost, std
-             * etc where we can't compute the inclusion directive.
-             */
-            std::string directive;
-            if (s.inclusion_directive())
-                directive = *s.inclusion_directive();
-            else {
-                /*
-                 * Finally, we have no alternative but to compute the
-                 * inclusion directive.
-                 */
-                const auto path(p->provide_inclusion_path(locator_, n));
-                directive = to_inclusion_directive(path);
-            }
-
-            BOOST_LOG_SEV(lg, debug) << "Inclusion directive: " << directive;
-            insert_inclusion_directive(id, fmt_n, directive);
-
-            /*
-             * If the provider is also the default for this facet and
-             * element, we need to register it against the facet
-             * too. Note that, for a given element type on a given
-             * facet, there can only be one default - or else we'll
-             * throw.
-             */
-            const auto def(inclusion_path_support::is_default);
-            const auto fct_n(p->facet_name());
-            if (p->inclusion_path_support() == def) {
-                BOOST_LOG_SEV(lg, debug) << "Inserting default for: " << fct_n;
-                insert_inclusion_directive(id, fct_n, directive);
-            }
-        }
-    }
-
-public:
-    using fabric::element_visitor::visit;
-    void visit(const yarn::module& m) override {
-        BOOST_LOG_SEV(lg, debug) << "Generating inclusion directive for: "
-                                 << m.name().id() << " (module)";
-        generate(container_.module_providers(), m);
-    }
-
-    void visit(const yarn::concept& c) override {
-        BOOST_LOG_SEV(lg, debug) << "Generating inclusion directive for: "
-                                 << c.name().id() << " (concept)";
-        generate(container_.concept_providers(), c);
-    }
-
-    void visit(const yarn::primitive& p) override {
-        BOOST_LOG_SEV(lg, debug) << "Generating inclusion directive for: "
-                                 << p.name().id() << " (primitive)";
-        generate(container_.primitive_providers(), p);
-    }
-
-    void visit(const yarn::enumeration& e) override {
-        BOOST_LOG_SEV(lg, debug) << "Generating inclusion directive for: "
-                                 << e.name().id() << " (enumeration)";
-        generate(container_.enumeration_providers(), e);
-    }
-
-    void visit(const yarn::object& o) override {
-        BOOST_LOG_SEV(lg, debug) << "Generating inclusion directive for: "
-                                 << o.name().id() << " (object)";
-        generate(container_.object_providers(), o);
-    }
-
-    void visit(const yarn::exception& e) override {
-        BOOST_LOG_SEV(lg, debug) << "Generating inclusion directive for: "
-                                 << e.name().id() << " (exception)";
-        generate(container_.exception_providers(), e);
-    }
-
-    void visit(const yarn::visitor& v) override {
-        BOOST_LOG_SEV(lg, debug) << "Generating inclusion directive for: "
-                                 << v.name().id() << " (visitor)";
-        generate(container_.visitor_providers(), v);
-    }
-
-    void visit(const fabric::registrar& rg) override {
-        BOOST_LOG_SEV(lg, debug) << "Generating inclusion directive for: "
-                                 << rg.name().id() << " (registrar)";
-        generate(container_.registrar_providers(), rg);
-    }
-
-    void visit(const fabric::master_header& mh) override {
-        BOOST_LOG_SEV(lg, debug) << "Generating inclusion directive for: "
-                                 << mh.name().id() << " (master header)";
-        generate(container_.master_header_providers(), mh);
-    }
-
-    void visit(const fabric::forward_declarations& fd) override {
-        BOOST_LOG_SEV(lg, debug) << "Generating inclusion directive for: "
-                                 << fd.name().id() << " (forward declarations)";
-        generate(container_.forward_declarations_providers(), fd);
-    }
-
-public:
-    const inclusion_directives_repository& result() const { return result_; }
-
-private:
-    const container container_;
-    const locator& locator_;
-    const annotations::inclusion_directive_annotations_factory factory_;
-    inclusion_directives_repository result_;
-};
-
-container generator::obtain_relevant_providers(const container& c) const {
-    container r;
-
-    const auto ns(inclusion_path_support::not_supported);
-
-    for (auto p : c.module_providers()) {
-        if (p->inclusion_path_support() == ns)
-            continue;
-        r.module_providers().push_front(p);
-    }
-
-    for (auto p : c.concept_providers()) {
-        if (p->inclusion_path_support() == ns)
-            continue;
-        r.concept_providers().push_front(p);
-    }
-
-    for (auto p : c.primitive_providers()) {
-        if (p->inclusion_path_support() == ns)
-            continue;
-        r.primitive_providers().push_front(p);
-    }
-
-    for (auto p : c.object_providers()) {
-        if (p->inclusion_path_support() == ns)
-            continue;
-        r.object_providers().push_front(p);
-    }
-
-    for (auto p : c.enumeration_providers()) {
-        if (p->inclusion_path_support() == ns)
-            continue;
-        r.enumeration_providers().push_front(p);
-    }
-
-    for (auto p : c.exception_providers()) {
-        if (p->inclusion_path_support() == ns)
-            continue;
-        r.exception_providers().push_front(p);
-    }
-
-    for (auto p : c.visitor_providers()) {
-        if (p->inclusion_path_support() == ns)
-            continue;
-        r.visitor_providers().push_front(p);
-    }
-
-    for (auto p : c.registrar_providers()) {
-        if (p->inclusion_path_support() == ns)
-            continue;
-        r.registrar_providers().push_front(p);
-    }
-
-    for (auto p : c.master_header_providers()) {
-        if (p->inclusion_path_support() == ns)
-            continue;
-        r.master_header_providers().push_front(p);
+    using formatters::inclusion_support_types;
+    static const auto ns(inclusion_support_types::not_supported);
+    for (const auto& f : formatters) {
+        if (f->inclusion_support_type() != ns)
+            r.push_front(f);
     }
+    return r;
+}
 
-    for (auto p : c.forward_declarations_providers()) {
-        if (p->inclusion_path_support() == ns)
-            continue;
-        r.forward_declarations_providers().push_front(p);
+std::unordered_map<std::type_index,
+                   inclusion_directives_repository_factory::formatter_list_type>
+inclusion_directives_repository_factory::
+filter_file_formatters_by_type_index(const formatters::container& fc) const {
+    std::unordered_map<std::type_index, formatter_list_type> r;
+    for (const auto& pair : fc.file_formatters_by_type_index()) {
+        const auto& ti(pair.first);
+        const auto& fmts(pair.second);
+        r[ti] = filter_formatters(fmts);
     }
-
     return r;
 }
 
-void generator::insert_inclusion_directive(const std::string& id,
-    const std::string& formatter_name, const std::string& directive) {
+void inclusion_directives_repository_factory::
+insert_inclusion_directive(const std::string& id,
+    const std::string& formatter_name, const std::string& directive,
+    inclusion_directives_repository& idrp) const {
 
     if (directive.empty()) {
         std::ostringstream s;
@@ -331,7 +98,7 @@ void generator::insert_inclusion_directive(const std::string& id,
     }
 
     const auto fn_dir(std::make_pair(formatter_name, directive));
-    const auto pair(result_.by_name()[id].insert(fn_dir));
+    const auto pair(idrp.by_name()[id].insert(fn_dir));
     if (pair.second)
         return;
 
@@ -339,30 +106,129 @@ void generator::insert_inclusion_directive(const std::string& id,
     BOOST_THROW_EXCEPTION(building_error(duplicate_name + id));
 }
 
-std::string generator::
+std::string inclusion_directives_repository_factory::
 to_inclusion_directive(const boost::filesystem::path& p) const {
     std::ostringstream ss;
     ss << double_quote << p.generic_string() << double_quote;
     return ss.str();
 }
 
+void inclusion_directives_repository_factory::populate_repository(
+    const yarn::element& e,
+    const annotations::inclusion_directive_annotations_factory& factory,
+    const formatter_list_type& formatters, const locator& locator,
+    inclusion_directives_repository& idrp) const {
+
+    const auto& n(e.name());
+    const auto id(n.id());
+
+    /*
+     * First we extract the configuration for the generation of
+     * include directives for this element. Note that we generate
+     * this setting for _all elements_ even if the user did not
+     * specify any meta-data (we do so via defaults).
+     *
+     * The question we are asking is: "does this element require
+     * any inclusion directives at all, across all facets?". Not
+     * all elements do; for example bool, int and so on don't
+     * require any inclusions at all across all facets. If the
+     * user did not override this, we default it to true because
+     * normally elements require inclusion.
+     */
+    const auto& o(e.extensions());
+    const bool required(factory.make_top_level_inclusion_required(o));
+    if (!required) {
+        BOOST_LOG_SEV(lg, debug) << "Inclusion not required for element.";
+        return;
+    }
+
+    if (formatters.empty()) {
+        BOOST_LOG_SEV(lg, debug) << "No providers found.";
+        return;
+    }
+
+    /*
+     * Now we start working at the formatter level.
+     */
+    for (const auto& fmt : formatters) {
+        const auto fmtn(fmt->ownership_hierarchy().formatter_name());
+        BOOST_LOG_SEV(lg, debug) << "Formatter: " << fmtn;
+
+        /*
+         * Does the type require an inclusion directive for this
+         * specific formatter? Some types require inclusion
+         * directives for some formatters, but not for others. For
+         * example, we may need an include for serialising a
+         * std::list, but in test data we make use of helpers and
+         * thus do not require an include.
+         *
+         * Again, we default this to true.
+         */
+        const auto s(factory.make_inclusion_directive_annotations(fmtn, o));
+        if (!s.inclusion_required()) {
+            BOOST_LOG_SEV(lg, debug) << "Inclusion directive not required "
+                                     << " for formatter: " << fmtn;
+            continue;
+        }
+
+        /*
+         * Do the annotations provide a "hard-coded" inclusion directive?
+         * That is, the type had an hard-coded incantation for its
+         * include. This is the case for system models such as boost, std
+         * etc where we can't compute the inclusion directive.
+         */
+        std::string directive;
+        if (s.inclusion_directive())
+            directive = *s.inclusion_directive();
+        else {
+            /*
+             * Finally, we have no alternative but to compute the
+             * inclusion directive.
+             */
+            const auto path(fmt->inclusion_path(locator, n));
+            directive = to_inclusion_directive(path);
+        }
+
+        BOOST_LOG_SEV(lg, debug) << "Inclusion directive: " << directive;
+        insert_inclusion_directive(id, fmtn, directive, idrp);
+
+        /*
+         * If the provider is also the default for this facet and
+         * element, we need to register it against the facet
+         * too. Note that, for a given element type on a given
+         * facet, there can only be one default - or else we'll
+         * throw.
+         */
+        const auto cs(formatters::inclusion_support_types::canonical_support);
+        const auto fctn(fmt->ownership_hierarchy().facet_name());
+        if (fmt->inclusion_support_type() == cs) {
+            BOOST_LOG_SEV(lg, debug) << "Inserting default for: " << fctn;
+            insert_inclusion_directive(id, fctn, directive, idrp);
+        }
+    }
 }
 
 inclusion_directives_repository inclusion_directives_repository_factory::make(
-    const dynamic::repository& drp,
-    const formatters::container& fc,
-    const registrar& rg, const locator& l,
-    const yarn::model& m) const {
+    const dynamic::repository& drp, const formatters::container& fc,
+    const locator& l, const yarn::model& m) const {
 
     BOOST_LOG_SEV(lg, debug) << "Making inclusion directives repository.";
 
+    inclusion_directives_repository r;
+    const auto ffti(filter_file_formatters_by_type_index(fc));
     const annotations::inclusion_directive_annotations_factory f(drp, fc);
-    generator g(rg.container(), l, f);
     for (const auto& ptr : m.elements()) {
         const auto& e(*ptr);
-        e.accept(g);
+        const auto id(e.name().id());
+        const auto ti(std::type_index(typeid(e)));
+
+        const auto i(ffti.find(ti));
+        if (i == ffti.end()) {
+            BOOST_LOG_SEV(lg, debug) << formatter_not_found_for_type << id;
+            continue;
+        }
+        populate_repository(e, f, i->second, l, r);
     }
-    const auto r(g.result());
 
     BOOST_LOG_SEV(lg, debug) << "Finished inclusion directives repository:"
                              << r;
diff --git a/projects/quilt.cpp/src/types/formattables/workflow.cpp b/projects/quilt.cpp/src/types/formattables/workflow.cpp
index 745720e..e262c69 100644
--- a/projects/quilt.cpp/src/types/formattables/workflow.cpp
+++ b/projects/quilt.cpp/src/types/formattables/workflow.cpp
@@ -116,7 +116,7 @@ create_formatter_properties(const dynamic::repository& drp,
     const yarn::model& m) const {
 
     formatter_properties_repository_factory f;
-    return f.make(drp, root_object, fdff, pdrp, registrar(), l, fc, m);
+    return f.make(drp, root_object, fdff, pdrp, l, fc, m);
 }
 
 element_properties_repository workflow::create_element_properties_repository(
diff --git a/projects/quilt.cpp/src/types/formatters/hash/enum_header_formatter.cpp b/projects/quilt.cpp/src/types/formatters/hash/enum_header_formatter.cpp
index 41c390f..aaf8da0 100644
--- a/projects/quilt.cpp/src/types/formatters/hash/enum_header_formatter.cpp
+++ b/projects/quilt.cpp/src/types/formatters/hash/enum_header_formatter.cpp
@@ -134,7 +134,7 @@ inclusion_support_types enum_header_formatter::inclusion_support_type() const {
 
 boost::filesystem::path enum_header_formatter::inclusion_path(
     const formattables::locator& l, const yarn::name& n) const {
-    return l.make_full_path_for_cpp_header(n, static_formatter_name());
+    return l.make_inclusion_path_for_cpp_header(n, static_formatter_name());
 }
 
 boost::filesystem::path enum_header_formatter::full_path(
