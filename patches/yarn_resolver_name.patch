diff --git a/doc/agile/sprint_backlog_74.org b/doc/agile/sprint_backlog_74.org
index c4687b6..b271991 100644
--- a/doc/agile/sprint_backlog_74.org
+++ b/doc/agile/sprint_backlog_74.org
@@ -15,18 +15,18 @@
 ** Active
 
 #+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75
-#+CAPTION: Clock summary at [2015-11-16 Mon 22:47]
+#+CAPTION: Clock summary at [2015-11-17 Tue 22:53]
 | <75>                                                                        |        |      |      |
 | Headline                                                                    | Time   |      |      |
 |-----------------------------------------------------------------------------+--------+------+------|
-| *Total time*                                                                | *8:10* |      |      |
+| *Total time*                                                                | *9:42* |      |      |
 |-----------------------------------------------------------------------------+--------+------+------|
-| Stories                                                                     | 8:10   |      |      |
-| Active                                                                      |        | 8:10 |      |
+| Stories                                                                     | 9:42   |      |      |
+| Active                                                                      |        | 9:42 |      |
 | STARTED Sprint and product backlog grooming                                 |        |      | 1:29 |
 | COMPLETED Write the next interesting instalment                             |        |      | 1:05 |
 | STARTED SML json hydrator =read_module_path= needs refactoring              |        |      | 1:21 |
-| STARTED Generate all yarn names using name factory                          |        |      | 4:15 |
+| STARTED Generate all yarn names using name factory                          |        |      | 5:47 |
 #+end:
 
 *** STARTED Sprint and product backlog grooming                       :story:
@@ -63,6 +63,8 @@ this into a =read= function without side-effects and a =create=
 function that creates the missing modules.
 
 *** STARTED Generate all yarn names using name factory                :story:
+    CLOCK: [2015-11-17 Tue 22:44]--[2015-11-17 Tue 22:53] =>  0:09
+    CLOCK: [2015-11-17 Tue 21:51]--[2015-11-17 Tue 22:43] =>  0:52
     CLOCK: [2015-11-17 Tue 21:19]--[2015-11-17 Tue 21:50] =>  0:31
     CLOCK: [2015-11-16 Mon 20:44]--[2015-11-16 Mon 22:47] =>  2:03
     CLOCK: [2015-11-11 Wed 21:26]--[2015-11-11 Wed 21:29] =>  0:03
diff --git a/projects/yarn/include/dogen/yarn/types/name_factory.hpp b/projects/yarn/include/dogen/yarn/types/name_factory.hpp
index b9853f7..b43cea5 100644
--- a/projects/yarn/include/dogen/yarn/types/name_factory.hpp
+++ b/projects/yarn/include/dogen/yarn/types/name_factory.hpp
@@ -74,6 +74,12 @@ public:
      */
     name build_module_name(const name& model_name,
         const std::list<std::string>& internal_module_path) const;
+
+    /**
+     * @brief Combines element name with model name.
+     */
+    name build_combined_element_name(const name& model_name,
+        const name& partial_element_name) const;
 };
 
 } }
diff --git a/projects/yarn/include/dogen/yarn/types/resolver.hpp b/projects/yarn/include/dogen/yarn/types/resolver.hpp
index 8f97336..2a4f8a2 100644
--- a/projects/yarn/include/dogen/yarn/types/resolver.hpp
+++ b/projects/yarn/include/dogen/yarn/types/resolver.hpp
@@ -65,6 +65,19 @@ public:
 
 private:
     /**
+     * @brief Returns a list of names for the model and its references.
+     */
+    std::list<name>
+    create_list_of_model_names(const intermediate_model& m) const;
+
+private:
+    /**
+     * @brief Returns true if the name is in the model, false
+     * otherwise.
+     */
+    bool is_name_in_model(const name& n) const;
+
+    /**
      * @brief Resolves a partially formed name into a full name.
      */
     name resolve_partial_type(const name& n) const;
@@ -124,6 +137,7 @@ public:
     void resolve();
 
 private:
+    const std::list<name> model_names_;
     intermediate_model& model_;
     bool has_resolved_;
 };
diff --git a/projects/yarn/src/types/name_factory.cpp b/projects/yarn/src/types/name_factory.cpp
index 5aac517..90f1abb 100644
--- a/projects/yarn/src/types/name_factory.cpp
+++ b/projects/yarn/src/types/name_factory.cpp
@@ -122,4 +122,16 @@ name name_factory::build_module_name(const name& model_name,
     return n;
 }
 
+name name_factory::build_combined_element_name(const name& model_name,
+    const name& partial_element_name) const {
+    name r(partial_element_name);
+
+    const auto& l(model_name.location());
+    r.location().original_model_name(l.original_model_name());
+    // r.location().model_module_path(l.model_module_path());
+    r.location().external_module_path(l.external_module_path());
+
+    return r;
+}
+
 } }
diff --git a/projects/yarn/src/types/resolver.cpp b/projects/yarn/src/types/resolver.cpp
index 57d670b..5dae4dd 100644
--- a/projects/yarn/src/types/resolver.cpp
+++ b/projects/yarn/src/types/resolver.cpp
@@ -27,10 +27,12 @@
 #include "dogen/utility/log/logger.hpp"
 #include "dogen/utility/io/unordered_set_io.hpp"
 #include "dogen/yarn/types/resolution_error.hpp"
+#include "dogen/yarn/io/name_io.hpp"
 #include "dogen/yarn/io/nested_name_io.hpp"
 #include "dogen/yarn/io/property_io.hpp"
 #include "dogen/yarn/io/intermediate_model_io.hpp"
 #include "dogen/yarn/types/object.hpp"
+#include "dogen/yarn/types/name_factory.hpp"
 #include "dogen/yarn/types/resolver.hpp"
 
 using namespace dogen::utility::log;
@@ -52,128 +54,81 @@ typedef boost::error_info<struct tag_errmsg, std::string> errmsg_info;
 namespace dogen {
 namespace yarn {
 
-resolver::resolver(intermediate_model& m) : model_(m), has_resolved_(false) { }
+resolver::resolver(intermediate_model& m)
+    : model_names_(create_list_of_model_names(m)),
+      model_(m), has_resolved_(false) { }
 
-void resolver::validate_inheritance_graph(const object& ao) const {
-    auto i(ao.relationships().find(relationship_types::parents));
-    if (i == ao.relationships().end())
-        return;
+std::list<name> resolver::
+create_list_of_model_names(const intermediate_model& m) const {
+    std::list<name> r;
+    r.push_back(m.name());
 
-    for (const auto& pn : i->second) {
-        const auto j(model_.objects().find(pn));
-        if (j == model_.objects().end()) {
-            std::ostringstream s;
-            s << orphan_object << ": " << ao.name().qualified()
-              << ". parent: " << pn.qualified();
+    for (const auto& pair : m.references())
+        r.push_back(pair.first);
 
-            BOOST_LOG_SEV(lg, error) << s.str();
-            BOOST_THROW_EXCEPTION(resolution_error(s.str()));
-        }
-    }
+    return r;
+}
 
-    i = ao.relationships().find(relationship_types::original_parents);
-    if (i == ao.relationships().end())
-        return;
+bool resolver::is_name_in_model(const name& n) const {
+    BOOST_LOG_SEV(lg, debug) << "Finding name:" << n;
 
-    for (const auto& pn : i->second) {
-        const auto j(model_.objects().find(pn));
-        if (j == model_.objects().end()) {
-            std::ostringstream s;
-            s << orphan_object << ": " << ao.name().qualified()
-              << ". original parent: " << pn.qualified();
-
-            BOOST_LOG_SEV(lg, error) << s.str();
-            BOOST_THROW_EXCEPTION(resolution_error(s.str()));
-        }
+    auto i(model_.objects().find(n));
+    if (i != model_.objects().end()) {
+        BOOST_LOG_SEV(lg, debug) << "Name belongs to an object in model.";
+        return true;
     }
-}
 
-void resolver::validate_refinements(const concept& c) const {
-    for (const auto& n : c.refines()) {
-        const auto i(model_.concepts().find(n));
-        if (i == model_.concepts().end()) {
-            std::ostringstream stream;
-            stream << orphan_concept << ". concept: "
-                   << c.name().qualified()
-                   << ". refined concept: " << n.qualified();
+    auto j(model_.enumerations().find(n));
+    if (j != model_.enumerations().end()) {
+        BOOST_LOG_SEV(lg, debug) << "Name belongs to an enumeration in model.";
+        return true;
+    }
 
-            BOOST_LOG_SEV(lg, error) << stream.str();
-            BOOST_THROW_EXCEPTION(resolution_error(stream.str()));
-        }
+    auto k(model_.primitives().find(n));
+    if (k != model_.primitives().end()) {
+        BOOST_LOG_SEV(lg, debug) << "Name belongs to a primitive in model.";
+        return true;
     }
+
+    BOOST_LOG_SEV(lg, debug) << "Name not found in model.";
+    return false;
 }
 
 name resolver::resolve_partial_type(const name& n) const {
     BOOST_LOG_SEV(lg, debug) << "Resolving type:" << n.qualified();
 
-    name r(n);
-
-    // first try the type as it was read originally.
-    const auto& objects(model_.objects());
-    auto i(objects.find(r));
-    if (i != objects.end())
-        return r;
-
-    // then try setting module path to the target one
-    r.location().external_module_path(
-        model_.name().location().external_module_path());
-    i = objects.find(r);
-    if (i != objects.end())
-        return r;
-
-    // now try all available module paths from references
-    for (const auto& pair : model_.references()) {
-        const auto n(pair.first);
-        r.location().external_module_path(
-            n.location().external_module_path());
-        i = objects.find(r);
-        if (i != objects.end())
-            return r;
-    }
-
-    // reset external module path
-    r.location().external_module_path(std::list<std::string>{});
-
-    // its not a object, could it be a primitive?
-    const auto& primitives(model_.primitives());
-    auto j(primitives.find(r));
-    if (j != primitives.end())
-        return r;
-
-    // try enumerations
-    const auto& enumerations(model_.enumerations());
-    auto k(enumerations.find(r));
-    if (k != enumerations.end())
-        return r;
-
-    // then try setting module path to the target one
-    r.location().external_module_path(
-        model_.name().location().external_module_path());
-    k = enumerations.find(r);
-    if (k != enumerations.end())
-        return r;
-
-    // now try all available module paths from references
-    for (const auto& pair : model_.references()) {
-        const auto n(pair.first);
-        r.location().external_module_path(
-            n.location().external_module_path());
-        k = enumerations.find(r);
-        if (k != enumerations.end())
+    /* first try the type as it was read originally. This caters for
+     * types placed in the global namespace.
+     */
+    if (is_name_in_model(n))
+        return n;
+
+    /* then try the type as if belonging to either the main model or
+     * one of its references.
+     * FIXME: if type has no model, then combine it with current
+     * model. if type has model, then find the reference and combine
+     * it with the reference.
+
+     */
+    name_factory nf;
+    for (const auto& mn : model_names_) {
+        const auto r(nf.build_combined_element_name(mn, n));
+        if (is_name_in_model(r))
             return r;
     }
 
+    auto r(n);
     if (r.location().original_model_name().empty()) {
         const auto& l(model_.name().location());
         // it could be a type defined in this model
         r.location().original_model_name(l.original_model_name());
         r.location().external_module_path(l.external_module_path());
-        i = objects.find(r);
-        if (i != objects.end())
+        const auto i = model_.objects().find(r);
+        if (i != model_.objects().end())
             return r;
 
-        auto k(enumerations.find(r));
-        if (k != enumerations.end())
+        const auto k(model_.enumerations().find(r));
+        if (k != model_.enumerations().end())
             return r;
     }
 
@@ -190,8 +145,8 @@ name resolver::resolve_partial_type(const name& n) const {
         n.location().external_module_path(
             model_.name().location().external_module_path());
 
-        i = objects.find(n);
-        if (i != objects.end())
+        const auto i = model_.objects().find(n);
+        if (i != model_.objects().end())
             return n;
     }
 
@@ -224,6 +179,55 @@ resolve_properties(const name& owner, std::list<property>& p) const {
     }
 }
 
+void resolver::validate_inheritance_graph(const object& ao) const {
+    auto i(ao.relationships().find(relationship_types::parents));
+    if (i == ao.relationships().end())
+        return;
+
+    for (const auto& pn : i->second) {
+        const auto j(model_.objects().find(pn));
+        if (j == model_.objects().end()) {
+            std::ostringstream s;
+            s << orphan_object << ": " << ao.name().qualified()
+              << ". parent: " << pn.qualified();
+
+            BOOST_LOG_SEV(lg, error) << s.str();
+            BOOST_THROW_EXCEPTION(resolution_error(s.str()));
+        }
+    }
+
+    i = ao.relationships().find(relationship_types::original_parents);
+    if (i == ao.relationships().end())
+        return;
+
+    for (const auto& pn : i->second) {
+        const auto j(model_.objects().find(pn));
+        if (j == model_.objects().end()) {
+            std::ostringstream s;
+            s << orphan_object << ": " << ao.name().qualified()
+              << ". original parent: " << pn.qualified();
+
+            BOOST_LOG_SEV(lg, error) << s.str();
+            BOOST_THROW_EXCEPTION(resolution_error(s.str()));
+        }
+    }
+}
+
+void resolver::validate_refinements(const concept& c) const {
+    for (const auto& n : c.refines()) {
+        const auto i(model_.concepts().find(n));
+        if (i == model_.concepts().end()) {
+            std::ostringstream stream;
+            stream << orphan_concept << ". concept: "
+                   << c.name().qualified()
+                   << ". refined concept: " << n.qualified();
+
+            BOOST_LOG_SEV(lg, error) << stream.str();
+            BOOST_THROW_EXCEPTION(resolution_error(stream.str()));
+        }
+    }
+}
+
 void resolver::require_not_has_resolved() const {
     if (!has_resolved())
         return;
