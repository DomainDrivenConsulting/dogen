diff --git a/diagrams/sml.dia b/diagrams/sml.dia
index b98521e..1fb85db 100644
--- a/diagrams/sml.dia
+++ b/diagrams/sml.dia
@@ -620,7 +620,7 @@ representation of the primitive type.#</dia:string>
         <dia:point val="-98,36"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="8.3349999999999991"/>
+        <dia:real val="8.3350000000000009"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="5.2000000000000011"/>
@@ -2264,7 +2264,7 @@ and all of the supported types within those models.#</dia:string>
         <dia:real val="24.77"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
-        <dia:real val="4.0999999999999996"/>
+        <dia:real val="4.1000000000000005"/>
       </dia:attribute>
       <dia:attribute name="line_width">
         <dia:real val="0.10000000000000001"/>
@@ -2638,7 +2638,7 @@ all types in the combined model.#</dia:string>
         <dia:point val="3,11"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="31.685000000000002"/>
+        <dia:real val="31.684999999999999"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="7.5999999999999996"/>
@@ -3327,7 +3327,7 @@ All of these steps are encompassed in the SML @ref workflow.
         <dia:point val="-32,-6"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="7.0924999999999994"/>
+        <dia:real val="7.0925000000000002"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="3"/>
@@ -3863,7 +3863,7 @@ All of these steps are encompassed in the SML @ref workflow.
         <dia:point val="48,117"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="6.6225000000000005"/>
+        <dia:real val="6.6224999999999996"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="5.2000000000000011"/>
@@ -5991,7 +5991,7 @@ for Java, etc.#</dia:string>
         <dia:point val="-70,50"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="27.064999999999998"/>
+        <dia:real val="27.065000000000001"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="4.4000000000000004"/>
@@ -10627,7 +10627,7 @@ User models are regular Dogen models, normally made using Dia.#</dia:string>
         <dia:point val="85,64"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="24.755000000000003"/>
+        <dia:real val="24.754999999999999"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="4.4000000000000004"/>
@@ -10911,7 +10911,7 @@ User models are regular Dogen models, normally made using Dia.#</dia:string>
         <dia:point val="151,64"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="20.134999999999998"/>
+        <dia:real val="20.135000000000002"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="5.2000000000000002"/>
@@ -12063,7 +12063,7 @@ User models are regular Dogen models, normally made using Dia.#</dia:string>
         <dia:point val="120,64"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="26.294999999999998"/>
+        <dia:real val="26.295000000000002"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="6"/>
@@ -12359,7 +12359,7 @@ User models are regular Dogen models, normally made using Dia.#</dia:string>
         <dia:point val="112,104"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="5.7799999999999994"/>
+        <dia:real val="5.7800000000000002"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="3"/>
@@ -12879,7 +12879,7 @@ User models are regular Dogen models, normally made using Dia.#</dia:string>
         <dia:point val="-52,4"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="25.155000000000005"/>
+        <dia:real val="25.154999999999998"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="2.5"/>
@@ -13188,7 +13188,7 @@ tag containers.#</dia:string>
         <dia:point val="-89,29"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="26.310000000000002"/>
+        <dia:real val="26.309999999999999"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="2.5"/>
@@ -13384,7 +13384,7 @@ any entity which models the Taggable concept. Provides defaulting.#</dia:string>
         <dia:point val="-85,4"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="23.615000000000002"/>
+        <dia:real val="23.614999999999998"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="2.5"/>
@@ -13683,7 +13683,7 @@ and values (where applicable) for tags.#</dia:string>
         <dia:point val="-66,-13"/>
       </dia:attribute>
       <dia:attribute name="elem_width">
-        <dia:real val="21.690000000000001"/>
+        <dia:real val="21.689999999999998"/>
       </dia:attribute>
       <dia:attribute name="elem_height">
         <dia:real val="2.5"/>
@@ -13755,5 +13755,115 @@ based on association and generalisation relationships.#</dia:string>
         <dia:connection handle="1" to="O115" connection="1"/>
       </dia:connections>
     </dia:object>
+    <dia:object type="UML - Class" version="0" id="O118">
+      <dia:attribute name="obj_pos">
+        <dia:point val="-41,29"/>
+      </dia:attribute>
+      <dia:attribute name="obj_bb">
+        <dia:rectangle val="-41.05,28.95;-35.445,32.05"/>
+      </dia:attribute>
+      <dia:attribute name="elem_corner">
+        <dia:point val="-41,29"/>
+      </dia:attribute>
+      <dia:attribute name="elem_width">
+        <dia:real val="5.5049999999999999"/>
+      </dia:attribute>
+      <dia:attribute name="elem_height">
+        <dia:real val="3"/>
+      </dia:attribute>
+      <dia:attribute name="name">
+        <dia:string>#tag_error#</dia:string>
+      </dia:attribute>
+      <dia:attribute name="stereotype">
+        <dia:string>#exception#</dia:string>
+      </dia:attribute>
+      <dia:attribute name="comment">
+        <dia:string>#An error has occurred while peforming an operation related to tagging.#</dia:string>
+      </dia:attribute>
+      <dia:attribute name="abstract">
+        <dia:boolean val="false"/>
+      </dia:attribute>
+      <dia:attribute name="suppress_attributes">
+        <dia:boolean val="false"/>
+      </dia:attribute>
+      <dia:attribute name="suppress_operations">
+        <dia:boolean val="false"/>
+      </dia:attribute>
+      <dia:attribute name="visible_attributes">
+        <dia:boolean val="true"/>
+      </dia:attribute>
+      <dia:attribute name="visible_operations">
+        <dia:boolean val="true"/>
+      </dia:attribute>
+      <dia:attribute name="visible_comments">
+        <dia:boolean val="false"/>
+      </dia:attribute>
+      <dia:attribute name="wrap_operations">
+        <dia:boolean val="true"/>
+      </dia:attribute>
+      <dia:attribute name="wrap_after_char">
+        <dia:int val="40"/>
+      </dia:attribute>
+      <dia:attribute name="comment_line_length">
+        <dia:int val="17"/>
+      </dia:attribute>
+      <dia:attribute name="comment_tagging">
+        <dia:boolean val="false"/>
+      </dia:attribute>
+      <dia:attribute name="line_width">
+        <dia:real val="0.10000000000000001"/>
+      </dia:attribute>
+      <dia:attribute name="line_color">
+        <dia:color val="#000000"/>
+      </dia:attribute>
+      <dia:attribute name="fill_color">
+        <dia:color val="#ffffff"/>
+      </dia:attribute>
+      <dia:attribute name="text_color">
+        <dia:color val="#000000"/>
+      </dia:attribute>
+      <dia:attribute name="normal_font">
+        <dia:font family="monospace" style="0" name="Courier"/>
+      </dia:attribute>
+      <dia:attribute name="abstract_font">
+        <dia:font family="monospace" style="88" name="Courier-BoldOblique"/>
+      </dia:attribute>
+      <dia:attribute name="polymorphic_font">
+        <dia:font family="monospace" style="8" name="Courier-Oblique"/>
+      </dia:attribute>
+      <dia:attribute name="classname_font">
+        <dia:font family="sans" style="80" name="Helvetica-Bold"/>
+      </dia:attribute>
+      <dia:attribute name="abstract_classname_font">
+        <dia:font family="sans" style="88" name="Helvetica-BoldOblique"/>
+      </dia:attribute>
+      <dia:attribute name="comment_font">
+        <dia:font family="sans" style="8" name="Helvetica-Oblique"/>
+      </dia:attribute>
+      <dia:attribute name="normal_font_height">
+        <dia:real val="0.80000000000000004"/>
+      </dia:attribute>
+      <dia:attribute name="polymorphic_font_height">
+        <dia:real val="0.80000000000000004"/>
+      </dia:attribute>
+      <dia:attribute name="abstract_font_height">
+        <dia:real val="0.80000000000000004"/>
+      </dia:attribute>
+      <dia:attribute name="classname_font_height">
+        <dia:real val="1"/>
+      </dia:attribute>
+      <dia:attribute name="abstract_classname_font_height">
+        <dia:real val="1"/>
+      </dia:attribute>
+      <dia:attribute name="comment_font_height">
+        <dia:real val="0.69999999999999996"/>
+      </dia:attribute>
+      <dia:attribute name="attributes"/>
+      <dia:attribute name="operations"/>
+      <dia:attribute name="template">
+        <dia:boolean val="false"/>
+      </dia:attribute>
+      <dia:attribute name="templates"/>
+    </dia:object>
   </dia:layer>
 </dia:diagram>
diff --git a/doc/agile/release_notes_sprint_35.org b/doc/agile/release_notes_sprint_35.org
index c47b9b8..230a8b3 100644
--- a/doc/agile/release_notes_sprint_35.org
+++ b/doc/agile/release_notes_sprint_35.org
@@ -10,20 +10,20 @@ This file contains all stories that were closed during sprint 35.
 ** Development Stories Implemented
 
 #+begin: clocktable :maxlevel 3 :scope subtree
-Clock summary at [2013-09-25 Wed 18:53]
+Clock summary at [2013-09-27 Fri 09:39]
 
 | Headline                                                     | Time   |      |      |
 |--------------------------------------------------------------+--------+------+------|
-| *Total time*                                                 | *6:32* |      |      |
+| *Total time*                                                 | *9:37* |      |      |
 |--------------------------------------------------------------+--------+------+------|
-| Development Stories Implemented                              |        | 6:32 |      |
+| Development Stories Implemented                              |        | 9:37 |      |
 | IMPLEMENTATION Release notes and backlog grooming            |        |      | 0:12 |
 | COMPLETED Refactor OM tests to avoid over-inclusion          |        |      | 0:32 |
 | COMPLETED Convert implementation specific parameters to list |        |      | 1:06 |
 | COMPLETED Rename implementation specific parameters          |        |      | 0:50 |
 | IMPLEMENTATION Implement the property cache in SML           |        |      | 1:14 |
-| IMPLEMENTATION Implement the opaque parameter cache in SML   |        |      | 0:56 |
-| IMPLEMENTATION Create a complete domain formatter in OM      |        |      | 1:42 |
+| IMPLEMENTATION Add meta-data support to SML                  |        |      | 3:04 |
+| IMPLEMENTATION Create a complete domain formatter in OM      |        |      | 2:39 |
 #+end:
 
 *** IMPLEMENTATION Release notes and backlog grooming                  :task:
@@ -85,7 +85,9 @@ Name choices:
     CLOCK: [2013-09-25 Wed 07:47]--[2013-09-25 Wed 08:09] =>  0:22
     CLOCK: [2013-09-24 Tue 23:40]--[2013-09-25 Wed 00:24] =>  0:44
 
-*** IMPLEMENTATION Implement the opaque parameter cache in SML        :story:
+*** IMPLEMENTATION Add meta-data support to SML                       :story:
+    CLOCK: [2013-09-27 Fri 08:21]--[2013-09-27 Fri 08:30] =>  0:09
+    CLOCK: [2013-09-27 Fri 07:48]--[2013-09-27 Fri 08:13] =>  0:25
     CLOCK: [2013-09-26 Thu 22:31]--[2013-09-26 Thu 23:31] =>  1:00
     CLOCK: [2013-09-26 Thu 22:25]--[2013-09-26 Thu 22:31] =>  0:06
     CLOCK: [2013-09-26 Thu 19:11]--[2013-09-26 Thu 19:18] =>  0:07
@@ -93,6 +95,8 @@ Name choices:
     CLOCK: [2013-09-25 Wed 18:02]--[2013-09-25 Wed 18:53] =>  0:51
     CLOCK: [2013-09-25 Wed 17:57]--[2013-09-25 Wed 18:02] =>  0:05
 
+New understanding:
+
 There is a fundamental problem with the parameter cache approach: it
 does not take into account parameters in properties. If we were to
 create another layer in the cache, we would be duplicating the object
@@ -116,6 +120,10 @@ rename it to avoid confusion. So we have:
 - =tagger=: visits the model as a graph and propagates tags across
   generalisations and associations.
 
+Old understanding:
+
+create a opaque parameter cache in SML.
+
 *** IMPLEMENTATION Create a complete domain formatter in OM           :story:
     CLOCK: [2013-09-26 Thu 22:08]--[2013-09-26 Thu 22:25] =>  0:17
     CLOCK: [2013-09-26 Thu 08:25]--[2013-09-26 Thu 08:33] =>  0:08
diff --git a/projects/dia_to_sml/src/types/transformer.cpp b/projects/dia_to_sml/src/types/transformer.cpp
index 728c578..e258836 100644
--- a/projects/dia_to_sml/src/types/transformer.cpp
+++ b/projects/dia_to_sml/src/types/transformer.cpp
@@ -32,10 +32,13 @@
 #include "dogen/sml/types/repository.hpp"
 #include "dogen/sml/types/value_object.hpp"
 #include "dogen/sml/types/service.hpp"
-#include "dogen/dia/types/composite.hpp"
-#include "dogen/dia/types/attribute.hpp"
 #include "dogen/sml/types/value_object.hpp"
 #include "dogen/sml/io/value_object_io.hpp"
+#include "dogen/sml/types/tags.hpp"
+#include "dogen/sml/types/tag_router.hpp"
+#include "dogen/sml/types/tag_adaptor.hpp"
+#include "dogen/dia/types/composite.hpp"
+#include "dogen/dia/types/attribute.hpp"
 #include "dogen/dia_to_sml/types/transformation_error.hpp"
 #include "dogen/dia_to_sml/io/object_types_io.hpp"
 #include "dogen/dia_to_sml/types/processed_object.hpp"
@@ -52,7 +55,6 @@ static logger lg(logger_factory("dia_to_sml.transformer"));
 const std::string empty;
 const std::string unsigned_int("unsigned int");
 const std::string identity_attribute_key("IDENTITY_ATTRIBUTE");
-const std::string comment_key("COMMENT");
 const std::string empty_dia_object_name("Dia object name is empty");
 const std::string original_parent_not_found("Object has no original parent: ");
 const std::string parent_not_found("Object has a parent but its not defined: ");
@@ -190,7 +192,8 @@ sml::property transformer::to_property(const processed_property& p) const {
 
     const auto pair(comments_parser_->parse(p.comment()));
     r.documentation(pair.first);
-    r.opaque_parameters(pair.second);
+    auto router(make_tag_router(r));
+    router.route(pair.second);
 
     return r;
 }
@@ -330,13 +333,9 @@ void transformer::update_abstract_entity(sml::abstract_entity& ae,
     ae.is_aggregate_root(p.is_aggregate_root());
 
     for (const auto& p : ae.properties()) {
-        for (const auto pair : p.opaque_parameters()) {
-            if (pair.first != identity_attribute_key)
-                continue;
-
+        auto adaptor(make_tag_adaptor(p));
+        if (adaptor.has_identity())
             ae.identity().push_back(p);
-            break;
-        }
     }
 }
 
@@ -450,19 +449,11 @@ void transformer::from_note(const processed_object& o) {
         return;
 
     const auto pair(comments_parser_->parse(o.text()));
-    bool has_marker(false);
-    for (const auto& p : pair.second) {
-        has_marker = p.first == comment_key;
-        if (has_marker)
-            break;
-    }
-
-    if (!has_marker)
-        return;
-
+    sml::model& model(context_.model());
     if (o.child_node_id().empty()) {
-        context_.model().documentation(pair.first);
-        context_.model().opaque_parameters(pair.second);
+        model.documentation(pair.first);
+        auto router(make_tag_router(model));
+        router.route_if(pair.second, sml::tags::comment);
         return;
     }
 
@@ -473,8 +464,8 @@ void transformer::from_note(const processed_object& o) {
             transformation_error(missing_module_for_id + o.child_node_id()));
     }
 
-    auto j(context_.model().modules().find(i->second));
-    if (j == context_.model().modules().end()) {
+    auto j(model.modules().find(i->second));
+    if (j == model.modules().end()) {
         BOOST_LOG_SEV(lg, error) << missing_module_for_qname
                                  << i->second.simple_name();
 
@@ -482,8 +473,12 @@ void transformer::from_note(const processed_object& o) {
             transformation_error(missing_module_for_qname +
                 i->second.simple_name()));
     }
-    j->second.documentation(pair.first);
-    j->second.opaque_parameters(pair.second);
+
+    sml::module& module(j->second);
+    module.documentation(pair.first);
+    auto router(make_tag_router(module));
+    router.route_if(pair.second, sml::tags::comment);
+
 }
 
 void transformer::to_concept(const processed_object& o, const profile& p) {
diff --git a/projects/sml/include/dogen/sml/types/abstract_entity.hpp b/projects/sml/include/dogen/sml/types/abstract_entity.hpp
index 31d00bd..a21c72c 100644
--- a/projects/sml/include/dogen/sml/types/abstract_entity.hpp
+++ b/projects/sml/include/dogen/sml/types/abstract_entity.hpp
@@ -73,7 +73,8 @@ public:
 public:
     abstract_entity(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
diff --git a/projects/sml/include/dogen/sml/types/abstract_object.hpp b/projects/sml/include/dogen/sml/types/abstract_object.hpp
index b958d0e..a5ec251 100644
--- a/projects/sml/include/dogen/sml/types/abstract_object.hpp
+++ b/projects/sml/include/dogen/sml/types/abstract_object.hpp
@@ -30,7 +30,7 @@
 #include <iosfwd>
 #include <list>
 #include <string>
-#include <utility>
+#include <unordered_map>
 #include "dogen/sml/serialization/abstract_object_fwd_ser.hpp"
 #include "dogen/sml/types/generation_types.hpp"
 #include "dogen/sml/types/operation.hpp"
@@ -60,7 +60,8 @@ public:
 public:
     abstract_object(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
diff --git a/projects/sml/include/dogen/sml/types/all.hpp b/projects/sml/include/dogen/sml/types/all.hpp
index 650ce65..363afba 100644
--- a/projects/sml/include/dogen/sml/types/all.hpp
+++ b/projects/sml/include/dogen/sml/types/all.hpp
@@ -39,9 +39,6 @@
 #include "dogen/sml/types/model.hpp"
 #include "dogen/sml/types/module.hpp"
 #include "dogen/sml/types/nested_qname.hpp"
-#include "dogen/sml/types/opaque_parameter_cache.hpp"
-#include "dogen/sml/types/opaque_parameter_cache_interface.hpp"
-#include "dogen/sml/types/opaque_parameters.hpp"
 #include "dogen/sml/types/operation.hpp"
 #include "dogen/sml/types/origin_types.hpp"
 #include "dogen/sml/types/parameter.hpp"
@@ -58,6 +55,11 @@
 #include "dogen/sml/types/service_types.hpp"
 #include "dogen/sml/types/sml.hpp"
 #include "dogen/sml/types/std_model_factory.hpp"
+#include "dogen/sml/types/tag_adaptor.hpp"
+#include "dogen/sml/types/tag_error.hpp"
+#include "dogen/sml/types/tag_router.hpp"
+#include "dogen/sml/types/tagger.hpp"
+#include "dogen/sml/types/tags.hpp"
 #include "dogen/sml/types/type.hpp"
 #include "dogen/sml/types/type_visitor.hpp"
 #include "dogen/sml/types/value_object.hpp"
diff --git a/projects/sml/include/dogen/sml/types/concept.hpp b/projects/sml/include/dogen/sml/types/concept.hpp
index 9a4d393..9221596 100644
--- a/projects/sml/include/dogen/sml/types/concept.hpp
+++ b/projects/sml/include/dogen/sml/types/concept.hpp
@@ -28,7 +28,7 @@
 #include <algorithm>
 #include <list>
 #include <string>
-#include <utility>
+#include <unordered_map>
 #include "dogen/sml/serialization/concept_fwd_ser.hpp"
 #include "dogen/sml/types/generation_types.hpp"
 #include "dogen/sml/types/operation.hpp"
@@ -55,7 +55,8 @@ public:
     concept(
         const std::list<dogen::sml::property>& properties,
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
@@ -97,13 +98,27 @@ public:
     /**@}*/
 
     /**
-     * @brief Associated generic parameters which may be opaque.
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key-value pair.
+     */
+    /**@{*/
+    const std::unordered_map<std::string, std::string>& simple_tags() const;
+    std::unordered_map<std::string, std::string>& simple_tags();
+    void simple_tags(const std::unordered_map<std::string, std::string>& v);
+    void simple_tags(const std::unordered_map<std::string, std::string>&& v);
+    /**@}*/
+
+    /**
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key, value 1, ... value n. Order of defintion is respected.
      */
     /**@{*/
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters() const;
-    std::list<std::pair<std::string, std::string> >& opaque_parameters();
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >& v);
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v);
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags() const;
+    std::unordered_map<std::string, std::list<std::string> >& complex_tags();
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v);
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v);
     /**@}*/
 
     /**
@@ -166,7 +181,8 @@ public:
 private:
     std::list<dogen::sml::property> properties_;
     std::string documentation_;
-    std::list<std::pair<std::string, std::string> > opaque_parameters_;
+    std::unordered_map<std::string, std::string> simple_tags_;
+    std::unordered_map<std::string, std::list<std::string> > complex_tags_;
     dogen::sml::qname name_;
     dogen::sml::generation_types generation_type_;
     dogen::sml::origin_types origin_type_;
diff --git a/projects/sml/include/dogen/sml/types/entity.hpp b/projects/sml/include/dogen/sml/types/entity.hpp
index 215fbec..93bd013 100644
--- a/projects/sml/include/dogen/sml/types/entity.hpp
+++ b/projects/sml/include/dogen/sml/types/entity.hpp
@@ -47,7 +47,8 @@ public:
 public:
     entity(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
diff --git a/projects/sml/include/dogen/sml/types/enumeration.hpp b/projects/sml/include/dogen/sml/types/enumeration.hpp
index 2f3fa01..3527db2 100644
--- a/projects/sml/include/dogen/sml/types/enumeration.hpp
+++ b/projects/sml/include/dogen/sml/types/enumeration.hpp
@@ -50,7 +50,8 @@ public:
 public:
     enumeration(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
diff --git a/projects/sml/include/dogen/sml/types/factory.hpp b/projects/sml/include/dogen/sml/types/factory.hpp
index f462d0d..80e016e 100644
--- a/projects/sml/include/dogen/sml/types/factory.hpp
+++ b/projects/sml/include/dogen/sml/types/factory.hpp
@@ -47,7 +47,8 @@ public:
 public:
     factory(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
diff --git a/projects/sml/include/dogen/sml/types/keyed_entity.hpp b/projects/sml/include/dogen/sml/types/keyed_entity.hpp
index 630e6d9..e44f7ee 100644
--- a/projects/sml/include/dogen/sml/types/keyed_entity.hpp
+++ b/projects/sml/include/dogen/sml/types/keyed_entity.hpp
@@ -58,7 +58,8 @@ public:
 public:
     keyed_entity(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
diff --git a/projects/sml/include/dogen/sml/types/model.hpp b/projects/sml/include/dogen/sml/types/model.hpp
index 4f72614..15c0485 100644
--- a/projects/sml/include/dogen/sml/types/model.hpp
+++ b/projects/sml/include/dogen/sml/types/model.hpp
@@ -31,7 +31,6 @@
 #include <string>
 #include <unordered_map>
 #include <unordered_set>
-#include <utility>
 #include "dogen/sml/hash/qname_hash.hpp"
 #include "dogen/sml/serialization/model_fwd_ser.hpp"
 #include "dogen/sml/types/abstract_object_fwd.hpp"
@@ -83,7 +82,8 @@ public:
 public:
     model(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
@@ -118,13 +118,27 @@ public:
     /**@}*/
 
     /**
-     * @brief Associated generic parameters which may be opaque.
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key-value pair.
+     */
+    /**@{*/
+    const std::unordered_map<std::string, std::string>& simple_tags() const;
+    std::unordered_map<std::string, std::string>& simple_tags();
+    void simple_tags(const std::unordered_map<std::string, std::string>& v);
+    void simple_tags(const std::unordered_map<std::string, std::string>&& v);
+    /**@}*/
+
+    /**
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key, value 1, ... value n. Order of defintion is respected.
      */
     /**@{*/
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters() const;
-    std::list<std::pair<std::string, std::string> >& opaque_parameters();
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >& v);
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v);
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags() const;
+    std::unordered_map<std::string, std::list<std::string> >& complex_tags();
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v);
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v);
     /**@}*/
 
     /**
@@ -238,7 +252,8 @@ public:
 
 private:
     std::string documentation_;
-    std::list<std::pair<std::string, std::string> > opaque_parameters_;
+    std::unordered_map<std::string, std::string> simple_tags_;
+    std::unordered_map<std::string, std::list<std::string> > complex_tags_;
     dogen::sml::qname name_;
     dogen::sml::generation_types generation_type_;
     dogen::sml::origin_types origin_type_;
diff --git a/projects/sml/include/dogen/sml/types/module.hpp b/projects/sml/include/dogen/sml/types/module.hpp
index cf2630f..3f276b3 100644
--- a/projects/sml/include/dogen/sml/types/module.hpp
+++ b/projects/sml/include/dogen/sml/types/module.hpp
@@ -28,7 +28,7 @@
 #include <algorithm>
 #include <list>
 #include <string>
-#include <utility>
+#include <unordered_map>
 #include "dogen/sml/serialization/module_fwd_ser.hpp"
 #include "dogen/sml/types/generation_types.hpp"
 #include "dogen/sml/types/origin_types.hpp"
@@ -54,7 +54,8 @@ public:
 public:
     module(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
@@ -83,13 +84,27 @@ public:
     /**@}*/
 
     /**
-     * @brief Associated generic parameters which may be opaque.
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key-value pair.
+     */
+    /**@{*/
+    const std::unordered_map<std::string, std::string>& simple_tags() const;
+    std::unordered_map<std::string, std::string>& simple_tags();
+    void simple_tags(const std::unordered_map<std::string, std::string>& v);
+    void simple_tags(const std::unordered_map<std::string, std::string>&& v);
+    /**@}*/
+
+    /**
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key, value 1, ... value n. Order of defintion is respected.
      */
     /**@{*/
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters() const;
-    std::list<std::pair<std::string, std::string> >& opaque_parameters();
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >& v);
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v);
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags() const;
+    std::unordered_map<std::string, std::list<std::string> >& complex_tags();
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v);
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v);
     /**@}*/
 
     /**
@@ -141,7 +156,8 @@ public:
 
 private:
     std::string documentation_;
-    std::list<std::pair<std::string, std::string> > opaque_parameters_;
+    std::unordered_map<std::string, std::string> simple_tags_;
+    std::unordered_map<std::string, std::list<std::string> > complex_tags_;
     dogen::sml::qname name_;
     dogen::sml::generation_types generation_type_;
     dogen::sml::origin_types origin_type_;
diff --git a/projects/sml/include/dogen/sml/types/opaque_parameter_cache.hpp b/projects/sml/include/dogen/sml/types/opaque_parameter_cache.hpp
deleted file mode 100644
index 6d4ff72..0000000
--- a/projects/sml/include/dogen/sml/types/opaque_parameter_cache.hpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- *
- */
-#ifndef DOGEN_SML_TYPES_OPAQUE_PARAMETER_CACHE_HPP
-#define DOGEN_SML_TYPES_OPAQUE_PARAMETER_CACHE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-#pragma once
-#endif
-
-#include <string>
-#include "dogen/sml/types/model.hpp"
-#include "dogen/sml/types/opaque_parameter_cache_interface.hpp"
-
-namespace dogen {
-namespace sml {
-
-/**
- * @brief Cache for all opaque parameters in a given model, per type.
- */
-class opaque_parameter_cache : public opaque_parameter_cache_interface {
-public:
-    opaque_parameter_cache() = default;
-    opaque_parameter_cache(const opaque_parameter_cache&) = default;
-    opaque_parameter_cache(opaque_parameter_cache&&) = default;
-
-public:
-    virtual ~opaque_parameter_cache() noexcept { }
-
-public:
-    void populate(const model& m);
-
-public:
-    virtual std::string
-    get(const qname& qn, const std::string& key) const override;
-
-    virtual std::string
-    get_with_default(const qname& qn, const std::string& key) const override;
-};
-
-} }
-
-#endif
diff --git a/projects/sml/include/dogen/sml/types/opaque_parameter_cache_fwd.hpp b/projects/sml/include/dogen/sml/types/opaque_parameter_cache_fwd.hpp
deleted file mode 100644
index 10a9115..0000000
--- a/projects/sml/include/dogen/sml/types/opaque_parameter_cache_fwd.hpp
+++ /dev/null
@@ -1,35 +0,0 @@
-/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- *
- */
-#ifndef DOGEN_SML_TYPES_OPAQUE_PARAMETER_CACHE_FWD_HPP
-#define DOGEN_SML_TYPES_OPAQUE_PARAMETER_CACHE_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-#pragma once
-#endif
-
-namespace dogen {
-namespace sml {
-
-class opaque_parameter_cache;
-
-} }
-
-#endif
diff --git a/projects/sml/include/dogen/sml/types/opaque_parameter_cache_interface.hpp b/projects/sml/include/dogen/sml/types/opaque_parameter_cache_interface.hpp
deleted file mode 100644
index 5a8f8b4..0000000
--- a/projects/sml/include/dogen/sml/types/opaque_parameter_cache_interface.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- *
- */
-#ifndef DOGEN_SML_TYPES_OPAQUE_PARAMETER_CACHE_INTERFACE_HPP
-#define DOGEN_SML_TYPES_OPAQUE_PARAMETER_CACHE_INTERFACE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-#pragma once
-#endif
-
-#include <string>
-#include "dogen/sml/types/qname.hpp"
-
-namespace dogen {
-namespace sml {
-
-/**
- * @brief Cache for all opaque parameters in a given model, per type.
- */
-class opaque_parameter_cache_interface {
-public:
-    opaque_parameter_cache_interface() = default;
-    opaque_parameter_cache_interface(const opaque_parameter_cache_interface&) = default;
-    opaque_parameter_cache_interface(opaque_parameter_cache_interface&&) = default;
-
-public:
-    virtual ~opaque_parameter_cache_interface() noexcept { }
-
-public:
-    /**
-     * @brief Get the value of a parameter for a given name.
-     *
-     * If the parameter does not exist, a @e cache_error exception is
-     * thrown.
-     */
-    virtual std::string get(const qname& qn, const std::string& key) const = 0;
-
-    /**
-     * @brief Get the value of a parameter for a given name.
-     *
-     * If the parameter does not exist, the default value for it is returned.
-     */
-    virtual std::string
-    get_with_default(const qname& qn, const std::string& key) const = 0;
-};
-
-} }
-
-#endif
diff --git a/projects/sml/include/dogen/sml/types/opaque_parameter_cache_interface_fwd.hpp b/projects/sml/include/dogen/sml/types/opaque_parameter_cache_interface_fwd.hpp
deleted file mode 100644
index df9572c..0000000
--- a/projects/sml/include/dogen/sml/types/opaque_parameter_cache_interface_fwd.hpp
+++ /dev/null
@@ -1,35 +0,0 @@
-/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- *
- */
-#ifndef DOGEN_SML_TYPES_OPAQUE_PARAMETER_CACHE_INTERFACE_FWD_HPP
-#define DOGEN_SML_TYPES_OPAQUE_PARAMETER_CACHE_INTERFACE_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-#pragma once
-#endif
-
-namespace dogen {
-namespace sml {
-
-class opaque_parameter_cache_interface;
-
-} }
-
-#endif
diff --git a/projects/sml/include/dogen/sml/types/opaque_parameters.hpp b/projects/sml/include/dogen/sml/types/opaque_parameters.hpp
deleted file mode 100644
index 56f4201..0000000
--- a/projects/sml/include/dogen/sml/types/opaque_parameters.hpp
+++ /dev/null
@@ -1,227 +0,0 @@
-/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- *
- */
-#ifndef DOGEN_OM_TYPES_OPAQUE_PARAMETERS_HPP
-#define DOGEN_OM_TYPES_OPAQUE_PARAMETERS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-#pragma once
-#endif
-
-#include <string>
-
-namespace dogen {
-namespace om {
-
-/**
- * @brief Constants for all keys that can be used in a opaque
- * parameter.
- */
-struct opaque_parameters {
-    /**
-     * @brief Key used to denote an ODB pragma.
-     *
-     * It is expected to be repeated for a given object type; order is
-     * kept as provided by user.
-     */
-    static const std::string odb_pragma;
-
-    /**
-     * @brief Comment provided by user when dia does not allow for it.
-     *
-     * For meta-types where comments are available in Dia (e.g. class,
-     * properties, etc), this parameter is ignored. For types where
-     * they are not (e.g. model, package), it will be used to populate
-     * the meta-type's documentation.
-     */
-    static const std::string comment;
-
-    /**
-     * @brief Valid values for Boolean types.
-     */
-    static const std::string bool_true;
-    static const std::string bool_false;
-
-    /**
-     * @brief All parameters specific to the C++ language.
-     */
-    struct cpp {
-        /**
-         * @brief C++ specific parameters that apply only to types.
-         */
-        struct type {
-            /**
-             * @brief Family of the type.
-             *
-             * Used for debug printing the object, generating test
-             * data, etc.
-             */
-            static const std::string family;
-        };
-
-        /**
-         * @brief Parameters specific to the domain facet.
-         */
-        struct domain {
-            /**
-             * @brief If set to disabled, the domain facet will not be
-             * generated for this type.
-             */
-            static const std::string status;
-
-            /**
-             * @brief If true, a manual default constructor is
-             * generated, otherwise the compiler generated will be
-             * used.
-             */
-            static const std::string requires_manual_default_constructor;
-
-            /**
-             * @brief If true, a manual move constructor is generated,
-             * otherwise the compiler generated will be used.
-             */
-            static const std::string requires_manual_move_constructor;
-
-            /**
-             * @brief Parameters associated with the domain header file.
-             */
-            struct header {
-                /**
-                 * @brief Relative file name for the header file.
-                 */
-                static const std::string file_name;
-
-                /**
-                 * @brief If true, the header file will use
-                 * angle-brackets in include statements. Quotes are
-                 * used otherwise.
-                 *
-                 */
-                static const std::string is_system;
-            };
-        };
-
-        /**
-         * @brief Parameters specific to the hash facet.
-         */
-        struct hash {
-            /**
-             * @brief Parameters specific to standard library hashing.
-             *
-             * Note: we do not use @e std because it causes strange
-             * compilation errors, most likely due to a clash with the
-             * @e std namespace.
-             */
-            struct standard {
-                /**
-                 * @brief If set to disabled, the hash facet will not
-                 * be generated for this type.
-                 */
-                static const std::string status;
-
-                /**
-                 * @brief Parameters associated with the hash header file.
-                 */
-                struct header {
-                    /**
-                     * @brief Relative file name for the header file.
-                     */
-                    static const std::string file_name;
-
-                    /**
-                     * @brief If true, the header file will use
-                     * angle-brackets in include statements. Quotes are
-                     * used otherwise.
-                     *
-                     */
-                    static const std::string is_system;
-                };
-            };
-        };
-
-        /**
-         * @brief Parameters specific to the serialization facet.
-         */
-        struct serialization {
-            /**
-             * @brief Parameters specific to boost serialization.
-             */
-            struct boost {
-                /**
-                 * @brief If set to disabled, the serialization facet
-                 * will not be generated for this type.
-                 */
-                static const std::string status;
-
-                /**
-                 * @brief Parameters associated with the boost
-                 * serialization C++ header file.
-                 */
-                struct header {
-                    /**
-                     * @brief Relative file name for the header file.
-                     */
-                    static const std::string file_name;
-
-                    /**
-                     * @brief If true, the header file will use
-                     * angle-brackets in include statements. Quotes are
-                     * used otherwise.
-                     *
-                     */
-                    static const std::string is_system;
-                };
-            };
-        };
-
-        /**
-         * @brief Parameters specific to the io facet.
-         */
-        struct io {
-            /**
-             * @brief If set to disabled, the serialization facet
-             * will not be generated for this type.
-             */
-            static const std::string status;
-
-            /**
-             * @brief Parameters associated with the io C++ header file.
-             */
-            struct header {
-                /**
-                 * @brief Relative file name for the header file.
-                 */
-                static const std::string file_name;
-
-                /**
-                 * @brief If true, the header file will use
-                 * angle-brackets in include statements. Quotes are
-                 * used otherwise.
-                 */
-                static const std::string is_system;
-
-            };
-        };
-    };
-};
-
-} }
-
-#endif
diff --git a/projects/sml/include/dogen/sml/types/opaque_parameters_fwd.hpp b/projects/sml/include/dogen/sml/types/opaque_parameters_fwd.hpp
deleted file mode 100644
index 4bfc9e3..0000000
--- a/projects/sml/include/dogen/sml/types/opaque_parameters_fwd.hpp
+++ /dev/null
@@ -1,35 +0,0 @@
-/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- *
- */
-#ifndef DOGEN_SML_TYPES_OPAQUE_PARAMETERS_FWD_HPP
-#define DOGEN_SML_TYPES_OPAQUE_PARAMETERS_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-#pragma once
-#endif
-
-namespace dogen {
-namespace sml {
-
-class opaque_parameters;
-
-} }
-
-#endif
diff --git a/projects/sml/include/dogen/sml/types/operation.hpp b/projects/sml/include/dogen/sml/types/operation.hpp
index efd624c..e9d610f 100644
--- a/projects/sml/include/dogen/sml/types/operation.hpp
+++ b/projects/sml/include/dogen/sml/types/operation.hpp
@@ -29,7 +29,7 @@
 #include <boost/optional.hpp>
 #include <list>
 #include <string>
-#include <utility>
+#include <unordered_map>
 #include "dogen/sml/serialization/operation_fwd_ser.hpp"
 #include "dogen/sml/types/nested_qname.hpp"
 #include "dogen/sml/types/parameter.hpp"
@@ -52,7 +52,8 @@ public:
 public:
     operation(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const std::string& name,
         const std::list<dogen::sml::parameter>& parameters,
         const boost::optional<dogen::sml::nested_qname>& type);
@@ -80,13 +81,27 @@ public:
     /**@}*/
 
     /**
-     * @brief Associated generic parameters which may be opaque.
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key-value pair.
+     */
+    /**@{*/
+    const std::unordered_map<std::string, std::string>& simple_tags() const;
+    std::unordered_map<std::string, std::string>& simple_tags();
+    void simple_tags(const std::unordered_map<std::string, std::string>& v);
+    void simple_tags(const std::unordered_map<std::string, std::string>&& v);
+    /**@}*/
+
+    /**
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key, value 1, ... value n. Order of defintion is respected.
      */
     /**@{*/
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters() const;
-    std::list<std::pair<std::string, std::string> >& opaque_parameters();
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >& v);
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v);
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags() const;
+    std::unordered_map<std::string, std::list<std::string> >& complex_tags();
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v);
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v);
     /**@}*/
 
     /**
@@ -131,7 +146,8 @@ public:
 
 private:
     std::string documentation_;
-    std::list<std::pair<std::string, std::string> > opaque_parameters_;
+    std::unordered_map<std::string, std::string> simple_tags_;
+    std::unordered_map<std::string, std::list<std::string> > complex_tags_;
     std::string name_;
     std::list<dogen::sml::parameter> parameters_;
     boost::optional<dogen::sml::nested_qname> type_;
diff --git a/projects/sml/include/dogen/sml/types/parameter.hpp b/projects/sml/include/dogen/sml/types/parameter.hpp
index c3b76b8..b6025d1 100644
--- a/projects/sml/include/dogen/sml/types/parameter.hpp
+++ b/projects/sml/include/dogen/sml/types/parameter.hpp
@@ -28,7 +28,7 @@
 #include <algorithm>
 #include <list>
 #include <string>
-#include <utility>
+#include <unordered_map>
 #include "dogen/sml/serialization/parameter_fwd_ser.hpp"
 #include "dogen/sml/types/nested_qname.hpp"
 
@@ -36,7 +36,7 @@ namespace dogen {
 namespace sml {
 
 /**
- * @brief Parameter supplied to an operation.
+ * @brief Argument supplied to an operation.
  */
 class parameter final {
 public:
@@ -48,7 +48,8 @@ public:
 public:
     parameter(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const std::string& name,
         const dogen::sml::nested_qname& type);
 
@@ -75,13 +76,27 @@ public:
     /**@}*/
 
     /**
-     * @brief Associated generic parameters which may be opaque.
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key-value pair.
+     */
+    /**@{*/
+    const std::unordered_map<std::string, std::string>& simple_tags() const;
+    std::unordered_map<std::string, std::string>& simple_tags();
+    void simple_tags(const std::unordered_map<std::string, std::string>& v);
+    void simple_tags(const std::unordered_map<std::string, std::string>&& v);
+    /**@}*/
+
+    /**
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key, value 1, ... value n. Order of defintion is respected.
      */
     /**@{*/
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters() const;
-    std::list<std::pair<std::string, std::string> >& opaque_parameters();
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >& v);
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v);
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags() const;
+    std::unordered_map<std::string, std::list<std::string> >& complex_tags();
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v);
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v);
     /**@}*/
 
     /**
@@ -116,7 +131,8 @@ public:
 
 private:
     std::string documentation_;
-    std::list<std::pair<std::string, std::string> > opaque_parameters_;
+    std::unordered_map<std::string, std::string> simple_tags_;
+    std::unordered_map<std::string, std::list<std::string> > complex_tags_;
     std::string name_;
     dogen::sml::nested_qname type_;
 };
diff --git a/projects/sml/include/dogen/sml/types/primitive.hpp b/projects/sml/include/dogen/sml/types/primitive.hpp
index 547e94c..e1d577c 100644
--- a/projects/sml/include/dogen/sml/types/primitive.hpp
+++ b/projects/sml/include/dogen/sml/types/primitive.hpp
@@ -47,7 +47,8 @@ public:
 public:
     primitive(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type);
diff --git a/projects/sml/include/dogen/sml/types/property.hpp b/projects/sml/include/dogen/sml/types/property.hpp
index e867337..0744d6a 100644
--- a/projects/sml/include/dogen/sml/types/property.hpp
+++ b/projects/sml/include/dogen/sml/types/property.hpp
@@ -28,7 +28,7 @@
 #include <algorithm>
 #include <list>
 #include <string>
-#include <utility>
+#include <unordered_map>
 #include "dogen/sml/serialization/property_fwd_ser.hpp"
 #include "dogen/sml/types/nested_qname.hpp"
 
@@ -48,7 +48,8 @@ public:
 public:
     property(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const std::string& name,
         const dogen::sml::nested_qname& type,
         const std::string& default_value);
@@ -76,13 +77,27 @@ public:
     /**@}*/
 
     /**
-     * @brief Associated generic parameters which may be opaque.
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key-value pair.
+     */
+    /**@{*/
+    const std::unordered_map<std::string, std::string>& simple_tags() const;
+    std::unordered_map<std::string, std::string>& simple_tags();
+    void simple_tags(const std::unordered_map<std::string, std::string>& v);
+    void simple_tags(const std::unordered_map<std::string, std::string>&& v);
+    /**@}*/
+
+    /**
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key, value 1, ... value n. Order of defintion is respected.
      */
     /**@{*/
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters() const;
-    std::list<std::pair<std::string, std::string> >& opaque_parameters();
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >& v);
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v);
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags() const;
+    std::unordered_map<std::string, std::list<std::string> >& complex_tags();
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v);
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v);
     /**@}*/
 
     /**
@@ -132,7 +147,8 @@ public:
 
 private:
     std::string documentation_;
-    std::list<std::pair<std::string, std::string> > opaque_parameters_;
+    std::unordered_map<std::string, std::string> simple_tags_;
+    std::unordered_map<std::string, std::list<std::string> > complex_tags_;
     std::string name_;
     dogen::sml::nested_qname type_;
     std::string default_value_;
diff --git a/projects/sml/include/dogen/sml/types/repository.hpp b/projects/sml/include/dogen/sml/types/repository.hpp
index 9f56e62..e3e2a5e 100644
--- a/projects/sml/include/dogen/sml/types/repository.hpp
+++ b/projects/sml/include/dogen/sml/types/repository.hpp
@@ -52,7 +52,8 @@ public:
 public:
     repository(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
diff --git a/projects/sml/include/dogen/sml/types/service.hpp b/projects/sml/include/dogen/sml/types/service.hpp
index f60d26f..f0b0bda 100644
--- a/projects/sml/include/dogen/sml/types/service.hpp
+++ b/projects/sml/include/dogen/sml/types/service.hpp
@@ -54,7 +54,8 @@ public:
 public:
     service(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
diff --git a/projects/sml/include/dogen/sml/types/tag_adaptor.hpp b/projects/sml/include/dogen/sml/types/tag_adaptor.hpp
new file mode 100644
index 0000000..03b81a0
--- /dev/null
+++ b/projects/sml/include/dogen/sml/types/tag_adaptor.hpp
@@ -0,0 +1,72 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_SML_TYPES_TAG_ADAPTOR_HPP
+#define DOGEN_SML_TYPES_TAG_ADAPTOR_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <list>
+#include <string>
+#include <unordered_map>
+
+namespace dogen {
+namespace sml {
+
+class tag_adaptor {
+public:
+    tag_adaptor() = delete;
+    ~tag_adaptor() noexcept = default;
+    tag_adaptor(const tag_adaptor&) = default;
+    tag_adaptor(tag_adaptor&&) = default;
+
+public:
+    tag_adaptor(std::unordered_map<std::string, std::string>& simple_tags,
+        std::unordered_map<std::string, std::list<std::string> >& complex_tags);
+
+public:
+    /**
+     * @brief Returns true if the tags contain the comment key, false
+     * otherwise.
+     */
+    bool has_comment() const;
+
+    /**
+     * @brief Returns true if the tags contain the identity key, false
+     * otherwise.
+     */
+    bool has_identity() const;
+
+private:
+    const std::unordered_map<std::string, std::string>& simple_tags_;
+    const std::unordered_map<std::string, std::list<std::string> >&
+    complex_tags_;
+};
+
+template<typename Taggable>
+inline tag_adaptor make_tag_adaptor(const Taggable& t) {
+    return tag_adaptor(t.simple_tags(), t.complex_tags());
+}
+
+} }
+
+#endif
diff --git a/projects/sml/include/dogen/sml/types/tag_adaptor_fwd.hpp b/projects/sml/include/dogen/sml/types/tag_adaptor_fwd.hpp
new file mode 100644
index 0000000..6063713
--- /dev/null
+++ b/projects/sml/include/dogen/sml/types/tag_adaptor_fwd.hpp
@@ -0,0 +1,35 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_SML_TYPES_TAG_ADAPTOR_FWD_HPP
+#define DOGEN_SML_TYPES_TAG_ADAPTOR_FWD_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+namespace dogen {
+namespace sml {
+
+class tag_adaptor;
+
+} }
+
+#endif
diff --git a/projects/sml/include/dogen/sml/types/tag_error.hpp b/projects/sml/include/dogen/sml/types/tag_error.hpp
new file mode 100644
index 0000000..fefcded
--- /dev/null
+++ b/projects/sml/include/dogen/sml/types/tag_error.hpp
@@ -0,0 +1,54 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_SML_TYPES_TAG_ERROR_HPP
+#define DOGEN_SML_TYPES_TAG_ERROR_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <boost/exception/info.hpp>
+#include <string>
+
+namespace dogen {
+namespace sml {
+
+/**
+ * @brief An error has occurred while peforming an operation related to tagging.
+ */
+class tag_error : public virtual std::exception, public virtual boost::exception {
+public:
+    tag_error() = default;
+    ~tag_error() noexcept = default;
+
+public:
+    tag_error(const std::string& message) : message_(message) { }
+
+public:
+    const char* what() const noexcept { return(message_.c_str()); }
+
+private:
+    const std::string message_;
+};
+
+} }
+
+#endif
diff --git a/projects/sml/include/dogen/sml/types/tag_error_fwd.hpp b/projects/sml/include/dogen/sml/types/tag_error_fwd.hpp
new file mode 100644
index 0000000..abb15d1
--- /dev/null
+++ b/projects/sml/include/dogen/sml/types/tag_error_fwd.hpp
@@ -0,0 +1,38 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_SML_TYPES_TAG_ERROR_FWD_HPP
+#define DOGEN_SML_TYPES_TAG_ERROR_FWD_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <boost/exception/info.hpp>
+#include <string>
+
+namespace dogen {
+namespace sml {
+
+class tag_error;
+
+} }
+
+#endif
diff --git a/projects/sml/include/dogen/sml/types/tag_router.hpp b/projects/sml/include/dogen/sml/types/tag_router.hpp
new file mode 100644
index 0000000..6411f1c
--- /dev/null
+++ b/projects/sml/include/dogen/sml/types/tag_router.hpp
@@ -0,0 +1,88 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_SML_TYPES_TAG_ROUTER_HPP
+#define DOGEN_SML_TYPES_TAG_ROUTER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <list>
+#include <string>
+#include <unordered_map>
+
+namespace dogen {
+namespace sml {
+
+/**
+ * @brief Given one or more key-value pairs, routes them to the
+ * appropriate tag container.
+ */
+class tag_router {
+public:
+    tag_router() = delete;
+    ~tag_router() noexcept = default;
+    tag_router(const tag_router&) = default;
+    tag_router(tag_router&&) = default;
+
+public:
+    tag_router(std::unordered_map<std::string, std::string>& simple_tags,
+        std::unordered_map<std::string, std::list<std::string> >& complex_tags);
+
+public:
+    /**
+     * @brief Returns true if the key belongs to the set of complex
+     * tag keys.
+     */
+    bool is_complex(const std::string& key) const;
+
+public:
+    /**
+     * @brief Routes the key-value pair to the appropriate tag
+     * container, based on the key.
+     */
+    void route(const std::string& key, const std::string& value);
+
+    /**
+     * @brief Routes all key-value pairs to the appropriate tag
+     * container, based on the key.
+     */
+    void route(const std::list<std::pair<std::string, std::string> >& kvps);
+
+    /**
+     * @brief Routes only if @e key is in the kvp container.
+     */
+    void route_if(const std::list<std::pair<std::string, std::string> >& kvps,
+        const std::string& key);
+
+private:
+    std::unordered_map<std::string, std::string>& simple_tags_;
+    std::unordered_map<std::string, std::list<std::string> >& complex_tags_;
+};
+
+template<typename Taggable>
+inline tag_router make_tag_router(const Taggable& t) {
+    return tag_router(t.simple_tags(), t.complex_tags());
+}
+
+} }
+
+#endif
diff --git a/projects/sml/include/dogen/sml/types/tag_router_fwd.hpp b/projects/sml/include/dogen/sml/types/tag_router_fwd.hpp
new file mode 100644
index 0000000..d82359e
--- /dev/null
+++ b/projects/sml/include/dogen/sml/types/tag_router_fwd.hpp
@@ -0,0 +1,35 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_SML_TYPES_TAG_ROUTER_FWD_HPP
+#define DOGEN_SML_TYPES_TAG_ROUTER_FWD_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+namespace dogen {
+namespace sml {
+
+class tag_router;
+
+} }
+
+#endif
diff --git a/projects/sml/include/dogen/sml/types/tagger.hpp b/projects/sml/include/dogen/sml/types/tagger.hpp
new file mode 100644
index 0000000..e69de29
diff --git a/projects/sml/include/dogen/sml/types/tagger_fwd.hpp b/projects/sml/include/dogen/sml/types/tagger_fwd.hpp
new file mode 100644
index 0000000..80cdc32
--- /dev/null
+++ b/projects/sml/include/dogen/sml/types/tagger_fwd.hpp
@@ -0,0 +1,35 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_SML_TYPES_TAGGER_FWD_HPP
+#define DOGEN_SML_TYPES_TAGGER_FWD_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+namespace dogen {
+namespace sml {
+
+class tagger;
+
+} }
+
+#endif
diff --git a/projects/sml/include/dogen/sml/types/tags.hpp b/projects/sml/include/dogen/sml/types/tags.hpp
new file mode 100644
index 0000000..3d836fa
--- /dev/null
+++ b/projects/sml/include/dogen/sml/types/tags.hpp
@@ -0,0 +1,232 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_SML_TYPES_TAGS_HPP
+#define DOGEN_SML_TYPES_TAGS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <string>
+
+namespace dogen {
+namespace sml {
+
+/**
+ * @brief Constants for all keys that can be used in a opaque
+ * parameter.
+ */
+struct tags {
+    /**
+     * @brief Key used to denote an ODB pragma.
+     *
+     * It is expected to be repeated for a given object type; order is
+     * kept as provided by user.
+     */
+    static const std::string odb_pragma;
+
+    /**
+     * @brief Comment provided by user when dia does not allow for it.
+     *
+     * For meta-types where comments are available in Dia (e.g. class,
+     * properties, etc), this parameter is ignored. For types where
+     * they are not (e.g. model, package), it will be used to populate
+     * the meta-type's documentation.
+     */
+    static const std::string comment;
+
+    /**
+     * @brief Attribute that provides this entity its identity.
+     */
+    static const std::string identity_attribute;
+
+    /**
+     * @brief Valid values for Boolean types.
+     */
+    static const std::string bool_true;
+    static const std::string bool_false;
+
+    /**
+     * @brief All parameters specific to the C++ language.
+     */
+    struct cpp {
+        /**
+         * @brief C++ specific parameters that apply only to types.
+         */
+        struct type {
+            /**
+             * @brief Family of the type.
+             *
+             * Used for debug printing the object, generating test
+             * data, etc.
+             */
+            static const std::string family;
+        };
+
+        /**
+         * @brief Parameters specific to the domain facet.
+         */
+        struct domain {
+            /**
+             * @brief If set to disabled, the domain facet will not be
+             * generated for this type.
+             */
+            static const std::string status;
+
+            /**
+             * @brief If true, a manual default constructor is
+             * generated, otherwise the compiler generated will be
+             * used.
+             */
+            static const std::string requires_manual_default_constructor;
+
+            /**
+             * @brief If true, a manual move constructor is generated,
+             * otherwise the compiler generated will be used.
+             */
+            static const std::string requires_manual_move_constructor;
+
+            /**
+             * @brief Parameters associated with the domain header file.
+             */
+            struct header {
+                /**
+                 * @brief Relative file name for the header file.
+                 */
+                static const std::string file_name;
+
+                /**
+                 * @brief If true, the header file will use
+                 * angle-brackets in include statements. Quotes are
+                 * used otherwise.
+                 *
+                 */
+                static const std::string is_system;
+            };
+        };
+
+        /**
+         * @brief Parameters specific to the hash facet.
+         */
+        struct hash {
+            /**
+             * @brief Parameters specific to standard library hashing.
+             *
+             * Note: we do not use @e std because it causes strange
+             * compilation errors, most likely due to a clash with the
+             * @e std namespace.
+             */
+            struct standard {
+                /**
+                 * @brief If set to disabled, the hash facet will not
+                 * be generated for this type.
+                 */
+                static const std::string status;
+
+                /**
+                 * @brief Parameters associated with the hash header file.
+                 */
+                struct header {
+                    /**
+                     * @brief Relative file name for the header file.
+                     */
+                    static const std::string file_name;
+
+                    /**
+                     * @brief If true, the header file will use
+                     * angle-brackets in include statements. Quotes are
+                     * used otherwise.
+                     *
+                     */
+                    static const std::string is_system;
+                };
+            };
+        };
+
+        /**
+         * @brief Parameters specific to the serialization facet.
+         */
+        struct serialization {
+            /**
+             * @brief Parameters specific to boost serialization.
+             */
+            struct boost {
+                /**
+                 * @brief If set to disabled, the serialization facet
+                 * will not be generated for this type.
+                 */
+                static const std::string status;
+
+                /**
+                 * @brief Parameters associated with the boost
+                 * serialization C++ header file.
+                 */
+                struct header {
+                    /**
+                     * @brief Relative file name for the header file.
+                     */
+                    static const std::string file_name;
+
+                    /**
+                     * @brief If true, the header file will use
+                     * angle-brackets in include statements. Quotes are
+                     * used otherwise.
+                     *
+                     */
+                    static const std::string is_system;
+                };
+            };
+        };
+
+        /**
+         * @brief Parameters specific to the io facet.
+         */
+        struct io {
+            /**
+             * @brief If set to disabled, the serialization facet
+             * will not be generated for this type.
+             */
+            static const std::string status;
+
+            /**
+             * @brief Parameters associated with the io C++ header file.
+             */
+            struct header {
+                /**
+                 * @brief Relative file name for the header file.
+                 */
+                static const std::string file_name;
+
+                /**
+                 * @brief If true, the header file will use
+                 * angle-brackets in include statements. Quotes are
+                 * used otherwise.
+                 */
+                static const std::string is_system;
+
+            };
+        };
+    };
+};
+
+} }
+
+#endif
diff --git a/projects/sml/include/dogen/sml/types/tags_fwd.hpp b/projects/sml/include/dogen/sml/types/tags_fwd.hpp
new file mode 100644
index 0000000..3b23a7c
--- /dev/null
+++ b/projects/sml/include/dogen/sml/types/tags_fwd.hpp
@@ -0,0 +1,35 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_SML_TYPES_TAGS_FWD_HPP
+#define DOGEN_SML_TYPES_TAGS_FWD_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+namespace dogen {
+namespace sml {
+
+class tags;
+
+} }
+
+#endif
diff --git a/projects/sml/include/dogen/sml/types/type.hpp b/projects/sml/include/dogen/sml/types/type.hpp
index 51e3c8b..cf52be9 100644
--- a/projects/sml/include/dogen/sml/types/type.hpp
+++ b/projects/sml/include/dogen/sml/types/type.hpp
@@ -29,7 +29,7 @@
 #include <iosfwd>
 #include <list>
 #include <string>
-#include <utility>
+#include <unordered_map>
 #include "dogen/sml/serialization/type_fwd_ser.hpp"
 #include "dogen/sml/types/generation_types.hpp"
 #include "dogen/sml/types/origin_types.hpp"
@@ -55,7 +55,8 @@ public:
 public:
     type(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type);
@@ -92,13 +93,27 @@ public:
     /**@}*/
 
     /**
-     * @brief Associated generic parameters which may be opaque.
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key-value pair.
+     */
+    /**@{*/
+    const std::unordered_map<std::string, std::string>& simple_tags() const;
+    std::unordered_map<std::string, std::string>& simple_tags();
+    void simple_tags(const std::unordered_map<std::string, std::string>& v);
+    void simple_tags(const std::unordered_map<std::string, std::string>&& v);
+    /**@}*/
+
+    /**
+     * @brief Tags associated with the object, opaque to SML.
+     *
+     * Tags are in the format key, value 1, ... value n. Order of defintion is respected.
      */
     /**@{*/
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters() const;
-    std::list<std::pair<std::string, std::string> >& opaque_parameters();
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >& v);
-    void opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v);
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags() const;
+    std::unordered_map<std::string, std::list<std::string> >& complex_tags();
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v);
+    void complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v);
     /**@}*/
 
     /**
@@ -138,7 +153,8 @@ protected:
 
 private:
     std::string documentation_;
-    std::list<std::pair<std::string, std::string> > opaque_parameters_;
+    std::unordered_map<std::string, std::string> simple_tags_;
+    std::unordered_map<std::string, std::list<std::string> > complex_tags_;
     dogen::sml::qname name_;
     dogen::sml::generation_types generation_type_;
     dogen::sml::origin_types origin_type_;
diff --git a/projects/sml/include/dogen/sml/types/value_object.hpp b/projects/sml/include/dogen/sml/types/value_object.hpp
index 6153b73..89dbffc 100644
--- a/projects/sml/include/dogen/sml/types/value_object.hpp
+++ b/projects/sml/include/dogen/sml/types/value_object.hpp
@@ -54,7 +54,8 @@ public:
 public:
     value_object(
         const std::string& documentation,
-        const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+        const std::unordered_map<std::string, std::string>& simple_tags,
+        const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
         const dogen::sml::qname& name,
         const dogen::sml::generation_types& generation_type,
         const dogen::sml::origin_types& origin_type,
diff --git a/projects/sml/src/hash/concept_hash.cpp b/projects/sml/src/hash/concept_hash.cpp
index 4024977..c5046a2 100644
--- a/projects/sml/src/hash/concept_hash.cpp
+++ b/projects/sml/src/hash/concept_hash.cpp
@@ -42,18 +42,28 @@ inline std::size_t hash_std_list_dogen_sml_property(const std::list<dogen::sml::
     return seed;
 }
 
-inline std::size_t hash_std_pair_std_string_std_string(const std::pair<std::string, std::string>& v){
+inline std::size_t hash_std_unordered_map_std_string_std_string(const std::unordered_map<std::string, std::string>& v){
     std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i.first);
+        combine(seed, i.second);
+    }
+    return seed;
+}
 
-    combine(seed, v.first);
-    combine(seed, v.second);
+inline std::size_t hash_std_list_std_string(const std::list<std::string>& v){
+    std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i);
+    }
     return seed;
 }
 
-inline std::size_t hash_std_list_std_pair_std_string_std_string_(const std::list<std::pair<std::string, std::string> >& v){
+inline std::size_t hash_std_unordered_map_std_string_std_list_std_string_(const std::unordered_map<std::string, std::list<std::string> >& v){
     std::size_t seed(0);
     for (const auto i : v) {
-        combine(seed, hash_std_pair_std_string_std_string(i));
+        combine(seed, i.first);
+        combine(seed, hash_std_list_std_string(i.second));
     }
     return seed;
 }
@@ -84,7 +94,8 @@ std::size_t concept_hasher::hash(const concept&v) {
 
     combine(seed, hash_std_list_dogen_sml_property(v.properties()));
     combine(seed, v.documentation());
-    combine(seed, hash_std_list_std_pair_std_string_std_string_(v.opaque_parameters()));
+    combine(seed, hash_std_unordered_map_std_string_std_string(v.simple_tags()));
+    combine(seed, hash_std_unordered_map_std_string_std_list_std_string_(v.complex_tags()));
     combine(seed, v.name());
     combine(seed, v.generation_type());
     combine(seed, v.origin_type());
diff --git a/projects/sml/src/hash/model_hash.cpp b/projects/sml/src/hash/model_hash.cpp
index 906c1bc..60755d3 100644
--- a/projects/sml/src/hash/model_hash.cpp
+++ b/projects/sml/src/hash/model_hash.cpp
@@ -37,18 +37,28 @@ inline void combine(std::size_t& seed, const HashableType& value)
     seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
 }
 
-inline std::size_t hash_std_pair_std_string_std_string(const std::pair<std::string, std::string>& v){
+inline std::size_t hash_std_unordered_map_std_string_std_string(const std::unordered_map<std::string, std::string>& v){
     std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i.first);
+        combine(seed, i.second);
+    }
+    return seed;
+}
 
-    combine(seed, v.first);
-    combine(seed, v.second);
+inline std::size_t hash_std_list_std_string(const std::list<std::string>& v){
+    std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i);
+    }
     return seed;
 }
 
-inline std::size_t hash_std_list_std_pair_std_string_std_string_(const std::list<std::pair<std::string, std::string> >& v){
+inline std::size_t hash_std_unordered_map_std_string_std_list_std_string_(const std::unordered_map<std::string, std::list<std::string> >& v){
     std::size_t seed(0);
     for (const auto i : v) {
-        combine(seed, hash_std_pair_std_string_std_string(i));
+        combine(seed, i.first);
+        combine(seed, hash_std_list_std_string(i.second));
     }
     return seed;
 }
@@ -130,7 +140,8 @@ std::size_t model_hasher::hash(const model&v) {
     std::size_t seed(0);
 
     combine(seed, v.documentation());
-    combine(seed, hash_std_list_std_pair_std_string_std_string_(v.opaque_parameters()));
+    combine(seed, hash_std_unordered_map_std_string_std_string(v.simple_tags()));
+    combine(seed, hash_std_unordered_map_std_string_std_list_std_string_(v.complex_tags()));
     combine(seed, v.name());
     combine(seed, v.generation_type());
     combine(seed, v.origin_type());
diff --git a/projects/sml/src/hash/module_hash.cpp b/projects/sml/src/hash/module_hash.cpp
index c2619d4..456922c 100644
--- a/projects/sml/src/hash/module_hash.cpp
+++ b/projects/sml/src/hash/module_hash.cpp
@@ -32,18 +32,28 @@ inline void combine(std::size_t& seed, const HashableType& value)
     seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
 }
 
-inline std::size_t hash_std_pair_std_string_std_string(const std::pair<std::string, std::string>& v){
+inline std::size_t hash_std_unordered_map_std_string_std_string(const std::unordered_map<std::string, std::string>& v){
     std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i.first);
+        combine(seed, i.second);
+    }
+    return seed;
+}
 
-    combine(seed, v.first);
-    combine(seed, v.second);
+inline std::size_t hash_std_list_std_string(const std::list<std::string>& v){
+    std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i);
+    }
     return seed;
 }
 
-inline std::size_t hash_std_list_std_pair_std_string_std_string_(const std::list<std::pair<std::string, std::string> >& v){
+inline std::size_t hash_std_unordered_map_std_string_std_list_std_string_(const std::unordered_map<std::string, std::list<std::string> >& v){
     std::size_t seed(0);
     for (const auto i : v) {
-        combine(seed, hash_std_pair_std_string_std_string(i));
+        combine(seed, i.first);
+        combine(seed, hash_std_list_std_string(i.second));
     }
     return seed;
 }
@@ -65,7 +75,8 @@ std::size_t module_hasher::hash(const module&v) {
     std::size_t seed(0);
 
     combine(seed, v.documentation());
-    combine(seed, hash_std_list_std_pair_std_string_std_string_(v.opaque_parameters()));
+    combine(seed, hash_std_unordered_map_std_string_std_string(v.simple_tags()));
+    combine(seed, hash_std_unordered_map_std_string_std_list_std_string_(v.complex_tags()));
     combine(seed, v.name());
     combine(seed, v.generation_type());
     combine(seed, v.origin_type());
diff --git a/projects/sml/src/hash/operation_hash.cpp b/projects/sml/src/hash/operation_hash.cpp
index 11a8317..48ff157 100644
--- a/projects/sml/src/hash/operation_hash.cpp
+++ b/projects/sml/src/hash/operation_hash.cpp
@@ -31,18 +31,28 @@ inline void combine(std::size_t& seed, const HashableType& value)
     seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
 }
 
-inline std::size_t hash_std_pair_std_string_std_string(const std::pair<std::string, std::string>& v){
+inline std::size_t hash_std_unordered_map_std_string_std_string(const std::unordered_map<std::string, std::string>& v){
     std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i.first);
+        combine(seed, i.second);
+    }
+    return seed;
+}
 
-    combine(seed, v.first);
-    combine(seed, v.second);
+inline std::size_t hash_std_list_std_string(const std::list<std::string>& v){
+    std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i);
+    }
     return seed;
 }
 
-inline std::size_t hash_std_list_std_pair_std_string_std_string_(const std::list<std::pair<std::string, std::string> >& v){
+inline std::size_t hash_std_unordered_map_std_string_std_list_std_string_(const std::unordered_map<std::string, std::list<std::string> >& v){
     std::size_t seed(0);
     for (const auto i : v) {
-        combine(seed, hash_std_pair_std_string_std_string(i));
+        combine(seed, i.first);
+        combine(seed, hash_std_list_std_string(i.second));
     }
     return seed;
 }
@@ -74,7 +84,8 @@ std::size_t operation_hasher::hash(const operation&v) {
     std::size_t seed(0);
 
     combine(seed, v.documentation());
-    combine(seed, hash_std_list_std_pair_std_string_std_string_(v.opaque_parameters()));
+    combine(seed, hash_std_unordered_map_std_string_std_string(v.simple_tags()));
+    combine(seed, hash_std_unordered_map_std_string_std_list_std_string_(v.complex_tags()));
     combine(seed, v.name());
     combine(seed, hash_std_list_dogen_sml_parameter(v.parameters()));
     combine(seed, hash_boost_optional_dogen_sml_nested_qname(v.type()));
diff --git a/projects/sml/src/hash/parameter_hash.cpp b/projects/sml/src/hash/parameter_hash.cpp
index 006b7e6..f6746af 100644
--- a/projects/sml/src/hash/parameter_hash.cpp
+++ b/projects/sml/src/hash/parameter_hash.cpp
@@ -30,18 +30,28 @@ inline void combine(std::size_t& seed, const HashableType& value)
     seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
 }
 
-inline std::size_t hash_std_pair_std_string_std_string(const std::pair<std::string, std::string>& v){
+inline std::size_t hash_std_unordered_map_std_string_std_string(const std::unordered_map<std::string, std::string>& v){
     std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i.first);
+        combine(seed, i.second);
+    }
+    return seed;
+}
 
-    combine(seed, v.first);
-    combine(seed, v.second);
+inline std::size_t hash_std_list_std_string(const std::list<std::string>& v){
+    std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i);
+    }
     return seed;
 }
 
-inline std::size_t hash_std_list_std_pair_std_string_std_string_(const std::list<std::pair<std::string, std::string> >& v){
+inline std::size_t hash_std_unordered_map_std_string_std_list_std_string_(const std::unordered_map<std::string, std::list<std::string> >& v){
     std::size_t seed(0);
     for (const auto i : v) {
-        combine(seed, hash_std_pair_std_string_std_string(i));
+        combine(seed, i.first);
+        combine(seed, hash_std_list_std_string(i.second));
     }
     return seed;
 }
@@ -55,7 +65,8 @@ std::size_t parameter_hasher::hash(const parameter&v) {
     std::size_t seed(0);
 
     combine(seed, v.documentation());
-    combine(seed, hash_std_list_std_pair_std_string_std_string_(v.opaque_parameters()));
+    combine(seed, hash_std_unordered_map_std_string_std_string(v.simple_tags()));
+    combine(seed, hash_std_unordered_map_std_string_std_list_std_string_(v.complex_tags()));
     combine(seed, v.name());
     combine(seed, v.type());
 
diff --git a/projects/sml/src/hash/property_hash.cpp b/projects/sml/src/hash/property_hash.cpp
index 5e721f4..f6af505 100644
--- a/projects/sml/src/hash/property_hash.cpp
+++ b/projects/sml/src/hash/property_hash.cpp
@@ -30,18 +30,28 @@ inline void combine(std::size_t& seed, const HashableType& value)
     seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
 }
 
-inline std::size_t hash_std_pair_std_string_std_string(const std::pair<std::string, std::string>& v){
+inline std::size_t hash_std_unordered_map_std_string_std_string(const std::unordered_map<std::string, std::string>& v){
     std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i.first);
+        combine(seed, i.second);
+    }
+    return seed;
+}
 
-    combine(seed, v.first);
-    combine(seed, v.second);
+inline std::size_t hash_std_list_std_string(const std::list<std::string>& v){
+    std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i);
+    }
     return seed;
 }
 
-inline std::size_t hash_std_list_std_pair_std_string_std_string_(const std::list<std::pair<std::string, std::string> >& v){
+inline std::size_t hash_std_unordered_map_std_string_std_list_std_string_(const std::unordered_map<std::string, std::list<std::string> >& v){
     std::size_t seed(0);
     for (const auto i : v) {
-        combine(seed, hash_std_pair_std_string_std_string(i));
+        combine(seed, i.first);
+        combine(seed, hash_std_list_std_string(i.second));
     }
     return seed;
 }
@@ -55,7 +65,8 @@ std::size_t property_hasher::hash(const property&v) {
     std::size_t seed(0);
 
     combine(seed, v.documentation());
-    combine(seed, hash_std_list_std_pair_std_string_std_string_(v.opaque_parameters()));
+    combine(seed, hash_std_unordered_map_std_string_std_string(v.simple_tags()));
+    combine(seed, hash_std_unordered_map_std_string_std_list_std_string_(v.complex_tags()));
     combine(seed, v.name());
     combine(seed, v.type());
     combine(seed, v.default_value());
diff --git a/projects/sml/src/hash/type_hash.cpp b/projects/sml/src/hash/type_hash.cpp
index 76a6df0..9b9c95d 100644
--- a/projects/sml/src/hash/type_hash.cpp
+++ b/projects/sml/src/hash/type_hash.cpp
@@ -32,18 +32,28 @@ inline void combine(std::size_t& seed, const HashableType& value)
     seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
 }
 
-inline std::size_t hash_std_pair_std_string_std_string(const std::pair<std::string, std::string>& v){
+inline std::size_t hash_std_unordered_map_std_string_std_string(const std::unordered_map<std::string, std::string>& v){
     std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i.first);
+        combine(seed, i.second);
+    }
+    return seed;
+}
 
-    combine(seed, v.first);
-    combine(seed, v.second);
+inline std::size_t hash_std_list_std_string(const std::list<std::string>& v){
+    std::size_t seed(0);
+    for (const auto i : v) {
+        combine(seed, i);
+    }
     return seed;
 }
 
-inline std::size_t hash_std_list_std_pair_std_string_std_string_(const std::list<std::pair<std::string, std::string> >& v){
+inline std::size_t hash_std_unordered_map_std_string_std_list_std_string_(const std::unordered_map<std::string, std::list<std::string> >& v){
     std::size_t seed(0);
     for (const auto i : v) {
-        combine(seed, hash_std_pair_std_string_std_string(i));
+        combine(seed, i.first);
+        combine(seed, hash_std_list_std_string(i.second));
     }
     return seed;
 }
@@ -57,7 +67,8 @@ std::size_t type_hasher::hash(const type&v) {
     std::size_t seed(0);
 
     combine(seed, v.documentation());
-    combine(seed, hash_std_list_std_pair_std_string_std_string_(v.opaque_parameters()));
+    combine(seed, hash_std_unordered_map_std_string_std_string(v.simple_tags()));
+    combine(seed, hash_std_unordered_map_std_string_std_list_std_string_(v.complex_tags()));
     combine(seed, v.name());
     combine(seed, v.generation_type());
     combine(seed, v.origin_type());
diff --git a/projects/sml/src/io/concept_io.cpp b/projects/sml/src/io/concept_io.cpp
index 2fb4ead..f85e546 100644
--- a/projects/sml/src/io/concept_io.cpp
+++ b/projects/sml/src/io/concept_io.cpp
@@ -51,12 +51,17 @@ inline std::string tidy_up_string(std::string s) {
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, std::string>& v) {
-    s << "{ " << "\"__type__\": " << "\"std::pair\"" << ", ";
-
-    s << "\"first\": " << "\"" << tidy_up_string(v.first) << "\"" << ", ";
-    s << "\"second\": " << "\"" << tidy_up_string(v.second) << "\"";
-    s << " }";
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::string>& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->second) << "\"";
+        s << " } ]";
+    }
+    s << " ] ";
     return s;
 }
 
@@ -64,11 +69,11 @@ inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, st
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::string, std::string> >& v) {
+inline std::ostream& operator<<(std::ostream& s, const std::list<std::string>& v) {
     s << "[ ";
     for (auto i(v.begin()); i != v.end(); ++i) {
         if (i != v.begin()) s << ", ";
-        s << *i;
+        s << "\"" << tidy_up_string(*i) << "\"";
     }
     s << "] ";
     return s;
@@ -78,6 +83,24 @@ inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::
 
 namespace std {
 
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::list<std::string> >& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << i->second;
+        s << " } ]";
+    }
+    s << " ] ";
+    return s;
+}
+
+}
+
+namespace std {
+
 inline std::ostream& operator<<(std::ostream& s, const std::list<dogen::sml::operation>& v) {
     s << "[ ";
     for (auto i(v.begin()); i != v.end(); ++i) {
@@ -112,7 +135,8 @@ std::ostream& operator<<(std::ostream& s, const concept& v) {
       << "\"__type__\": " << "\"dogen::sml::concept\"" << ", "
       << "\"properties\": " << v.properties() << ", "
       << "\"documentation\": " << "\"" << tidy_up_string(v.documentation()) << "\"" << ", "
-      << "\"opaque_parameters\": " << v.opaque_parameters() << ", "
+      << "\"simple_tags\": " << v.simple_tags() << ", "
+      << "\"complex_tags\": " << v.complex_tags() << ", "
       << "\"name\": " << v.name() << ", "
       << "\"generation_type\": " << v.generation_type() << ", "
       << "\"origin_type\": " << v.origin_type() << ", "
diff --git a/projects/sml/src/io/model_io.cpp b/projects/sml/src/io/model_io.cpp
index afb17d7..d971fa1 100644
--- a/projects/sml/src/io/model_io.cpp
+++ b/projects/sml/src/io/model_io.cpp
@@ -40,12 +40,17 @@ inline std::string tidy_up_string(std::string s) {
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, std::string>& v) {
-    s << "{ " << "\"__type__\": " << "\"std::pair\"" << ", ";
-
-    s << "\"first\": " << "\"" << tidy_up_string(v.first) << "\"" << ", ";
-    s << "\"second\": " << "\"" << tidy_up_string(v.second) << "\"";
-    s << " }";
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::string>& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->second) << "\"";
+        s << " } ]";
+    }
+    s << " ] ";
     return s;
 }
 
@@ -53,11 +58,11 @@ inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, st
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::string, std::string> >& v) {
+inline std::ostream& operator<<(std::ostream& s, const std::list<std::string>& v) {
     s << "[ ";
     for (auto i(v.begin()); i != v.end(); ++i) {
         if (i != v.begin()) s << ", ";
-        s << *i;
+        s << "\"" << tidy_up_string(*i) << "\"";
     }
     s << "] ";
     return s;
@@ -67,6 +72,24 @@ inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::
 
 namespace std {
 
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::list<std::string> >& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << i->second;
+        s << " } ]";
+    }
+    s << " ] ";
+    return s;
+}
+
+}
+
+namespace std {
+
 inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<dogen::sml::qname, dogen::sml::origin_types>& v) {
     s << "[";
     for (auto i(v.begin()); i != v.end(); ++i) {
@@ -210,7 +233,8 @@ std::ostream& operator<<(std::ostream& s, const model& v) {
     s << " { "
       << "\"__type__\": " << "\"dogen::sml::model\"" << ", "
       << "\"documentation\": " << "\"" << tidy_up_string(v.documentation()) << "\"" << ", "
-      << "\"opaque_parameters\": " << v.opaque_parameters() << ", "
+      << "\"simple_tags\": " << v.simple_tags() << ", "
+      << "\"complex_tags\": " << v.complex_tags() << ", "
       << "\"name\": " << v.name() << ", "
       << "\"generation_type\": " << v.generation_type() << ", "
       << "\"origin_type\": " << v.origin_type() << ", "
diff --git a/projects/sml/src/io/module_io.cpp b/projects/sml/src/io/module_io.cpp
index 6c68c08..ed78b81 100644
--- a/projects/sml/src/io/module_io.cpp
+++ b/projects/sml/src/io/module_io.cpp
@@ -35,12 +35,17 @@ inline std::string tidy_up_string(std::string s) {
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, std::string>& v) {
-    s << "{ " << "\"__type__\": " << "\"std::pair\"" << ", ";
-
-    s << "\"first\": " << "\"" << tidy_up_string(v.first) << "\"" << ", ";
-    s << "\"second\": " << "\"" << tidy_up_string(v.second) << "\"";
-    s << " }";
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::string>& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->second) << "\"";
+        s << " } ]";
+    }
+    s << " ] ";
     return s;
 }
 
@@ -48,11 +53,11 @@ inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, st
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::string, std::string> >& v) {
+inline std::ostream& operator<<(std::ostream& s, const std::list<std::string>& v) {
     s << "[ ";
     for (auto i(v.begin()); i != v.end(); ++i) {
         if (i != v.begin()) s << ", ";
-        s << *i;
+        s << "\"" << tidy_up_string(*i) << "\"";
     }
     s << "] ";
     return s;
@@ -62,6 +67,24 @@ inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::
 
 namespace std {
 
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::list<std::string> >& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << i->second;
+        s << " } ]";
+    }
+    s << " ] ";
+    return s;
+}
+
+}
+
+namespace std {
+
 inline std::ostream& operator<<(std::ostream& s, const std::list<dogen::sml::qname>& v) {
     s << "[ ";
     for (auto i(v.begin()); i != v.end(); ++i) {
@@ -81,7 +104,8 @@ std::ostream& operator<<(std::ostream& s, const module& v) {
     s << " { "
       << "\"__type__\": " << "\"dogen::sml::module\"" << ", "
       << "\"documentation\": " << "\"" << tidy_up_string(v.documentation()) << "\"" << ", "
-      << "\"opaque_parameters\": " << v.opaque_parameters() << ", "
+      << "\"simple_tags\": " << v.simple_tags() << ", "
+      << "\"complex_tags\": " << v.complex_tags() << ", "
       << "\"name\": " << v.name() << ", "
       << "\"generation_type\": " << v.generation_type() << ", "
       << "\"origin_type\": " << v.origin_type() << ", "
diff --git a/projects/sml/src/io/operation_io.cpp b/projects/sml/src/io/operation_io.cpp
index d122f8a..23abc61 100644
--- a/projects/sml/src/io/operation_io.cpp
+++ b/projects/sml/src/io/operation_io.cpp
@@ -34,12 +34,17 @@ inline std::string tidy_up_string(std::string s) {
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, std::string>& v) {
-    s << "{ " << "\"__type__\": " << "\"std::pair\"" << ", ";
-
-    s << "\"first\": " << "\"" << tidy_up_string(v.first) << "\"" << ", ";
-    s << "\"second\": " << "\"" << tidy_up_string(v.second) << "\"";
-    s << " }";
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::string>& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->second) << "\"";
+        s << " } ]";
+    }
+    s << " ] ";
     return s;
 }
 
@@ -47,11 +52,11 @@ inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, st
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::string, std::string> >& v) {
+inline std::ostream& operator<<(std::ostream& s, const std::list<std::string>& v) {
     s << "[ ";
     for (auto i(v.begin()); i != v.end(); ++i) {
         if (i != v.begin()) s << ", ";
-        s << *i;
+        s << "\"" << tidy_up_string(*i) << "\"";
     }
     s << "] ";
     return s;
@@ -61,6 +66,24 @@ inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::
 
 namespace std {
 
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::list<std::string> >& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << i->second;
+        s << " } ]";
+    }
+    s << " ] ";
+    return s;
+}
+
+}
+
+namespace std {
+
 inline std::ostream& operator<<(std::ostream& s, const std::list<dogen::sml::parameter>& v) {
     s << "[ ";
     for (auto i(v.begin()); i != v.end(); ++i) {
@@ -95,7 +118,8 @@ std::ostream& operator<<(std::ostream& s, const operation& v) {
     s << " { "
       << "\"__type__\": " << "\"dogen::sml::operation\"" << ", "
       << "\"documentation\": " << "\"" << tidy_up_string(v.documentation()) << "\"" << ", "
-      << "\"opaque_parameters\": " << v.opaque_parameters() << ", "
+      << "\"simple_tags\": " << v.simple_tags() << ", "
+      << "\"complex_tags\": " << v.complex_tags() << ", "
       << "\"name\": " << "\"" << tidy_up_string(v.name()) << "\"" << ", "
       << "\"parameters\": " << v.parameters() << ", "
       << "\"type\": " << v.type()
diff --git a/projects/sml/src/io/parameter_io.cpp b/projects/sml/src/io/parameter_io.cpp
index bd9f2f4..75532d6 100644
--- a/projects/sml/src/io/parameter_io.cpp
+++ b/projects/sml/src/io/parameter_io.cpp
@@ -33,12 +33,17 @@ inline std::string tidy_up_string(std::string s) {
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, std::string>& v) {
-    s << "{ " << "\"__type__\": " << "\"std::pair\"" << ", ";
-
-    s << "\"first\": " << "\"" << tidy_up_string(v.first) << "\"" << ", ";
-    s << "\"second\": " << "\"" << tidy_up_string(v.second) << "\"";
-    s << " }";
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::string>& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->second) << "\"";
+        s << " } ]";
+    }
+    s << " ] ";
     return s;
 }
 
@@ -46,11 +51,11 @@ inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, st
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::string, std::string> >& v) {
+inline std::ostream& operator<<(std::ostream& s, const std::list<std::string>& v) {
     s << "[ ";
     for (auto i(v.begin()); i != v.end(); ++i) {
         if (i != v.begin()) s << ", ";
-        s << *i;
+        s << "\"" << tidy_up_string(*i) << "\"";
     }
     s << "] ";
     return s;
@@ -58,6 +63,24 @@ inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::
 
 }
 
+namespace std {
+
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::list<std::string> >& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << i->second;
+        s << " } ]";
+    }
+    s << " ] ";
+    return s;
+}
+
+}
+
 namespace dogen {
 namespace sml {
 
@@ -65,7 +88,8 @@ std::ostream& operator<<(std::ostream& s, const parameter& v) {
     s << " { "
       << "\"__type__\": " << "\"dogen::sml::parameter\"" << ", "
       << "\"documentation\": " << "\"" << tidy_up_string(v.documentation()) << "\"" << ", "
-      << "\"opaque_parameters\": " << v.opaque_parameters() << ", "
+      << "\"simple_tags\": " << v.simple_tags() << ", "
+      << "\"complex_tags\": " << v.complex_tags() << ", "
       << "\"name\": " << "\"" << tidy_up_string(v.name()) << "\"" << ", "
       << "\"type\": " << v.type()
       << " }";
diff --git a/projects/sml/src/io/property_io.cpp b/projects/sml/src/io/property_io.cpp
index 52b74f6..a7de776 100644
--- a/projects/sml/src/io/property_io.cpp
+++ b/projects/sml/src/io/property_io.cpp
@@ -33,12 +33,17 @@ inline std::string tidy_up_string(std::string s) {
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, std::string>& v) {
-    s << "{ " << "\"__type__\": " << "\"std::pair\"" << ", ";
-
-    s << "\"first\": " << "\"" << tidy_up_string(v.first) << "\"" << ", ";
-    s << "\"second\": " << "\"" << tidy_up_string(v.second) << "\"";
-    s << " }";
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::string>& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->second) << "\"";
+        s << " } ]";
+    }
+    s << " ] ";
     return s;
 }
 
@@ -46,11 +51,11 @@ inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, st
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::string, std::string> >& v) {
+inline std::ostream& operator<<(std::ostream& s, const std::list<std::string>& v) {
     s << "[ ";
     for (auto i(v.begin()); i != v.end(); ++i) {
         if (i != v.begin()) s << ", ";
-        s << *i;
+        s << "\"" << tidy_up_string(*i) << "\"";
     }
     s << "] ";
     return s;
@@ -58,6 +63,24 @@ inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::
 
 }
 
+namespace std {
+
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::list<std::string> >& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << i->second;
+        s << " } ]";
+    }
+    s << " ] ";
+    return s;
+}
+
+}
+
 namespace dogen {
 namespace sml {
 
@@ -65,7 +88,8 @@ std::ostream& operator<<(std::ostream& s, const property& v) {
     s << " { "
       << "\"__type__\": " << "\"dogen::sml::property\"" << ", "
       << "\"documentation\": " << "\"" << tidy_up_string(v.documentation()) << "\"" << ", "
-      << "\"opaque_parameters\": " << v.opaque_parameters() << ", "
+      << "\"simple_tags\": " << v.simple_tags() << ", "
+      << "\"complex_tags\": " << v.complex_tags() << ", "
       << "\"name\": " << "\"" << tidy_up_string(v.name()) << "\"" << ", "
       << "\"type\": " << v.type() << ", "
       << "\"default_value\": " << "\"" << tidy_up_string(v.default_value()) << "\""
diff --git a/projects/sml/src/serialization/abstract_object_ser.cpp b/projects/sml/src/serialization/abstract_object_ser.cpp
index 53cb99f..42cf26b 100644
--- a/projects/sml/src/serialization/abstract_object_ser.cpp
+++ b/projects/sml/src/serialization/abstract_object_ser.cpp
@@ -30,7 +30,6 @@
 #include <boost/serialization/nvp.hpp>
 #include <boost/serialization/optional.hpp>
 #include <boost/serialization/string.hpp>
-#include <boost/serialization/utility.hpp>
 #include "dogen/sml/serialization/abstract_object_ser.hpp"
 #include "dogen/sml/serialization/entity_ser.hpp"
 #include "dogen/sml/serialization/factory_ser.hpp"
@@ -44,6 +43,7 @@
 #include "dogen/sml/serialization/service_ser.hpp"
 #include "dogen/sml/serialization/type_ser.hpp"
 #include "dogen/sml/serialization/value_object_ser.hpp"
+#include "dogen/utility/serialization/unordered_map.hpp"
 
 #ifdef __linux__
 #include "eos/portable_iarchive.hpp"
diff --git a/projects/sml/src/serialization/concept_ser.cpp b/projects/sml/src/serialization/concept_ser.cpp
index 7b2d28a..36de0aa 100644
--- a/projects/sml/src/serialization/concept_ser.cpp
+++ b/projects/sml/src/serialization/concept_ser.cpp
@@ -29,13 +29,13 @@
 #include <boost/serialization/list.hpp>
 #include <boost/serialization/nvp.hpp>
 #include <boost/serialization/string.hpp>
-#include <boost/serialization/utility.hpp>
 #include "dogen/sml/serialization/concept_ser.hpp"
 #include "dogen/sml/serialization/generation_types_ser.hpp"
 #include "dogen/sml/serialization/operation_ser.hpp"
 #include "dogen/sml/serialization/origin_types_ser.hpp"
 #include "dogen/sml/serialization/property_ser.hpp"
 #include "dogen/sml/serialization/qname_ser.hpp"
+#include "dogen/utility/serialization/unordered_map.hpp"
 
 #ifdef __linux__
 #include "eos/portable_iarchive.hpp"
@@ -51,7 +51,8 @@ void save(Archive& ar,
     const unsigned int /*version*/) {
     ar << make_nvp("properties", v.properties_);
     ar << make_nvp("documentation", v.documentation_);
-    ar << make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar << make_nvp("simple_tags", v.simple_tags_);
+    ar << make_nvp("complex_tags", v.complex_tags_);
     ar << make_nvp("name", v.name_);
     ar << make_nvp("generation_type", v.generation_type_);
     ar << make_nvp("origin_type", v.origin_type_);
@@ -65,7 +66,8 @@ void load(Archive& ar,
     const unsigned int /*version*/) {
     ar >> make_nvp("properties", v.properties_);
     ar >> make_nvp("documentation", v.documentation_);
-    ar >> make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar >> make_nvp("simple_tags", v.simple_tags_);
+    ar >> make_nvp("complex_tags", v.complex_tags_);
     ar >> make_nvp("name", v.name_);
     ar >> make_nvp("generation_type", v.generation_type_);
     ar >> make_nvp("origin_type", v.origin_type_);
diff --git a/projects/sml/src/serialization/model_ser.cpp b/projects/sml/src/serialization/model_ser.cpp
index 3a11f40..5fc355d 100644
--- a/projects/sml/src/serialization/model_ser.cpp
+++ b/projects/sml/src/serialization/model_ser.cpp
@@ -30,7 +30,6 @@
 #include <boost/serialization/nvp.hpp>
 #include <boost/serialization/shared_ptr.hpp>
 #include <boost/serialization/string.hpp>
-#include <boost/serialization/utility.hpp>
 #include "dogen/sml/serialization/abstract_object_ser.hpp"
 #include "dogen/sml/serialization/concept_ser.hpp"
 #include "dogen/sml/serialization/enumeration_ser.hpp"
@@ -56,7 +55,8 @@ void save(Archive& ar,
     const dogen::sml::model& v,
     const unsigned int /*version*/) {
     ar << make_nvp("documentation", v.documentation_);
-    ar << make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar << make_nvp("simple_tags", v.simple_tags_);
+    ar << make_nvp("complex_tags", v.complex_tags_);
     ar << make_nvp("name", v.name_);
     ar << make_nvp("generation_type", v.generation_type_);
     ar << make_nvp("origin_type", v.origin_type_);
@@ -74,7 +74,8 @@ void load(Archive& ar,
     dogen::sml::model& v,
     const unsigned int /*version*/) {
     ar >> make_nvp("documentation", v.documentation_);
-    ar >> make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar >> make_nvp("simple_tags", v.simple_tags_);
+    ar >> make_nvp("complex_tags", v.complex_tags_);
     ar >> make_nvp("name", v.name_);
     ar >> make_nvp("generation_type", v.generation_type_);
     ar >> make_nvp("origin_type", v.origin_type_);
diff --git a/projects/sml/src/serialization/module_ser.cpp b/projects/sml/src/serialization/module_ser.cpp
index b04066a..ec21632 100644
--- a/projects/sml/src/serialization/module_ser.cpp
+++ b/projects/sml/src/serialization/module_ser.cpp
@@ -29,11 +29,11 @@
 #include <boost/serialization/list.hpp>
 #include <boost/serialization/nvp.hpp>
 #include <boost/serialization/string.hpp>
-#include <boost/serialization/utility.hpp>
 #include "dogen/sml/serialization/generation_types_ser.hpp"
 #include "dogen/sml/serialization/module_ser.hpp"
 #include "dogen/sml/serialization/origin_types_ser.hpp"
 #include "dogen/sml/serialization/qname_ser.hpp"
+#include "dogen/utility/serialization/unordered_map.hpp"
 
 #ifdef __linux__
 #include "eos/portable_iarchive.hpp"
@@ -48,7 +48,8 @@ void save(Archive& ar,
     const dogen::sml::module& v,
     const unsigned int /*version*/) {
     ar << make_nvp("documentation", v.documentation_);
-    ar << make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar << make_nvp("simple_tags", v.simple_tags_);
+    ar << make_nvp("complex_tags", v.complex_tags_);
     ar << make_nvp("name", v.name_);
     ar << make_nvp("generation_type", v.generation_type_);
     ar << make_nvp("origin_type", v.origin_type_);
@@ -60,7 +61,8 @@ void load(Archive& ar,
     dogen::sml::module& v,
     const unsigned int /*version*/) {
     ar >> make_nvp("documentation", v.documentation_);
-    ar >> make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar >> make_nvp("simple_tags", v.simple_tags_);
+    ar >> make_nvp("complex_tags", v.complex_tags_);
     ar >> make_nvp("name", v.name_);
     ar >> make_nvp("generation_type", v.generation_type_);
     ar >> make_nvp("origin_type", v.origin_type_);
diff --git a/projects/sml/src/serialization/operation_ser.cpp b/projects/sml/src/serialization/operation_ser.cpp
index 7366a8d..e35184d 100644
--- a/projects/sml/src/serialization/operation_ser.cpp
+++ b/projects/sml/src/serialization/operation_ser.cpp
@@ -30,10 +30,10 @@
 #include <boost/serialization/nvp.hpp>
 #include <boost/serialization/optional.hpp>
 #include <boost/serialization/string.hpp>
-#include <boost/serialization/utility.hpp>
 #include "dogen/sml/serialization/nested_qname_ser.hpp"
 #include "dogen/sml/serialization/operation_ser.hpp"
 #include "dogen/sml/serialization/parameter_ser.hpp"
+#include "dogen/utility/serialization/unordered_map.hpp"
 
 #ifdef __linux__
 #include "eos/portable_iarchive.hpp"
@@ -48,7 +48,8 @@ void save(Archive& ar,
     const dogen::sml::operation& v,
     const unsigned int /*version*/) {
     ar << make_nvp("documentation", v.documentation_);
-    ar << make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar << make_nvp("simple_tags", v.simple_tags_);
+    ar << make_nvp("complex_tags", v.complex_tags_);
     ar << make_nvp("name", v.name_);
     ar << make_nvp("parameters", v.parameters_);
     ar << make_nvp("type", v.type_);
@@ -59,7 +60,8 @@ void load(Archive& ar,
     dogen::sml::operation& v,
     const unsigned int /*version*/) {
     ar >> make_nvp("documentation", v.documentation_);
-    ar >> make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar >> make_nvp("simple_tags", v.simple_tags_);
+    ar >> make_nvp("complex_tags", v.complex_tags_);
     ar >> make_nvp("name", v.name_);
     ar >> make_nvp("parameters", v.parameters_);
     ar >> make_nvp("type", v.type_);
diff --git a/projects/sml/src/serialization/parameter_ser.cpp b/projects/sml/src/serialization/parameter_ser.cpp
index 654b1fe..ceea8ac 100644
--- a/projects/sml/src/serialization/parameter_ser.cpp
+++ b/projects/sml/src/serialization/parameter_ser.cpp
@@ -29,9 +29,9 @@
 #include <boost/serialization/list.hpp>
 #include <boost/serialization/nvp.hpp>
 #include <boost/serialization/string.hpp>
-#include <boost/serialization/utility.hpp>
 #include "dogen/sml/serialization/nested_qname_ser.hpp"
 #include "dogen/sml/serialization/parameter_ser.hpp"
+#include "dogen/utility/serialization/unordered_map.hpp"
 
 #ifdef __linux__
 #include "eos/portable_iarchive.hpp"
@@ -46,7 +46,8 @@ void save(Archive& ar,
     const dogen::sml::parameter& v,
     const unsigned int /*version*/) {
     ar << make_nvp("documentation", v.documentation_);
-    ar << make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar << make_nvp("simple_tags", v.simple_tags_);
+    ar << make_nvp("complex_tags", v.complex_tags_);
     ar << make_nvp("name", v.name_);
     ar << make_nvp("type", v.type_);
 }
@@ -56,7 +57,8 @@ void load(Archive& ar,
     dogen::sml::parameter& v,
     const unsigned int /*version*/) {
     ar >> make_nvp("documentation", v.documentation_);
-    ar >> make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar >> make_nvp("simple_tags", v.simple_tags_);
+    ar >> make_nvp("complex_tags", v.complex_tags_);
     ar >> make_nvp("name", v.name_);
     ar >> make_nvp("type", v.type_);
 }
diff --git a/projects/sml/src/serialization/property_ser.cpp b/projects/sml/src/serialization/property_ser.cpp
index 8c78931..066a341 100644
--- a/projects/sml/src/serialization/property_ser.cpp
+++ b/projects/sml/src/serialization/property_ser.cpp
@@ -29,9 +29,9 @@
 #include <boost/serialization/list.hpp>
 #include <boost/serialization/nvp.hpp>
 #include <boost/serialization/string.hpp>
-#include <boost/serialization/utility.hpp>
 #include "dogen/sml/serialization/nested_qname_ser.hpp"
 #include "dogen/sml/serialization/property_ser.hpp"
+#include "dogen/utility/serialization/unordered_map.hpp"
 
 #ifdef __linux__
 #include "eos/portable_iarchive.hpp"
@@ -46,7 +46,8 @@ void save(Archive& ar,
     const dogen::sml::property& v,
     const unsigned int /*version*/) {
     ar << make_nvp("documentation", v.documentation_);
-    ar << make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar << make_nvp("simple_tags", v.simple_tags_);
+    ar << make_nvp("complex_tags", v.complex_tags_);
     ar << make_nvp("name", v.name_);
     ar << make_nvp("type", v.type_);
     ar << make_nvp("default_value", v.default_value_);
@@ -57,7 +58,8 @@ void load(Archive& ar,
     dogen::sml::property& v,
     const unsigned int /*version*/) {
     ar >> make_nvp("documentation", v.documentation_);
-    ar >> make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar >> make_nvp("simple_tags", v.simple_tags_);
+    ar >> make_nvp("complex_tags", v.complex_tags_);
     ar >> make_nvp("name", v.name_);
     ar >> make_nvp("type", v.type_);
     ar >> make_nvp("default_value", v.default_value_);
diff --git a/projects/sml/src/serialization/type_ser.cpp b/projects/sml/src/serialization/type_ser.cpp
index 28f9091..807e078 100644
--- a/projects/sml/src/serialization/type_ser.cpp
+++ b/projects/sml/src/serialization/type_ser.cpp
@@ -29,7 +29,6 @@
 #include <boost/serialization/list.hpp>
 #include <boost/serialization/nvp.hpp>
 #include <boost/serialization/string.hpp>
-#include <boost/serialization/utility.hpp>
 #include "dogen/sml/serialization/entity_ser.hpp"
 #include "dogen/sml/serialization/enumeration_ser.hpp"
 #include "dogen/sml/serialization/factory_ser.hpp"
@@ -42,6 +41,7 @@
 #include "dogen/sml/serialization/service_ser.hpp"
 #include "dogen/sml/serialization/type_ser.hpp"
 #include "dogen/sml/serialization/value_object_ser.hpp"
+#include "dogen/utility/serialization/unordered_map.hpp"
 
 #ifdef __linux__
 #include "eos/portable_iarchive.hpp"
@@ -60,7 +60,8 @@ void save(Archive& ar,
     const dogen::sml::type& v,
     const unsigned int /*version*/) {
     ar << make_nvp("documentation", v.documentation_);
-    ar << make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar << make_nvp("simple_tags", v.simple_tags_);
+    ar << make_nvp("complex_tags", v.complex_tags_);
     ar << make_nvp("name", v.name_);
     ar << make_nvp("generation_type", v.generation_type_);
     ar << make_nvp("origin_type", v.origin_type_);
@@ -71,7 +72,8 @@ void load(Archive& ar,
     dogen::sml::type& v,
     const unsigned int /*version*/) {
     ar >> make_nvp("documentation", v.documentation_);
-    ar >> make_nvp("opaque_parameters", v.opaque_parameters_);
+    ar >> make_nvp("simple_tags", v.simple_tags_);
+    ar >> make_nvp("complex_tags", v.complex_tags_);
     ar >> make_nvp("name", v.name_);
     ar >> make_nvp("generation_type", v.generation_type_);
     ar >> make_nvp("origin_type", v.origin_type_);
diff --git a/projects/sml/src/test_data/concept_td.cpp b/projects/sml/src/test_data/concept_td.cpp
index 3970a7b..e17f7a9 100644
--- a/projects/sml/src/test_data/concept_td.cpp
+++ b/projects/sml/src/test_data/concept_td.cpp
@@ -47,18 +47,26 @@ std::string create_std_string(const unsigned int position) {
     return s.str();
 }
 
-std::pair<std::string, std::string>
-create_std_pair_std_string_std_string(unsigned int position) {
-    std::pair<std::string, std::string> r(
-        create_std_string(position),
-        create_std_string(position));
+std::unordered_map<std::string, std::string> create_std_unordered_map_std_string_std_string(unsigned int position) {
+    std::unordered_map<std::string, std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.insert(std::make_pair(create_std_string(position + i), create_std_string(position + i)));
+    }
+    return r;
+}
+
+std::list<std::string> create_std_list_std_string(unsigned int position) {
+    std::list<std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.push_back(create_std_string(position + i));
+    }
     return r;
 }
 
-std::list<std::pair<std::string, std::string> > create_std_list_std_pair_std_string_std_string_(unsigned int position) {
-    std::list<std::pair<std::string, std::string> > r;
+std::unordered_map<std::string, std::list<std::string> > create_std_unordered_map_std_string_std_list_std_string_(unsigned int position) {
+    std::unordered_map<std::string, std::list<std::string> > r;
     for (unsigned int i(0); i < 10; ++i) {
-        r.push_back(create_std_pair_std_string_std_string(position + i));
+        r.insert(std::make_pair(create_std_string(position + i), create_std_list_std_string(position + i)));
     }
     return r;
 }
@@ -110,12 +118,13 @@ void concept_generator::
 populate(const unsigned int position, result_type& v) {
     v.properties(create_std_list_dogen_sml_property(position + 0));
     v.documentation(create_std_string(position + 1));
-    v.opaque_parameters(create_std_list_std_pair_std_string_std_string_(position + 2));
-    v.name(create_dogen_sml_qname(position + 3));
-    v.generation_type(create_dogen_sml_generation_types(position + 4));
-    v.origin_type(create_dogen_sml_origin_types(position + 5));
-    v.operations(create_std_list_dogen_sml_operation(position + 6));
-    v.refines(create_std_list_dogen_sml_qname(position + 7));
+    v.simple_tags(create_std_unordered_map_std_string_std_string(position + 2));
+    v.complex_tags(create_std_unordered_map_std_string_std_list_std_string_(position + 3));
+    v.name(create_dogen_sml_qname(position + 4));
+    v.generation_type(create_dogen_sml_generation_types(position + 5));
+    v.origin_type(create_dogen_sml_origin_types(position + 6));
+    v.operations(create_std_list_dogen_sml_operation(position + 7));
+    v.refines(create_std_list_dogen_sml_qname(position + 8));
 }
 
 concept_generator::result_type
diff --git a/projects/sml/src/test_data/model_td.cpp b/projects/sml/src/test_data/model_td.cpp
index 8917c8c..f9d32a8 100644
--- a/projects/sml/src/test_data/model_td.cpp
+++ b/projects/sml/src/test_data/model_td.cpp
@@ -37,18 +37,26 @@ std::string create_std_string(const unsigned int position) {
     return s.str();
 }
 
-std::pair<std::string, std::string>
-create_std_pair_std_string_std_string(unsigned int position) {
-    std::pair<std::string, std::string> r(
-        create_std_string(position),
-        create_std_string(position));
+std::unordered_map<std::string, std::string> create_std_unordered_map_std_string_std_string(unsigned int position) {
+    std::unordered_map<std::string, std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.insert(std::make_pair(create_std_string(position + i), create_std_string(position + i)));
+    }
+    return r;
+}
+
+std::list<std::string> create_std_list_std_string(unsigned int position) {
+    std::list<std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.push_back(create_std_string(position + i));
+    }
     return r;
 }
 
-std::list<std::pair<std::string, std::string> > create_std_list_std_pair_std_string_std_string_(unsigned int position) {
-    std::list<std::pair<std::string, std::string> > r;
+std::unordered_map<std::string, std::list<std::string> > create_std_unordered_map_std_string_std_list_std_string_(unsigned int position) {
+    std::unordered_map<std::string, std::list<std::string> > r;
     for (unsigned int i(0); i < 10; ++i) {
-        r.push_back(create_std_pair_std_string_std_string(position + i));
+        r.insert(std::make_pair(create_std_string(position + i), create_std_list_std_string(position + i)));
     }
     return r;
 }
@@ -166,17 +174,18 @@ model_generator::model_generator() : position_(0) { }
 void model_generator::
 populate(const unsigned int position, result_type& v) {
     v.documentation(create_std_string(position + 0));
-    v.opaque_parameters(create_std_list_std_pair_std_string_std_string_(position + 1));
-    v.name(create_dogen_sml_qname(position + 2));
-    v.generation_type(create_dogen_sml_generation_types(position + 3));
-    v.origin_type(create_dogen_sml_origin_types(position + 4));
-    v.references(create_std_unordered_map_dogen_sml_qname_dogen_sml_origin_types(position + 5));
-    v.leaves(create_std_unordered_set_dogen_sml_qname(position + 6));
-    v.modules(create_std_unordered_map_dogen_sml_qname_dogen_sml_module(position + 7));
-    v.concepts(create_std_unordered_map_dogen_sml_qname_dogen_sml_concept(position + 8));
-    v.primitives(create_std_unordered_map_dogen_sml_qname_dogen_sml_primitive(position + 9));
-    v.enumerations(create_std_unordered_map_dogen_sml_qname_dogen_sml_enumeration(position + 10));
-    v.objects(create_std_unordered_map_dogen_sml_qname_boost_shared_ptr_dogen_sml_abstract_object_(position + 11));
+    v.simple_tags(create_std_unordered_map_std_string_std_string(position + 1));
+    v.complex_tags(create_std_unordered_map_std_string_std_list_std_string_(position + 2));
+    v.name(create_dogen_sml_qname(position + 3));
+    v.generation_type(create_dogen_sml_generation_types(position + 4));
+    v.origin_type(create_dogen_sml_origin_types(position + 5));
+    v.references(create_std_unordered_map_dogen_sml_qname_dogen_sml_origin_types(position + 6));
+    v.leaves(create_std_unordered_set_dogen_sml_qname(position + 7));
+    v.modules(create_std_unordered_map_dogen_sml_qname_dogen_sml_module(position + 8));
+    v.concepts(create_std_unordered_map_dogen_sml_qname_dogen_sml_concept(position + 9));
+    v.primitives(create_std_unordered_map_dogen_sml_qname_dogen_sml_primitive(position + 10));
+    v.enumerations(create_std_unordered_map_dogen_sml_qname_dogen_sml_enumeration(position + 11));
+    v.objects(create_std_unordered_map_dogen_sml_qname_boost_shared_ptr_dogen_sml_abstract_object_(position + 12));
 }
 
 model_generator::result_type
diff --git a/projects/sml/src/test_data/module_td.cpp b/projects/sml/src/test_data/module_td.cpp
index 518f0b2..a504a99 100644
--- a/projects/sml/src/test_data/module_td.cpp
+++ b/projects/sml/src/test_data/module_td.cpp
@@ -32,18 +32,26 @@ std::string create_std_string(const unsigned int position) {
     return s.str();
 }
 
-std::pair<std::string, std::string>
-create_std_pair_std_string_std_string(unsigned int position) {
-    std::pair<std::string, std::string> r(
-        create_std_string(position),
-        create_std_string(position));
+std::unordered_map<std::string, std::string> create_std_unordered_map_std_string_std_string(unsigned int position) {
+    std::unordered_map<std::string, std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.insert(std::make_pair(create_std_string(position + i), create_std_string(position + i)));
+    }
+    return r;
+}
+
+std::list<std::string> create_std_list_std_string(unsigned int position) {
+    std::list<std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.push_back(create_std_string(position + i));
+    }
     return r;
 }
 
-std::list<std::pair<std::string, std::string> > create_std_list_std_pair_std_string_std_string_(unsigned int position) {
-    std::list<std::pair<std::string, std::string> > r;
+std::unordered_map<std::string, std::list<std::string> > create_std_unordered_map_std_string_std_list_std_string_(unsigned int position) {
+    std::unordered_map<std::string, std::list<std::string> > r;
     for (unsigned int i(0); i < 10; ++i) {
-        r.push_back(create_std_pair_std_string_std_string(position + i));
+        r.insert(std::make_pair(create_std_string(position + i), create_std_list_std_string(position + i)));
     }
     return r;
 }
@@ -81,11 +89,12 @@ module_generator::module_generator() : position_(0) { }
 void module_generator::
 populate(const unsigned int position, result_type& v) {
     v.documentation(create_std_string(position + 0));
-    v.opaque_parameters(create_std_list_std_pair_std_string_std_string_(position + 1));
-    v.name(create_dogen_sml_qname(position + 2));
-    v.generation_type(create_dogen_sml_generation_types(position + 3));
-    v.origin_type(create_dogen_sml_origin_types(position + 4));
-    v.members(create_std_list_dogen_sml_qname(position + 5));
+    v.simple_tags(create_std_unordered_map_std_string_std_string(position + 1));
+    v.complex_tags(create_std_unordered_map_std_string_std_list_std_string_(position + 2));
+    v.name(create_dogen_sml_qname(position + 3));
+    v.generation_type(create_dogen_sml_generation_types(position + 4));
+    v.origin_type(create_dogen_sml_origin_types(position + 5));
+    v.members(create_std_list_dogen_sml_qname(position + 6));
 }
 
 module_generator::result_type
diff --git a/projects/sml/src/test_data/operation_td.cpp b/projects/sml/src/test_data/operation_td.cpp
index 0ec453b..72b016a 100644
--- a/projects/sml/src/test_data/operation_td.cpp
+++ b/projects/sml/src/test_data/operation_td.cpp
@@ -31,18 +31,26 @@ std::string create_std_string(const unsigned int position) {
     return s.str();
 }
 
-std::pair<std::string, std::string>
-create_std_pair_std_string_std_string(unsigned int position) {
-    std::pair<std::string, std::string> r(
-        create_std_string(position),
-        create_std_string(position));
+std::unordered_map<std::string, std::string> create_std_unordered_map_std_string_std_string(unsigned int position) {
+    std::unordered_map<std::string, std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.insert(std::make_pair(create_std_string(position + i), create_std_string(position + i)));
+    }
+    return r;
+}
+
+std::list<std::string> create_std_list_std_string(unsigned int position) {
+    std::list<std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.push_back(create_std_string(position + i));
+    }
     return r;
 }
 
-std::list<std::pair<std::string, std::string> > create_std_list_std_pair_std_string_std_string_(unsigned int position) {
-    std::list<std::pair<std::string, std::string> > r;
+std::unordered_map<std::string, std::list<std::string> > create_std_unordered_map_std_string_std_list_std_string_(unsigned int position) {
+    std::unordered_map<std::string, std::list<std::string> > r;
     for (unsigned int i(0); i < 10; ++i) {
-        r.push_back(create_std_pair_std_string_std_string(position + i));
+        r.insert(std::make_pair(create_std_string(position + i), create_std_list_std_string(position + i)));
     }
     return r;
 }
@@ -82,10 +90,11 @@ operation_generator::operation_generator() : position_(0) { }
 void operation_generator::
 populate(const unsigned int position, result_type& v) {
     v.documentation(create_std_string(position + 0));
-    v.opaque_parameters(create_std_list_std_pair_std_string_std_string_(position + 1));
-    v.name(create_std_string(position + 2));
-    v.parameters(create_std_list_dogen_sml_parameter(position + 3));
-    v.type(create_boost_optional_dogen_sml_nested_qname(position + 4));
+    v.simple_tags(create_std_unordered_map_std_string_std_string(position + 1));
+    v.complex_tags(create_std_unordered_map_std_string_std_list_std_string_(position + 2));
+    v.name(create_std_string(position + 3));
+    v.parameters(create_std_list_dogen_sml_parameter(position + 4));
+    v.type(create_boost_optional_dogen_sml_nested_qname(position + 5));
 }
 
 operation_generator::result_type
diff --git a/projects/sml/src/test_data/parameter_td.cpp b/projects/sml/src/test_data/parameter_td.cpp
index 95b95ff..a37a42a 100644
--- a/projects/sml/src/test_data/parameter_td.cpp
+++ b/projects/sml/src/test_data/parameter_td.cpp
@@ -30,18 +30,26 @@ std::string create_std_string(const unsigned int position) {
     return s.str();
 }
 
-std::pair<std::string, std::string>
-create_std_pair_std_string_std_string(unsigned int position) {
-    std::pair<std::string, std::string> r(
-        create_std_string(position),
-        create_std_string(position));
+std::unordered_map<std::string, std::string> create_std_unordered_map_std_string_std_string(unsigned int position) {
+    std::unordered_map<std::string, std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.insert(std::make_pair(create_std_string(position + i), create_std_string(position + i)));
+    }
+    return r;
+}
+
+std::list<std::string> create_std_list_std_string(unsigned int position) {
+    std::list<std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.push_back(create_std_string(position + i));
+    }
     return r;
 }
 
-std::list<std::pair<std::string, std::string> > create_std_list_std_pair_std_string_std_string_(unsigned int position) {
-    std::list<std::pair<std::string, std::string> > r;
+std::unordered_map<std::string, std::list<std::string> > create_std_unordered_map_std_string_std_list_std_string_(unsigned int position) {
+    std::unordered_map<std::string, std::list<std::string> > r;
     for (unsigned int i(0); i < 10; ++i) {
-        r.push_back(create_std_pair_std_string_std_string(position + i));
+        r.insert(std::make_pair(create_std_string(position + i), create_std_list_std_string(position + i)));
     }
     return r;
 }
@@ -61,9 +69,10 @@ parameter_generator::parameter_generator() : position_(0) { }
 void parameter_generator::
 populate(const unsigned int position, result_type& v) {
     v.documentation(create_std_string(position + 0));
-    v.opaque_parameters(create_std_list_std_pair_std_string_std_string_(position + 1));
-    v.name(create_std_string(position + 2));
-    v.type(create_dogen_sml_nested_qname(position + 3));
+    v.simple_tags(create_std_unordered_map_std_string_std_string(position + 1));
+    v.complex_tags(create_std_unordered_map_std_string_std_list_std_string_(position + 2));
+    v.name(create_std_string(position + 3));
+    v.type(create_dogen_sml_nested_qname(position + 4));
 }
 
 parameter_generator::result_type
diff --git a/projects/sml/src/test_data/property_td.cpp b/projects/sml/src/test_data/property_td.cpp
index d7393c1..81be712 100644
--- a/projects/sml/src/test_data/property_td.cpp
+++ b/projects/sml/src/test_data/property_td.cpp
@@ -30,18 +30,26 @@ std::string create_std_string(const unsigned int position) {
     return s.str();
 }
 
-std::pair<std::string, std::string>
-create_std_pair_std_string_std_string(unsigned int position) {
-    std::pair<std::string, std::string> r(
-        create_std_string(position),
-        create_std_string(position));
+std::unordered_map<std::string, std::string> create_std_unordered_map_std_string_std_string(unsigned int position) {
+    std::unordered_map<std::string, std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.insert(std::make_pair(create_std_string(position + i), create_std_string(position + i)));
+    }
+    return r;
+}
+
+std::list<std::string> create_std_list_std_string(unsigned int position) {
+    std::list<std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.push_back(create_std_string(position + i));
+    }
     return r;
 }
 
-std::list<std::pair<std::string, std::string> > create_std_list_std_pair_std_string_std_string_(unsigned int position) {
-    std::list<std::pair<std::string, std::string> > r;
+std::unordered_map<std::string, std::list<std::string> > create_std_unordered_map_std_string_std_list_std_string_(unsigned int position) {
+    std::unordered_map<std::string, std::list<std::string> > r;
     for (unsigned int i(0); i < 10; ++i) {
-        r.push_back(create_std_pair_std_string_std_string(position + i));
+        r.insert(std::make_pair(create_std_string(position + i), create_std_list_std_string(position + i)));
     }
     return r;
 }
@@ -61,10 +69,11 @@ property_generator::property_generator() : position_(0) { }
 void property_generator::
 populate(const unsigned int position, result_type& v) {
     v.documentation(create_std_string(position + 0));
-    v.opaque_parameters(create_std_list_std_pair_std_string_std_string_(position + 1));
-    v.name(create_std_string(position + 2));
-    v.type(create_dogen_sml_nested_qname(position + 3));
-    v.default_value(create_std_string(position + 4));
+    v.simple_tags(create_std_unordered_map_std_string_std_string(position + 1));
+    v.complex_tags(create_std_unordered_map_std_string_std_list_std_string_(position + 2));
+    v.name(create_std_string(position + 3));
+    v.type(create_dogen_sml_nested_qname(position + 4));
+    v.default_value(create_std_string(position + 5));
 }
 
 property_generator::result_type
diff --git a/projects/sml/src/test_data/type_td.cpp b/projects/sml/src/test_data/type_td.cpp
index 23aca69..acb8e3f 100644
--- a/projects/sml/src/test_data/type_td.cpp
+++ b/projects/sml/src/test_data/type_td.cpp
@@ -40,18 +40,26 @@ std::string create_std_string(const unsigned int position) {
     return s.str();
 }
 
-std::pair<std::string, std::string>
-create_std_pair_std_string_std_string(unsigned int position) {
-    std::pair<std::string, std::string> r(
-        create_std_string(position),
-        create_std_string(position));
+std::unordered_map<std::string, std::string> create_std_unordered_map_std_string_std_string(unsigned int position) {
+    std::unordered_map<std::string, std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.insert(std::make_pair(create_std_string(position + i), create_std_string(position + i)));
+    }
+    return r;
+}
+
+std::list<std::string> create_std_list_std_string(unsigned int position) {
+    std::list<std::string> r;
+    for (unsigned int i(0); i < 10; ++i) {
+        r.push_back(create_std_string(position + i));
+    }
     return r;
 }
 
-std::list<std::pair<std::string, std::string> > create_std_list_std_pair_std_string_std_string_(unsigned int position) {
-    std::list<std::pair<std::string, std::string> > r;
+std::unordered_map<std::string, std::list<std::string> > create_std_unordered_map_std_string_std_list_std_string_(unsigned int position) {
+    std::unordered_map<std::string, std::list<std::string> > r;
     for (unsigned int i(0); i < 10; ++i) {
-        r.push_back(create_std_pair_std_string_std_string(position + i));
+        r.insert(std::make_pair(create_std_string(position + i), create_std_list_std_string(position + i)));
     }
     return r;
 }
@@ -80,10 +88,11 @@ namespace sml {
 void type_generator::
 populate(const unsigned int position, result_type& v) {
     v.documentation(create_std_string(position + 0));
-    v.opaque_parameters(create_std_list_std_pair_std_string_std_string_(position + 1));
-    v.name(create_dogen_sml_qname(position + 2));
-    v.generation_type(create_dogen_sml_generation_types(position + 3));
-    v.origin_type(create_dogen_sml_origin_types(position + 4));
+    v.simple_tags(create_std_unordered_map_std_string_std_string(position + 1));
+    v.complex_tags(create_std_unordered_map_std_string_std_list_std_string_(position + 2));
+    v.name(create_dogen_sml_qname(position + 3));
+    v.generation_type(create_dogen_sml_generation_types(position + 4));
+    v.origin_type(create_dogen_sml_origin_types(position + 5));
 }
 
 type_generator::result_type*
diff --git a/projects/sml/src/types/abstract_entity.cpp b/projects/sml/src/types/abstract_entity.cpp
index d0c4ac6..7437988 100644
--- a/projects/sml/src/types/abstract_entity.cpp
+++ b/projects/sml/src/types/abstract_entity.cpp
@@ -46,7 +46,8 @@ abstract_entity::abstract_entity()
 
 abstract_entity::abstract_entity(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
@@ -66,7 +67,8 @@ abstract_entity::abstract_entity(
     const bool is_aggregate_root,
     const std::list<dogen::sml::property>& identity)
     : dogen::sml::abstract_object(documentation,
-      opaque_parameters,
+      simple_tags,
+      complex_tags,
       name,
       generation_type,
       origin_type,
diff --git a/projects/sml/src/types/abstract_object.cpp b/projects/sml/src/types/abstract_object.cpp
index aa3e1e4..9e36416 100644
--- a/projects/sml/src/types/abstract_object.cpp
+++ b/projects/sml/src/types/abstract_object.cpp
@@ -117,7 +117,8 @@ abstract_object::abstract_object(abstract_object&& rhs)
 
 abstract_object::abstract_object(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
@@ -135,7 +136,8 @@ abstract_object::abstract_object(
     const bool is_fluent,
     const std::list<dogen::sml::qname>& modeled_concepts)
     : dogen::sml::type(documentation,
-      opaque_parameters,
+      simple_tags,
+      complex_tags,
       name,
       generation_type,
       origin_type),
diff --git a/projects/sml/src/types/concept.cpp b/projects/sml/src/types/concept.cpp
index c1017bf..b287741 100644
--- a/projects/sml/src/types/concept.cpp
+++ b/projects/sml/src/types/concept.cpp
@@ -30,7 +30,8 @@ concept::concept()
 concept::concept(
     const std::list<dogen::sml::property>& properties,
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
@@ -38,7 +39,8 @@ concept::concept(
     const std::list<dogen::sml::qname>& refines)
     : properties_(properties),
       documentation_(documentation),
-      opaque_parameters_(opaque_parameters),
+      simple_tags_(simple_tags),
+      complex_tags_(complex_tags),
       name_(name),
       generation_type_(generation_type),
       origin_type_(origin_type),
@@ -49,7 +51,8 @@ void concept::swap(concept& other) noexcept {
     using std::swap;
     swap(properties_, other.properties_);
     swap(documentation_, other.documentation_);
-    swap(opaque_parameters_, other.opaque_parameters_);
+    swap(simple_tags_, other.simple_tags_);
+    swap(complex_tags_, other.complex_tags_);
     swap(name_, other.name_);
     swap(generation_type_, other.generation_type_);
     swap(origin_type_, other.origin_type_);
@@ -60,7 +63,8 @@ void concept::swap(concept& other) noexcept {
 bool concept::operator==(const concept& rhs) const {
     return properties_ == rhs.properties_ &&
         documentation_ == rhs.documentation_ &&
-        opaque_parameters_ == rhs.opaque_parameters_ &&
+        simple_tags_ == rhs.simple_tags_ &&
+        complex_tags_ == rhs.complex_tags_ &&
         name_ == rhs.name_ &&
         generation_type_ == rhs.generation_type_ &&
         origin_type_ == rhs.origin_type_ &&
@@ -106,20 +110,36 @@ void concept::documentation(const std::string&& v) {
     documentation_ = std::move(v);
 }
 
-const std::list<std::pair<std::string, std::string> >& concept::opaque_parameters() const {
-    return opaque_parameters_;
+const std::unordered_map<std::string, std::string>& concept::simple_tags() const {
+    return simple_tags_;
 }
 
-std::list<std::pair<std::string, std::string> >& concept::opaque_parameters() {
-    return opaque_parameters_;
+std::unordered_map<std::string, std::string>& concept::simple_tags() {
+    return simple_tags_;
 }
 
-void concept::opaque_parameters(const std::list<std::pair<std::string, std::string> >& v) {
-    opaque_parameters_ = v;
+void concept::simple_tags(const std::unordered_map<std::string, std::string>& v) {
+    simple_tags_ = v;
 }
 
-void concept::opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v) {
-    opaque_parameters_ = std::move(v);
+void concept::simple_tags(const std::unordered_map<std::string, std::string>&& v) {
+    simple_tags_ = std::move(v);
+}
+
+const std::unordered_map<std::string, std::list<std::string> >& concept::complex_tags() const {
+    return complex_tags_;
+}
+
+std::unordered_map<std::string, std::list<std::string> >& concept::complex_tags() {
+    return complex_tags_;
+}
+
+void concept::complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v) {
+    complex_tags_ = v;
+}
+
+void concept::complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v) {
+    complex_tags_ = std::move(v);
 }
 
 const dogen::sml::qname& concept::name() const {
diff --git a/projects/sml/src/types/entity.cpp b/projects/sml/src/types/entity.cpp
index 13215ba..6c14888 100644
--- a/projects/sml/src/types/entity.cpp
+++ b/projects/sml/src/types/entity.cpp
@@ -27,7 +27,8 @@ namespace sml {
 
 entity::entity(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
@@ -47,7 +48,8 @@ entity::entity(
     const bool is_aggregate_root,
     const std::list<dogen::sml::property>& identity)
     : dogen::sml::abstract_entity(documentation,
-      opaque_parameters,
+      simple_tags,
+      complex_tags,
       name,
       generation_type,
       origin_type,
diff --git a/projects/sml/src/types/enumeration.cpp b/projects/sml/src/types/enumeration.cpp
index b279db9..b46450f 100644
--- a/projects/sml/src/types/enumeration.cpp
+++ b/projects/sml/src/types/enumeration.cpp
@@ -43,14 +43,16 @@ namespace sml {
 
 enumeration::enumeration(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
     const dogen::sml::qname& underlying_type,
     const std::vector<dogen::sml::enumerator>& enumerators)
     : dogen::sml::type(documentation,
-      opaque_parameters,
+      simple_tags,
+      complex_tags,
       name,
       generation_type,
       origin_type),
diff --git a/projects/sml/src/types/factory.cpp b/projects/sml/src/types/factory.cpp
index 7b2a96e..d39a305 100644
--- a/projects/sml/src/types/factory.cpp
+++ b/projects/sml/src/types/factory.cpp
@@ -27,7 +27,8 @@ namespace sml {
 
 factory::factory(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
@@ -45,7 +46,8 @@ factory::factory(
     const bool is_fluent,
     const std::list<dogen::sml::qname>& modeled_concepts)
     : dogen::sml::abstract_object(documentation,
-      opaque_parameters,
+      simple_tags,
+      complex_tags,
       name,
       generation_type,
       origin_type,
diff --git a/projects/sml/src/types/keyed_entity.cpp b/projects/sml/src/types/keyed_entity.cpp
index 310d184..e80da2d 100644
--- a/projects/sml/src/types/keyed_entity.cpp
+++ b/projects/sml/src/types/keyed_entity.cpp
@@ -49,7 +49,8 @@ keyed_entity::keyed_entity(keyed_entity&& rhs)
 
 keyed_entity::keyed_entity(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
@@ -71,7 +72,8 @@ keyed_entity::keyed_entity(
     const dogen::sml::qname& unversioned_key,
     const boost::optional<dogen::sml::qname>& versioned_key)
     : dogen::sml::abstract_entity(documentation,
-      opaque_parameters,
+      simple_tags,
+      complex_tags,
       name,
       generation_type,
       origin_type,
diff --git a/projects/sml/src/types/model.cpp b/projects/sml/src/types/model.cpp
index b27d0f2..6a32b1b 100644
--- a/projects/sml/src/types/model.cpp
+++ b/projects/sml/src/types/model.cpp
@@ -39,7 +39,8 @@ model::model()
 
 model::model(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
@@ -51,7 +52,8 @@ model::model(
     const std::unordered_map<dogen::sml::qname, dogen::sml::enumeration>& enumerations,
     const std::unordered_map<dogen::sml::qname, boost::shared_ptr<dogen::sml::abstract_object> >& objects)
     : documentation_(documentation),
-      opaque_parameters_(opaque_parameters),
+      simple_tags_(simple_tags),
+      complex_tags_(complex_tags),
       name_(name),
       generation_type_(generation_type),
       origin_type_(origin_type),
@@ -66,7 +68,8 @@ model::model(
 void model::swap(model& other) noexcept {
     using std::swap;
     swap(documentation_, other.documentation_);
-    swap(opaque_parameters_, other.opaque_parameters_);
+    swap(simple_tags_, other.simple_tags_);
+    swap(complex_tags_, other.complex_tags_);
     swap(name_, other.name_);
     swap(generation_type_, other.generation_type_);
     swap(origin_type_, other.origin_type_);
@@ -81,7 +84,8 @@ void model::swap(model& other) noexcept {
 
 bool model::operator==(const model& rhs) const {
     return documentation_ == rhs.documentation_ &&
-        opaque_parameters_ == rhs.opaque_parameters_ &&
+        simple_tags_ == rhs.simple_tags_ &&
+        complex_tags_ == rhs.complex_tags_ &&
         name_ == rhs.name_ &&
         generation_type_ == rhs.generation_type_ &&
         origin_type_ == rhs.origin_type_ &&
@@ -116,20 +120,36 @@ void model::documentation(const std::string&& v) {
     documentation_ = std::move(v);
 }
 
-const std::list<std::pair<std::string, std::string> >& model::opaque_parameters() const {
-    return opaque_parameters_;
+const std::unordered_map<std::string, std::string>& model::simple_tags() const {
+    return simple_tags_;
 }
 
-std::list<std::pair<std::string, std::string> >& model::opaque_parameters() {
-    return opaque_parameters_;
+std::unordered_map<std::string, std::string>& model::simple_tags() {
+    return simple_tags_;
 }
 
-void model::opaque_parameters(const std::list<std::pair<std::string, std::string> >& v) {
-    opaque_parameters_ = v;
+void model::simple_tags(const std::unordered_map<std::string, std::string>& v) {
+    simple_tags_ = v;
 }
 
-void model::opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v) {
-    opaque_parameters_ = std::move(v);
+void model::simple_tags(const std::unordered_map<std::string, std::string>&& v) {
+    simple_tags_ = std::move(v);
+}
+
+const std::unordered_map<std::string, std::list<std::string> >& model::complex_tags() const {
+    return complex_tags_;
+}
+
+std::unordered_map<std::string, std::list<std::string> >& model::complex_tags() {
+    return complex_tags_;
+}
+
+void model::complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v) {
+    complex_tags_ = v;
+}
+
+void model::complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v) {
+    complex_tags_ = std::move(v);
 }
 
 const dogen::sml::qname& model::name() const {
diff --git a/projects/sml/src/types/module.cpp b/projects/sml/src/types/module.cpp
index 138c9d8..9bdefbd 100644
--- a/projects/sml/src/types/module.cpp
+++ b/projects/sml/src/types/module.cpp
@@ -29,13 +29,15 @@ module::module()
 
 module::module(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
     const std::list<dogen::sml::qname>& members)
     : documentation_(documentation),
-      opaque_parameters_(opaque_parameters),
+      simple_tags_(simple_tags),
+      complex_tags_(complex_tags),
       name_(name),
       generation_type_(generation_type),
       origin_type_(origin_type),
@@ -44,7 +46,8 @@ module::module(
 void module::swap(module& other) noexcept {
     using std::swap;
     swap(documentation_, other.documentation_);
-    swap(opaque_parameters_, other.opaque_parameters_);
+    swap(simple_tags_, other.simple_tags_);
+    swap(complex_tags_, other.complex_tags_);
     swap(name_, other.name_);
     swap(generation_type_, other.generation_type_);
     swap(origin_type_, other.origin_type_);
@@ -53,7 +56,8 @@ void module::swap(module& other) noexcept {
 
 bool module::operator==(const module& rhs) const {
     return documentation_ == rhs.documentation_ &&
-        opaque_parameters_ == rhs.opaque_parameters_ &&
+        simple_tags_ == rhs.simple_tags_ &&
+        complex_tags_ == rhs.complex_tags_ &&
         name_ == rhs.name_ &&
         generation_type_ == rhs.generation_type_ &&
         origin_type_ == rhs.origin_type_ &&
@@ -82,20 +86,36 @@ void module::documentation(const std::string&& v) {
     documentation_ = std::move(v);
 }
 
-const std::list<std::pair<std::string, std::string> >& module::opaque_parameters() const {
-    return opaque_parameters_;
+const std::unordered_map<std::string, std::string>& module::simple_tags() const {
+    return simple_tags_;
 }
 
-std::list<std::pair<std::string, std::string> >& module::opaque_parameters() {
-    return opaque_parameters_;
+std::unordered_map<std::string, std::string>& module::simple_tags() {
+    return simple_tags_;
 }
 
-void module::opaque_parameters(const std::list<std::pair<std::string, std::string> >& v) {
-    opaque_parameters_ = v;
+void module::simple_tags(const std::unordered_map<std::string, std::string>& v) {
+    simple_tags_ = v;
 }
 
-void module::opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v) {
-    opaque_parameters_ = std::move(v);
+void module::simple_tags(const std::unordered_map<std::string, std::string>&& v) {
+    simple_tags_ = std::move(v);
+}
+
+const std::unordered_map<std::string, std::list<std::string> >& module::complex_tags() const {
+    return complex_tags_;
+}
+
+std::unordered_map<std::string, std::list<std::string> >& module::complex_tags() {
+    return complex_tags_;
+}
+
+void module::complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v) {
+    complex_tags_ = v;
+}
+
+void module::complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v) {
+    complex_tags_ = std::move(v);
 }
 
 const dogen::sml::qname& module::name() const {
diff --git a/projects/sml/src/types/opaque_parameter_cache.cpp b/projects/sml/src/types/opaque_parameter_cache.cpp
deleted file mode 100644
index cb9087b..0000000
--- a/projects/sml/src/types/opaque_parameter_cache.cpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- *
- */
-#include "dogen/sml/types/opaque_parameter_cache.hpp"
-
-namespace dogen {
-namespace sml {
-
-void opaque_parameter_cache::populate(const model& /*m*/) {
-}
-
-std::string opaque_parameter_cache::
-get(const qname& /*qn*/, const std::string& /*key*/) const {
-    std::string r;
-    return r;
-}
-
-std::string opaque_parameter_cache::
-get_with_default(const qname& /*qn*/, const std::string& /*key*/) const {
-    std::string r;
-    return r;
-}
-
-} }
diff --git a/projects/sml/src/types/opaque_parameter_cache_interface.cpp b/projects/sml/src/types/opaque_parameter_cache_interface.cpp
deleted file mode 100644
index 28e5d22..0000000
--- a/projects/sml/src/types/opaque_parameter_cache_interface.cpp
+++ /dev/null
@@ -1,2 +0,0 @@
-// dummy function to suppress ranlib warnings
-void opaque_parameter_cache_interface() { }
diff --git a/projects/sml/src/types/opaque_parameters.cpp b/projects/sml/src/types/opaque_parameters.cpp
deleted file mode 100644
index 9698836..0000000
--- a/projects/sml/src/types/opaque_parameters.cpp
+++ /dev/null
@@ -1,59 +0,0 @@
-/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA 02110-1301, USA.
- *
- */
-#include "dogen/sml/types/opaque_parameters.hpp"
-
-namespace dogen {
-namespace om {
-
-const std::string opaque_parameters::odb_pragma("ODB_PRAGMA");
-const std::string opaque_parameters::comment("COMMENT");
-const std::string opaque_parameters::bool_true("true");
-const std::string opaque_parameters::bool_false("false");
-const std::string opaque_parameters::cpp::type::family("cpp.type.family");
-const std::string opaque_parameters::cpp::domain::status("cpp.domain.status");
-const std::string opaque_parameters::cpp::domain::
-requires_manual_default_constructor(
-    "cpp.domain.requires_manual_default_constructor");
-const std::string opaque_parameters::cpp::domain::
-requires_manual_move_constructor("cpp.domain.requires_manual_move_constructor");
-const std::string opaque_parameters::cpp::domain::header::file_name(
-    "cpp.domain.header.file_name");
-const std::string opaque_parameters::cpp::domain::header::is_system(
-    "cpp.domain.header.is_system");
-const std::string opaque_parameters::cpp::hash::standard::status(
-    "cpp.hash.standard.status");
-const std::string opaque_parameters::cpp::hash::standard::header::file_name(
-    "cpp.hash.standard.header.file_name");
-const std::string opaque_parameters::cpp::hash::standard::header::is_system(
-    "cpp.hash.standard.header.is_system");
-const std::string opaque_parameters::cpp::serialization::boost::status(
-    "cpp.serialization.boost.status");
-const std::string opaque_parameters::cpp::serialization::boost::header::
-file_name("cpp.serialization.boost.header.file_name");
-const std::string opaque_parameters::cpp::serialization::boost::header::
-is_system("cpp.serialization.boost.header.is_system");
-const std::string opaque_parameters::cpp::io::status("cpp.io.status");
-const std::string opaque_parameters::cpp::io::header::file_name(
-    "cpp.io.header.file_name");
-const std::string opaque_parameters::cpp::io::header::is_system(
-    "cpp.io.header.is_system");
-
-} }
diff --git a/projects/sml/src/types/operation.cpp b/projects/sml/src/types/operation.cpp
index 55129aa..d91e5d9 100644
--- a/projects/sml/src/types/operation.cpp
+++ b/projects/sml/src/types/operation.cpp
@@ -25,19 +25,22 @@ namespace sml {
 
 operation::operation(operation&& rhs)
     : documentation_(std::move(rhs.documentation_)),
-      opaque_parameters_(std::move(rhs.opaque_parameters_)),
+      simple_tags_(std::move(rhs.simple_tags_)),
+      complex_tags_(std::move(rhs.complex_tags_)),
       name_(std::move(rhs.name_)),
       parameters_(std::move(rhs.parameters_)),
       type_(std::move(rhs.type_)) { }
 
 operation::operation(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const std::string& name,
     const std::list<dogen::sml::parameter>& parameters,
     const boost::optional<dogen::sml::nested_qname>& type)
     : documentation_(documentation),
-      opaque_parameters_(opaque_parameters),
+      simple_tags_(simple_tags),
+      complex_tags_(complex_tags),
       name_(name),
       parameters_(parameters),
       type_(type) { }
@@ -45,7 +48,8 @@ operation::operation(
 void operation::swap(operation& other) noexcept {
     using std::swap;
     swap(documentation_, other.documentation_);
-    swap(opaque_parameters_, other.opaque_parameters_);
+    swap(simple_tags_, other.simple_tags_);
+    swap(complex_tags_, other.complex_tags_);
     swap(name_, other.name_);
     swap(parameters_, other.parameters_);
     swap(type_, other.type_);
@@ -53,7 +57,8 @@ void operation::swap(operation& other) noexcept {
 
 bool operation::operator==(const operation& rhs) const {
     return documentation_ == rhs.documentation_ &&
-        opaque_parameters_ == rhs.opaque_parameters_ &&
+        simple_tags_ == rhs.simple_tags_ &&
+        complex_tags_ == rhs.complex_tags_ &&
         name_ == rhs.name_ &&
         parameters_ == rhs.parameters_ &&
         type_ == rhs.type_;
@@ -81,20 +86,36 @@ void operation::documentation(const std::string&& v) {
     documentation_ = std::move(v);
 }
 
-const std::list<std::pair<std::string, std::string> >& operation::opaque_parameters() const {
-    return opaque_parameters_;
+const std::unordered_map<std::string, std::string>& operation::simple_tags() const {
+    return simple_tags_;
 }
 
-std::list<std::pair<std::string, std::string> >& operation::opaque_parameters() {
-    return opaque_parameters_;
+std::unordered_map<std::string, std::string>& operation::simple_tags() {
+    return simple_tags_;
 }
 
-void operation::opaque_parameters(const std::list<std::pair<std::string, std::string> >& v) {
-    opaque_parameters_ = v;
+void operation::simple_tags(const std::unordered_map<std::string, std::string>& v) {
+    simple_tags_ = v;
 }
 
-void operation::opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v) {
-    opaque_parameters_ = std::move(v);
+void operation::simple_tags(const std::unordered_map<std::string, std::string>&& v) {
+    simple_tags_ = std::move(v);
+}
+
+const std::unordered_map<std::string, std::list<std::string> >& operation::complex_tags() const {
+    return complex_tags_;
+}
+
+std::unordered_map<std::string, std::list<std::string> >& operation::complex_tags() {
+    return complex_tags_;
+}
+
+void operation::complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v) {
+    complex_tags_ = v;
+}
+
+void operation::complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v) {
+    complex_tags_ = std::move(v);
 }
 
 const std::string& operation::name() const {
diff --git a/projects/sml/src/types/parameter.cpp b/projects/sml/src/types/parameter.cpp
index a43dfef..6b9e3c6 100644
--- a/projects/sml/src/types/parameter.cpp
+++ b/projects/sml/src/types/parameter.cpp
@@ -25,25 +25,29 @@ namespace sml {
 
 parameter::parameter(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const std::string& name,
     const dogen::sml::nested_qname& type)
     : documentation_(documentation),
-      opaque_parameters_(opaque_parameters),
+      simple_tags_(simple_tags),
+      complex_tags_(complex_tags),
       name_(name),
       type_(type) { }
 
 void parameter::swap(parameter& other) noexcept {
     using std::swap;
     swap(documentation_, other.documentation_);
-    swap(opaque_parameters_, other.opaque_parameters_);
+    swap(simple_tags_, other.simple_tags_);
+    swap(complex_tags_, other.complex_tags_);
     swap(name_, other.name_);
     swap(type_, other.type_);
 }
 
 bool parameter::operator==(const parameter& rhs) const {
     return documentation_ == rhs.documentation_ &&
-        opaque_parameters_ == rhs.opaque_parameters_ &&
+        simple_tags_ == rhs.simple_tags_ &&
+        complex_tags_ == rhs.complex_tags_ &&
         name_ == rhs.name_ &&
         type_ == rhs.type_;
 }
@@ -70,20 +74,36 @@ void parameter::documentation(const std::string&& v) {
     documentation_ = std::move(v);
 }
 
-const std::list<std::pair<std::string, std::string> >& parameter::opaque_parameters() const {
-    return opaque_parameters_;
+const std::unordered_map<std::string, std::string>& parameter::simple_tags() const {
+    return simple_tags_;
 }
 
-std::list<std::pair<std::string, std::string> >& parameter::opaque_parameters() {
-    return opaque_parameters_;
+std::unordered_map<std::string, std::string>& parameter::simple_tags() {
+    return simple_tags_;
 }
 
-void parameter::opaque_parameters(const std::list<std::pair<std::string, std::string> >& v) {
-    opaque_parameters_ = v;
+void parameter::simple_tags(const std::unordered_map<std::string, std::string>& v) {
+    simple_tags_ = v;
 }
 
-void parameter::opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v) {
-    opaque_parameters_ = std::move(v);
+void parameter::simple_tags(const std::unordered_map<std::string, std::string>&& v) {
+    simple_tags_ = std::move(v);
+}
+
+const std::unordered_map<std::string, std::list<std::string> >& parameter::complex_tags() const {
+    return complex_tags_;
+}
+
+std::unordered_map<std::string, std::list<std::string> >& parameter::complex_tags() {
+    return complex_tags_;
+}
+
+void parameter::complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v) {
+    complex_tags_ = v;
+}
+
+void parameter::complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v) {
+    complex_tags_ = std::move(v);
 }
 
 const std::string& parameter::name() const {
diff --git a/projects/sml/src/types/primitive.cpp b/projects/sml/src/types/primitive.cpp
index a6cde25..a30c37d 100644
--- a/projects/sml/src/types/primitive.cpp
+++ b/projects/sml/src/types/primitive.cpp
@@ -27,12 +27,14 @@ namespace sml {
 
 primitive::primitive(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type)
     : dogen::sml::type(documentation,
-      opaque_parameters,
+      simple_tags,
+      complex_tags,
       name,
       generation_type,
       origin_type) { }
diff --git a/projects/sml/src/types/property.cpp b/projects/sml/src/types/property.cpp
index 6d809e8..3b683ae 100644
--- a/projects/sml/src/types/property.cpp
+++ b/projects/sml/src/types/property.cpp
@@ -25,12 +25,14 @@ namespace sml {
 
 property::property(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const std::string& name,
     const dogen::sml::nested_qname& type,
     const std::string& default_value)
     : documentation_(documentation),
-      opaque_parameters_(opaque_parameters),
+      simple_tags_(simple_tags),
+      complex_tags_(complex_tags),
       name_(name),
       type_(type),
       default_value_(default_value) { }
@@ -38,7 +40,8 @@ property::property(
 void property::swap(property& other) noexcept {
     using std::swap;
     swap(documentation_, other.documentation_);
-    swap(opaque_parameters_, other.opaque_parameters_);
+    swap(simple_tags_, other.simple_tags_);
+    swap(complex_tags_, other.complex_tags_);
     swap(name_, other.name_);
     swap(type_, other.type_);
     swap(default_value_, other.default_value_);
@@ -46,7 +49,8 @@ void property::swap(property& other) noexcept {
 
 bool property::operator==(const property& rhs) const {
     return documentation_ == rhs.documentation_ &&
-        opaque_parameters_ == rhs.opaque_parameters_ &&
+        simple_tags_ == rhs.simple_tags_ &&
+        complex_tags_ == rhs.complex_tags_ &&
         name_ == rhs.name_ &&
         type_ == rhs.type_ &&
         default_value_ == rhs.default_value_;
@@ -74,20 +78,36 @@ void property::documentation(const std::string&& v) {
     documentation_ = std::move(v);
 }
 
-const std::list<std::pair<std::string, std::string> >& property::opaque_parameters() const {
-    return opaque_parameters_;
+const std::unordered_map<std::string, std::string>& property::simple_tags() const {
+    return simple_tags_;
 }
 
-std::list<std::pair<std::string, std::string> >& property::opaque_parameters() {
-    return opaque_parameters_;
+std::unordered_map<std::string, std::string>& property::simple_tags() {
+    return simple_tags_;
 }
 
-void property::opaque_parameters(const std::list<std::pair<std::string, std::string> >& v) {
-    opaque_parameters_ = v;
+void property::simple_tags(const std::unordered_map<std::string, std::string>& v) {
+    simple_tags_ = v;
 }
 
-void property::opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v) {
-    opaque_parameters_ = std::move(v);
+void property::simple_tags(const std::unordered_map<std::string, std::string>&& v) {
+    simple_tags_ = std::move(v);
+}
+
+const std::unordered_map<std::string, std::list<std::string> >& property::complex_tags() const {
+    return complex_tags_;
+}
+
+std::unordered_map<std::string, std::list<std::string> >& property::complex_tags() {
+    return complex_tags_;
+}
+
+void property::complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v) {
+    complex_tags_ = v;
+}
+
+void property::complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v) {
+    complex_tags_ = std::move(v);
 }
 
 const std::string& property::name() const {
diff --git a/projects/sml/src/types/repository.cpp b/projects/sml/src/types/repository.cpp
index 50cf581..b40055d 100644
--- a/projects/sml/src/types/repository.cpp
+++ b/projects/sml/src/types/repository.cpp
@@ -27,7 +27,8 @@ namespace sml {
 
 repository::repository(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
@@ -45,7 +46,8 @@ repository::repository(
     const bool is_fluent,
     const std::list<dogen::sml::qname>& modeled_concepts)
     : dogen::sml::abstract_object(documentation,
-      opaque_parameters,
+      simple_tags,
+      complex_tags,
       name,
       generation_type,
       origin_type,
diff --git a/projects/sml/src/types/service.cpp b/projects/sml/src/types/service.cpp
index fe1211b..3509ea1 100644
--- a/projects/sml/src/types/service.cpp
+++ b/projects/sml/src/types/service.cpp
@@ -31,7 +31,8 @@ service::service()
 
 service::service(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
@@ -50,7 +51,8 @@ service::service(
     const std::list<dogen::sml::qname>& modeled_concepts,
     const dogen::sml::service_types& type)
     : dogen::sml::abstract_object(documentation,
-      opaque_parameters,
+      simple_tags,
+      complex_tags,
       name,
       generation_type,
       origin_type,
diff --git a/projects/sml/src/types/tag_adaptor.cpp b/projects/sml/src/types/tag_adaptor.cpp
new file mode 100644
index 0000000..9942b3c
--- /dev/null
+++ b/projects/sml/src/types/tag_adaptor.cpp
@@ -0,0 +1,37 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include "dogen/sml/types/tags.hpp"
+#include "dogen/sml/types/tag_adaptor.hpp"
+
+namespace dogen {
+namespace sml {
+
+bool tag_adaptor::has_comment() const {
+    const auto i(simple_tags_.find(tags::comment));
+    return i != simple_tags_.end();
+}
+
+bool tag_adaptor::has_identity() const {
+    const auto i(simple_tags_.find(tags::identity_attribute));
+    return i != simple_tags_.end();
+}
+
+} }
diff --git a/projects/sml/src/types/tag_router.cpp b/projects/sml/src/types/tag_router.cpp
new file mode 100644
index 0000000..15f578a
--- /dev/null
+++ b/projects/sml/src/types/tag_router.cpp
@@ -0,0 +1,85 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <boost/throw_exception.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/sml/types/tag_error.hpp"
+#include "dogen/sml/types/tags.hpp"
+#include "dogen/sml/types/tag_router.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("om_formatters.modeline_formatter"));
+const std::string duplicated_key(
+    "Attempt to use a simple tag key which has already been used: ");
+
+}
+
+namespace dogen {
+namespace sml {
+
+tag_router::
+tag_router(std::unordered_map<std::string, std::string>& simple_tags,
+    std::unordered_map<std::string, std::list<std::string> >& complex_tags)
+    : simple_tags_(simple_tags), complex_tags_(complex_tags) { }
+
+bool tag_router::is_complex(const std::string& key) const {
+    return key == tags::odb_pragma;
+}
+
+void tag_router::route(const std::string& key, const std::string& value) {
+    if (is_complex(tags::odb_pragma)) {
+        complex_tags_[tags::odb_pragma].push_back(value);
+        return;
+    }
+
+    const auto result(simple_tags_.insert(std::make_pair(key, value)));
+    if (!result.second) {
+        BOOST_LOG_SEV(lg, error) << duplicated_key << key;
+        BOOST_THROW_EXCEPTION(tag_error(duplicated_key + key));
+    }
+}
+
+void tag_router::
+route(const std::list<std::pair<std::string, std::string> >& kvps) {
+    for (const auto& pair : kvps)
+        route(pair.first, pair.second);
+}
+
+void tag_router::
+route_if(const std::list<std::pair<std::string, std::string> >& kvps,
+    const std::string& key) {
+
+    bool has_marker(false);
+    for (const auto& kvp : kvps) {
+        has_marker = kvp.first == key;
+        if (has_marker)
+            break;
+    }
+
+    if (!has_marker)
+        return;
+
+    route(kvps);
+}
+
+} }
diff --git a/projects/sml/src/types/tagger.cpp b/projects/sml/src/types/tagger.cpp
new file mode 100644
index 0000000..c7cb502
--- /dev/null
+++ b/projects/sml/src/types/tagger.cpp
@@ -0,0 +1,2 @@
+// dummy function to suppress ranlib warnings
+void tagger() { }
diff --git a/projects/sml/src/types/tags.cpp b/projects/sml/src/types/tags.cpp
new file mode 100644
index 0000000..7983cfa
--- /dev/null
+++ b/projects/sml/src/types/tags.cpp
@@ -0,0 +1,59 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include "dogen/sml/types/tags.hpp"
+
+namespace dogen {
+namespace sml {
+
+const std::string tags::odb_pragma("ODB_PRAGMA");
+const std::string tags::comment("COMMENT");
+const std::string tags::bool_true("true");
+const std::string tags::bool_false("false");
+const std::string tags::cpp::type::family("cpp.type.family");
+const std::string tags::cpp::domain::status("cpp.domain.status");
+const std::string tags::cpp::domain::
+requires_manual_default_constructor(
+    "cpp.domain.requires_manual_default_constructor");
+const std::string tags::cpp::domain::
+requires_manual_move_constructor("cpp.domain.requires_manual_move_constructor");
+const std::string tags::cpp::domain::header::file_name(
+    "cpp.domain.header.file_name");
+const std::string tags::cpp::domain::header::is_system(
+    "cpp.domain.header.is_system");
+const std::string tags::cpp::hash::standard::status(
+    "cpp.hash.standard.status");
+const std::string tags::cpp::hash::standard::header::file_name(
+    "cpp.hash.standard.header.file_name");
+const std::string tags::cpp::hash::standard::header::is_system(
+    "cpp.hash.standard.header.is_system");
+const std::string tags::cpp::serialization::boost::status(
+    "cpp.serialization.boost.status");
+const std::string tags::cpp::serialization::boost::header::
+file_name("cpp.serialization.boost.header.file_name");
+const std::string tags::cpp::serialization::boost::header::
+is_system("cpp.serialization.boost.header.is_system");
+const std::string tags::cpp::io::status("cpp.io.status");
+const std::string tags::cpp::io::header::file_name(
+    "cpp.io.header.file_name");
+const std::string tags::cpp::io::header::is_system(
+    "cpp.io.header.is_system");
+
+} }
diff --git a/projects/sml/src/types/type.cpp b/projects/sml/src/types/type.cpp
index 3a2cc42..033f541 100644
--- a/projects/sml/src/types/type.cpp
+++ b/projects/sml/src/types/type.cpp
@@ -35,12 +35,17 @@ inline std::string tidy_up_string(std::string s) {
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, std::string>& v) {
-    s << "{ " << "\"__type__\": " << "\"std::pair\"" << ", ";
-
-    s << "\"first\": " << "\"" << tidy_up_string(v.first) << "\"" << ", ";
-    s << "\"second\": " << "\"" << tidy_up_string(v.second) << "\"";
-    s << " }";
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::string>& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->second) << "\"";
+        s << " } ]";
+    }
+    s << " ] ";
     return s;
 }
 
@@ -48,11 +53,11 @@ inline std::ostream& operator<<(std::ostream& s, const std::pair<std::string, st
 
 namespace std {
 
-inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::string, std::string> >& v) {
+inline std::ostream& operator<<(std::ostream& s, const std::list<std::string>& v) {
     s << "[ ";
     for (auto i(v.begin()); i != v.end(); ++i) {
         if (i != v.begin()) s << ", ";
-        s << *i;
+        s << "\"" << tidy_up_string(*i) << "\"";
     }
     s << "] ";
     return s;
@@ -60,6 +65,24 @@ inline std::ostream& operator<<(std::ostream& s, const std::list<std::pair<std::
 
 }
 
+namespace std {
+
+inline std::ostream& operator<<(std::ostream& s, const std::unordered_map<std::string, std::list<std::string> >& v) {
+    s << "[";
+    for (auto i(v.begin()); i != v.end(); ++i) {
+        if (i != v.begin()) s << ", ";
+        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
+        s << "\"" << tidy_up_string(i->first) << "\"";
+        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
+        s << i->second;
+        s << " } ]";
+    }
+    s << " ] ";
+    return s;
+}
+
+}
+
 namespace dogen {
 namespace sml {
 
@@ -69,12 +92,14 @@ type::type()
 
 type::type(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type)
     : documentation_(documentation),
-      opaque_parameters_(opaque_parameters),
+      simple_tags_(simple_tags),
+      complex_tags_(complex_tags),
       name_(name),
       generation_type_(generation_type),
       origin_type_(origin_type) { }
@@ -83,7 +108,8 @@ void type::to_stream(std::ostream& s) const {
     s << " { "
       << "\"__type__\": " << "\"dogen::sml::type\"" << ", "
       << "\"documentation\": " << "\"" << tidy_up_string(documentation_) << "\"" << ", "
-      << "\"opaque_parameters\": " << opaque_parameters_ << ", "
+      << "\"simple_tags\": " << simple_tags_ << ", "
+      << "\"complex_tags\": " << complex_tags_ << ", "
       << "\"name\": " << name_ << ", "
       << "\"generation_type\": " << generation_type_ << ", "
       << "\"origin_type\": " << origin_type_
@@ -93,7 +119,8 @@ void type::to_stream(std::ostream& s) const {
 void type::swap(type& other) noexcept {
     using std::swap;
     swap(documentation_, other.documentation_);
-    swap(opaque_parameters_, other.opaque_parameters_);
+    swap(simple_tags_, other.simple_tags_);
+    swap(complex_tags_, other.complex_tags_);
     swap(name_, other.name_);
     swap(generation_type_, other.generation_type_);
     swap(origin_type_, other.origin_type_);
@@ -101,7 +128,8 @@ void type::swap(type& other) noexcept {
 
 bool type::compare(const type& rhs) const {
     return documentation_ == rhs.documentation_ &&
-        opaque_parameters_ == rhs.opaque_parameters_ &&
+        simple_tags_ == rhs.simple_tags_ &&
+        complex_tags_ == rhs.complex_tags_ &&
         name_ == rhs.name_ &&
         generation_type_ == rhs.generation_type_ &&
         origin_type_ == rhs.origin_type_;
@@ -123,20 +151,36 @@ void type::documentation(const std::string&& v) {
     documentation_ = std::move(v);
 }
 
-const std::list<std::pair<std::string, std::string> >& type::opaque_parameters() const {
-    return opaque_parameters_;
+const std::unordered_map<std::string, std::string>& type::simple_tags() const {
+    return simple_tags_;
+}
+
+std::unordered_map<std::string, std::string>& type::simple_tags() {
+    return simple_tags_;
+}
+
+void type::simple_tags(const std::unordered_map<std::string, std::string>& v) {
+    simple_tags_ = v;
+}
+
+void type::simple_tags(const std::unordered_map<std::string, std::string>&& v) {
+    simple_tags_ = std::move(v);
+}
+
+const std::unordered_map<std::string, std::list<std::string> >& type::complex_tags() const {
+    return complex_tags_;
 }
 
-std::list<std::pair<std::string, std::string> >& type::opaque_parameters() {
-    return opaque_parameters_;
+std::unordered_map<std::string, std::list<std::string> >& type::complex_tags() {
+    return complex_tags_;
 }
 
-void type::opaque_parameters(const std::list<std::pair<std::string, std::string> >& v) {
-    opaque_parameters_ = v;
+void type::complex_tags(const std::unordered_map<std::string, std::list<std::string> >& v) {
+    complex_tags_ = v;
 }
 
-void type::opaque_parameters(const std::list<std::pair<std::string, std::string> >&& v) {
-    opaque_parameters_ = std::move(v);
+void type::complex_tags(const std::unordered_map<std::string, std::list<std::string> >&& v) {
+    complex_tags_ = std::move(v);
 }
 
 const dogen::sml::qname& type::name() const {
diff --git a/projects/sml/src/types/value_object.cpp b/projects/sml/src/types/value_object.cpp
index aee69a7..9fb2923 100644
--- a/projects/sml/src/types/value_object.cpp
+++ b/projects/sml/src/types/value_object.cpp
@@ -31,7 +31,8 @@ value_object::value_object()
 
 value_object::value_object(
     const std::string& documentation,
-    const std::list<std::pair<std::string, std::string> >& opaque_parameters,
+    const std::unordered_map<std::string, std::string>& simple_tags,
+    const std::unordered_map<std::string, std::list<std::string> >& complex_tags,
     const dogen::sml::qname& name,
     const dogen::sml::generation_types& generation_type,
     const dogen::sml::origin_types& origin_type,
@@ -50,7 +51,8 @@ value_object::value_object(
     const std::list<dogen::sml::qname>& modeled_concepts,
     const dogen::sml::value_object_types& type)
     : dogen::sml::abstract_object(documentation,
-      opaque_parameters,
+      simple_tags,
+      complex_tags,
       name,
       generation_type,
       origin_type,
