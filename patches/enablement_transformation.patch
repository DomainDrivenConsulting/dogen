diff --git a/projects/yarn/include/dogen/yarn/types/transforms/enablement_transform.hpp b/projects/yarn/include/dogen/yarn/types/transforms/enablement_transform.hpp
index 39577ce85..0949b4054 100644
--- a/projects/yarn/include/dogen/yarn/types/transforms/enablement_transform.hpp
+++ b/projects/yarn/include/dogen/yarn/types/transforms/enablement_transform.hpp
@@ -25,26 +25,94 @@
 #pragma once
 #endif
 
-#include <algorithm>
+#include <typeindex>
+#include <unordered_map>
+#include <boost/optional.hpp>
+#include "dogen/annotations/types/annotation.hpp"
+#include "dogen/annotations/types/type_repository.hpp"
+#include "dogen/annotations/types/type.hpp"
+#include "dogen/yarn/types/meta_model/intermediate_model.hpp"
+#include "dogen/yarn/types/transforms/context.hpp"
+#include "dogen/yarn/types/transforms/local_enablement_configuration.hpp"
+#include "dogen/yarn/types/transforms/global_enablement_configuration.hpp"
 
 namespace dogen {
 namespace yarn {
 namespace transforms {
 
 class enablement_transform final {
-public:
-    enablement_transform() = default;
-    enablement_transform(const enablement_transform&) = default;
-    enablement_transform(enablement_transform&&) = default;
-    ~enablement_transform() = default;
-    enablement_transform& operator=(const enablement_transform&) = default;
+private:
+    struct global_type_group {
+        annotations::type kernel_enabled;
+        annotations::type facet_enabled;
+        annotations::type archetype_enabled;
+        annotations::type facet_overwrite;
+        annotations::type archetype_overwrite;
 
-public:
-    bool operator==(const enablement_transform& rhs) const;
-    bool operator!=(const enablement_transform& rhs) const {
-        return !this->operator==(rhs);
-    }
+        std::string facet_name;
+    };
+
+    friend std::ostream& operator<<(std::ostream& s,
+        const global_type_group& v);
+
+    typedef std::unordered_map<std::string, global_type_group>
+    global_type_group_type;
+
+    global_type_group_type make_global_type_group(
+        const annotations::type_repository& atrp,
+        const std::list<annotations::archetype_location>& als) const;
+
+private:
+    typedef std::unordered_map<std::string, global_enablement_configuration>
+    global_enablement_configurations_type;
+
+    global_enablement_configurations_type
+    obtain_global_configurations(const global_type_group_type& gtg,
+        const annotations::annotation& ra) const;
+
+    void update_facet_enablement(
+        const std::list<annotations::archetype_location>& als,
+        const global_enablement_configurations_type& gcs,
+        meta_model::intermediate_model& im) const;
+
+private:
+    struct local_type_group {
+        annotations::type facet_enabled;
+        annotations::type archetype_enabled;
+        annotations::type facet_supported;
+        annotations::type facet_overwrite;
+        annotations::type archetype_overwrite;
+    };
 
+    friend std::ostream& operator<<(std::ostream& s,
+        const local_type_group& v);
+
+    typedef std::unordered_map<std::string, local_type_group>
+    local_type_group_type;
+
+    local_type_group_type
+    make_local_type_group(const annotations::type_repository& atrp,
+        const std::list<annotations::archetype_location>& als) const;
+
+private:
+    typedef std::unordered_map<std::string, local_enablement_configuration>
+    local_enablement_configurations_type;
+
+    local_enablement_configurations_type
+    obtain_local_configurations(const local_type_group_type& ltg,
+        const annotations::annotation& o) const;
+
+private:
+    bool is_element_disabled(const meta_model::element& e) const;
+
+    void compute_enablement(
+        const global_enablement_configurations_type& gcs,
+        const local_enablement_configurations_type& lcs,
+        meta_model::element& e) const;
+
+public:
+    static void transform(const context& ctx,
+        meta_model::intermediate_model& im);
 };
 
 } } }
diff --git a/projects/yarn/src/types/transforms/enablement_transform.cpp b/projects/yarn/src/types/transforms/enablement_transform.cpp
index 042f1ea46..fc2cc19f6 100644
--- a/projects/yarn/src/types/transforms/enablement_transform.cpp
+++ b/projects/yarn/src/types/transforms/enablement_transform.cpp
@@ -18,14 +18,468 @@
  * MA 02110-1301, USA.
  *
  */
+#include <boost/throw_exception.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/utility/io/unordered_set_io.hpp"
+#include "dogen/utility/io/unordered_map_io.hpp"
+#include "dogen/annotations/io/type_io.hpp"
+#include "dogen/annotations/types/entry_selector.hpp"
+#include "dogen/annotations/types/type_repository_selector.hpp"
+#include "dogen/yarn/types/meta_model/module.hpp"
+#include "dogen/yarn/types/traits.hpp"
+#include "dogen/yarn/io/meta_model/facet_properties_io.hpp"
+#include "dogen/yarn/io/transforms/local_enablement_configuration_io.hpp"
+#include "dogen/yarn/io/transforms/global_enablement_configuration_io.hpp"
+#include "dogen/yarn/types/transforms/transformation_error.hpp"
 #include "dogen/yarn/types/transforms/enablement_transform.hpp"
 
+namespace {
+
+using namespace dogen::utility::log;
+static logger lg(logger_factory("yarn.transforms.enablement_transform"));
+
+const std::string global_configuration_not_found(
+    "Could not find global enablement configuration for formatter: ");
+const std::string duplicate_archetype_name("Duplicate archetype name: ");
+const std::string archetype_not_found("Archetype not found: ");
+const std::string incompatible_facet(
+    "Facet is not compatible with C++ standard chosen: ");
+const std::string element_not_found("Element not found: ");
+const std::string default_value_unset("Default value not set for field: ");
+
+}
+
 namespace dogen {
 namespace yarn {
 namespace transforms {
 
-bool enablement_transform::operator==(const enablement_transform& /*rhs*/) const {
-    return true;
+inline std::ostream& operator<<(std::ostream& s,
+    const enablement_transform::global_type_group& v) {
+
+    s << " { "
+      << "\"__type__\": " << "\"yarn::transform::"
+      << "enablement_transform::global_type_group\"" << ", "
+      << "\"kernel_enabled\": " << v.kernel_enabled << ", "
+      << "\"facet_enabled\": " << v.facet_enabled << ", "
+      << "\"archetype_enabled\": " << v.archetype_enabled
+      << " }";
+
+    return s;
+}
+
+inline std::ostream& operator<<(std::ostream& s,
+    const enablement_transform::local_type_group& v) {
+
+    s << " { "
+      << "\"__type__\": " << "\"yarn::transform"
+      << "enablement_transform::local_type_group\"" << ", "
+      << "\"facet_enabled\": " << v.facet_enabled << ", "
+      << "\"archetype_enabled\": " << v.archetype_enabled << ", "
+      << "\"supported\": " << v.facet_supported
+      << " }";
+
+    return s;
+}
+
+enablement_transform::global_type_group_type enablement_transform::
+make_global_type_group(const annotations::type_repository& atrp,
+    const std::list<annotations::archetype_location>& als) const {
+
+    BOOST_LOG_SEV(lg, debug) << "Creating global type group.";
+
+    global_type_group_type r;
+    const annotations::type_repository_selector s(atrp);
+    for (const auto& al : als) {
+        global_type_group gtg;
+        const auto ebl(traits::enabled());
+        gtg.kernel_enabled = s.select_type_by_name(al.kernel(), ebl);
+        gtg.facet_enabled = s.select_type_by_name(al.facet(), ebl);
+        gtg.archetype_enabled = s.select_type_by_name(al.archetype(), ebl);
+
+        const auto ow(traits::overwrite());
+        gtg.facet_overwrite = s.select_type_by_name(al.facet(), ow);
+        gtg.archetype_overwrite = s.select_type_by_name(al.archetype(), ow);
+
+        gtg.facet_name = al.facet();
+
+        r[al.archetype()] = gtg;
+    }
+
+    BOOST_LOG_SEV(lg, debug) << "Created global type group. Result: " << r;
+    return r;
+}
+
+enablement_transform::global_enablement_configurations_type
+enablement_transform::obtain_global_configurations(
+    const std::unordered_map<std::string, global_type_group>& gtg,
+    const annotations::annotation& ra) const {
+
+    BOOST_LOG_SEV(lg, debug) << "Creating global enablement configuration.";
+
+    global_enablement_configurations_type r;
+    const annotations::entry_selector s(ra);
+    for (const auto& pair : gtg) {
+        const auto& arch(pair.first);
+        const auto& t(pair.second);
+
+        global_enablement_configuration gec;
+        gec.kernel_enabled(s.get_boolean_content_or_default(t.kernel_enabled));
+        gec.facet_enabled(s.get_boolean_content_or_default(t.facet_enabled));
+        gec.facet_name(t.facet_name);
+        gec.archetype_enabled(
+            s.get_boolean_content_or_default(t.archetype_enabled));
+        gec.facet_overwrite(
+            s.get_boolean_content_or_default(t.facet_overwrite));
+
+        if (s.has_entry(t.archetype_overwrite)) {
+            gec.archetype_overwrite(
+                s.get_boolean_content(t.archetype_overwrite));
+        }
+
+        r[arch] = gec;
+    }
+
+    BOOST_LOG_SEV(lg, debug) << "Created global enablement configuration. "
+                             << "Result: " << r;
+    return r;
+}
+
+void enablement_transform::update_facet_enablement(
+    const std::list<annotations::archetype_location>& als,
+    const global_enablement_configurations_type& gcs,
+    meta_model::intermediate_model& im) const {
+    BOOST_LOG_SEV(lg, debug) << "Updating facet enablement.";
+
+    /*
+     * For each formatter in our global configurations: find the facet
+     * to which the formatter belongs to, and update the enablement
+     * value of that facet in the main facet container.
+     *
+     * Note that this is all a bit silly - we're doing this N times
+     * for one facet - where N is the number of formatters for that
+     * facet - rather than just read the facet field and update it
+     * once.
+     *
+     * FIXME: read facet fields here instead of reusing configuration.
+     */
+    const auto archetype_to_facet([&]() {
+            std::unordered_map<std::string, std::string> r;
+            for (const auto& al : als)
+                r[al.archetype()] = al.facet();
+            return r;
+        }());
+
+    for (const auto& pair : gcs) {
+        const auto arch(pair.first);
+        const auto i(archetype_to_facet.find(arch));
+        if (i == archetype_to_facet.end()) {
+            BOOST_LOG_SEV(lg, error) << archetype_not_found << arch;
+            BOOST_THROW_EXCEPTION(
+                transformation_error(archetype_not_found + arch));
+        }
+
+        const auto& fct(i->second);
+        const auto& gc(pair.second);
+        im.facet_properties()[fct].enabled(gc.facet_enabled());
+    }
+
+    BOOST_LOG_SEV(lg, debug) << "Finished updating facet enablement."
+                             << "Result: " << im.facet_properties();
+}
+
+enablement_transform::local_type_group_type enablement_transform::
+make_local_type_group(const annotations::type_repository& atrp,
+    const std::list<annotations::archetype_location>& als) const {
+
+    BOOST_LOG_SEV(lg, debug) << "Creating local type grup.";
+
+    local_type_group_type r;
+    const annotations::type_repository_selector s(atrp);
+    for (const auto& al : als) {
+        const auto& fct(al.facet());
+        const auto ebl(traits::enabled());
+
+        local_type_group ltg;
+        ltg.facet_enabled = s.select_type_by_name(fct, ebl);
+
+        const auto& arch(al.archetype());
+        ltg.archetype_enabled = s.select_type_by_name(arch, ebl);
+
+        const auto ow(traits::overwrite());
+        ltg.facet_overwrite = s.select_type_by_name(fct, ow);
+        ltg.archetype_overwrite = s.select_type_by_name(arch, ow);
+        ltg.facet_supported = s.select_type_by_name(fct, traits::supported());
+        r[arch] = ltg;
+    }
+
+    BOOST_LOG_SEV(lg, debug) << "Created local type group. Result: " << r;
+    return r;
+}
+
+enablement_transform::local_enablement_configurations_type
+enablement_transform::
+obtain_local_configurations(const local_type_group_type& ltg,
+    const annotations::annotation& o) const {
+
+    BOOST_LOG_SEV(lg, debug) << "Obtaining local configurations.";
+    local_enablement_configurations_type r;
+    const annotations::entry_selector s(o);
+    for (const auto& pair : ltg) {
+        const auto& arch(pair.first);
+        const auto& t(pair.second);
+
+        local_enablement_configuration lec;
+        if (s.has_entry(t.facet_enabled))
+            lec.facet_enabled(s.get_boolean_content(t.facet_enabled));
+
+        if (s.has_entry(t.archetype_enabled))
+            lec.archetype_enabled(s.get_boolean_content(t.archetype_enabled));
+
+        if (s.has_entry(t.facet_overwrite))
+            lec.facet_overwrite(s.get_boolean_content(t.facet_overwrite));
+
+        if (s.has_entry(t.archetype_overwrite))
+            lec.archetype_overwrite(
+                s.get_boolean_content(t.archetype_overwrite));
+
+        r[arch] = lec;
+    }
+
+    BOOST_LOG_SEV(lg, debug) << "Obtained local configurations. Result: " << r;
+    return r;
+}
+
+bool enablement_transform::
+is_element_disabled(const yarn::meta_model::element& e) const {
+    /*
+     * We're only interested in modules as these are the only elements
+     * that can be enabled/disabled based on their state.
+     */
+    const auto ptr(dynamic_cast<const yarn::meta_model::module*>(&e));
+    if (!ptr)
+        return false;
+
+    const auto& m(*ptr);
+
+    /*
+     * Ignore the global module. This is just a pseudo module that is
+     * used as a top-level container and has no expression in code.
+     */
+    if (m.is_global_module())
+        return true;
+
+    /*
+     * Modules are only generatable for the purposes of
+     * documentation. Set them to disabled if there is no
+     * documentation.
+     */
+    if (m.documentation().empty()) {
+        BOOST_LOG_SEV(lg, debug) << "Module does not have documentation. "
+                                 << "Disabling it. Id: " << m.name().id();
+        return true;
+    }
+    return false;
+}
+
+void enablement_transform::
+compute_enablement(const global_enablement_configurations_type& gcs,
+    const local_enablement_configurations_type& lcs,
+    meta_model::element& e) const {
+
+    BOOST_LOG_SEV(lg, debug) << "Started computing enablement.";
+    for (auto& pair : e.element_properties().artefact_properties()) {
+        const auto arch(pair.first);
+
+        /*
+         * As we may be processing a segmented entity, not all
+         * formatters need to be present in the local
+         * configuration. For example, an entity may be segmented into
+         * an object and a forward declaration; in this case, when we
+         * are processing the object, we will still see the forward
+         * declaration formatters in the formattable configuration
+         * since the transformer merged all segments of the element
+         * together. However, these are not present in the local
+         * configuration container because we are only processing one
+         * segment at a time. So, we need to ignore the formatters for
+         * the segments we are not processing.
+         */
+        const auto j(lcs.find(arch));
+        if (j == lcs.end()) {
+            BOOST_LOG_SEV(lg, debug) << "Ignoring formatter: " << arch;
+            continue;
+        }
+        const auto& lc(j->second);
+
+        /*
+         * Global configuration must always be present for all
+         * archetypes.
+         */
+        const auto i(gcs.find(arch));
+        if (i == gcs.end()) {
+            BOOST_LOG_SEV(lg, error) << global_configuration_not_found << arch;
+            BOOST_THROW_EXCEPTION(
+                transformation_error(global_configuration_not_found + arch));
+        }
+        const auto gc(i->second);
+
+        /*
+         * If the overwrite flag is set locally at the archetype or
+         * facet level, then that takes priority. If not, first check
+         * to see if its set globally at the archetype level; if so,
+         * it takes priority. Finally, if nothing else is set, use the
+         * global facet default.
+         *
+         * The rationale here is as follows: users can set facets to
+         * overwrite locally on a model element (either directly of
+         * via profiles); for example, for an handcrafted class, we
+         * want to set overwrite to false at the element level. This
+         * is normally done via a profile, but can be conceivable be
+         * done directly for less common configurations - for example
+         * adding manual support for IO for a handcrafted type. The
+         * global archetype overwrite flag is a bit less useful - we
+         * haven't got a use case for it just yet but it is added for
+         * (foolish) consistency. Finally, the global facet level
+         * overwrite flag is useful for the general case of code
+         * generated code. Having said that, it does not make a lot of
+         * sense to set overwrite globally to false.
+         *
+         * Note that the overwrite flag is only relevant if enabled is
+         * true. It is not used otherwise. We set it up before
+         * enablement just so we don't have to worry about handling
+         * the ""continue"" statements.
+         */
+        auto& art_props(pair.second);
+        if (lc.archetype_overwrite())
+            art_props.overwrite(*lc.archetype_overwrite());
+        else if (lc.facet_overwrite())
+            art_props.overwrite(*lc.facet_overwrite());
+        else if (gc.archetype_overwrite())
+            art_props.overwrite(*gc.archetype_overwrite());
+        else
+            art_props.overwrite(gc.facet_overwrite());
+
+        /*
+         * If either the entire kernel or facet have been disabled
+         * globally, the formatter will be disabled too.
+         */
+        if (!gc.kernel_enabled() || !gc.facet_enabled()) {
+            art_props.enabled(false);
+            continue;
+        }
+
+        /*
+         * Check to see if the formatter enablement field has been set
+         * locally. If so, it takes precedence over the facet
+         * configuration.
+         */
+        if (lc.archetype_enabled()) {
+            art_props.enabled(*lc.archetype_enabled());
+            continue;
+        }
+
+        /*
+         * Check to see if the facet enablement field has been set
+         * locally. If so, it takes precedence over global
+         * configuration.
+         */
+        if (lc.facet_enabled()) {
+            art_props.enabled(*lc.facet_enabled());
+            continue;
+        }
+
+        /*
+         * If nothing else has been set, use the global enablement
+         * flag for the formatter.
+         */
+        art_props.enabled(gc.archetype_enabled());
+        BOOST_LOG_SEV(lg, debug) << "Enablement for: " << arch
+                                 << " value: " << art_props.enabled();
+    }
+
+    BOOST_LOG_SEV(lg, debug) << "Finished computed enablement.";
+}
+
+void enablement_transform::
+expand(const context& ctx, meta_model::intermediate_model& im) {
+    const auto& atrp(ctx.type_repository());
+    const auto& ra(im.root_module().annotation());
+    const auto& als(ctx.archetype_locations());
+
+    BOOST_LOG_SEV(lg, debug) << "Started expanding enablement.";
+
+    /*
+     * Obtain the types at the global level. These are types that only
+     * apply to the root object, as some of these should not exist
+     * anywhere else.
+     */
+    const auto gtg(make_global_type_group(atrp, als));
+
+    /*
+     * Read the values for the global type from the root annotations,
+     * and update the facet configurations with it.
+     */
+    const auto gcs(obtain_global_configurations(gtg, ra));
+    update_facet_enablement(als, gcs, im);
+
+    /*
+     * Create the fields for the local types. These are generated
+     * against all registered formatters.
+     */
+    const auto ltg(make_local_type_group(atrp, als));
+
+    /*
+     * Bucket the local types by element - i.e., we only care about
+     * those formatters which are valid for a particular element.
+     */
+    // const auto ltgti(bucket_local_type_group_by_type_index(ltg, frp));
+
+    for (auto& pair : fm.formattables()) {
+        const auto id(pair.first);
+        BOOST_LOG_SEV(lg, debug) << "Procesing element: " << id;
+
+        auto& formattable(pair.second);
+        for (const auto& segment : formattable.all_segments()) {
+            const auto& e(*segment);
+
+            /*
+             * On some very special cases we may disable an element
+             * based on its state. If so, there is nothing to do.
+             */
+            if (is_element_disabled(e))
+                continue;
+
+            const auto ti(std::type_index(typeid(e)));
+            BOOST_LOG_SEV(lg, debug) << "Type index: " << ti.name();
+
+            /*
+             * Not all elements have formatters; for example, concepts
+             * don't have any at present. If so, skip the element.
+             */
+            // const auto i(ltgti.find(ti));
+            // if (i == ltgti.end()) {
+            //     BOOST_LOG_SEV(lg, debug) << "Element has no formatters, "
+            //                              << " so nothing enable.";
+            //     continue;
+            // }
+
+            /*
+             * Now, for each element segment, find the corresponding
+             * local types and use those to obtain the local
+             * configuration.
+             */
+            const auto& t(i->second);
+            auto lcs(obtain_local_configurations(t, e.annotation()));
+
+            /*
+             * Once we got both the global and the local configuration, we
+             * can then compute the enablement values for this
+             * formattable, across all the supported formatters.
+             */
+            compute_enablement(gcs, lcs, formattable);
+        }
+    }
+
+    BOOST_LOG_SEV(lg, debug) << "Finished expanding enablement.";
 }
 
 } } }
