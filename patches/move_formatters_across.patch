diff --git a/dogen.ede b/dogen.ede
index 54ffeb4..331c9b1 100644
--- a/dogen.ede
+++ b/dogen.ede
@@ -45,6 +45,7 @@
    "/projects/stereotypes/include"
    "/projects/database/include"
    "/projects/cpp/include"
+   "/projects/cpp_formatters/include"
    "/projects/dia_to_sml/include"
    )
  :system-include-path
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_declaration.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_declaration.hpp
index e69de29..1de49e9 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_declaration.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_declaration.hpp
@@ -0,0 +1,83 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_CLASS_DECLARATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_CLASS_DECLARATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+#include "dogen/cpp/types/class_info.hpp"
+#include "dogen/cpp/types/property_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class class_declaration {
+public:
+    class_declaration() = delete;
+    class_declaration(const class_declaration&) = default;
+    class_declaration(class_declaration&&) = default;
+    class_declaration& operator=(const class_declaration&) = default;
+
+public:
+    class_declaration(std::ostream& stream,
+        const bool disable_serialization);
+    virtual ~class_declaration() noexcept {}
+
+private:
+    void non_object_getters_and_setters(const std::string class_name,
+        const cpp::property_info& pi);
+    void object_getters_and_setters(const std::string class_name,
+        const cpp::property_info& pi);
+
+protected:
+    void open_class(const cpp::class_info& ci);
+    void close_class();
+    void compiler_generated_constuctors(const cpp::class_info& ci);
+    void default_constructor(const cpp::class_info& ci);
+    void move_constructor(const cpp::class_info& ci);
+    void complete_constructor(const cpp::class_info& ci);
+    void destructor(const cpp::class_info& ci);
+    void friends(const cpp::class_info& ci);
+    void getters_and_setters(const cpp::class_info& ci);
+    void member_variables(const cpp::class_info& ci);
+    void equality(const cpp::class_info& ci);
+    void to_stream(const cpp::class_info& ci);
+    void swap_and_assignment(const cpp::class_info& ci);
+
+public:
+    virtual void format(const cpp::class_info& ci) = 0;
+
+protected:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+    const bool disable_serialization_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_declaration_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_declaration_fwd.hpp
index 3227a3d..96af6ee 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_declaration_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_declaration_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_CLASS_DECLARATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_CLASS_DECLARATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_CLASS_DECLARATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_CLASS_DECLARATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class class_declaration;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_implementation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_implementation.hpp
index e69de29..1d405e3 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_implementation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_implementation.hpp
@@ -0,0 +1,78 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_CLASS_IMPLEMENTATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_CLASS_IMPLEMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+types/#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+#include "dogen/cpp/types/class_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp/types/property_info.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class class_implementation {
+public:
+    class_implementation() = default;
+    class_implementation(const class_implementation&) = default;
+    ~class_implementation() = default;
+    class_implementation(class_implementation&&) = default;
+    class_implementation&
+    operator=(const class_implementation&) = default;
+
+public:
+    explicit class_implementation(std::ostream& stream);
+
+private:
+    void non_object_getters_and_setters(const std::string class_name,
+        const cpp::property_info& pi);
+    void object_getters_and_setters(const std::string class_name,
+        const cpp::property_info& pi);
+
+protected:
+    void default_constructor(const cpp::class_info& ci);
+    void move_constructor(const cpp::class_info& ci);
+    void complete_constructor(const cpp::class_info& ci);
+    void to_stream(const cpp::class_info& ci);
+    void swap(const cpp::class_info& ci);
+    void equals_method(const cpp::class_info& ci);
+    void equals_operator(const cpp::class_info& ci);
+    void assignment_operator(const cpp::class_info& ci);
+    void getters_and_setters(const cpp::class_info& ci);
+
+public:
+    virtual void format(const cpp::class_info& ci) = 0;
+
+protected:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_implementation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_implementation_fwd.hpp
index 00f3685..750d512 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_implementation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/class_implementation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_CLASS_IMPLEMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_CLASS_IMPLEMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_CLASS_IMPLEMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_CLASS_IMPLEMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class class_implementation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_declaration.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_declaration.hpp
index e69de29..d213c1d 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_declaration.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_declaration.hpp
@@ -0,0 +1,63 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_CLASS_DECLARATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_CLASS_DECLARATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include "dogen/cpp_formatters/types/class_declaration.hpp"
+#include "dogen/cpp/types/class_info.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class domain_class_declaration : public class_declaration {
+public:
+    domain_class_declaration() = delete;
+    domain_class_declaration(const domain_class_declaration&) = default;
+    domain_class_declaration(domain_class_declaration&&) = default;
+    domain_class_declaration&
+    operator=(const domain_class_declaration&) = default;
+
+public:
+    domain_class_declaration(std::ostream& stream,
+        const bool disable_complete_constructor, const bool disable_io_,
+        const bool serialization_enabled);
+    virtual ~domain_class_declaration() noexcept {}
+
+private:
+    void hand_crafted_constructors(const cpp::class_info& ci);
+    void visitor_method(const cpp::class_info& ci);
+
+public:
+    virtual void format(const cpp::class_info& ci) override;
+
+private:
+    const bool disable_complete_constructor_;
+    const bool disable_io_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_declaration_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_declaration_fwd.hpp
index 99e3edc..8060cfc 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_declaration_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_declaration_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_CLASS_DECLARATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_CLASS_DECLARATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_DOMAIN_CLASS_DECLARATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_DOMAIN_CLASS_DECLARATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class domain_class_declaration;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_implementation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_implementation.hpp
index e69de29..9e56745 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_implementation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_implementation.hpp
@@ -0,0 +1,61 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_CLASS_IMPLEMENTATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_CLASS_IMPLEMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include "dogen/cpp_formatters/types/class_implementation.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class domain_class_implementation : public class_implementation {
+public:
+    domain_class_implementation() = delete;
+    domain_class_implementation(
+        const domain_class_implementation&) = default;
+    domain_class_implementation(
+        domain_class_implementation&&) = default;
+    domain_class_implementation&
+    operator=(const domain_class_implementation&) = default;
+
+private:
+    void hand_crafted_constructors(const cpp::class_info& ci);
+
+public:
+    domain_class_implementation(std::ostream& stream,
+        bool disable_complete_constructor, bool disable_io);
+    virtual ~domain_class_implementation() noexcept {}
+
+public:
+    virtual void format(const cpp::class_info& ci) override;
+
+private:
+    const bool disable_complete_constructor_;
+    const bool disable_io_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_implementation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_implementation_fwd.hpp
index 579e1b2..4667497 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_implementation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_class_implementation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_CLASS_IMPLEMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_CLASS_IMPLEMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_DOMAIN_CLASS_IMPLEMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_DOMAIN_CLASS_IMPLEMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class domain_class_implementation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_header.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_header.hpp
index e69de29..e98fd02 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_header.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_header.hpp
@@ -0,0 +1,88 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_HEADER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_HEADER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/class_info.hpp"
+#include "dogen/cpp/types/exception_info.hpp"
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class domain_header : public file_formatter {
+public:
+    domain_header() = delete;
+    domain_header(const domain_header&) = default;
+    domain_header(domain_header&&) = default;
+    domain_header& operator=(const domain_header&) = default;
+
+public:
+    domain_header(std::ostream& stream, const bool disable_complete_constructor,
+        const bool use_integrated_io, const bool disable_io,
+        const bool serialization_enabled);
+
+    virtual ~domain_header() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream,
+        const bool disable_complete_constructor, const bool use_integrated_io,
+        const bool disable_io, const bool disable_serialization);
+
+private:
+    void inserter_operator(const cpp::class_info& ci);
+    void equality_operator(const cpp::class_info& ci);
+    void swap_method(const cpp::class_info& ci);
+    void class_declaration(const cpp::content_descriptor& cd,
+        const cpp::class_info& ci);
+    void format_main(const cpp::content_descriptor& cd,
+        const cpp::class_info& ci);
+
+private:
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+    void format_exception(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+    const bool disable_complete_constructor_;
+    const bool use_integrated_io_;
+    const bool disable_io_;
+    const bool disable_serialization_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_header_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_header_fwd.hpp
index d16331c..045f6cc 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_header_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_header_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_HEADER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_HEADER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_DOMAIN_HEADER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_DOMAIN_HEADER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class domain_header;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_implementation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_implementation.hpp
index e69de29..e9fd4e6 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_implementation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_implementation.hpp
@@ -0,0 +1,87 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_IMPLEMENTATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_IMPLEMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <unordered_set>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/nested_type_info.hpp"
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class domain_implementation : public file_formatter {
+public:
+    domain_implementation() = delete;
+    domain_implementation(const domain_implementation&) = default;
+    domain_implementation(domain_implementation&&) = default;
+    domain_implementation& operator=(const domain_implementation&) = default;
+
+public:
+    domain_implementation(std::ostream& stream,
+        bool disable_complete_constructor,
+        bool use_integrated_io, bool disable_io);
+
+    virtual ~domain_implementation() noexcept {}
+
+private:
+    void smart_pointer_helper(const cpp::nested_type_info& nti);
+    void recursive_helper_method_creator(const cpp::nested_type_info& nti,
+        std::unordered_set<std::string>& types_done);
+
+    void io_helper_methods(const cpp::class_info& ci);
+    void inserter_operator(const cpp::class_info& ci);
+    void class_implementation(const cpp::content_descriptor& cd,
+        const cpp::class_info& ci);
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream,
+        bool disable_complete_constructor, bool use_integrated_io,
+        bool disable_io);
+
+private:
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+    const bool disable_complete_constructor_;
+    const bool use_integrated_io_;
+    const bool disable_io_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_implementation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_implementation_fwd.hpp
index 713233b..7e29815 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_implementation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/domain_implementation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_IMPLEMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_DOMAIN_IMPLEMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_DOMAIN_IMPLEMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_DOMAIN_IMPLEMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class domain_implementation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/doxygen_comments.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/doxygen_comments.hpp
index e69de29..4853911 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/doxygen_comments.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/doxygen_comments.hpp
@@ -0,0 +1,58 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_DOXYGEN_COMMENTS_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_DOXYGEN_COMMENTS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include "dogen/cpp_formatters/types/indenter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class doxygen_comments {
+public:
+    doxygen_comments() = delete;
+    doxygen_comments(const doxygen_comments&) = default;
+    ~doxygen_comments() = default;
+    doxygen_comments(doxygen_comments&&) = default;
+    doxygen_comments& operator=(const doxygen_comments&) = default;
+
+public:
+    doxygen_comments(std::ostream& stream, indenter& indenter);
+
+public:
+    void format(const std::string& documentation);
+    void format_inline(const std::string& documentation);
+    void format_start_block(const std::string& documentation);
+    void format_end_block(const std::string& documentation);
+
+private:
+    std::ostream& stream_;
+    indenter& indenter_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/doxygen_comments_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/doxygen_comments_fwd.hpp
index 342f43e..35b5f3f 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/doxygen_comments_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/doxygen_comments_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_DOXYGEN_COMMENTS_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_DOXYGEN_COMMENTS_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_DOXYGEN_COMMENTS_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_DOXYGEN_COMMENTS_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class doxygen_comments;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/enum_declaration.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/enum_declaration.hpp
index e69de29..10f7f6a 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/enum_declaration.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/enum_declaration.hpp
@@ -0,0 +1,60 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_ENUM_DECLARATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_ENUM_DECLARATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+#include "dogen/cpp/types/enum_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class enum_declaration {
+public:
+    enum_declaration() = default;
+    ~enum_declaration() = default;
+    enum_declaration(const enum_declaration&) = default;
+    enum_declaration(enum_declaration&&) = default;
+    enum_declaration& operator=(
+        const enum_declaration&) = default;
+
+public:
+    enum_declaration(std::ostream& stream);
+
+public:
+    void format(const cpp::enum_info& ei);
+
+protected:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/enum_declaration_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/enum_declaration_fwd.hpp
index 5e6144b..98656ca 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/enum_declaration_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/enum_declaration_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_ENUM_DECLARATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_ENUM_DECLARATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_ENUM_DECLARATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_ENUM_DECLARATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class enum_declaration;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/exception_declaration.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/exception_declaration.hpp
index e69de29..970e4f4 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/exception_declaration.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/exception_declaration.hpp
@@ -0,0 +1,60 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_EXCEPTION_DECLARATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_EXCEPTION_DECLARATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+#include "dogen/cpp/types/exception_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class exception_declaration {
+public:
+    exception_declaration() = default;
+    ~exception_declaration() = default;
+    exception_declaration(const exception_declaration&) = default;
+    exception_declaration(exception_declaration&&) = default;
+    exception_declaration& operator=(
+        const exception_declaration&) = default;
+
+public:
+    exception_declaration(std::ostream& stream);
+
+public:
+    void format(const cpp::exception_info& ei);
+
+protected:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/exception_declaration_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/exception_declaration_fwd.hpp
index e00b629..a2250a4 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/exception_declaration_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/exception_declaration_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_EXCEPTION_DECLARATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_EXCEPTION_DECLARATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_EXCEPTION_DECLARATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_EXCEPTION_DECLARATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class exception_declaration;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/facet_includer.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/facet_includer.hpp
index e69de29..a57452a 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/facet_includer.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/facet_includer.hpp
@@ -0,0 +1,64 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_FACET_INCLUDER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_FACET_INCLUDER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <list>
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class facet_includer : public file_formatter {
+public:
+    facet_includer() = delete;
+    facet_includer(const facet_includer&) = default;
+    facet_includer(facet_includer&&) = default;
+    facet_includer& operator=(const facet_includer&) = default;
+
+public:
+    explicit facet_includer(std::ostream& stream);
+    virtual ~facet_includer() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/facet_includer_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/facet_includer_fwd.hpp
index d301902..295d800 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/facet_includer_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/facet_includer_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_FACET_INCLUDER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_FACET_INCLUDER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_FACET_INCLUDER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_FACET_INCLUDER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class facet_includer;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/factory.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/factory.hpp
index e69de29..9cae665 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/factory.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/factory.hpp
@@ -0,0 +1,71 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_FACTORY_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_FACTORY_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include "dogen/config/types/cpp_settings.hpp"
+#include "dogen/cpp/types/content_descriptor.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class factory {
+public:
+    factory() = delete;
+    factory(const factory&) = default;
+    ~factory() = default;
+    factory(factory&&) = default;
+    factory& operator=(const factory&) = default;
+
+public:
+    typedef file_formatter::shared_ptr result_type;
+
+public:
+    factory(const config::cpp_settings& settings);
+
+private:
+    result_type create_main_formatter(std::ostream& s,
+        const cpp::content_descriptor& cd) const;
+
+    result_type create_registrar_formatter(
+        std::ostream& s, const cpp::content_descriptor& cd) const;
+
+    result_type create_null_formatter(std::ostream& s) const;
+
+public:
+    result_type create(std::ostream& s,
+        const cpp::content_descriptor& cd) const;
+
+private:
+    const config::cpp_settings settings_;
+    const bool disable_io_;
+    const bool disable_serialization_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/factory_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/factory_fwd.hpp
index d033c52..4b9a445 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/factory_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/factory_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_FACTORY_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_FACTORY_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_FACTORY_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_FACTORY_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class factory;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/file_formatter.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/file_formatter.hpp
index e69de29..e600175 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/file_formatter.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/file_formatter.hpp
@@ -0,0 +1,53 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_FILE_FORMATTER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_FILE_FORMATTER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <memory>
+#include "dogen/cpp/types/file_info.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class file_formatter {
+public:
+    file_formatter(const file_formatter&) = default;
+    file_formatter(file_formatter&&) = default;
+    file_formatter& operator=(const file_formatter&) = default;
+
+protected:
+    file_formatter();
+    virtual ~file_formatter() noexcept {}
+
+public:
+    typedef std::shared_ptr<file_formatter> shared_ptr;
+
+public:
+    virtual void format(const cpp::file_info& fi) = 0;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/file_formatter_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/file_formatter_fwd.hpp
index 78a4e72..8856122 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/file_formatter_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/file_formatter_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_FILE_FORMATTER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_FILE_FORMATTER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_FILE_FORMATTER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_FILE_FORMATTER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class file_formatter;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/forward_declarations_header.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/forward_declarations_header.hpp
index e69de29..ccab2ed 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/forward_declarations_header.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/forward_declarations_header.hpp
@@ -0,0 +1,72 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_FORWARD_DECLARATIONS_HEADER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_FORWARD_DECLARATIONS_HEADER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/class_info.hpp"
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class forward_declarations_header : public file_formatter {
+public:
+    forward_declarations_header() = delete;
+    forward_declarations_header(const forward_declarations_header&) = default;
+    forward_declarations_header(forward_declarations_header&&) = default;
+    forward_declarations_header& operator=(const forward_declarations_header&) = default;
+
+public:
+    explicit forward_declarations_header(std::ostream& stream);
+    virtual ~forward_declarations_header() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+private:
+    void format_serialization_class(const cpp::class_info& ci);
+    void format_domain_class(const cpp::class_info& ci);
+
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+    void format_exception(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/forward_declarations_header_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/forward_declarations_header_fwd.hpp
index 6a55db2..5d0cca5 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/forward_declarations_header_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/forward_declarations_header_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_FORWARD_DECLARATIONS_HEADER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_FORWARD_DECLARATIONS_HEADER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_FORWARD_DECLARATIONS_HEADER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_FORWARD_DECLARATIONS_HEADER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class forward_declarations_header;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_header.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_header.hpp
index e69de29..74cd1e9 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_header.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_header.hpp
@@ -0,0 +1,72 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_GENERATOR_HEADER_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_GENERATOR_HEADER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/enum_info.hpp"
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class generator_header : public file_formatter {
+public:
+    generator_header() = delete;
+    generator_header(const generator_header&) = default;
+    generator_header(generator_header&&) = default;
+    generator_header& operator=(const generator_header&) = default;
+
+public:
+    explicit generator_header(std::ostream& stream);
+    virtual ~generator_header() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+private:
+    void generator_class(const cpp::class_info& ci);
+    void generator_class(const cpp::enum_info& ei);
+
+private:
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_header_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_header_fwd.hpp
index a893428..2bf9884 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_header_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_header_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_GENERATOR_HEADER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_GENERATOR_HEADER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_GENERATOR_HEADER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_GENERATOR_HEADER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class generator_header;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_implementation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_implementation.hpp
index e69de29..f3d8142 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_implementation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_implementation.hpp
@@ -0,0 +1,106 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPPFORMATTERS__TYPES_GENERATOR_IMPLEMENTATION_HPP
+#define DOGEN_CPPFORMATTERS__TYPES_GENERATOR_IMPLEMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <unordered_set>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp/types/nested_type_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class generator_implementation : public file_formatter {
+public:
+    generator_implementation() = delete;
+    generator_implementation(const generator_implementation&) = default;
+    generator_implementation(generator_implementation&&) = default;
+    generator_implementation&
+    operator=(const generator_implementation&) = default;
+
+public:
+    explicit generator_implementation(std::ostream& stream);
+    virtual ~generator_implementation() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+private:
+    void sequence_container_helper(
+        const cpp::nested_type_info& nti, unsigned int quantity);
+    void associative_container_helper(
+        const cpp::nested_type_info& nti, unsigned int quantity);
+    void smart_pointer_helper(const cpp::nested_type_info& nti);
+    void optional_helper(const cpp::nested_type_info& nti);
+    void pair_helper(const cpp::nested_type_info& nti);
+    void variant_helper(const cpp::nested_type_info& nti);
+    void filesystem_path_helper(const cpp::nested_type_info& nti);
+    void date_helper(const cpp::nested_type_info& nti);
+    void ptime_helper(const cpp::nested_type_info& nti);
+    void time_duration_helper(const cpp::nested_type_info& nti);
+
+    void composite_domain_type_helper(const std::string& identifiable_type_name,
+        const std::string& type_name, bool as_pointer);
+    void domain_type_helper(const std::string& identifiable_type_name,
+        const std::string& type_name, bool as_pointer);
+    void bool_helper();
+    void string_helper();
+    void char_like_helper(const std::string& identifiable_type_name,
+        const std::string& type_name);
+    void int_like_helper(const std::string& identifiable_type_name,
+        const std::string& type_name);
+    void recursive_helper_method_creator(const std::string& owner_name,
+        const cpp::nested_type_info& nti,
+        std::unordered_set<std::string>& types_done, bool as_pointer);
+    void create_helper_methods(const cpp::class_info& ci);
+
+private:
+    void populate_method(const cpp::class_info& ci);
+    void create_method(const cpp::class_info& ci);
+    void create_method_ptr(const cpp::class_info& ci);
+    void function_operator(const cpp::class_info& ci);
+    void default_constructor(const cpp::class_info& ci);
+
+private:
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_implementation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_implementation_fwd.hpp
index eb28558..d2863f3 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_implementation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/generator_implementation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_GENERATOR_IMPLEMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_GENERATOR_IMPLEMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_GENERATOR_IMPLEMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_GENERATOR_IMPLEMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class generator_implementation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_header.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_header.hpp
index e69de29..dc1a06d 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_header.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_header.hpp
@@ -0,0 +1,72 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_HASH_HEADER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_HASH_HEADER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class hash_header : public file_formatter {
+public:
+    hash_header() = delete;
+    hash_header(const hash_header&) = default;
+    hash_header(hash_header&&) = default;
+    hash_header& operator=(const hash_header&) = default;
+
+public:
+    explicit hash_header(std::ostream& stream);
+    virtual ~hash_header() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+private:
+    void operator_bracket_method(const cpp::class_info& ci);
+    void hash_helper_class(const cpp::class_info& ci);
+    void hash_class(const cpp::class_info& ci);
+
+private:
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_header_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_header_fwd.hpp
index 27dff61..04d2752 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_header_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_header_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_HASH_HEADER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_HASH_HEADER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_HASH_HEADER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_HASH_HEADER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class hash_header;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_implementation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_implementation.hpp
index e69de29..9031fa4 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_implementation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_implementation.hpp
@@ -0,0 +1,90 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_HASH_IMPLEMENTATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_HASH_IMPLEMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <unordered_set>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp/types/nested_type_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class hash_implementation : public file_formatter {
+public:
+    hash_implementation() = delete;
+    hash_implementation(const hash_implementation&) = default;
+    hash_implementation(hash_implementation&&) = default;
+    hash_implementation& operator=(const hash_implementation&) = default;
+
+public:
+    explicit hash_implementation(std::ostream& stream);
+    virtual ~hash_implementation() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+private:
+    bool is_hashable(const cpp::nested_type_info& nti);
+
+private:
+    void pair_helper(const cpp::nested_type_info& nti);
+    void optional_helper(const cpp::nested_type_info& nti);
+    void variant_helper(const cpp::nested_type_info& nti);
+    void sequence_container_helper(const cpp::nested_type_info& nti);
+    void associative_container_helper(const cpp::nested_type_info& nti);
+    void smart_pointer_helper(const cpp::nested_type_info& nti);
+    void ptime_helper(const cpp::nested_type_info& nti);
+    void time_duration_helper(const cpp::nested_type_info& nti);
+    void recursive_helper_method_creator(const cpp::nested_type_info& nti,
+        std::unordered_set<std::string>& types_done);
+    void create_helper_methods(const cpp::class_info& ci);
+
+private:
+    void combine_function(const cpp::class_info& ci);
+    void hasher_hash_method(const cpp::class_info& ci);
+
+private:
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_implementation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_implementation_fwd.hpp
index 6eb2068..7296bf6 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_implementation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/hash_implementation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_HASH_IMPLEMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_HASH_IMPLEMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_HASH_IMPLEMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_HASH_IMPLEMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class hash_implementation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/header_guards.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/header_guards.hpp
index e69de29..e5c6848 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/header_guards.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/header_guards.hpp
@@ -0,0 +1,55 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_HEADER_GUARDS_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_HEADER_GUARDS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+
+namespace dogen {
+namespace cpp_formatters {
+
+class header_guards {
+public:
+    header_guards() = delete;
+    header_guards(const header_guards&) = default;
+    ~header_guards() = default;
+    header_guards(header_guards&&) = default;
+    header_guards& operator=(const header_guards&) = default;
+
+public:
+    explicit header_guards(std::ostream& stream);
+
+public:
+    void format_start(const std::string& guard_name);
+    void format_end();
+
+private:
+    std::ostream& stream_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/header_guards_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/header_guards_fwd.hpp
index 7ee33ec..4d5246f 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/header_guards_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/header_guards_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_HEADER_GUARDS_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_HEADER_GUARDS_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_HEADER_GUARDS_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_HEADER_GUARDS_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class header_guards;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/include_cmakelists.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/include_cmakelists.hpp
index e69de29..a55ead8 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/include_cmakelists.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/include_cmakelists.hpp
@@ -0,0 +1,60 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_INCLUDE_CMAKELISTS_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_INCLUDE_CMAKELISTS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+#include "dogen/cpp/types/cmakelists_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class include_cmakelists {
+public:
+    include_cmakelists() = delete;
+    include_cmakelists(const include_cmakelists&) = default;
+    ~include_cmakelists() noexcept = default;
+    include_cmakelists(include_cmakelists&&) = default;
+    include_cmakelists& operator=(const include_cmakelists&) = default;
+
+public:
+    include_cmakelists(std::ostream& stream, const bool odb_enabled,
+        const std::string odb_folder);
+
+public:
+    void format(const cpp::cmakelists_info& ci);
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    const bool odb_enabled_;
+    const std::string odb_folder_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/include_cmakelists_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/include_cmakelists_fwd.hpp
index b4a6711..e016593 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/include_cmakelists_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/include_cmakelists_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_INCLUDE_CMAKELISTS_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_INCLUDE_CMAKELISTS_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_INCLUDE_CMAKELISTS_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_INCLUDE_CMAKELISTS_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class include_cmakelists;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/includes.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/includes.hpp
index e69de29..1375e7b 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/includes.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/includes.hpp
@@ -0,0 +1,64 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_INCLUDES_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_INCLUDES_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <list>
+#include <string>
+#include <iosfwd>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class includes {
+public:
+    includes() = delete;
+    includes(const includes&) = default;
+    ~includes() = default;
+    includes(includes&&) = default;
+    includes& operator=(const includes&) = default;
+
+public:
+    explicit includes(std::ostream& stream, const bool blank_line = true);
+
+private:
+    void format(std::list<std::string> v, bool is_system);
+
+public:
+    void format(const cpp::file_info& fi);
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+    const bool blank_line_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/includes_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/includes_fwd.hpp
index fa553d3..99cb942 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/includes_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/includes_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_INCLUDES_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_INCLUDES_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_INCLUDES_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_INCLUDES_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class includes;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/indenter.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/indenter.hpp
index e69de29..56ddca3 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/indenter.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/indenter.hpp
@@ -0,0 +1,92 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FOMATTERS_TYPES_INDENTER_HPP
+#define DOGEN_CPP_FOMATTERS_TYPES_INDENTER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+
+namespace dogen {
+namespace cpp_formatters {
+
+class indenter {
+public:
+    indenter(const indenter&) = default;
+    ~indenter() = default;
+    indenter(indenter&&) = default;
+    indenter& operator=(const indenter&) = default;
+
+public:
+    indenter() : indent_level_(0) {}
+
+public:
+    indenter& operator++() {
+        ++indent_level_;
+        return *this;
+    }
+
+    indenter& operator--() {
+        if (indent_level_ > 0)
+            --indent_level_;
+        return *this;
+    }
+
+    bool empty() const { return indent_level_ == 0; }
+    void to_stream(std::ostream& stream) const;
+
+private:
+    unsigned int indent_level_;
+};
+
+class positive_indenter_scope {
+public:
+    positive_indenter_scope(indenter& i) : indenter_(i) { ++indenter_; }
+    ~positive_indenter_scope() { --indenter_; }
+
+private:
+    indenter& indenter_;
+};
+
+class negative_indenter_scope {
+public:
+    negative_indenter_scope(indenter& i) :
+    indenter_(i), started_empty_(i.empty()) {
+        --indenter_;
+    }
+
+    ~negative_indenter_scope() {
+        if (!started_empty_)
+            ++indenter_;
+    }
+
+private:
+    indenter& indenter_;
+    const bool started_empty_;
+};
+
+std::ostream& operator<<(std::ostream& stream, indenter indenter);
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/indenter_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/indenter_fwd.hpp
index 6b4103b..7601c3f 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/indenter_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/indenter_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_INDENTER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_INDENTER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_INDENTER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_INDENTER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class indenter;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/inserter_implementation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/inserter_implementation.hpp
index e69de29..72b7dc2 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/inserter_implementation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/inserter_implementation.hpp
@@ -0,0 +1,78 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_INSERTER_IMPLEMENTATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_INSERTER_IMPLEMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+#include <unordered_set>
+#include "dogen/cpp/types/nested_type_info.hpp"
+#include "dogen/cpp/types/class_info.hpp"
+#include "dogen/cpp_formatters/types//indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class inserter_implementation {
+public:
+    inserter_implementation() = delete;
+    inserter_implementation(const inserter_implementation&) = default;
+    inserter_implementation(inserter_implementation&&) = default;
+    inserter_implementation& operator=(const inserter_implementation&) = default;
+
+public:
+    inserter_implementation(std::ostream& stream, indenter& indenter,
+        const bool is_inside_class);
+    virtual ~inserter_implementation() noexcept {}
+
+private:
+    bool is_insertable(const cpp::nested_type_info& nti);
+
+private:
+    void tidy_up_string_method();
+    void sequence_container_helper(const cpp::nested_type_info& nti);
+    void associative_container_helper(const cpp::nested_type_info& nti);
+    void smart_pointer_helper(const cpp::nested_type_info& nti);
+    void optional_helper(const cpp::nested_type_info& nti);
+    void pair_helper(const cpp::nested_type_info& nti);
+    void variant_helper(const cpp::nested_type_info& nti);
+    void recursive_helper_method_creator(const cpp::nested_type_info& nti,
+        std::unordered_set<std::string>& types_done);
+
+public:
+    void format_helper_methods(const cpp::class_info& ci);
+    void format_inserter_implementation(const cpp::class_info& ci);
+
+protected:
+    const bool is_inside_class_;
+    std::ostream& stream_;
+    indenter& indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/inserter_implementation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/inserter_implementation_fwd.hpp
index 9070387..cac609d 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/inserter_implementation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/inserter_implementation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_INSERTER_IMPLEMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_INSERTER_IMPLEMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_INSERTER_IMPLEMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_INSERTER_IMPLEMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class inserter_implementation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_header.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_header.hpp
index e69de29..0818eeb 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_header.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_header.hpp
@@ -0,0 +1,67 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_IO_HEADER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_IO_HEADER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class io_header : public file_formatter {
+public:
+    io_header() = delete;
+    io_header(const io_header&) = default;
+    io_header(io_header&&) = default;
+    io_header& operator=(const io_header&) = default;
+
+public:
+    explicit io_header(std::ostream& stream);
+    virtual ~io_header() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+private:
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_header_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_header_fwd.hpp
index e01e537..6f43112 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_header_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_header_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_IO_HEADER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_IO_HEADER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_IO_HEADER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_IO_HEADER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class io_header;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_implementation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_implementation.hpp
index e69de29..f173526 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_implementation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_implementation.hpp
@@ -0,0 +1,70 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_IO_IMPLEMENTATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_IO_IMPLEMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class io_implementation : public file_formatter {
+public:
+    io_implementation() = delete;
+    io_implementation(const io_implementation&) = default;
+    io_implementation(io_implementation&&) = default;
+    io_implementation& operator=(const io_implementation&) = default;
+
+public:
+    explicit io_implementation(std::ostream& stream);
+    virtual ~io_implementation() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+private:
+    void io_helper_methods(const cpp::class_info& ci);
+
+private:
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_implementation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_implementation_fwd.hpp
index 34fbd37..90a0d8b 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_implementation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/io_implementation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_IO_IMPLEMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_IO_IMPLEMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_IO_IMPLEMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_IO_IMPLEMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class io_implementation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_declaration.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_declaration.hpp
index e69de29..6272af8 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_declaration.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_declaration.hpp
@@ -0,0 +1,62 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_KEY_CLASS_DECLARATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_KEY_CLASS_DECLARATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include "dogen/cpp/types/class_info.hpp"
+#include "dogen/cpp_formatters/types/class_declaration.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class key_class_declaration : public class_declaration {
+public:
+    key_class_declaration() = delete;
+    key_class_declaration(const key_class_declaration&) = default;
+    key_class_declaration(key_class_declaration&&) = default;
+    key_class_declaration&
+    operator=(const key_class_declaration&) = default;
+
+public:
+    key_class_declaration(std::ostream& stream,
+        const bool disable_complete_constructor,
+        const bool disable_io, const bool disable_serialization);
+    virtual ~key_class_declaration() noexcept {}
+
+private:
+    void hand_crafted_constructors(const cpp::class_info& ci);
+
+public:
+    virtual void format(const cpp::class_info& ci) override;
+
+private:
+    const bool disable_complete_constructor_;
+    const bool disable_io_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_declaration_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_declaration_fwd.hpp
index c4aa132..20fdfb7 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_declaration_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_declaration_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_KEY_CLASS_DECLARATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_KEY_CLASS_DECLARATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_KEY_CLASS_DECLARATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_KEY_CLASS_DECLARATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class key_class_declaration;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_implementation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_implementation.hpp
index e69de29..837d945 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_implementation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_implementation.hpp
@@ -0,0 +1,60 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_KEY_CLASS_IMPLEMENTATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_KEY_CLASS_IMPLEMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include "dogen/cpp/types/class_info.hpp"
+#include "dogen/cpp_formatters/types/class_implementation.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class key_class_implementation : public class_implementation {
+public:
+    key_class_implementation() = delete;
+    key_class_implementation(const key_class_implementation&) = default;
+    key_class_implementation(key_class_implementation&&) = default;
+    key_class_implementation&
+    operator=(const key_class_implementation&) = default;
+
+public:
+    key_class_implementation(std::ostream& stream,
+        bool disable_complete_constructor, bool disable_io);
+    virtual ~key_class_implementation() noexcept {}
+
+private:
+    void hand_crafted_constructors(const cpp::class_info& ci);
+
+public:
+    virtual void format(const cpp::class_info& ci) override;
+
+private:
+    const bool disable_complete_constructor_;
+    const bool disable_io_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_implementation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_implementation_fwd.hpp
index eafd675..2a8801c 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_implementation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/key_class_implementation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_KEY_CLASS_IMPLEMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_KEY_CLASS_IMPLEMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_KEY_CLASS_IMPLEMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_KEY_CLASS_IMPLEMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class key_class_implementation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/licence.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/licence.hpp
index e69de29..82736e4 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/licence.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/licence.hpp
@@ -0,0 +1,53 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_LICENCE_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_LICENCE_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+
+namespace dogen {
+namespace cpp_formatters {
+
+class licence {
+public:
+    licence() = delete;
+    licence(const licence&) = default;
+    ~licence() = default;
+    licence(licence&&) = default;
+    licence& operator=(const licence&) = default;
+
+public:
+    explicit licence(std::ostream& stream);
+
+public:
+    void format();
+
+private:
+    std::ostream& stream_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/licence_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/licence_fwd.hpp
index bc4453a..b607756 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/licence_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/licence_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_LICENCE_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_LICENCE_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_LICENCE_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_LICENCE_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class licence;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_documentation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_documentation.hpp
index e69de29..e80ec31 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_documentation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_documentation.hpp
@@ -0,0 +1,66 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_NAMESPACE_DOCUMENTATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_NAMESPACE_DOCUMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class namespace_documentation : public file_formatter {
+public:
+    namespace_documentation() = delete;
+    namespace_documentation(const namespace_documentation&) = default;
+    namespace_documentation(namespace_documentation&&) = default;
+    namespace_documentation& operator=(const namespace_documentation&) = default;
+
+public:
+    explicit namespace_documentation(std::ostream& stream);
+    virtual ~namespace_documentation() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+private:
+    void format_namespace(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_documentation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_documentation_fwd.hpp
index b1a86f7..f898e58 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_documentation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_documentation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_NAMESPACE_DOCUMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_NAMESPACE_DOCUMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_NAMESPACE_DOCUMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_NAMESPACE_DOCUMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class namespace_documentation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_formatter.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_formatter.hpp
index e69de29..ff2f7ef 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_formatter.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_formatter.hpp
@@ -0,0 +1,55 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_NAMESPACE_FORMATTER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_NAMESPACE_FORMATTER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+
+namespace dogen {
+namespace cpp_formatters {
+
+class namespace_formatter {
+public:
+    namespace_formatter() = delete;
+    namespace_formatter(const namespace_formatter&) = default;
+    ~namespace_formatter() = default;
+    namespace_formatter(namespace_formatter&&) = default;
+    namespace_formatter& operator=(const namespace_formatter&) = default;
+
+public:
+    explicit namespace_formatter(std::ostream& stream);
+
+public:
+    void format_start(const std::string& name);
+    void format_end();
+
+private:
+    std::ostream& stream_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_formatter_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_formatter_fwd.hpp
index 380fce7..cfb07d8 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_formatter_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_formatter_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_NAMESPACE_FORMATTER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_NAMESPACE_FORMATTER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_NAMESPACE_FORMATTER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_NAMESPACE_FORMATTER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class namespace_formatter;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_helper.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_helper.hpp
index e69de29..7879a4e 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_helper.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_helper.hpp
@@ -0,0 +1,57 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_NAMEPSACE_HELPER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_NAMEPSACE_HELPER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+#include <list>
+#include "dogen/cpp_formatters/types/namespace_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class namespace_helper {
+public:
+    namespace_helper() = delete;
+    namespace_helper(const namespace_helper&) = default;
+    namespace_helper(namespace_helper&&) = default;
+    namespace_helper& operator=(const namespace_helper&) = default;
+
+public:
+    namespace_helper(std::ostream& stream,
+        const std::list<std::string>& namespaces);
+
+    ~namespace_helper();
+
+private:
+    std::ostream& stream_;
+    namespace_formatter namespace_formatter_;
+    std::list<std::string> namespaces_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_helper_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_helper_fwd.hpp
index f4d580e..3279b96 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_helper_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/namespace_helper_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_NAMESPACE_HELPER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_NAMESPACE_HELPER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_NAMESPACE_HELPER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_NAMESPACE_HELPER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class namespace_helper;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/null_formatter.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/null_formatter.hpp
index e69de29..90fb35e 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/null_formatter.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/null_formatter.hpp
@@ -0,0 +1,54 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_NULL_FORMATTER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_NULL_FORMATTER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class null_formatter : public file_formatter {
+public:
+    null_formatter() = default;
+    null_formatter(const null_formatter&) = default;
+    null_formatter(null_formatter&&) = default;
+    null_formatter& operator=(const null_formatter&) = default;
+
+public:
+    virtual ~null_formatter() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/null_formatter_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/null_formatter_fwd.hpp
index 227b37b..270323f 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/null_formatter_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/null_formatter_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_NULL_FORMATTER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_NULL_FORMATTER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_NULL_FORMATTER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_NULL_FORMATTER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class null_formatter;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_header.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_header.hpp
index e69de29..754c14a 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_header.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_header.hpp
@@ -0,0 +1,67 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_ODB_HEADER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_ODB_HEADER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class odb_header : public file_formatter {
+public:
+    odb_header() = delete;
+    odb_header(const odb_header&) = default;
+    odb_header(odb_header&&) = default;
+    odb_header& operator=(const odb_header&) = default;
+
+public:
+    explicit odb_header(std::ostream& stream);
+    virtual ~odb_header() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+private:
+    void format_enumeration(const cpp::file_info& fi);
+    void format_class(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_header_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_header_fwd.hpp
index dba7a31..7f7ff22 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_header_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_header_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_ODB_HEADER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_ODB_HEADER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_ODB_HEADER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_ODB_HEADER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class odb_header;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_options.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_options.hpp
index e69de29..cf479de 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_options.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_options.hpp
@@ -0,0 +1,57 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_ODB_OPTIONS_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_ODB_OPTIONS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+#include "dogen/cpp/types/odb_options_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class odb_options {
+public:
+    odb_options() = delete;
+    odb_options(const odb_options&) = default;
+    ~odb_options() noexcept = default;
+    odb_options(odb_options&&) = default;
+    odb_options& operator=(const odb_options&) = default;
+
+public:
+    explicit odb_options(std::ostream& stream);
+
+public:
+    void format(const cpp::odb_options_info& ooi);
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_options_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_options_fwd.hpp
index b4fc1f7..448a695 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_options_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/odb_options_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_ODB_OPTIONS_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_ODB_OPTIONS_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_ODB_OPTIONS_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_ODB_OPTIONS_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class odb_options;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/qname.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/qname.hpp
index e69de29..58675a0 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/qname.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/qname.hpp
@@ -0,0 +1,59 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_QNAME_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_QNAME_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+#include "dogen/cpp/types/class_info.hpp"
+#include "dogen/cpp/types/parent_info.hpp"
+#include "dogen/cpp/types/enum_info.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class qname {
+public:
+    qname() = delete;
+    qname(const qname&) = default;
+    ~qname() = default;
+    qname(qname&&) = default;
+    qname& operator=(const qname&) = default;
+
+public:
+    explicit qname(std::ostream& stream);
+
+public:
+    void format(const cpp::class_info& ci);
+    void format(const cpp::enum_info& ei);
+    void format(const cpp::parent_info& pi);
+
+private:
+    std::ostream& stream_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/qname_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/qname_fwd.hpp
index ce7bb88..bcff644 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/qname_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/qname_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_QNAME_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_QNAME_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_QNAME_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_QNAME_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class qname;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_header.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_header.hpp
index e69de29..0237426 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_header.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_header.hpp
@@ -0,0 +1,64 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_REGISTRAR_HEADER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_REGISTRAR_HEADER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <list>
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class registrar_header : public file_formatter {
+public:
+    registrar_header() = delete;
+    registrar_header(const registrar_header&) = default;
+    registrar_header(registrar_header&&) = default;
+    registrar_header& operator=(const registrar_header&) = default;
+
+public:
+    registrar_header(std::ostream& stream);
+    virtual ~registrar_header() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_header_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_header_fwd.hpp
index 5b45c35..7a2deb4 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_header_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_header_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_REGISTRAR_HEADER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_REGISTRAR_HEADER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_REGISTRAR_HEADER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_REGISTRAR_HEADER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class registrar_header;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_implementation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_implementation.hpp
index e69de29..49e9531 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_implementation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_implementation.hpp
@@ -0,0 +1,67 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_REGISTRAR_IMPLEMENTATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_REGISTRAR_IMPLEMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <list>
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class registrar_implementation : public file_formatter {
+public:
+    registrar_implementation() = delete;
+    registrar_implementation(const registrar_implementation&) = default;
+    registrar_implementation(registrar_implementation&&) = default;
+    registrar_implementation& operator=(const registrar_implementation&) = default;
+
+public:
+    registrar_implementation(std::ostream& stream,
+        const bool disable_xml_serialization);
+    virtual ~registrar_implementation() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream,
+        const bool disable_xml_serialization);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+    const bool disable_xml_serialization_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_implementation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_implementation_fwd.hpp
index f509cda..ea4024e 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_implementation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/registrar_implementation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_REGISTRAR_IMPLEMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_REGISTRAR_IMPLEMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_REGISTRAR_IMPLEMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_REGISTRAR_IMPLEMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class registrar_implementation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_header.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_header.hpp
index e69de29..623f100 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_header.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_header.hpp
@@ -0,0 +1,73 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_SERIALIZATION_HEADER_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_SERIALIZATION_HEADER_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class serialization_header : public file_formatter {
+public:
+    serialization_header() = delete;
+    serialization_header(const serialization_header&) = default;
+    serialization_header(serialization_header&&) = default;
+    serialization_header& operator=(const serialization_header&) = default;
+
+public:
+    explicit serialization_header(std::ostream& stream,
+        const bool disable_xml_serialization);
+    virtual ~serialization_header() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream,
+        const bool disable_xml_serialization);
+
+private:
+    void load_and_save_functions(const cpp::class_info& ci);
+
+private:
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+    const bool disable_xml_serialization_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_header_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_header_fwd.hpp
index 775b413..c3f693d 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_header_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_header_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_SERIALIZATION_HEADER_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_SERIALIZATION_HEADER_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_SERIALIZATION_HEADER_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_SERIALIZATION_HEADER_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class serialization_header;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_implementation.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_implementation.hpp
index e69de29..f53520b 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_implementation.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_implementation.hpp
@@ -0,0 +1,76 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_SERIALIZATION_IMPLEMENTATION_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_SERIALIZATION_IMPLEMENTATION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/file_info.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class serialization_implementation : public file_formatter {
+public:
+    serialization_implementation() = delete;
+    serialization_implementation(const serialization_implementation&) = default;
+    serialization_implementation(serialization_implementation&&) = default;
+    serialization_implementation&
+    operator=(const serialization_implementation&) = default;
+
+public:
+    serialization_implementation(std::ostream& stream,
+        const bool disable_xml_serialization);
+    virtual ~serialization_implementation() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream,
+        const bool disable_xml_serialization);
+
+private:
+    void save_function(const cpp::class_info& ci);
+    void load_function(const cpp::class_info& ci);
+    void template_instantiations(const cpp::class_info& ci);
+
+private:
+    void format_class(const cpp::file_info& fi);
+    void format_enumeration(const cpp::file_info& fi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+    const bool disable_xml_serialization_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_implementation_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_implementation_fwd.hpp
index 4c360b1..7587692 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_implementation_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/serialization_implementation_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_SERIALIZATION_IMPLEMENTATION_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_SERIALIZATION_IMPLEMENTATION_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_SERIALIZATION_IMPLEMENTATION_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_SERIALIZATION_IMPLEMENTATION_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class serialization_implementation;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/src_cmakelists.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/src_cmakelists.hpp
index e69de29..ee7167f 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/src_cmakelists.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/src_cmakelists.hpp
@@ -0,0 +1,56 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_SRC_CMAKELISTS_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_SRC_CMAKELISTS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include <string>
+#include <boost/filesystem/path.hpp>
+#include "dogen/cpp/types/cmakelists_info.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class src_cmakelists {
+public:
+    src_cmakelists() = delete;
+    src_cmakelists(const src_cmakelists&) = default;
+    ~src_cmakelists() noexcept = default;
+    src_cmakelists(src_cmakelists&&) = default;
+    src_cmakelists& operator=(const src_cmakelists&) = default;
+
+public:
+    explicit src_cmakelists(std::ostream& stream);
+
+public:
+    void format(const cpp::cmakelists_info& ci);
+
+private:
+    std::ostream& stream_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/src_cmakelists_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/src_cmakelists_fwd.hpp
index 99ace8a..a7f3e18 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/src_cmakelists_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/src_cmakelists_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_SRC_CMAKELISTS_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_SRC_CMAKELISTS_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_SRC_CMAKELISTS_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_SRC_CMAKELISTS_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class src_cmakelists;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/utility.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/utility.hpp
index e69de29..a23c494 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/utility.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/utility.hpp
@@ -0,0 +1,94 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_UTILITY_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_UTILITY_HPP
+
+#include <iosfwd>
+#include <string>
+#include "dogen/cpp_formatters/types/indenter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class utility {
+public:
+    utility() = delete;
+    utility(const utility&) = delete;
+    ~utility() = default;
+    utility(utility&&) = default;
+    utility& operator=(const utility&) = delete;
+
+public:
+    utility(std::ostream& stream, indenter& indenter) :
+        stream_(stream), indenter_(indenter) { }
+
+public:
+    /**
+     * @brief Inserts the desired c++ access specifier.
+     */
+    /**@{*/
+    void public_access_specifier();
+    void protected_access_specifier();
+    void private_access_specifier();
+    /**@}*/
+
+    void open_scope();
+    void close_scope();
+    void blank_line(unsigned int how_many = 1);
+    std::string as_member_variable(const std::string& property_name) const;
+    std::string as_getter(const std::string& property_name) const;
+
+    /**
+     * @brief Adds double quotes to original.
+     *
+     * Using single quotes to denote the string boundary (e.g. they
+     * are not actually on the string), an original of 'a' produces
+     * the output '"a"'.
+     */
+    std::string quote(const std::string& original) const;
+
+    /**
+     * @brief Adds escapped quotes to original.
+     *
+     * Using single quotes to denote the string boundary (e.g. they
+     * are not actually on the string), an original of 'a' produces
+     * the output '\"a\"'.
+     */
+    std::string quote_escaped(const std::string& original) const;
+
+    /**
+     * @brief Adds escapped quotes to original, with c++ streaming
+     * syntax.
+     *
+     * Using single quotes to denote the string boundary (e.g. they
+     * are not actually on the string), an original of 'a' produces
+     * the output '<< "\"" << a << "\"""'.
+     */
+    std::string quote_escaped_streamed(const std::string& original) const;
+
+private:
+    std::ostream& stream_;
+    indenter& indenter_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/utility_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/utility_fwd.hpp
index 34b85a7..877f1d2 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/utility_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/utility_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_UTILITY_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_UTILITY_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_UTILITY_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_UTILITY_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class utility;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/visitor.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/visitor.hpp
index e69de29..9e89685 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/visitor.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/visitor.hpp
@@ -0,0 +1,65 @@
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#ifndef DOGEN_CPP_FORMATTERS_TYPES_VISITOR_HPP
+#define DOGEN_CPP_FORMATTERS_TYPES_VISITOR_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#pragma once
+#endif
+
+#include <iosfwd>
+#include "dogen/cpp/types/visitor_info.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class visitor : public file_formatter {
+public:
+    visitor() = delete;
+    visitor(const visitor&) = default;
+    visitor(visitor&&) = default;
+    visitor& operator=(const visitor&) = default;
+
+public:
+    explicit visitor(std::ostream& stream);
+    virtual ~visitor() noexcept {}
+
+public:
+    static file_formatter::shared_ptr create(std::ostream& stream);
+
+private:
+    void format(const cpp::visitor_info& vi);
+
+public:
+    virtual void format(const cpp::file_info& fi) override;
+
+private:
+    std::ostream& stream_;
+    indenter indenter_;
+    utility utility_;
+};
+
+} }
+
+#endif
diff --git a/projects/cpp_formatters/include/dogen/cpp_formatters/types/visitor_fwd.hpp b/projects/cpp_formatters/include/dogen/cpp_formatters/types/visitor_fwd.hpp
index 5d8e88b..dff7248 100644
--- a/projects/cpp_formatters/include/dogen/cpp_formatters/types/visitor_fwd.hpp
+++ b/projects/cpp_formatters/include/dogen/cpp_formatters/types/visitor_fwd.hpp
@@ -18,18 +18,19 @@
  * MA 02110-1301, USA.
  *
  */
-#ifndef DOGEN_CPP_FORMATTERS_TYPES_VISITOR_FWD_HPP
-#define DOGEN_CPP_FORMATTERS_TYPES_VISITOR_FWD_HPP
+#ifndef DOGEN_CPP_TYPES_FORMATTERS_VISITOR_FWD_HPP
+#define DOGEN_CPP_TYPES_FORMATTERS_VISITOR_FWD_HPP
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 #pragma once
 #endif
 
 namespace dogen {
-namespace cpp_formatters {
+namespace cpp {
+namespace formatters {
 
 class visitor;
 
-} }
+} } }
 
 #endif
diff --git a/projects/cpp_formatters/src/types/class_declaration.cpp b/projects/cpp_formatters/src/types/class_declaration.cpp
index 3469d04..7fada82 100644
--- a/projects/cpp_formatters/src/types/class_declaration.cpp
+++ b/projects/cpp_formatters/src/types/class_declaration.cpp
@@ -1,2 +1,396 @@
-// dummy function to suppress ranlib warnings
-void class_declaration() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <iostream>
+#include <ostream>
+#include "dogen/cpp_formatters/types/doxygen_comments.hpp"
+#include "dogen/cpp_formatters/types/qname.hpp"
+#include "dogen/cpp_formatters/types/class_declaration.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+class_declaration::
+class_declaration(std::ostream& stream, const bool disable_serialization)
+    : stream_(stream), utility_(stream_, indenter_),
+      disable_serialization_(disable_serialization) { }
+
+void class_declaration::open_class(const cpp::class_info& ci) {
+    doxygen_comments dc(stream_, indenter_);
+    dc.format(ci.documentation());
+    stream_ << indenter_ << "class " << ci.name();
+
+    if (!ci.is_parent())
+        stream_ << " final";
+
+    const auto parents(ci.parents());
+    if (!parents.empty()) {
+        stream_ << " :";
+
+        qname qname(stream_);
+        if (parents.size() == 1) {
+            stream_ << " public ";
+            qname.format(parents.front());
+        } else {
+            bool is_first(true);
+            positive_indenter_scope s(indenter_);
+            for (const auto p : ci.parents()) {
+                stream_ << (is_first ? "" : ",") << std::endl << indenter_;
+                stream_ << " public " << p.name();
+                is_first = false;
+            }
+        }
+    }
+    stream_ << " {" << std::endl;
+}
+
+void class_declaration::close_class() {
+    stream_ << indenter_ << "};" << std::endl;
+    utility_.blank_line();
+}
+
+void class_declaration::default_constructor(const cpp::class_info& ci) {
+    if (!ci.requires_manual_default_constructor())
+        return;
+
+    const auto props(ci.properties());
+    utility_.public_access_specifier();
+    stream_ << indenter_ << ci.name() << "();" << std::endl;
+    utility_.blank_line();
+}
+
+void class_declaration::complete_constructor(const cpp::class_info& ci) {
+    const auto props(ci.all_properties());
+    if (props.empty())
+        return;
+
+    utility_.public_access_specifier();
+    if (props.size() == 1) {
+        const auto p(*props.begin());
+        stream_ << indenter_ << "explicit " << ci.name() << "(const "
+                << p.type().complete_name();
+
+        if (!p.type().is_primitive())
+            stream_ << "&";
+
+        stream_ << " " << p.name() << ");" << std::endl;
+        utility_.blank_line();
+        return;
+    }
+
+    stream_ << indenter_ << ci.name() << "(";
+    {
+        positive_indenter_scope s(indenter_);
+        bool is_first(true);
+        for (const auto p : props) {
+            stream_ << (is_first ? "" : ",") << std::endl;
+            stream_ << indenter_ << "const " << p.type().complete_name();
+
+            if (!p.type().is_primitive())
+                stream_ << "&";
+
+            stream_ << " " << p.name();
+            is_first = false;
+        }
+        stream_ << ");" << std::endl;
+    }
+    utility_.blank_line();
+}
+
+void class_declaration::move_constructor(const cpp::class_info& ci) {
+    if (!ci.requires_manual_move_constructor())
+        return;
+
+    const auto props(ci.all_properties());
+    if (props.empty())
+        return;
+
+    utility_.public_access_specifier();
+    const auto p(*props.begin());
+    stream_ << indenter_ << ci.name() << "(" << ci.name()
+            << "&& rhs);" << std::endl;
+    utility_.blank_line();
+}
+
+void class_declaration::destructor(const cpp::class_info& ci) {
+    /*
+     * according to MEC++, item 33, base classes should always be
+     * abstract. this avoids all sorts of tricky problems with
+     * assignment and swap.
+     *
+     * incidentally, this also fixes some strange clang errors:
+     * undefined reference to `vtable.
+     */
+    if (ci.is_parent()) {
+        stream_ << indenter_ << "virtual ~" << ci.name()
+                << "() noexcept = 0;" << std::endl;
+        utility_.blank_line();
+    } else if (ci.parents().size() != 0) {
+        stream_ << indenter_ << "virtual ~" << ci.name()
+                << "() noexcept { }" << std::endl;
+        utility_.blank_line();
+    }
+}
+
+void class_declaration::
+compiler_generated_constuctors(const cpp::class_info& ci) {
+    utility_.public_access_specifier();
+
+    if (!ci.requires_manual_default_constructor())
+        stream_ << indenter_ << ci.name() << "() = default;" << std::endl;
+
+    stream_ << indenter_ << ci.name() << "(const " << ci.name()
+            << "&) = default;" << std::endl;
+
+    if (!ci.requires_manual_move_constructor()) {
+        stream_ << indenter_ << ci.name() << "(" << ci.name()
+                << "&&) = default;"
+                << std::endl;
+    }
+
+    if (!ci.is_parent() && ci.parents().empty()) {
+        stream_ << indenter_ << "~" << ci.name() << "() = default;"
+                << std::endl;
+    }
+
+    if (ci.is_immutable()) {
+        stream_ << indenter_ << ci.name() << "& operator=(const " << ci.name()
+                << "&) = delete;" << std::endl;
+    } else if (ci.all_properties().empty()) {
+        stream_ << indenter_ << ci.name() << "& operator=(const " << ci.name()
+                << "&) = default;" << std::endl;
+    }
+    utility_.blank_line();
+}
+
+void class_declaration::friends(const cpp::class_info& ci) {
+    if (disable_serialization_)
+        return;
+
+    utility_.private_access_specifier();
+
+    stream_ << indenter_ << "template<typename Archive>" << std::endl
+            << indenter_ << "friend void boost::serialization::save(Archive& ar"
+            << ", const " << ci.name() << "& v, unsigned int version);"
+            << std::endl;
+    utility_.blank_line();
+
+    stream_ << indenter_ << "template<typename Archive>" << std::endl
+            << indenter_ << "friend void boost::serialization::load(Archive& ar"
+            << ", " << ci.name() << "& v, unsigned int version);" << std::endl;
+    utility_.blank_line();
+}
+
+void class_declaration::
+non_object_getters_and_setters(const std::string class_name,
+    const cpp::property_info& pi) {
+    doxygen_comments dc(stream_, indenter_);
+    dc.format(pi.documentation());
+    if (!pi.is_immutable())
+        dc.format_start_block(pi.documentation());
+
+    stream_ << indenter_ << pi.type().complete_name() << " " << pi.name()
+            << "() const;" << std::endl;
+
+    if (!pi.is_immutable()) {
+        stream_ << indenter_;
+        if (pi.is_fluent())
+            stream_ << class_name << "& ";
+        else
+            stream_ << "void ";
+
+        stream_ << pi.name() << "(const " << pi.type().complete_name();
+
+        if (!pi.type().is_primitive())
+            stream_ << "&";
+
+        stream_ << " v);" << std::endl;
+    }
+
+    if (!pi.is_immutable())
+        dc.format_end_block(pi.documentation());
+    utility_.blank_line();
+}
+
+void class_declaration::
+object_getters_and_setters(const std::string class_name,
+    const cpp::property_info& pi) {
+    doxygen_comments dc(stream_, indenter_);
+    dc.format(pi.documentation());
+    if (!pi.is_immutable())
+        dc.format_start_block(pi.documentation());
+
+    // const getter
+    stream_ << indenter_ << "const " << pi.type().complete_name()
+            << "& " << pi.name() << "() const;" << std::endl;
+
+    if (!pi.is_immutable()) {
+        // Popsicle immutability
+        stream_ << indenter_ << "" << pi.type().complete_name()
+                << "& " << pi.name() << "();" << std::endl;
+
+        // traditional setter
+        stream_ << indenter_;
+        if (pi.is_fluent())
+            stream_ << class_name << "& ";
+        else
+            stream_ << "void ";
+        stream_ << pi.name() << "(const " << pi.type().complete_name();
+
+        if (!pi.type().is_primitive())
+            stream_ << "&";
+
+        stream_ << " v);" << std::endl;
+
+        // move setter
+        stream_ << indenter_;
+        if (pi.is_fluent())
+            stream_ << class_name << "& ";
+        else
+            stream_ << "void ";
+        stream_ << pi.name() << "(const " << pi.type().complete_name();
+
+        if (!pi.type().is_primitive())
+            stream_ << "&&";
+
+        stream_ << " v);" << std::endl;
+    }
+
+    if (!pi.is_immutable())
+        dc.format_end_block(pi.documentation());
+    utility_.blank_line();
+}
+
+void class_declaration::getters_and_setters(const cpp::class_info& ci) {
+    if (ci.properties().empty())
+        return;
+
+    utility_.public_access_specifier();
+    for (const auto p : ci.properties()) {
+        if (p.type().is_primitive() || p.type().is_enumeration()) {
+            non_object_getters_and_setters(ci.name(), p);
+            continue;
+        }
+
+        object_getters_and_setters(ci.name(), p);
+    }
+}
+
+void class_declaration::member_variables(const cpp::class_info& ci) {
+    if (ci.properties().empty())
+        return;
+
+    utility_.private_access_specifier();
+    for (const auto p : ci.properties()) {
+        stream_ << indenter_ << p.type().complete_name() << " "
+                << utility_.as_member_variable(p.name()) << ";"
+                << std::endl;
+    }
+}
+
+void class_declaration::equality(const cpp::class_info& ci) {
+    // equality is only public in leaf classes - MEC++-33
+    if (ci.is_parent()) {
+        utility_.protected_access_specifier();
+        stream_ << indenter_ << "bool compare(const " << ci.name()
+                <<  "& rhs) const;" << std::endl;
+    } else {
+        utility_.public_access_specifier();
+        stream_ << indenter_ << "bool operator==(const " << ci.name()
+                <<  "& rhs) const;" << std::endl;
+        stream_ << indenter_ << "bool operator!=(const " << ci.name()
+                << "& rhs) const ";
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "return !this->operator==(rhs);"
+                    << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+
+    if (!ci.is_parent() && ci.parents().empty())
+        return;
+
+    utility_.public_access_specifier();
+    if (ci.is_parent() && ci.parents().empty()) {
+        stream_ << indenter_
+                << "virtual bool equals(const " << ci.name()
+                <<  "& other) const = 0;"
+                << std::endl;
+    } else if (ci.is_parent()) {
+        stream_ << indenter_
+                << "virtual bool equals(const "
+                << ci.original_parent_name_qualified()
+                <<  "& other) const = 0;"
+                << std::endl;
+    } else {
+        stream_ << indenter_
+                << "bool equals(const "
+                << ci.original_parent_name_qualified()
+                <<  "& other) const override;"
+                << std::endl;
+    }
+    utility_.blank_line();
+}
+
+void class_declaration::to_stream(const cpp::class_info& ci) {
+    if (!ci.is_parent() && ci.parents().empty())
+        return;
+
+    utility_.public_access_specifier();
+    if (ci.is_parent()) {
+        stream_ << indenter_
+                << "virtual void to_stream("
+                << "std::ostream& s) const;"
+                << std::endl;
+    } else {
+        stream_ << indenter_
+                << "void to_stream(std::ostream& s) "
+                << "const override;"
+                << std::endl;
+    }
+    utility_.blank_line();
+}
+
+void class_declaration::swap_and_assignment(const cpp::class_info& ci) {
+    if ((ci.all_properties().empty() && !ci.is_parent()) || ci.is_immutable())
+        return;
+
+    // swap is only public in leaf classes - MEC++-33
+    if (ci.is_parent())
+        utility_.protected_access_specifier();
+    else
+        utility_.public_access_specifier();
+
+    stream_ << indenter_ << "void swap(" << ci.name() << "& other) noexcept;"
+            << std::endl;
+
+    // assignment is only available in leaf classes - MEC++-33
+    if (!ci.is_parent()) {
+        stream_ << indenter_ << ci.name() << "& operator=(" << ci.name()
+                << " other);" << std::endl;
+    }
+
+    utility_.blank_line();
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/class_implementation.cpp b/projects/cpp_formatters/src/types/class_implementation.cpp
index dbe4a72..b9e0a7b 100644
--- a/projects/cpp_formatters/src/types/class_implementation.cpp
+++ b/projects/cpp_formatters/src/types/class_implementation.cpp
@@ -1,2 +1,469 @@
-// dummy function to suppress ranlib warnings
-void class_implementation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include "dogen/cpp_formatters/types/qname.hpp"
+#include "dogen/cpp_formatters/types/inserter_implementation.hpp"
+#include "dogen/cpp_formatters/types/class_implementation.hpp"
+
+namespace {
+
+// FIXME: until we add support to indenter.
+const std::string special_indent("       ");
+const std::string space(" ");
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+class_implementation::class_implementation(std::ostream& stream)
+    : stream_(stream), utility_(stream_, indenter_) { }
+
+void class_implementation::default_constructor(const cpp::class_info& ci) {
+    if (!ci.requires_manual_default_constructor())
+        return;
+
+    stream_ << indenter_ << ci.name() << "::"
+            << ci.name() << "()" << std::endl;
+    {
+        positive_indenter_scope s(indenter_);
+        bool is_first(true);
+        for (const auto p : ci.properties()) {
+            if (!p.type().is_primitive() && !p.type().is_enumeration())
+                continue;
+
+            if (is_first)
+                stream_ << indenter_ << ": ";
+            else
+                stream_ << "," << std::endl << indenter_ << "  ";
+
+            stream_ << utility_.as_member_variable(p.name()) << "("
+                    << "static_cast<" << p.type().complete_name() << ">(0))";
+            is_first = false;
+        }
+        stream_ << " { }" << std::endl;
+    }
+    utility_.blank_line();
+}
+
+void class_implementation::move_constructor(const cpp::class_info& ci) {
+    if (!ci.requires_manual_move_constructor())
+        return;
+
+    stream_ << indenter_ << ci.name() << "::" << ci.name()
+            << "(" << ci.name() << "&& rhs)" << std::endl;
+    {
+        positive_indenter_scope s(indenter_);
+        bool is_first(true);
+
+        for (const auto p : ci.parents()) {
+            if (is_first)
+                stream_ << indenter_ << ": ";
+            else
+                stream_ << "," << std::endl << indenter_ << "  ";
+
+            qname qname(stream_);
+            qname.format(p);
+            stream_ << "(" << std::endl;
+            {
+                positive_indenter_scope s(indenter_);
+                stream_ << indenter_ << "std::forward<";
+                qname.format(p);
+                stream_ << ">(rhs))";
+            }
+            is_first = false;
+        }
+
+        for (const auto p : ci.properties()) {
+            if (is_first)
+                stream_ << indenter_ << ": ";
+            else
+                stream_ << "," << std::endl << indenter_ << "  ";
+
+            stream_ << utility_.as_member_variable(p.name()) << "("
+                    << "std::move(rhs." << utility_.as_member_variable(p.name())
+                    << "))";
+            is_first = false;
+        }
+        stream_ << " { }" << std::endl;
+    }
+    utility_.blank_line();
+}
+
+void class_implementation::complete_constructor(const cpp::class_info& ci) {
+    const auto props(ci.all_properties());
+    if (props.empty())
+        return;
+
+    stream_ << indenter_ << ci.name() << "::" << ci.name() << "(";
+
+    if (props.size() == 1) {
+        const auto p(*props.begin());
+        stream_ << "const " << p.type().complete_name();
+
+        if (!p.type().is_primitive())
+            stream_ << "&";
+
+        stream_ << " " << p.name() << ")" << std::endl;
+    } else {
+        positive_indenter_scope s(indenter_);
+        bool is_first(true);
+        for (const auto p : props) {
+            stream_ << (is_first ? "" : ",") << std::endl;
+            stream_ << indenter_ << "const " << p.type().complete_name();
+
+            if (!p.type().is_primitive())
+                stream_ << "&";
+
+            stream_ << " " << p.name();
+            is_first = false;
+        }
+        stream_ << ")" << std::endl;
+    }
+
+    {
+        positive_indenter_scope s(indenter_);
+        bool is_first(true);
+        stream_ << indenter_ << ": ";
+
+        for (const auto p : ci.parents()) {
+            qname qname(stream_);
+            qname.format(p);
+
+            stream_ << "(";
+            for (const auto prop : p.properties()) {
+                if (!is_first)
+                    stream_ << "," << std::endl << indenter_ << "  ";
+
+                stream_ << prop.name();
+                is_first = false;
+            }
+            stream_ << ")";
+            is_first = false;
+        }
+
+        for (const auto p : ci.properties()) {
+            if (!is_first)
+                stream_ << "," << std::endl << indenter_ << "  ";
+
+            stream_ << utility_.as_member_variable(p.name()) << "("
+                    << p.name() << ")";
+            is_first = false;
+        }
+        stream_ << " { }" << std::endl;
+    }
+    utility_.blank_line();
+}
+
+void class_implementation::to_stream(const cpp::class_info& ci) {
+    if (!ci.is_parent() && ci.parents().empty())
+        return;
+
+    stream_ << "void " << ci.name()
+            << "::to_stream(std::ostream& s) const ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+
+        const bool inside_class(true);
+        inserter_implementation inserter(stream_, indenter_, inside_class);
+        inserter.format_inserter_implementation(ci);
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void class_implementation::swap(const cpp::class_info& ci) {
+    if ((ci.all_properties().empty() && !ci.is_parent()) || ci.is_immutable())
+        return;
+
+    const bool empty(ci.all_properties().empty() && ci.parents().empty());
+    stream_ << indenter_ << "void " << ci.name() << "::swap("
+            << ci.name() << "&" << (empty ? "" : " other")
+            <<") noexcept ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        const auto parents(ci.parents());
+        for (const auto p : parents)
+            stream_ << indenter_ << p.name() << "::swap(other);" << std::endl;
+
+        if (!parents.empty())
+            utility_.blank_line();
+
+        const auto props(ci.properties());
+        if (!props.empty()) {
+            stream_ << indenter_ << "using std::swap;" << std::endl;
+            for (const auto p : props) {
+                stream_ << indenter_ << "swap("
+                        << utility_.as_member_variable(p.name())
+                        << ", other."
+                        << utility_.as_member_variable(p.name())
+                        << ");" << std::endl;
+            }
+        }
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void class_implementation::equals_method(const cpp::class_info& ci) {
+    if (ci.is_parent() || ci.parents().empty())
+        return;
+
+    stream_ << indenter_ << "bool " << ci.name() << "::equals(const "
+            << ci.original_parent_name_qualified() << "& other) const ";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "const " << ci.name()
+                << "* const p(dynamic_cast<const " << ci.name()
+                << "* const>(&other));"
+                << std::endl;
+        stream_ << indenter_ << "if (!p) return false;"
+                << std::endl;
+        stream_ << indenter_ << "return *this == *p;"
+                << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void class_implementation::equals_operator(const cpp::class_info& ci) {
+    if (ci.is_parent()) {
+        stream_ << indenter_ << "bool " << ci.name() << "::compare(const "
+                << ci.name() <<  "& ";
+    } else {
+        stream_ << indenter_ << "bool " << ci.name() << "::operator==(const "
+                << ci.name() <<  "& ";
+    }
+
+    if (ci.all_properties().empty())
+        stream_ << "/*rhs*/";
+    else
+        stream_ << "rhs";
+
+    stream_ << ") const ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        if (ci.all_properties().empty())
+            stream_ << indenter_ << "return true";
+        else {
+            stream_ << indenter_ << "return ";
+            bool is_first(true);
+            {
+                positive_indenter_scope s(indenter_);
+                const auto parents(ci.parents());
+                for (const auto p : parents) {
+                    if (!is_first)
+                        stream_ << " &&" << std::endl << indenter_;
+                    {
+                        positive_indenter_scope s(indenter_);
+                        stream_ << p.name() << "::compare(rhs)";
+                    }
+                    is_first = false;
+                }
+
+                for (const auto p : ci.properties()) {
+                    if (!is_first)
+                        stream_ << " &&" << std::endl << indenter_;
+                    {
+                        positive_indenter_scope s(indenter_);
+                        stream_ << utility_.as_member_variable(p.name())
+                                << " == rhs."
+                                << utility_.as_member_variable(p.name());
+                    }
+                    is_first = false;
+                }
+            }
+        }
+        stream_ << ";" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void class_implementation::
+non_object_getters_and_setters(const std::string class_name,
+    const cpp::property_info& ci) {
+    stream_ << indenter_ << ci.type().complete_name() << " " << class_name
+            << "::" << ci.name() << "() const ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "return "
+                << utility_.as_member_variable(ci.name()) << ";"
+                << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+
+    if (!ci.is_immutable()) {
+        stream_ << indenter_;
+        if (ci.is_fluent())
+            stream_ << class_name << "& ";
+        else
+            stream_ << "void ";
+
+        stream_ << class_name << "::" << ci.name() << "(const "
+                << ci.type().complete_name();
+
+        if (!ci.type().is_primitive())
+            stream_ << "&";
+
+        stream_ << " v) ";
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << utility_.as_member_variable(ci.name())
+                    << " = v;" << std::endl;
+
+            if (ci.is_fluent())
+                stream_ << indenter_ << "return *this;" << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+}
+
+void class_implementation::
+object_getters_and_setters(const std::string class_name,
+    const cpp::property_info& ci) {
+    // const getter
+    stream_ << indenter_ << "const " << ci.type().complete_name()
+            << "& " << class_name << "::" << ci.name()
+            << "() const ";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "return "
+                << utility_.as_member_variable(ci.name()) << ";"
+                << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+
+    if (!ci.is_immutable()) {
+        // Popsicle immutability
+        stream_ << indenter_ << ci.type().complete_name()
+                << "& " << class_name << "::" << ci.name()
+                << "() ";
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "return "
+                    << utility_.as_member_variable(ci.name()) << ";"
+                    << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+
+        // traditional setter
+        stream_ << indenter_;
+        if (ci.is_fluent())
+            stream_ << class_name << "& ";
+        else
+            stream_ << "void ";
+        stream_ << class_name << "::" << ci.name() << "(const "
+                << ci.type().complete_name();
+
+        if (!ci.type().is_primitive())
+            stream_ << "&";
+
+        stream_ << " v) ";
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << utility_.as_member_variable(ci.name())
+                    << " = v;" << std::endl;
+            if (ci.is_fluent())
+                stream_ << indenter_ << "return *this;" << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+
+        // move setter
+        stream_ << indenter_;
+        if (ci.is_fluent())
+            stream_ << class_name << "& ";
+        else
+            stream_ << "void ";
+        stream_ << class_name << "::" << ci.name() << "(const "
+                << ci.type().complete_name();
+
+        if (!ci.type().is_primitive())
+            stream_ << "&&";
+
+        stream_ << " v) ";
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << utility_.as_member_variable(ci.name())
+                    << " = std::move(v);" << std::endl;
+            if (ci.is_fluent())
+                stream_ << indenter_ << "return *this;" << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+}
+
+void class_implementation::getters_and_setters(const cpp::class_info& ci) {
+    if (ci.properties().empty())
+        return;
+
+    for (const auto p : ci.properties()) {
+        if (p.type().is_primitive() || p.type().is_enumeration())
+            non_object_getters_and_setters(ci.name(), p);
+        else
+            object_getters_and_setters(ci.name(), p);
+    }
+}
+
+void class_implementation::
+assignment_operator(const cpp::class_info& ci) {
+    // assignment is only available in leaf classes - MEC++-33
+    if (ci.all_properties().empty() || ci.is_parent() || ci.is_immutable())
+        return;
+
+    stream_ << indenter_ << ci.name() << "& "
+            << ci.name() << "::operator=(" << ci.name()
+            << " other) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "using std::swap;" << std::endl;
+        stream_ << indenter_ << "swap(*this, other);"
+                << std::endl
+                << indenter_ << "return *this;"
+                << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/domain_class_declaration.cpp b/projects/cpp_formatters/src/types/domain_class_declaration.cpp
index 3761386..47b768c 100644
--- a/projects/cpp_formatters/src/types/domain_class_declaration.cpp
+++ b/projects/cpp_formatters/src/types/domain_class_declaration.cpp
@@ -1,2 +1,119 @@
-// dummy function to suppress ranlib warnings
-void domain_class_declaration() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include "dogen/cpp_formatters/types/domain_class_declaration.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+domain_class_declaration::
+domain_class_declaration(std::ostream& stream,
+    const bool disable_complete_constructor, const bool disable_io,
+    const bool serialization_enabled)
+    : class_declaration(stream, serialization_enabled),
+      disable_complete_constructor_(disable_complete_constructor),
+      disable_io_(disable_io) { }
+
+void domain_class_declaration::
+hand_crafted_constructors(const cpp::class_info& ci) {
+    default_constructor(ci);
+    destructor(ci);
+    move_constructor(ci);
+    if (!disable_complete_constructor_)
+        complete_constructor(ci);
+}
+
+void domain_class_declaration::visitor_method(const cpp::class_info& ci) {
+    if (ci.is_visitable()) {
+        utility_.public_access_specifier();
+        stream_ << indenter_ << "virtual void accept(const " << ci.name()
+                << "_visitor& v) const = 0;" << std::endl;
+        stream_ << indenter_ << "virtual void accept(" << ci.name()
+                << "_visitor& v) const = 0;" << std::endl;
+        stream_ << indenter_ << "virtual void accept(const " << ci.name()
+                << "_visitor& v) = 0;" << std::endl;
+        stream_ << indenter_ << "virtual void accept(" << ci.name()
+                << "_visitor& v) = 0;" << std::endl;
+        utility_.blank_line();
+    } else if (ci.is_original_parent_visitable() && !ci.is_parent()) {
+        utility_.public_access_specifier();
+        stream_ << indenter_ << "virtual void accept(const "
+                << ci.original_parent_name()
+                << "_visitor& v) const override {" << std::endl;
+
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "v.visit(*this);" << std::endl;
+        }
+        stream_ << indenter_ << "}" << std::endl;
+        utility_.blank_line();
+        stream_ << indenter_ << "virtual void accept("
+                << ci.original_parent_name()
+                << "_visitor& v) const override {" << std::endl;
+
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "v.visit(*this);" << std::endl;
+        }
+        stream_ << indenter_ << "}" << std::endl;
+        utility_.blank_line();
+        stream_ << indenter_ << "virtual void accept(const "
+                << ci.original_parent_name()
+                << "_visitor& v) override {" << std::endl;
+
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "v.visit(*this);" << std::endl;
+        }
+        stream_ << indenter_ << "}" << std::endl;
+        utility_.blank_line();
+        stream_ << indenter_ << "virtual void accept("
+                << ci.original_parent_name()
+                << "_visitor& v) override {" << std::endl;
+
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "v.visit(*this);" << std::endl;
+        }
+        stream_ << indenter_ << "}" << std::endl;
+        utility_.blank_line();
+    }
+}
+
+void domain_class_declaration::format(const cpp::class_info& ci) {
+    open_class(ci);
+    {
+        positive_indenter_scope s(indenter_);
+        compiler_generated_constuctors(ci);
+        hand_crafted_constructors(ci);
+        friends(ci);
+        visitor_method(ci);
+        if (!disable_io_)
+            to_stream(ci);
+        getters_and_setters(ci);
+        equality(ci);
+        swap_and_assignment(ci);
+        member_variables(ci);
+    }
+    close_class();
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/domain_class_implementation.cpp b/projects/cpp_formatters/src/types/domain_class_implementation.cpp
index d31711c..c8d35b3 100644
--- a/projects/cpp_formatters/src/types/domain_class_implementation.cpp
+++ b/projects/cpp_formatters/src/types/domain_class_implementation.cpp
@@ -1,2 +1,53 @@
-// dummy function to suppress ranlib warnings
-void domain_class_implementation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include "dogen/cpp_formatters/types/domain_class_implementation.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+domain_class_implementation::
+domain_class_implementation(std::ostream& stream,
+    bool disable_complete_constructor, bool disable_io) :
+    class_implementation(stream),
+    disable_complete_constructor_(disable_complete_constructor),
+    disable_io_(disable_io) { }
+
+void domain_class_implementation::
+hand_crafted_constructors(const cpp::class_info& ci) {
+    default_constructor(ci);
+    move_constructor(ci);
+    if (!disable_complete_constructor_)
+        complete_constructor(ci);
+}
+
+
+void domain_class_implementation::format(const cpp::class_info& ci) {
+    hand_crafted_constructors(ci);
+    if (!disable_io_)
+        to_stream(ci);
+    swap(ci);
+    equals_method(ci);
+    equals_operator(ci);
+    assignment_operator(ci);
+    getters_and_setters(ci);
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/domain_header.cpp b/projects/cpp_formatters/src/types/domain_header.cpp
index c5e0314..3755222 100644
--- a/projects/cpp_formatters/src/types/domain_header.cpp
+++ b/projects/cpp_formatters/src/types/domain_header.cpp
@@ -1,2 +1,255 @@
-// dummy function to suppress ranlib warnings
-void domain_header() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/utility/exception/invalid_enum_value.hpp"
+#include "dogen/cpp_formatters/types//formatting_error.hpp"
+#include "dogen/cpp_formatters/types/qname.hpp"
+#include "dogen/cpp_formatters/types/licence.hpp"
+#include "dogen/cpp_formatters/types/header_guards.hpp"
+#include "dogen/cpp_formatters/types/namespace_formatter.hpp"
+#include "dogen/cpp_formatters/types/domain_class_declaration.hpp"
+#include "dogen/cpp_formatters/types/key_class_declaration.hpp"
+#include "dogen/cpp_formatters/types/namespace_helper.hpp"
+#include "dogen/cpp_formatters/types/includes.hpp"
+#include "dogen/cpp_formatters/types/enum_declaration.hpp"
+#include "dogen/cpp_formatters/types/exception_declaration.hpp"
+#include "dogen/cpp_formatters/types/domain_header.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.domain_header"));
+
+const std::string boost_ns("boost");
+const std::string serialization_ns("serialization");
+const std::string invalid_aspect_type("Invalid value for aspect_types");
+const std::string invalid_category_type("Invalid value for category_types");
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+const std::string missing_exception_info("Exception info is empty");
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+domain_header::
+domain_header(std::ostream& stream, const bool disable_complete_constructor,
+    const bool use_integrated_io, const bool disable_io,
+    const bool disable_serialization) :
+    stream_(stream),
+    utility_(stream_, indenter_),
+    disable_complete_constructor_(disable_complete_constructor),
+    use_integrated_io_(use_integrated_io),
+    disable_io_(disable_io), disable_serialization_(disable_serialization) { }
+
+file_formatter::shared_ptr domain_header::
+create(std::ostream& stream, const bool disable_complete_constructor,
+    const bool use_integrated_io, const bool disable_io,
+    const bool disable_serialization) {
+    return file_formatter::shared_ptr(new domain_header(stream,
+            disable_complete_constructor, use_integrated_io, disable_io,
+            disable_serialization));
+}
+
+void domain_header::
+equality_operator(const cpp::class_info& ci) {
+    if (!ci.is_parent())
+        return;
+
+    stream_ << indenter_ << "inline bool operator==(const "
+            << ci.name() << "& lhs, const " << ci.name() << "& rhs) ";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "return lhs.equals(rhs);" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void domain_header::
+inserter_operator(const cpp::class_info& ci) {
+    if (!use_integrated_io_ || disable_io_)
+        return;
+
+    stream_ << indenter_ << "std::ostream& operator<<(std::ostream& s, "
+            << "const " << ci.name() << "& v);" << std::endl;
+    utility_.blank_line();
+}
+
+void domain_header::
+swap_method(const cpp::class_info& ci) {
+    // swap overload is only available in leaf classes - MEC++-33
+    if (ci.all_properties().empty() || ci.is_parent() || ci.is_immutable())
+        return;
+
+    namespace_helper ns(stream_, std::list<std::string> { "std" });
+    utility_.blank_line();
+
+    stream_ << indenter_ << "template<>" << std::endl
+            << indenter_ << "inline void swap(" << std::endl;
+
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_;
+        qname qname(stream_);
+        qname.format(ci);
+        stream_ << "& lhs," << std::endl;
+
+        stream_ << indenter_;
+        qname.format(ci);
+        stream_ << "& rhs) ";
+
+        utility_.open_scope();
+        stream_ << indenter_ << "lhs.swap(rhs);" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void domain_header::class_declaration(const cpp::content_descriptor& cd,
+    const cpp::class_info& ci) {
+    using dogen::utility::exception::invalid_enum_value;
+    using cpp::content_types;
+    const auto ct(cd.content_type());
+    if (ct == content_types::versioned_key ||
+        ct == content_types::unversioned_key) {
+        key_class_declaration
+            f(stream_, disable_complete_constructor_, disable_io_,
+                disable_serialization_);
+        f.format(ci);
+        return;
+    } else if (ct == content_types::value_object) {
+        domain_class_declaration
+            f(stream_, disable_complete_constructor_, disable_io_,
+                disable_serialization_);
+        f.format(ci);
+        return;
+    }
+
+    BOOST_LOG_SEV(lg, error) << invalid_category_type;
+    BOOST_THROW_EXCEPTION(invalid_enum_value(invalid_category_type));
+}
+
+void domain_header::
+format_main(const cpp::content_descriptor& cd, const cpp::class_info& ci) {
+
+    {
+        namespace_helper ns(stream_, ci.namespaces());
+        utility_.blank_line();
+        class_declaration(cd, ci);
+
+        if (ci.is_parent()) {
+            stream_ << indenter_ << "inline " << ci.name() << "::~"<< ci.name()
+                    << "() noexcept { }" << std::endl;
+            utility_.blank_line();
+        }
+
+        inserter_operator(ci);
+        equality_operator(ci);
+    }
+    utility_.blank_line(2);
+
+    swap_method(ci);
+    if (!ci.all_properties().empty())
+        utility_.blank_line(2);
+}
+
+void domain_header::format_class(const cpp::file_info& fi) {
+    boost::optional<cpp::class_info> o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+    const auto at(fi.descriptor().aspect_type());
+    const cpp::class_info& ci(*o);
+    if (at == cpp::aspect_types::main)
+        format_main(fi.descriptor(), ci);
+    else {
+        using dogen::utility::exception::invalid_enum_value;
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(invalid_enum_value(invalid_aspect_type));
+    }
+}
+
+void domain_header::format_enumeration(const cpp::file_info& fi) {
+    const auto o(fi.enum_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_enum_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_enum_info));
+    }
+    {
+        const auto ei(*o);
+        namespace_helper ns(stream_, ei.namespaces());
+        utility_.blank_line();
+        enum_declaration f(stream_);
+        f.format(ei);
+    }
+    utility_.blank_line(2);
+}
+
+void domain_header::format_exception(const cpp::file_info& fi) {
+    const auto o(fi.exception_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_enum_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_exception_info));
+    }
+    {
+        const auto ei(*o);
+        namespace_helper ns(stream_, ei.namespaces());
+        utility_.blank_line();
+        exception_declaration f(stream_);
+        f.format(ei);
+    }
+    utility_.blank_line(2);
+}
+
+void domain_header::format(const cpp::file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    header_guards guards(stream_);
+    guards.format_start(fi.header_guard());
+    utility_.blank_line();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    using cpp::content_types;
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+    else if (fi.descriptor().content_type() == content_types::exception)
+        format_exception(fi);
+
+    guards.format_end();
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/domain_implementation.cpp b/projects/cpp_formatters/src/types/domain_implementation.cpp
index b81052f..4f6e97f 100644
--- a/projects/cpp_formatters/src/types/domain_implementation.cpp
+++ b/projects/cpp_formatters/src/types/domain_implementation.cpp
@@ -1,2 +1,243 @@
-// dummy function to suppress ranlib warnings
-void domain_implementation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/utility/exception/invalid_enum_value.hpp"
+#include "dogen/cpp_formatters/types/formatting_error.hpp"
+#include "dogen/cpp_formatters/types/inserter_implementation.hpp"
+#include "dogen/cpp_formatters/types/licence.hpp"
+#include "dogen/cpp_formatters/types/header_guards.hpp"
+#include "dogen/cpp_formatters/types/namespace_formatter.hpp"
+#include "dogen/cpp_formatters/types/namespace_helper.hpp"
+#include "dogen/cpp_formatters/types/includes.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/utility.hpp"
+#include "dogen/cpp_formatters/types/key_class_implementation.hpp"
+#include "dogen/cpp_formatters/types/domain_class_implementation.hpp"
+#include "dogen/cpp_formatters/types/domain_implementation.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.domain_implementation"));
+
+const std::string inserter("<< ");
+const std::string space_inserter(" << ");
+const std::string open_bracket(" {");
+const std::string close_bracket(" }");
+const std::string colon(": ");
+const std::string semi_colon(";");
+const std::string space(" ");
+const std::string comma(",");
+
+const std::string missing_class_info("Class info is empty");
+const std::string enum_info_not_supported(
+    "Enumerations do not have an implementation");
+const std::string invalid_smart_pointer(
+    "Smart pointers have exactly one type argument");
+
+const std::string invalid_aspect_type("Invalid value for aspect_types");
+const std::string invalid_category_type("Invalid value for category_types");
+
+// FIXME: until we add support to indenter.
+const std::string special_indent("       ");
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+domain_implementation::
+domain_implementation(std::ostream& stream, bool disable_complete_constructor,
+    bool use_integrated_io, bool disable_io) :
+    stream_(stream),
+    utility_(stream_, indenter_),
+    disable_complete_constructor_(disable_complete_constructor),
+    use_integrated_io_(use_integrated_io),
+    disable_io_(disable_io) { }
+
+file_formatter::shared_ptr domain_implementation::
+create(std::ostream& stream, bool disable_complete_constructor,
+    bool use_integrated_io, bool disable_io) {
+    return file_formatter::shared_ptr(new domain_implementation(stream,
+            disable_complete_constructor, use_integrated_io, disable_io));
+}
+
+void domain_implementation::
+smart_pointer_helper(const cpp::nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 1) {
+        BOOST_LOG_SEV(lg, error) << invalid_smart_pointer;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_smart_pointer));
+    }
+    const auto container(nti);
+    {
+        namespace_helper ns_helper(stream_, container.namespaces());
+
+        utility_.blank_line();
+        stream_ << indenter_ << "inline bool operator=="
+                << "(const " << container.complete_name() << "& lhs,"
+                << std::endl
+                << indenter_ << "const "
+                << container.complete_name() << "& rhs) ";
+
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "return (!lhs && !rhs) ||"
+                    << "(lhs && rhs && (*lhs == *rhs));"
+                    << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void domain_implementation::
+recursive_helper_method_creator(const cpp::nested_type_info& nti,
+    std::unordered_set<std::string>& types_done) {
+    if (types_done.find(nti.complete_identifiable_name()) != types_done.end())
+        return;
+
+    const auto children(nti.children());
+    for (const auto c : children)
+        recursive_helper_method_creator(c, types_done);
+
+    if (nti.is_smart_pointer())
+        smart_pointer_helper(nti);
+
+    types_done.insert(nti.complete_identifiable_name());
+}
+
+void domain_implementation::io_helper_methods(const cpp::class_info& ci) {
+    const bool has_io(ci.is_parent() || !ci.parents().empty() ||
+        use_integrated_io_);
+
+    if (!has_io  || disable_io_)
+        return;
+
+    const bool inside_class(false);
+    inserter_implementation i(stream_, indenter_, inside_class);
+    i.format_helper_methods(ci);
+}
+
+void domain_implementation::
+inserter_operator(const cpp::class_info& ci) {
+    if (!use_integrated_io_ || disable_io_)
+        return;
+
+    const bool no_arg(!ci.is_parent() && ci.parents().empty() &&
+        ci.properties().empty());
+    stream_ << indenter_ << "std::ostream& operator<<(std::ostream& s"
+            << ", const " << ci.name() << "&" << (no_arg ? ") " : "v) ");
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+
+        if (ci.is_parent() || !ci.parents().empty()) {
+            stream_ << indenter_ << "v.to_stream(s);" << std::endl
+                    << indenter_ << "return(s);" << std::endl;
+        } else {
+            const bool inside_class(false);
+            inserter_implementation i(stream_, indenter_, inside_class);
+            i.format_inserter_implementation(ci);
+        }
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void domain_implementation::
+class_implementation(const cpp::content_descriptor& cd,
+    const cpp::class_info& ci) {
+
+    using utility::exception::invalid_enum_value;
+    using cpp::aspect_types;
+    if (cd.aspect_type() == aspect_types::main) {
+        const auto ct(cd.content_type());
+        if (ct == content_types::versioned_key ||
+            ct == content_types::unversioned_key) {
+            key_class_implementation
+                f(stream_, disable_complete_constructor_, disable_io_);
+            f.format(ci);
+            return;
+        } else if (ct == content_types::value_object) {
+            domain_class_implementation
+                f(stream_, disable_complete_constructor_, disable_io_);
+            f.format(ci);
+            return;
+        }
+        BOOST_LOG_SEV(lg, error) << invalid_category_type;
+        BOOST_THROW_EXCEPTION(invalid_enum_value(invalid_category_type));
+    }
+    BOOST_LOG_SEV(lg, error) << invalid_aspect_type;
+    BOOST_THROW_EXCEPTION(invalid_enum_value(invalid_aspect_type));
+}
+
+void domain_implementation::format_class(const cpp::file_info& fi) {
+    auto o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+    const cpp::class_info& ci(*o);
+    io_helper_methods(ci);
+
+    std::unordered_set<std::string> types_done;
+    const auto props(ci.properties());
+    for (const auto p : props)
+        recursive_helper_method_creator(p.type(), types_done);
+
+    namespace_helper ns_helper(stream_, ci.namespaces());
+    utility_.blank_line();
+    class_implementation(fi.descriptor(), ci);
+    inserter_operator(ci);
+}
+
+void domain_implementation::format_enumeration(const cpp::file_info&) {
+    BOOST_LOG_SEV(lg, error) << missing_class_info;
+    BOOST_THROW_EXCEPTION(
+        formatting_error(enum_info_not_supported));
+}
+
+void domain_implementation::format(const cpp::file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    using cpp::content_types;
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+}
+*/
+} }
diff --git a/projects/cpp_formatters/src/types/doxygen_comments.cpp b/projects/cpp_formatters/src/types/doxygen_comments.cpp
index 34c2729..a8f2784 100644
--- a/projects/cpp_formatters/src/types/doxygen_comments.cpp
+++ b/projects/cpp_formatters/src/types/doxygen_comments.cpp
@@ -1,2 +1,86 @@
-// dummy function to suppress ranlib warnings
-void doxygen_comments() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <string>
+#include <sstream>
+#include <ostream>
+#include <boost/algorithm/string.hpp>
+#include "dogen/cpp_formatters/types/doxygen_comments.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+doxygen_comments::
+doxygen_comments(std::ostream& stream, indenter& indenter)
+    : stream_(stream), indenter_(indenter) { }
+
+void doxygen_comments::format(const std::string& documentation) {
+    std::string trimmed(boost::algorithm::trim_copy(documentation));
+    if (trimmed.empty())
+        return;
+
+    std::stringstream s(documentation);
+    std::string line;
+    bool is_first(true);
+    stream_ << indenter_ << "/**" << std::endl;
+    while(std::getline(s, line)) {
+        boost::algorithm::trim_right(line);
+        if (is_first)
+            stream_ << indenter_ << " * @brief " << line << std::endl;
+        else {
+            trimmed = boost::algorithm::trim_copy(line);
+            if (trimmed.empty())
+                stream_ << indenter_ << " *" << std::endl;
+            else
+                stream_ << indenter_ << " * " << line << std::endl;
+        }
+        is_first = false;
+    }
+    stream_ << indenter_ << " */" << std::endl;
+}
+
+void doxygen_comments::format_inline(const std::string& documentation) {
+    std::string trimmed(boost::algorithm::trim_copy(documentation));
+    if (trimmed.empty())
+        return;
+
+    const auto s(boost::algorithm::trim_right_copy(documentation));
+    stream_ << " ///< " << s;
+}
+
+void doxygen_comments::
+format_start_block(const std::string& documentation) {
+    std::string trimmed(boost::algorithm::trim_copy(documentation));
+    if (trimmed.empty())
+        return;
+
+    stream_ << indenter_ << "/**@{*/" << std::endl;
+}
+
+void doxygen_comments::
+format_end_block(const std::string& documentation) {
+    std::string trimmed(boost::algorithm::trim_copy(documentation));
+    if (trimmed.empty())
+        return;
+
+    stream_ << indenter_ << "/**@}*/" << std::endl;
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/enum_declaration.cpp b/projects/cpp_formatters/src/types/enum_declaration.cpp
index 9e65236..a4fd948 100644
--- a/projects/cpp_formatters/src/types/enum_declaration.cpp
+++ b/projects/cpp_formatters/src/types/enum_declaration.cpp
@@ -1,2 +1,71 @@
-// dummy function to suppress ranlib warnings
-void enum_declaration() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <sstream>
+#include "dogen/cpp_formatters/types/doxygen_comments.hpp"
+#include "dogen/cpp_formatters/types/enum_declaration.hpp"
+
+namespace {
+
+const std::string empty;
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+enum_declaration::
+enum_declaration(std::ostream& stream)
+    : stream_(stream), utility_(stream_, indenter_) { }
+
+void enum_declaration::format(const cpp::enum_info& ei) {
+    doxygen_comments dc1(stream_, indenter_);
+    dc1.format(ei.documentation());
+
+    stream_ << indenter_ << "enum class " << ei.name() << " : unsigned int ";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        bool is_first(true);
+        const auto enumerators(ei.enumerators());
+        std::ostringstream assignment;
+        std::ostringstream comment;
+        for (auto i(enumerators.cbegin()); i != enumerators.cend(); ++i) {
+            if (!is_first) {
+                stream_ << assignment.str() << "," << comment.str()
+                        << std::endl;
+                assignment.str(empty);
+                comment.str(empty);
+            }
+
+            const auto e(*i);
+            assignment << indenter_ << e.name() << " = " << e.value();
+            doxygen_comments dc2(comment, indenter_);
+            dc2.format_inline(e.documentation());
+            is_first = false;
+        }
+        stream_ << assignment.str() << comment.str() << std::endl;
+    }
+    stream_ << indenter_ << "};" << std::endl;
+    utility_.blank_line();
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/exception_declaration.cpp b/projects/cpp_formatters/src/types/exception_declaration.cpp
index a2d3bed..393b97e 100644
--- a/projects/cpp_formatters/src/types/exception_declaration.cpp
+++ b/projects/cpp_formatters/src/types/exception_declaration.cpp
@@ -1,2 +1,77 @@
-// dummy function to suppress ranlib warnings
-void exception_declaration() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <sstream>
+#include "dogen/cpp_formatters/types/doxygen_comments.hpp"
+#include "dogen/cpp_formatters/types/doxygen_comments.hpp"
+#include "dogen/cpp_formatters/types/exception_declaration.hpp"
+
+namespace {
+
+const std::string empty;
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+exception_declaration::
+exception_declaration(std::ostream& stream)
+    : stream_(stream), utility_(stream_, indenter_) { }
+
+void exception_declaration::format(const cpp::exception_info& ei) {
+    doxygen_comments dc1(stream_, indenter_);
+    dc1.format(ei.documentation());
+
+    stream_ << indenter_ << "class " << ei.name()
+            << " : public virtual std::exception, "
+            << "public virtual boost::exception ";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        utility_.public_access_specifier();
+        stream_ << indenter_ << ei.name() << "() = default;"
+                << std::endl;
+        stream_ << indenter_ << "~" << ei.name() << "() noexcept = default;"
+                << std::endl;
+        utility_.blank_line();
+
+        utility_.public_access_specifier();
+        stream_ << indenter_ << ei.name()
+                << "(const std::string& message) : message_(message) { }"
+                << std::endl;
+        utility_.blank_line();
+
+        utility_.public_access_specifier();
+        stream_ << indenter_ << "const char* what() const noexcept {"
+                << " return(message_.c_str()); }"
+                << std::endl;
+        utility_.blank_line();
+
+        utility_.private_access_specifier();
+        stream_ << indenter_ << "const std::string message_;"
+                << std::endl;
+    }
+    stream_ << indenter_ << "};" << std::endl;
+    utility_.blank_line();
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/facet_includer.cpp b/projects/cpp_formatters/src/types/facet_includer.cpp
index 5175d64..4b07616 100644
--- a/projects/cpp_formatters/src/types/facet_includer.cpp
+++ b/projects/cpp_formatters/src/types/facet_includer.cpp
@@ -1,2 +1,60 @@
-// dummy function to suppress ranlib warnings
-void facet_includer() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <boost/throw_exception.hpp>
+#include "dogen/cpp_formatters/types/formatting_error.hpp"
+#include "dogen/cpp_formatters/types/licence.hpp"
+#include "dogen/cpp_formatters/types/includes.hpp"
+#include "dogen/cpp_formatters/types/facet_includer.hpp"
+
+namespace {
+
+const bool is_system(true);
+const bool is_user(false);
+
+const std::string unexpected_class_info(
+    "File view model should not contain a class view model");
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+facet_includer::facet_includer(std::ostream& stream) :
+    stream_(stream), utility_(stream_, indenter_) { }
+
+file_formatter::shared_ptr facet_includer::
+create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new facet_includer(stream));
+}
+
+void facet_includer::format(const cpp::file_info& fi) {
+    if (fi.class_info())
+        BOOST_THROW_EXCEPTION(formatting_error(unexpected_class_info));
+
+    licence licence(stream_);
+    licence.format();
+
+    const bool blank_line(false);
+    includes includes(stream_, blank_line);
+    includes.format(fi);
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/factory.cpp b/projects/cpp_formatters/src/types/factory.cpp
index b6bee4c..c43449a 100644
--- a/projects/cpp_formatters/src/types/factory.cpp
+++ b/projects/cpp_formatters/src/types/factory.cpp
@@ -1,2 +1,210 @@
-// dummy function to suppress ranlib warnings
-void factory() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <sstream>
+#include <boost/throw_exception.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/config/types/cpp_facet_types.hpp"
+#include "dogen/config/io/cpp_facet_types_io.hpp"
+#include "dogen/cpp/io/file_types_io.hpp"
+#include "dogen/cpp/io/content_types_io.hpp"
+#include "dogen/cpp/io/aspect_types_io.hpp"
+#include "dogen/cpp_formatters/types/production_failure.hpp"
+#include "dogen/cpp_formatters/types/facet_includer.hpp"
+#include "dogen/cpp_formatters/types/domain_header.hpp"
+#include "dogen/cpp_formatters/types/domain_implementation.hpp"
+#include "dogen/cpp_formatters/types/facet_includer.hpp"
+#include "dogen/cpp_formatters/types/hash_header.hpp"
+#include "dogen/cpp_formatters/types/hash_implementation.hpp"
+#include "dogen/cpp_formatters/types/io_header.hpp"
+#include "dogen/cpp_formatters/types/io_implementation.hpp"
+#include "dogen/cpp_formatters/types/generator_header.hpp"
+#include "dogen/cpp_formatters/types/generator_implementation.hpp"
+#include "dogen/cpp_formatters/types/serialization_header.hpp"
+#include "dogen/cpp_formatters/types/serialization_implementation.hpp"
+#include "dogen/cpp_formatters/types/registrar_header.hpp"
+#include "dogen/cpp_formatters/types/registrar_implementation.hpp"
+#include "dogen/cpp_formatters/types/forward_declarations_header.hpp"
+#include "dogen/cpp_formatters/types/null_formatter.hpp"
+#include "dogen/cpp_formatters/types/namespace_documentation.hpp"
+#include "dogen/cpp_formatters/types/odb_header.hpp"
+#include "dogen/cpp_formatters/types/visitor.hpp"
+#include "dogen/cpp_formatters/types/factory.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.factory"));
+const std::string production_failure_msg("Formatter factory not setup for: ");
+
+bool contains(const std::set<dogen::config::cpp_facet_types>& f,
+    dogen::config::cpp_facet_types ft) {
+    return f.find(ft) != f.end();
+}
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+factory::factory(const config::cpp_settings& settings)
+    : settings_(settings),
+      disable_io_(!contains(settings_.enabled_facets(),
+              config::cpp_facet_types::io)),
+      disable_serialization_(!contains(settings_.enabled_facets(),
+              config::cpp_facet_types::serialization)) { }
+
+factory::result_type factory::create_main_formatter(std::ostream& s,
+    const cpp::content_descriptor& cd) const {
+
+    using config::cpp_facet_types;
+    using cpp::file_types;
+    switch (cd.facet_type()) {
+    case cpp_facet_types::types:
+        if (cd.file_type() == file_types::header)
+            return domain_header::create(s,
+                settings_.disable_complete_constructor(),
+                settings_.use_integrated_io(),
+                disable_io_, disable_serialization_);
+        else
+            return domain_implementation::create(s,
+                settings_.disable_complete_constructor(),
+                settings_.use_integrated_io(),
+                disable_io_);
+        break;
+    case cpp_facet_types::io:
+        if (cd.file_type() == file_types::header)
+            return io_header::create(s);
+        else
+            return io_implementation::create(s);
+        break;
+    case cpp_facet_types::hash:
+        if (cd.file_type() == file_types::header)
+            return hash_header::create(s);
+        else
+            return hash_implementation::create(s);
+        break;
+    case cpp_facet_types::serialization:
+        if (cd.file_type() == file_types::header)
+            return serialization_header::create(s,
+                settings_.disable_xml_serialization());
+        else
+            return serialization_implementation::create(s,
+                settings_.disable_xml_serialization());
+        break;
+    case cpp_facet_types::test_data:
+        if (cd.file_type() == file_types::header)
+            return generator_header::create(s);
+        else
+            return generator_implementation::create(s);
+        break;
+    case cpp_facet_types::odb:
+        if (cd.file_type() == file_types::header)
+            return odb_header::create(s);
+
+    default: {
+        std::ostringstream s;
+        s << production_failure_msg << cd.facet_type()
+          << ", " << cd.file_type() ;
+        BOOST_THROW_EXCEPTION(production_failure(s.str()));
+    } }
+}
+
+factory::result_type factory::create_registrar_formatter(
+    std::ostream& s, const cpp::content_descriptor& cd) const {
+
+    using cpp::file_types;
+    switch (cd.file_type()) {
+    case file_types::header:
+        return registrar_header::create(s);
+        break;
+
+    case file_types::implementation:
+        return registrar_implementation::create(s,
+            settings_.disable_xml_serialization());
+        break;
+
+    default: {
+        std::ostringstream ss;
+        ss << production_failure_msg << cd.file_type();
+        BOOST_LOG_SEV(lg, error) << ss.str();
+        BOOST_THROW_EXCEPTION(production_failure(ss.str()));
+    } }
+}
+
+factory::result_type factory::create_null_formatter(std::ostream& s) const {
+    return null_formatter::create(s);
+}
+
+factory::result_type
+factory::create(std::ostream& s, const cpp::content_descriptor& cd) const {
+
+    using cpp::aspect_types;
+    using cpp::content_types;
+    switch (cd.aspect_type()) {
+    case aspect_types::main:
+        switch(cd.content_type()) {
+        case content_types::includer:
+            return facet_includer::create(s);
+            break;
+        case content_types::registrar:
+            return create_registrar_formatter(s, cd);
+            break;
+        case content_types::namespace_doc:
+            return namespace_documentation::create(s);
+            break;
+        case content_types::visitor:
+            return visitor::create(s);
+            break;
+        case content_types::exception:
+        case content_types::enumeration:
+        case content_types::value_object:
+        case content_types::unversioned_key:
+        case content_types::versioned_key:
+            return create_main_formatter(s, cd);
+            break;
+        case content_types::user_defined_service:
+            return create_null_formatter(s);
+            break;
+        default: {
+            std::ostringstream s;
+            s << production_failure_msg << cd.facet_type() << ", "
+              << cd.file_type() << ", " << cd.aspect_type() << ", "
+              << cd.content_type();
+            BOOST_LOG_SEV(lg, error) << s.str();
+            BOOST_THROW_EXCEPTION(production_failure(s.str()));
+        } };
+    case aspect_types::forward_decls:
+        return forward_declarations_header::create(s);
+        break;
+    case aspect_types::null_aspect:
+        return create_null_formatter(s);
+        break;
+    default: {
+        std::ostringstream s;
+        s << production_failure_msg << cd.facet_type() << ", "
+          << cd.file_type() << ", " << cd.aspect_type();
+        BOOST_LOG_SEV(lg, error) << s.str();
+        BOOST_THROW_EXCEPTION(production_failure(s.str()));
+    } }
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/file_formatter.cpp b/projects/cpp_formatters/src/types/file_formatter.cpp
index e116aeb..1dcf47f 100644
--- a/projects/cpp_formatters/src/types/file_formatter.cpp
+++ b/projects/cpp_formatters/src/types/file_formatter.cpp
@@ -1,2 +1,28 @@
-// dummy function to suppress ranlib warnings
-void file_formatter() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include "dogen/cpp_formatters/types/file_formatter.hpp"
+
+namespace dogen {
+namespace cpp_formatters {
+
+file_formatter::file_formatter() { }
+
+} }
diff --git a/projects/cpp_formatters/src/types/forward_declarations_header.cpp b/projects/cpp_formatters/src/types/forward_declarations_header.cpp
index b87815f..6ead4a2 100644
--- a/projects/cpp_formatters/src/types/forward_declarations_header.cpp
+++ b/projects/cpp_formatters/src/types/forward_declarations_header.cpp
@@ -1,2 +1,194 @@
-// dummy function to suppress ranlib warnings
-void forward_declarations_header() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/utility/exception/invalid_enum_value.hpp"
+#include "dogen/cpp_formatters/types/formatting_error.hpp"
+#include "dogen/cpp_formatters/types/licence.hpp"
+#include "dogen/cpp_formatters/types/includes.hpp"
+#include "dogen/cpp_formatters/types/namespace_formatter.hpp"
+#include "dogen/cpp_formatters/types/header_guards.hpp"
+#include "dogen/cpp_formatters/types/qname.hpp"
+#include "dogen/cpp_formatters/types/namespace_helper.hpp"
+#include "dogen/cpp_formatters/types/forward_declarations_header.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.forward_declarations_header"));
+
+const std::string boost_ns("boost");
+const std::string serialization_ns("serialization");
+const std::string invalid_aspect_type("Invalid value for aspect_types");
+const std::string invalid_category_type("Invalid value for category_types");
+
+const std::string invalid_facet_types("Invalid value for facet_types");
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+const std::string missing_exception_info("Exception info is empty");
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+forward_declarations_header::
+forward_declarations_header(std::ostream& stream)
+    : stream_(stream), utility_(stream_, indenter_) { }
+
+file_formatter::shared_ptr forward_declarations_header::
+create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new forward_declarations_header(stream));
+}
+
+void forward_declarations_header::
+format_serialization_class(const cpp::class_info& ci) {
+    {
+        std::list<std::string> ns({ boost_ns, serialization_ns });
+        namespace_helper nsh(stream_, ns);
+        utility_.blank_line();
+
+        stream_ << indenter_ << "template<class Archive>" << std::endl
+            << indenter_ << "void save(Archive& ar, const ";
+
+        qname qname(stream_);
+        qname.format(ci);
+
+        stream_ << indenter_ << "& v, unsigned int version);" << std::endl;
+        utility_.blank_line();
+
+        stream_ << indenter_ << "template<class Archive>" << std::endl
+                << indenter_ << "void load(Archive& ar, ";
+        qname.format(ci);
+
+        stream_ << indenter_ << "& v, unsigned int version);" << std::endl;
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void forward_declarations_header::
+format_domain_class(const cpp::class_info& ci) {
+    {
+        namespace_helper nsh(stream_, ci.namespaces());
+        utility_.blank_line();
+
+        stream_ << indenter_ << "class " << ci.name() << ";" << std::endl;
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void forward_declarations_header::format_class(const cpp::file_info& fi) {
+    boost::optional<cpp::class_info> o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+
+    const auto ft(fi.descriptor().facet_type());
+    const cpp::class_info& ci(*o);
+    if (ft == config::cpp_facet_types::serialization)
+        format_serialization_class(ci);
+    else if (ft == config::cpp_facet_types::types)
+        format_domain_class(ci);
+    else {
+        using dogen::utility::exception::invalid_enum_value;
+        BOOST_LOG_SEV(lg, error) << invalid_facet_types;
+        BOOST_THROW_EXCEPTION(invalid_enum_value(invalid_facet_types));
+    }
+}
+
+void forward_declarations_header::
+format_enumeration(const cpp::file_info& fi) {
+    const auto o(fi.enum_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_enum_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_enum_info));
+    }
+
+    const auto ei(*o);
+    {
+        namespace_helper nsh(stream_, ei.namespaces());
+        utility_.blank_line();
+
+        stream_ << indenter_ << "enum class " << ei.name()
+                << " : unsigned int;";
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void forward_declarations_header::format_exception(const cpp::file_info& fi) {
+    const auto o(fi.exception_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_exception_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_exception_info));
+    }
+
+    const auto ei(*o);
+    {
+        namespace_helper nsh(stream_, ei.namespaces());
+        utility_.blank_line();
+
+        stream_ << indenter_ << "class " << ei.name() << ";" << std::endl;
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void forward_declarations_header::format(const cpp::file_info& fi) {
+    using cpp::aspect_types;
+    if (fi.descriptor().aspect_type() != aspect_types::forward_decls) {
+        using dogen::utility::exception::invalid_enum_value;
+        BOOST_LOG_SEV(lg, error) << invalid_facet_types;
+        BOOST_THROW_EXCEPTION(invalid_enum_value(invalid_facet_types));
+    }
+
+    licence licence(stream_);
+    licence.format();
+
+    header_guards guards(stream_);
+    guards.format_start(fi.header_guard());
+    utility_.blank_line();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    using cpp::content_types;
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::user_defined_service ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+    else if (fi.descriptor().content_type() == content_types::exception)
+        format_exception(fi);
+
+    guards.format_end();
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/generator_header.cpp b/projects/cpp_formatters/src/types/generator_header.cpp
index 81717d9..c5450cb 100644
--- a/projects/cpp_formatters/src/types/generator_header.cpp
+++ b/projects/cpp_formatters/src/types/generator_header.cpp
@@ -1,2 +1,212 @@
-// dummy function to suppress ranlib warnings
-void generator_header() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp_formatters/types/formatting_error.hpp"
+#include "dogen/cpp_formatters/types/licence.hpp"
+#include "dogen/cpp_formatters/types/header_guards.hpp"
+#include "dogen/cpp_formatters/types/namespace_formatter.hpp"
+#include "dogen/cpp_formatters/types/includes.hpp"
+#include "dogen/cpp_formatters/types/namespace_helper.hpp"
+#include "dogen/cpp_formatters/types/qname.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/generator_header.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.generator_header"));
+
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+generator_header::
+generator_header(std::ostream& stream) :
+    stream_(stream),
+    utility_(stream_, indenter_) {
+}
+
+file_formatter::shared_ptr generator_header::create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new generator_header(stream));
+}
+
+void generator_header::generator_class(const cpp::enum_info& ei) {
+    const std::string class_name(ei.name() + "_generator");
+
+    stream_ << indenter_ << "class " << class_name << " ";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+
+        utility_.public_access_specifier();
+        stream_ << indenter_ << class_name << "();" << std::endl;
+        utility_.blank_line();
+
+        utility_.public_access_specifier();
+
+        stream_ << indenter_ << "typedef ";
+        qname qname(stream_);
+        qname.format(ei);
+        stream_ << " result_type;" << std::endl;
+        utility_.blank_line();
+
+        utility_.public_access_specifier();
+        stream_ << indenter_
+                << "static void populate(const unsigned int position,"
+                <<" result_type& v);"
+                << std::endl;
+
+        stream_ << indenter_
+                << "static result_type create(const unsigned int position);"
+                << std::endl;
+
+        stream_ << indenter_ << "result_type operator()();" << std::endl;
+        utility_.blank_line();
+
+        utility_.private_access_specifier();
+        stream_ << indenter_ << "unsigned int "
+                << utility_.as_member_variable("position") << ";"
+                << std::endl;
+    }
+    stream_ << "};";
+}
+
+void generator_header::generator_class(const cpp::class_info& ci) {
+    const std::string class_name(ci.name() + "_generator");
+
+    stream_ << indenter_ << "class " << class_name << " ";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+
+        utility_.public_access_specifier();
+        stream_ << indenter_ << class_name << "();" << std::endl;
+        utility_.blank_line();
+
+        utility_.public_access_specifier();
+
+        stream_ << indenter_ << "typedef ";
+        qname qname(stream_);
+        qname.format(ci);
+        stream_ << " result_type;" << std::endl;
+        utility_.blank_line();
+
+        utility_.public_access_specifier();
+        if (!ci.is_immutable()) {
+            stream_ << indenter_
+                    << "static void populate(const unsigned int position,"
+                    <<" result_type& v);"
+                    << std::endl;
+        }
+
+        if (!ci.is_parent()) {
+            stream_ << indenter_
+                    << "static result_type create(const unsigned int position);"
+                    << std::endl;
+
+            stream_ << indenter_ << "result_type operator()();" << std::endl;
+            utility_.blank_line();
+
+            utility_.private_access_specifier();
+            stream_ << indenter_ << "unsigned int "
+                    << utility_.as_member_variable("position") << ";"
+                    << std::endl;
+        }
+
+        utility_.public_access_specifier();
+        stream_ << indenter_
+                << "static result_type* create_ptr("
+                << "const unsigned int position);"
+                << std::endl;
+    }
+    stream_ << "};";
+}
+
+void generator_header::format_enumeration(const cpp::file_info& fi) {
+    const auto o(fi.enum_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_enum_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_enum_info));
+    }
+
+    const auto ei(*o);
+    {
+        std::list<std::string> namespaces(ei.namespaces());
+        namespace_helper ns_helper(stream_, namespaces);
+        utility_.blank_line();
+
+        generator_class(ei);
+        utility_.blank_line(2);
+    }
+    utility_.blank_line(2);
+}
+
+void generator_header::format_class(const cpp::file_info& fi) {
+    auto o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+
+    {
+        const cpp::class_info& ci(*o);
+        std::list<std::string> namespaces(ci.namespaces());
+        namespace_helper ns_helper(stream_, namespaces);
+        utility_.blank_line();
+
+        generator_class(ci);
+        utility_.blank_line(2);
+    }
+    utility_.blank_line(2);
+}
+
+void generator_header::format(const cpp::file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    header_guards guards(stream_);
+    guards.format_start(fi.header_guard());
+    utility_.blank_line();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    using cpp::content_types;
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+
+    guards.format_end();
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/generator_implementation.cpp b/projects/cpp_formatters/src/types/generator_implementation.cpp
index 78bc115..3d1db33 100644
--- a/projects/cpp_formatters/src/types/generator_implementation.cpp
+++ b/projects/cpp_formatters/src/types/generator_implementation.cpp
@@ -1,2 +1,884 @@
-// dummy function to suppress ranlib warnings
-void generator_implementation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp_formatters/types/formatting_error.hpp"
+#include "dogen/cpp_formatters/types/licence.hpp"
+#include "dogen/cpp_formatters/types/header_guards.hpp"
+#include "dogen/cpp_formatters/types/namespace_formatter.hpp"
+#include "dogen/cpp_formatters/types/includes.hpp"
+#include "dogen/cpp_formatters/types/namespace_helper.hpp"
+#include "dogen/cpp_formatters/types/qname.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/generator_implementation.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.generator_implementation"));
+
+const std::string int_type("int");
+const std::string bool_type("bool");
+const std::string string_type("std::string");
+const std::string invalid_sequence_container(
+    "Sequence containers have exactly one type argument");
+const std::string invalid_associative_container(
+    "Associative containers have one or two type arguments");
+const std::string invalid_smart_pointer(
+    "Smart pointers have exactly one type argument");
+const std::string invalid_pair(
+    "Pairs  have exactly two type arguments");
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+generator_implementation::
+generator_implementation(std::ostream& stream) :
+    stream_(stream),
+    utility_(stream_, indenter_) { }
+
+file_formatter::shared_ptr
+generator_implementation::create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new generator_implementation(stream));
+}
+
+void generator_implementation::
+sequence_container_helper(
+    const cpp::nested_type_info& nti, unsigned int quantity) {
+    const auto container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const auto container_type_name(nti.complete_name());
+
+    const auto children(nti.children());
+    if (children.size() != 1) {
+        BOOST_LOG_SEV(lg, error) << invalid_sequence_container;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_sequence_container));
+    }
+
+    const auto containee_nti(children.front());
+    const auto containee_identifiable_type_name(
+        containee_nti.complete_identifiable_name());
+
+    stream_ << indenter_ << container_type_name << " create_"
+            << container_identifiable_type_name
+            << "(unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << container_type_name << " r;"
+                << std::endl;
+        stream_ << indenter_ << "for (unsigned int i(0); i < " << quantity
+                << "; ++i) ";
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "r.push_back(create_"
+                    << containee_identifiable_type_name
+                    << "(position + i));" << std::endl;
+        }
+        utility_.close_scope();
+        stream_ << indenter_ << "return r;" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void generator_implementation::
+associative_container_helper(
+    const cpp::nested_type_info& nti, unsigned int quantity) {
+
+    const auto children(nti.children());
+    if (children.size() != 1 && children.size() != 2) {
+        BOOST_LOG_SEV(lg, error) << invalid_associative_container;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_associative_container));
+    }
+
+    const auto container_identifiable_type_name(nti.complete_identifiable_name());
+    const auto container_type_name(nti.complete_name());
+
+    stream_ << indenter_ << container_type_name << " create_"
+            << container_identifiable_type_name
+            << "(unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << container_type_name << " r;"
+                << std::endl;
+        stream_ << indenter_ << "for (unsigned int i(0); i < " << quantity
+                << "; ++i) ";
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            if (children.size() == 1) {
+                const auto containee_nti(children.front());
+                const auto containee_identifiable_type_name(
+                    containee_nti.complete_identifiable_name());
+
+                stream_ << indenter_ << "r.insert(create_"
+                        << containee_identifiable_type_name
+                        << "(position + i));" << std::endl;
+            } else {
+                const auto key(children.front());
+                const auto value(children.back());
+                stream_ << indenter_ << "r.insert(std::make_pair("
+                        << "create_" << key.complete_identifiable_name()
+                        << "(position + i), "
+                        << "create_" << value.complete_identifiable_name()
+                        << "(position + i)));"
+                        << std::endl;
+            }
+        }
+        utility_.close_scope();
+        stream_ << indenter_ << "return r;" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void generator_implementation::
+smart_pointer_helper(const cpp::nested_type_info& nti) {
+    const auto container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const auto container_type_name(nti.complete_name());
+
+    const auto children(nti.children());
+    if (children.size() != 1) {
+        BOOST_LOG_SEV(lg, error) << invalid_smart_pointer;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_smart_pointer));
+    }
+
+    const auto containee_nti(children.front());
+    const auto containee_identifiable_type_name(
+        containee_nti.complete_identifiable_name());
+
+    stream_ << indenter_ << container_type_name
+            << std::endl
+            << indenter_ << "create_"
+            << container_identifiable_type_name
+            << "(unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << container_type_name << " r("
+                << std::endl;
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "create_"
+                    << containee_identifiable_type_name
+                    << "_ptr(position));" << std::endl;
+        }
+        stream_ << indenter_ << "return r;" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void generator_implementation::
+optional_helper(const cpp::nested_type_info& nti) {
+    const auto container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const auto container_type_name(nti.complete_name());
+
+    const auto children(nti.children());
+    if (children.size() != 1) {
+        BOOST_LOG_SEV(lg, error) << invalid_smart_pointer;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_smart_pointer));
+    }
+
+    stream_ << indenter_ << container_type_name
+            << std::endl
+            << indenter_ << "create_"
+            << container_identifiable_type_name
+            << "(unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << container_type_name << " r(" << std::endl;
+        {
+            positive_indenter_scope s(indenter_);
+            const auto containee_nti(children.front());
+            const auto containee_identifiable_type_name(
+                containee_nti.complete_identifiable_name());
+
+            stream_ << indenter_ << "create_"
+                    << containee_identifiable_type_name
+                    << "(position));" << std::endl;
+        }
+        stream_ << indenter_ << "return r;" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void generator_implementation::
+pair_helper(const cpp::nested_type_info& nti) {
+    const auto container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const auto container_type_name(nti.complete_name());
+
+    const auto children(nti.children());
+    if (children.size() != 2) {
+        BOOST_LOG_SEV(lg, error) << invalid_pair;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_pair));
+    }
+
+    stream_ << indenter_ << container_type_name
+            << std::endl
+            << indenter_ << "create_"
+            << container_identifiable_type_name
+            << "(unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << container_type_name << " r(" << std::endl;
+        {
+            positive_indenter_scope s(indenter_);
+            const auto first(children.front());
+            const auto first_identifiable_type_name(
+                first.complete_identifiable_name());
+
+            stream_ << indenter_ << "create_"
+                    << first_identifiable_type_name
+                    << "(position)," << std::endl;
+
+            const auto second(children.back());
+            const auto second_identifiable_type_name(
+                second.complete_identifiable_name());
+
+            stream_ << indenter_ << "create_"
+                    << second_identifiable_type_name
+                    << "(position));" << std::endl;
+        }
+        stream_ << indenter_ << "return r;" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void generator_implementation::
+filesystem_path_helper(const cpp::nested_type_info& nti) {
+    const auto type_name(nti.identifiable_name());
+    const auto identifiable_type_name(nti.complete_identifiable_name());
+
+    stream_ << indenter_ << nti.name() << std::endl
+            << "create_" << identifiable_type_name
+            << "(const unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "std::ostringstream s;" << std::endl
+                << indenter_ << "s << " << utility_.quote("/a/path/number_")
+                << " << position;" << std::endl;
+        stream_ << indenter_ << "return " << nti.name() << "(s.str());"
+                << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void generator_implementation::date_helper(const cpp::nested_type_info& nti) {
+    const auto type_name(nti.identifiable_name());
+    const auto identifiable_type_name(nti.complete_identifiable_name());
+
+    stream_ << indenter_ << nti.name() << std::endl
+            << "create_" << identifiable_type_name
+            << "(const unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "unsigned int day(position % 28);" << std::endl
+                << indenter_ << "boost::gregorian::date r(2002, 2, day);"
+                << std::endl
+                << indenter_ << "return r;" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void generator_implementation::ptime_helper(const cpp::nested_type_info& nti) {
+    const auto type_name(nti.identifiable_name());
+    const auto identifiable_type_name(nti.complete_identifiable_name());
+
+    stream_ << indenter_ << nti.name() << std::endl
+            << "create_" << identifiable_type_name
+            << "(const unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "unsigned int day(position % 28);" << std::endl
+                << indenter_ << "using boost::gregorian::date;" << std::endl
+                << indenter_ << "using boost::posix_time::ptime;"
+                << std::endl
+                << indenter_ << "using boost::posix_time::time_duration;"
+                << std::endl
+                << indenter_ << "date d(2002, 2, day);"
+                << indenter_
+                << "ptime r(d, time_duration(1,2,3));" << std::endl
+                << indenter_ << "return r;" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void generator_implementation::
+time_duration_helper(const cpp::nested_type_info& nti) {
+    const auto type_name(nti.identifiable_name());
+    const auto identifiable_type_name(nti.complete_identifiable_name());
+
+    stream_ << indenter_ << nti.name() << std::endl
+            << "create_" << identifiable_type_name
+            << "(const unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "unsigned int hour(position % 55);" << std::endl
+                << indenter_ << "using boost::posix_time::time_duration;"
+                << std::endl
+                << indenter_ << "time_duration r(hour, 2, 3);" << std::endl
+                << indenter_ << "return r;" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void generator_implementation::
+variant_helper(const cpp::nested_type_info& nti) {
+    const auto container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const auto container_type_name(nti.complete_name());
+
+    const auto children(nti.children());
+    if (children.empty()) {
+        BOOST_LOG_SEV(lg, error) << invalid_smart_pointer;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_smart_pointer));
+    }
+
+    utility_.blank_line();
+    stream_ << indenter_ << container_type_name
+            << std::endl
+            << indenter_ << "create_"
+            << container_identifiable_type_name
+            << "(unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << container_type_name << " r;" << std::endl;
+        utility_.blank_line();
+
+        unsigned int i(0);
+        for (const auto& c : children) {
+            if (i == 0) {
+                stream_ << indenter_ << "if (position == 0 || ((position % "
+                        << children.size() << ") == 0))" << std::endl;
+            } else if (i == 1) {
+                stream_ << indenter_
+                        << "else if (position == 1 || ((position %"
+                        << children.size() + 1 << ") == 0))" << std::endl;
+            } else {
+                stream_ << indenter_
+                        << "else if ((position % " << i << ") == 0)"
+                        << std::endl;
+            }
+            ++i;
+
+            {
+                positive_indenter_scope s(indenter_);
+                stream_ << indenter_ << "r = create_"
+                        << c.complete_identifiable_name()
+                        << "(position);" << std::endl;
+            }
+        }
+        utility_.blank_line();
+        stream_ << indenter_ << "return r;" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void generator_implementation::
+domain_type_helper(const std::string& identifiable_type_name,
+    const std::string& type_name, bool as_pointer) {
+    stream_ << indenter_ << type_name << (as_pointer ? "*" : "")
+            << std::endl
+            << "create_" << identifiable_type_name
+            << (as_pointer ? "_ptr" : "")
+            << "(const unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        if (as_pointer) {
+            stream_ << indenter_ << "return " << type_name
+                    << "_generator::create_ptr(position);" << std::endl;
+        } else {
+            stream_ << indenter_ << "return " << type_name
+                    << "_generator::create(position);" << std::endl;
+        }
+    }
+    utility_.close_scope();
+}
+
+void generator_implementation::
+composite_domain_type_helper(const std::string& identifiable_type_name,
+    const std::string& type_name, bool as_pointer) {
+    stream_ << indenter_ << type_name << (as_pointer ? "*" : "")
+            << std::endl
+            << "create_" << identifiable_type_name
+            << (as_pointer ? "_ptr" : "")
+            << "(const unsigned int) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        if (as_pointer) {
+            stream_ << indenter_ << "return nullptr" << ";"
+                    << std::endl;
+        } else
+            stream_ << indenter_ << "return " << type_name << "();"
+                    << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void generator_implementation::bool_helper() {
+    stream_ << indenter_ << "bool create_bool(const unsigned int position) ";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "return (position % 2) == 0;" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void generator_implementation::string_helper() {
+    stream_ << indenter_ << "std::string create_std_string"
+            << "(const unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "std::ostringstream s;" << std::endl
+                << indenter_ << "s << " << utility_.quote("a_string_")
+                << " << position;" << std::endl;
+        stream_ << indenter_ << "return s.str();" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void generator_implementation::
+char_like_helper(const std::string& identifiable_type_name,
+    const std::string& type_name) {
+    stream_ << indenter_ << type_name << " create_" << identifiable_type_name
+            << "(const unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_
+                << "return static_cast<" << type_name
+                << ">(((position % 95) + 32) == 34) ? 35 :"
+                << " ((position % 95) + 32);"
+                << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void generator_implementation::
+int_like_helper(const std::string& identifiable_type_name,
+    const std::string& type_name) {
+    stream_ << indenter_ << type_name << " create_" << identifiable_type_name
+            << "(const unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        if (type_name == int_type)
+            stream_ << indenter_ << "return position;";
+        else
+            stream_ << indenter_ << "return static_cast<" << type_name
+                    << ">(position);";
+
+        stream_ << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void generator_implementation::
+recursive_helper_method_creator(const std::string& owner_name,
+    const cpp::nested_type_info& nti,
+    std::unordered_set<std::string>& types_done, bool as_pointer) {
+    const unsigned int quantity(10);
+
+    std::string type_name(nti.complete_identifiable_name());
+    if (as_pointer)
+        type_name += "_ptr";
+
+    if (types_done.find(type_name) != types_done.end())
+        return;
+
+    const auto children(nti.children());
+    for (const auto c : children)
+        recursive_helper_method_creator(owner_name, c, types_done,
+            nti.is_smart_pointer());
+
+    if (nti.is_primitive()) {
+        if (nti.is_char_like()) {
+            char_like_helper(nti.identifiable_name(), nti.name());
+            utility_.blank_line();
+        } else if (nti.is_int_like()) {
+            int_like_helper(nti.identifiable_name(), nti.name());
+            utility_.blank_line();
+        } else if (nti.name() == bool_type) {
+            bool_helper();
+            utility_.blank_line();
+        }
+    } else if (nti.is_sequence_container())
+        sequence_container_helper(nti, quantity);
+    else if (nti.is_associative_container())
+        associative_container_helper(nti, quantity);
+    else if (nti.is_smart_pointer())
+        smart_pointer_helper(nti);
+    else if (nti.is_optional_like())
+        optional_helper(nti);
+    else if (nti.is_pair())
+        pair_helper(nti);
+    else if (nti.is_variant_like())
+        variant_helper(nti);
+    else if (nti.is_filesystem_path())
+        filesystem_path_helper(nti);
+    else if (nti.is_date())
+        date_helper(nti);
+    else if (nti.is_ptime())
+        ptime_helper(nti);
+    else if (nti.is_time_duration())
+        time_duration_helper(nti);
+    else {
+        if (nti.name() == string_type) {
+            string_helper();
+            utility_.blank_line();
+        } else {
+            if (boost::algorithm::ends_with(nti.name(), "::" + owner_name)) {
+                composite_domain_type_helper(nti.identifiable_name(), nti.name(),
+                    as_pointer);
+            } else {
+                domain_type_helper(nti.identifiable_name(), nti.name(),
+                    as_pointer);
+            }
+            utility_.blank_line();
+        }
+    }
+    types_done.insert(type_name);
+}
+
+void generator_implementation::
+create_helper_methods(const cpp::class_info& ci) {
+    const auto props(ci.properties());
+    if (props.empty())
+        return;
+
+    namespace_helper ns_helper(stream_, std::list<std::string> { });
+    std::unordered_set<std::string> types_done;
+
+    utility_.blank_line();
+    const bool as_ptr(false);
+    const auto owner(ci.name());
+    for (const auto p : props)
+        recursive_helper_method_creator(owner, p.type(), types_done, as_ptr);
+}
+
+void generator_implementation::populate_method(const cpp::class_info& ci) {
+    if (ci.is_immutable())
+        return;
+
+    const auto props(ci.properties());
+    const std::string name(ci.name() + "_generator");
+
+    stream_ << indenter_ << "void " << name << "::" << std::endl;
+    if (!props.empty() || !ci.parents().empty()) {
+        stream_ << "populate(const unsigned int position, result_type& v) " ;
+    } else {
+        stream_ << "populate(const unsigned int /*position*/, "
+                << "result_type& /*v*/) " ;
+    }
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        for (const auto p : ci.parents()) {
+            stream_ << indenter_;
+            qname qname(stream_);
+            qname.format(p);
+            stream_ << "_generator::populate(position, v);"
+                    << std::endl;
+        }
+
+        unsigned int i(0);
+        for (const auto p : props) {
+            stream_ << indenter_ << "v." << p.name() << "("
+                    << "create_" << p.type().complete_identifiable_name()
+                    << "(position + " << i << "));" << std::endl;
+            ++i;
+        }
+    }
+    utility_.close_scope();
+}
+
+void generator_implementation::create_method(const cpp::class_info& ci) {
+    if (ci.is_parent())
+        return;
+
+    const bool has_properties(!ci.all_properties().empty());
+    const std::string name(ci.name() + "_generator");
+    stream_ << indenter_ << name << "::result_type" << std::endl
+            << name << "::create(const unsigned int"
+            << (has_properties ? " position" : "/*position*/")
+            << ") ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+
+        if (ci.is_immutable()) {
+            stream_ << indenter_ << "return " << ci.name() << "(" << std::endl;
+            positive_indenter_scope s(indenter_);
+            {
+                unsigned int i(0);
+                for (const auto p : ci.properties()) {
+                    if (i != 0)
+                        stream_ << "," << std::endl;
+
+                    stream_ << indenter_ << "create_"
+                            << p.type().complete_identifiable_name()
+                            << "(position + " << i << ")";
+                    ++i;
+                }
+                stream_ << std::endl;
+            }
+            stream_ << indenter_ << ");" << std::endl;
+        } else {
+            stream_ << indenter_ << ci.name() << " r;" << std::endl;
+            if (has_properties) {
+                stream_ << indenter_ << name << "::populate(position, r);"
+                        << std::endl;
+            }
+            stream_ << indenter_ << "return r;" << std::endl;
+        }
+    }
+    utility_.close_scope();
+}
+
+void generator_implementation::create_method_ptr(const cpp::class_info& ci) {
+    auto leaves(ci.leaves());
+    const std::string name(ci.name() + "_generator");
+    stream_ << indenter_ << name << "::result_type*" << std::endl
+            << name << "::create_ptr(const unsigned int position) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+
+        if (leaves.empty()) {
+            if (ci.is_immutable()) {
+                stream_ << indenter_ << "return new " << ci.name()
+                        << "(create(position));" << std::endl;
+            } else {
+                stream_ << indenter_ << ci.name() << "* p = new " << ci.name()
+                        << "();" << std::endl
+                        << indenter_ << name << "::populate(position, *p);"
+                        << std::endl
+                        << indenter_ << "return p;" << std::endl;
+            }
+        } else {
+            const auto front(leaves.front());
+            leaves.pop_front();
+            unsigned int i(0);
+            unsigned int total(leaves.size());
+            for (const auto l : leaves) {
+                stream_ << indenter_ << "if ((position % " << total << ") == "
+                        << i++ << ")"
+                        << std::endl;
+                {
+                    positive_indenter_scope s(indenter_);
+                    stream_ << indenter_ << "return " << l
+                            << "_generator::create_ptr(position);"
+                            << std::endl;
+                }
+            }
+            stream_ << indenter_ << "return " << front
+                    << "_generator::create_ptr(position);"
+                    << std::endl;
+        }
+    }
+    utility_.close_scope();
+}
+
+void generator_implementation::function_operator(const cpp::class_info& ci) {
+    if (ci.is_parent())
+        return;
+
+    const std::string name(ci.name() + "_generator");
+    stream_ << indenter_ << name << "::result_type" << std::endl
+            << name << "::operator()() ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "return create("
+                << utility_.as_member_variable("position") << "++);"
+                << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void generator_implementation::default_constructor(const cpp::class_info& ci) {
+    if (ci.is_parent())
+        return;
+
+    const std::string name(ci.name() + "_generator");
+    stream_ << indenter_ << name << "::" << name << "() : position_(0) { }";
+    utility_.blank_line();
+}
+
+void generator_implementation::format_class(const cpp::file_info& fi) {
+    auto o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+
+    const cpp::class_info& ci(*o);
+    create_helper_methods(ci);
+    utility_.blank_line(2);
+
+    {
+        std::list<std::string> ns(ci.namespaces());
+        namespace_helper ns_helper(stream_, ns);
+
+        utility_.blank_line();
+        default_constructor(ci);
+        utility_.blank_line();
+        populate_method(ci);
+        if (!ci.is_immutable())
+            utility_.blank_line();
+        create_method(ci);
+        create_method_ptr(ci);
+        utility_.blank_line();
+        function_operator(ci);
+        utility_.blank_line();
+    }
+    utility_.blank_line();
+}
+
+void generator_implementation::format_enumeration(const cpp::file_info& fi) {
+    const auto o(fi.enum_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_enum_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_enum_info));
+    }
+
+    const auto ei(*o);
+    {
+        std::list<std::string> ns(ei.namespaces());
+        namespace_helper ns_helper(stream_, ns);
+
+        utility_.blank_line();
+        const std::string name(ei.name() + "_generator");
+        stream_ << indenter_ << name << "::" << name << "() : position_(0) { }";
+        utility_.blank_line();
+
+        stream_ << indenter_ << "void " << name << "::" << std::endl
+                << "populate(const unsigned int position, result_type& v) " ;
+
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "v = static_cast<" << ei.name() << ">"
+                    << "(position % " << ei.enumerators().size() << ");"
+                    << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+
+        stream_ << indenter_ << name << "::result_type" << std::endl
+                << name << "::create(const unsigned int  position) ";
+        utility_.open_scope();
+        {
+            {
+                positive_indenter_scope s(indenter_);
+                stream_ << indenter_ << "result_type r;" << std::endl;
+                stream_ << indenter_ << name << "::populate(position, r);"
+                        << std::endl;
+                stream_<< indenter_ << "return r;" << std::endl;
+            }
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+
+        stream_ << indenter_ << name << "::result_type" << std::endl
+                << name << "::operator()() ";
+
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "return create("
+                    << utility_.as_member_variable("position") << "++);"
+                    << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+}
+
+void generator_implementation::format(const cpp::file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    using cpp::content_types;
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/hash_header.cpp b/projects/cpp_formatters/src/types/hash_header.cpp
index 16132db..b4ec3fd 100644
--- a/projects/cpp_formatters/src/types/hash_header.cpp
+++ b/projects/cpp_formatters/src/types/hash_header.cpp
@@ -1,2 +1,204 @@
-// dummy function to suppress ranlib warnings
-void hash_header() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/io/file_info_io.hpp"
+#include "dogen/cpp_formatters/types/formatting_error.hpp"
+#include "dogen/cpp_formatters/types/licence.hpp"
+#include "dogen/cpp_formatters/types/header_guards.hpp"
+#include "dogen/cpp_formatters/types/namespace_formatter.hpp"
+#include "dogen/cpp_formatters/types/includes.hpp"
+#include "dogen/cpp_formatters/types/namespace_helper.hpp"
+#include "dogen/cpp_formatters/types/qname.hpp"
+#include "dogen/cpp_formatters/types/indenter.hpp"
+#include "dogen/cpp_formatters/types/hash_header.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.hash_header"));
+
+const std::string std_ns("std");
+
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+
+}
+
+namespace dogen {
+namespace cpp_formatters {
+
+hash_header::
+hash_header(std::ostream& stream) :
+    stream_(stream),
+    utility_(stream_, indenter_) {
+}
+
+file_formatter::shared_ptr hash_header::create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new hash_header(stream));
+}
+
+void hash_header::operator_bracket_method(const cpp::class_info& ci) {
+    stream_ << indenter_ << "size_t operator()(const ";
+
+    qname qname(stream_);
+    qname.format(ci);
+
+    stream_ << "& v) const ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+
+        stream_ << indenter_ << "return ";
+        qname.format(ci);
+        stream_ << "_hasher::hash(v);" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_header::hash_helper_class(const cpp::class_info& ci) {
+    stream_ << indenter_ << indenter_ << "struct " << ci.name()
+            << "_hasher ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        utility_.public_access_specifier();
+        stream_ << indenter_ << "static std::size_t hash(const "
+                << ci.name() << "& v);" << std::endl;
+    }
+    stream_ << indenter_ << "};" << std::endl;
+}
+
+void hash_header::hash_class(const cpp::class_info& ci) {
+    stream_ << indenter_ << "template<>" << std::endl
+            << indenter_ << "struct hash<";
+
+    qname qname(stream_);
+    qname.format(ci);
+
+    stream_ << "> ";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        utility_.public_access_specifier();
+        operator_bracket_method(ci);
+    }
+    stream_ << indenter_ << "};" << std::endl;
+}
+
+void hash_header::format_enumeration(const cpp::file_info& fi) {
+    const auto o(fi.enum_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_enum_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_enum_info));
+    }
+
+    const auto ei(*o);
+    {
+        namespace_helper nsh(stream_, std::list<std::string> { std_ns });
+        utility_.blank_line();
+
+        stream_ << indenter_ << "template<>" << std::endl
+                << indenter_ << "struct hash<";
+
+        qname qnf(stream_);
+        qnf.format(ei);
+
+        stream_ << "> ";
+        utility_.open_scope();
+        utility_.public_access_specifier();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "size_t operator()(const ";
+            qnf.format(ei);
+            stream_ << "& v) const ";
+            utility_.open_scope();
+            {
+                positive_indenter_scope s(indenter_);
+                stream_ << indenter_ << "return std::hash<unsigned int>()("
+                        << "static_cast<unsigned int>(v));" << std::endl;
+            }
+            stream_ << indenter_;
+        }
+        utility_.close_scope();
+        stream_ << "};" << std::endl;
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void hash_header::format_class(const cpp::file_info& fi) {
+    const auto o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+
+    const cpp::class_info& ci(*o);
+    {
+        namespace_helper nsh(stream_, ci.namespaces());
+        utility_.blank_line();
+        hash_helper_class(ci);
+        utility_.blank_line();
+    }
+
+    utility_.blank_line(2);
+    {
+        std::list<std::string> namespaces;
+        namespaces.push_back(std_ns);
+        namespace_helper nsh(stream_, namespaces);
+
+        utility_.blank_line();
+        hash_class(ci);
+        utility_.blank_line();
+    }
+    utility_.blank_line();
+}
+
+void hash_header::format(const cpp::file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    header_guards guards(stream_);
+    guards.format_start(fi.header_guard());
+    stream_ << std::endl;
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    using cpp::content_types;
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+
+    guards.format_end();
+}
+
+} }
diff --git a/projects/cpp_formatters/src/types/hash_implementation.cpp b/projects/cpp_formatters/src/types/hash_implementation.cpp
index 518046a..0f2970c 100644
--- a/projects/cpp_formatters/src/types/hash_implementation.cpp
+++ b/projects/cpp_formatters/src/types/hash_implementation.cpp
@@ -1,2 +1,598 @@
-// dummy function to suppress ranlib warnings
-void hash_implementation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/qname.hpp"
+#include "dogen/cpp/types/formatters/licence.hpp"
+#include "dogen/cpp/types/formatters/header_guards.hpp"
+#include "dogen/cpp/types/formatters/namespace_formatter.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+#include "dogen/cpp/types/formatters/qname.hpp"
+#include "dogen/cpp/types/formatters/indenter.hpp"
+#include "dogen/cpp/types/formatters/hash_implementation.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.hash_implementation"));
+
+const std::string std_ns("std");
+
+const std::string invalid_sequence_container(
+    "Sequence containers have exactly one type argument: ");
+const std::string invalid_associative_container(
+    "Associative containers have one or two type arguments");
+const std::string invalid_smart_pointer(
+    "Smart pointers have exactly one type argument");
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+const std::string enum_info_not_supported(
+    "Enumerations do not have an implementation");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+hash_implementation::hash_implementation(std::ostream& stream) :
+    stream_(stream), utility_(stream_, indenter_) { }
+
+file_formatter::shared_ptr hash_implementation::create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new hash_implementation(stream));
+}
+
+bool hash_implementation::is_hashable(const nested_type_info& nti) {
+    return
+        !nti.is_sequence_container() &&
+        !nti.is_associative_container() &&
+        !nti.is_smart_pointer() &&
+        !nti.is_pair() &&
+        !nti.is_optional_like() &&
+        !nti.is_variant_like() &&
+        !nti.is_ptime() &&
+        !nti.is_time_duration();
+}
+
+void hash_implementation::combine_function(const class_info& ci) {
+    if (ci.properties().empty() && ci.parents().empty())
+        return;
+
+    stream_ << indenter_ << "template <typename HashableType>" << std::endl
+            << indenter_ << "inline void combine(std::size_t& seed, "
+            << "const HashableType& value)" << std::endl;
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "std::hash<HashableType> hasher;" << std::endl
+                << indenter_ << "seed ^= hasher(value) + 0x9e3779b9 + "
+                << "(seed << 6) + (seed >> 2);" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_implementation::pair_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 2) {
+        BOOST_LOG_SEV(lg, error) << "Children container has unexpected size: "
+                                 << children.size() << " in nested type: "
+                                 << nti.name();
+
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_sequence_container
+                + nti.name()));
+    }
+
+    const std::string container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const std::string container_type_name(nti.complete_name());
+
+    utility_.blank_line();
+    stream_ << indenter_ << "inline std::size_t hash_"
+            << container_identifiable_type_name
+            << "(const " << container_type_name << "& v)";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "std::size_t seed(0);"
+                << std::endl;
+
+        utility_.blank_line();
+        const auto first(children.front());
+        if (is_hashable(first)) {
+            stream_ << indenter_ << "combine(seed, v.first);" << std::endl;
+        } else {
+            stream_ << indenter_ << "combine(seed, "
+                    << "hash_" << first.complete_identifiable_name()
+                    << "(v.first));" << std::endl;
+        }
+
+        const auto second(children.front());
+        if (is_hashable(second)) {
+            stream_ << indenter_ << "combine(seed, v.second);" << std::endl;
+        } else {
+            stream_ << indenter_ << "combine(seed, "
+                    << "hash_" << second.complete_identifiable_name()
+                    << "(v.second));" << std::endl;
+        }
+
+        stream_ << indenter_ << "return seed;" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_implementation::optional_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 1) {
+        BOOST_LOG_SEV(lg, error) << "Children container has unexpected size: "
+                                 << children.size() << " in nested type: "
+                                 << nti.name();
+
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_sequence_container
+                + nti.name()));
+    }
+
+    const std::string container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const std::string container_type_name(nti.complete_name());
+
+    utility_.blank_line();
+    stream_ << indenter_ << "inline std::size_t hash_"
+            << container_identifiable_type_name
+            << "(const " << container_type_name << "& v)";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "std::size_t seed(0);"
+                << std::endl;
+
+        utility_.blank_line();
+        stream_ << indenter_ << "if (!v)" << std::endl;
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "return seed;" << std::endl;
+        }
+
+        utility_.blank_line();
+        const auto containee(children.front());
+        if (is_hashable(containee)) {
+            stream_ << indenter_ << "combine(seed, *v);" << std::endl;
+        } else {
+            stream_ << indenter_ << "combine(seed, "
+                    << "hash_" << containee.complete_identifiable_name()
+                    << "(*v));" << std::endl;
+        }
+        stream_ << indenter_ << "return seed;" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_implementation::variant_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.empty()) {
+        BOOST_LOG_SEV(lg, error) << "Children container has unexpected size: "
+                                 << children.size() << " in nested type: "
+                                 << nti.name();
+
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_sequence_container
+                + nti.name()));
+    }
+
+    const std::string container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const std::string container_type_name(nti.complete_name());
+
+    utility_.blank_line();
+    stream_ << indenter_ << "struct "
+            << nti.complete_identifiable_name()
+            << "_visitor : public boost::static_visitor<> ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << nti.complete_identifiable_name()
+                << "_visitor() : hash(0) {}" << std::endl;
+
+        for (const auto& c : children) {
+            stream_ << indenter_
+                    << "void operator()(const " << c.name()
+                    << (c.is_primitive() ? "" : "&")
+                    << " v) const ";
+
+            utility_.open_scope();
+            {
+                positive_indenter_scope s(indenter_);
+                if (is_hashable(c)) {
+                    stream_ << indenter_ << "combine(hash, v);" << std::endl;
+                } else {
+                    stream_ << indenter_ << "combine(hash, "
+                            << "hash_" << c.complete_identifiable_name()
+                            << "(v));" << std::endl;
+                }
+            }
+            utility_.close_scope();
+            utility_.blank_line();
+        }
+        stream_ << indenter_ << "mutable std::size_t hash;" << std::endl;
+    }
+    stream_ << indenter_ << "};" << std::endl;
+
+    utility_.blank_line();
+    stream_ << indenter_ << "inline std::size_t hash_"
+            << container_identifiable_type_name
+            << "(const " << container_type_name << "& v) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << nti.complete_identifiable_name()
+                << "_visitor vis;" << std::endl
+                << indenter_ << "boost::apply_visitor(vis, v);" << std::endl
+                << indenter_ << "return vis.hash;" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_implementation::
+sequence_container_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 1) {
+        BOOST_LOG_SEV(lg, error) << "Children container has unexpected size: "
+                                 << children.size() << " in nested type: "
+                                 << nti.name();
+
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_sequence_container
+                + nti.name()));
+    }
+
+    const std::string container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const std::string container_type_name(nti.complete_name());
+
+    utility_.blank_line();
+    stream_ << indenter_ << "inline std::size_t hash_"
+            << container_identifiable_type_name
+            << "(const " << container_type_name << "& v)";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "std::size_t seed(0);"
+                << std::endl;
+        stream_ << indenter_ << "for (const auto i : v) ";
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            const auto containee(children.front());
+            if (is_hashable(containee)) {
+                stream_ << indenter_ << "combine(seed, i);" << std::endl;
+            } else {
+                stream_ << indenter_ << "combine(seed, "
+                        << "hash_" << containee.complete_identifiable_name()
+                        << "(i));" << std::endl;
+            }
+        }
+        utility_.close_scope();
+        stream_ << indenter_ << "return seed;" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_implementation::
+associative_container_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 1 && children.size() != 2) {
+        BOOST_LOG_SEV(lg, error) << invalid_associative_container;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_associative_container));
+    }
+
+    if (children.size() == 1) {
+        sequence_container_helper(nti);
+
+        return;
+    }
+
+    const std::string container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const std::string container_type_name(nti.complete_name());
+
+    utility_.blank_line();
+    stream_ << indenter_ << "inline std::size_t hash_"
+            << container_identifiable_type_name
+            << "(const " << container_type_name << "& v)";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "std::size_t seed(0);"
+                << std::endl;
+        stream_ << indenter_ << "for (const auto i : v) ";
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            const auto key(children.front());
+            const auto value(children.back());
+
+            if (is_hashable(key)) {
+                stream_ << indenter_ << "combine(seed, i.first);" << std::endl;
+            } else {
+                stream_ << indenter_ << "combine(seed, "
+                        << "hash_" << key.complete_identifiable_name()
+                        << "(i.first));" << std::endl;
+            }
+
+            if (is_hashable(value)) {
+                stream_ << indenter_ << "combine(seed, i.second);" << std::endl;
+            } else {
+                stream_ << indenter_ << "combine(seed, "
+                        << "hash_" << value.complete_identifiable_name()
+                        << "(i.second));" << std::endl;
+            }
+        }
+        utility_.close_scope();
+        stream_ << indenter_ << "return seed;" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_implementation::
+smart_pointer_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 1) {
+        BOOST_LOG_SEV(lg, error) << invalid_smart_pointer;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_smart_pointer));
+    }
+
+    const std::string container_identifiable_type_name(
+        nti.complete_identifiable_name());
+    const std::string container_type_name(nti.complete_name());
+
+    utility_.blank_line();
+    stream_ << indenter_ << "inline std::size_t hash_"
+            << container_identifiable_type_name
+            << "(const " << container_type_name << "& v)";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "std::size_t seed(0);"
+                << std::endl;
+
+        const auto containee(children.front());
+        if (is_hashable(containee)) {
+            stream_ << indenter_ << "combine(seed, *v);" << std::endl;
+        } else {
+            stream_ << indenter_ << "combine(seed, "
+                    << "hash_" << containee.complete_identifiable_name()
+                    << "(*v));" << std::endl;
+        }
+        stream_ << indenter_ << "return seed;" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_implementation::ptime_helper(const nested_type_info& nti) {
+    const std::string identifiable_type_name(
+        nti.complete_identifiable_name());
+    const std::string type_name(nti.complete_name());
+
+    utility_.blank_line();
+    stream_ << indenter_ << "inline std::size_t hash_" << identifiable_type_name
+            << "(const " << type_name << "& v) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "std::size_t seed(0);"
+                << std::endl;
+
+        stream_ << indenter_
+                << "const boost::posix_time::ptime"
+                << " epoch(boost::gregorian::date(1970, 1, 1));"
+                << std::endl
+                << indenter_ << "boost::posix_time::time_duration d(v - epoch);"
+                << std::endl
+                << indenter_
+                << "seed = static_cast<std::size_t>(d.total_seconds());"
+                << std::endl;
+        stream_ << indenter_ << "return seed;" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_implementation::
+time_duration_helper(const nested_type_info& nti) {
+    const std::string identifiable_type_name(
+        nti.complete_identifiable_name());
+    const std::string type_name(nti.complete_name());
+
+    utility_.blank_line();
+    stream_ << indenter_ << "inline std::size_t hash_" << identifiable_type_name
+            << "(const " << type_name << "& v) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "std::size_t seed(0);"
+                << std::endl;
+
+        stream_ << indenter_
+                << "seed = static_cast<std::size_t>(v.total_seconds());"
+                << std::endl;
+        stream_ << indenter_ << "return seed;" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_implementation::
+recursive_helper_method_creator(const nested_type_info& nti,
+    std::unordered_set<std::string>& types_done) {
+    BOOST_LOG_SEV(lg, debug) << "Creating helper methods for " << nti.name();
+
+    if (types_done.find(nti.complete_identifiable_name()) != types_done.end())
+        return;
+
+    const auto children(nti.children());
+    for (const auto c : children)
+        recursive_helper_method_creator(c, types_done);
+
+    if (nti.is_sequence_container())
+        sequence_container_helper(nti);
+    else if (nti.is_associative_container())
+        associative_container_helper(nti);
+    else if (nti.is_smart_pointer())
+        smart_pointer_helper(nti);
+    else if (nti.is_pair())
+        pair_helper(nti);
+    else if (nti.is_optional_like())
+        optional_helper(nti);
+    else if (nti.is_variant_like())
+        variant_helper(nti);
+    else if (nti.is_ptime())
+        ptime_helper(nti);
+    else if (nti.is_time_duration())
+        time_duration_helper(nti);
+
+    types_done.insert(nti.complete_identifiable_name());
+}
+
+void hash_implementation::create_helper_methods(const class_info& ci) {
+    const auto props(ci.properties());
+    if (props.empty())
+        return;
+
+    std::unordered_set<std::string> types_done;
+    for (const auto p : props)
+        recursive_helper_method_creator(p.type(), types_done);
+}
+
+void hash_implementation::hasher_hash_method(const class_info& ci) {
+    BOOST_LOG_SEV(lg, debug) << "Creating hash method for " << ci.name();
+
+    const auto props(ci.properties());
+    const auto parents(ci.parents());
+    stream_ << indenter_ << "std::size_t " << ci.name() << "_hasher::"
+            << "hash(const "
+            << ci.name() << "&"
+            << (props.empty() && parents.empty() ? ") " : "v) ");
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+
+        stream_ << indenter_ << "std::size_t seed(0);" << std::endl;
+
+        const auto parents(ci.parents());
+        if (!parents.empty())
+            utility_.blank_line();
+
+        for (const auto p : parents) {
+            stream_ << indenter_ << "combine(seed, dynamic_cast<const ";
+            qname qname(stream_);
+            qname.format(p);
+            stream_ << "&>(v));" << std::endl;
+        }
+
+        if (!props.empty())
+            utility_.blank_line();
+
+        for (const auto p : props) {
+            if (p.type().is_filesystem_path()) {
+                stream_ << indenter_ << "combine(seed, v." << p.name()
+                        << "().generic_string());" << std::endl;
+            } else if (p.type().is_date()) {
+                    stream_ << indenter_ << "combine(seed, v." << p.name()
+                            << "().modjulian_day());" << std::endl;
+            } else if (is_hashable(p.type())) {
+                stream_ << indenter_ << "combine(seed, v." << p.name()
+                        << "());" << std::endl;
+            } else {
+                stream_ << indenter_ << "combine(seed, "
+                        << "hash_" << p.type().complete_identifiable_name()
+                        << "(v." << p.name()
+                        << "()));" << std::endl;
+            }
+        }
+
+        if (props.size() > 1)
+            utility_.blank_line();
+
+        stream_ << indenter_ << "return seed;" << std::endl;
+    }
+    utility_.close_scope();
+}
+
+void hash_implementation::format_class(const file_info& fi) {
+    boost::optional<class_info> o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+
+    const class_info& ci(*o);
+    {
+        namespace_helper nsh(stream_, std::list<std::string> { });
+        utility_.blank_line();
+        combine_function(ci);
+        create_helper_methods(ci);
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+    {
+        namespace_helper ns_helper(stream_, ci.namespaces());
+        utility_.blank_line();
+
+        hasher_hash_method(ci);
+        utility_.blank_line();
+    }
+    utility_.blank_line();
+}
+
+void hash_implementation::format_enumeration(const file_info&) {
+    BOOST_LOG_SEV(lg, error) << enum_info_not_supported;
+    BOOST_THROW_EXCEPTION(formatting_error(enum_info_not_supported));
+}
+
+void hash_implementation::format(const file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/header_guards.cpp b/projects/cpp_formatters/src/types/header_guards.cpp
index cfdeb94..add9558 100644
--- a/projects/cpp_formatters/src/types/header_guards.cpp
+++ b/projects/cpp_formatters/src/types/header_guards.cpp
@@ -1,2 +1,60 @@
-// dummy function to suppress ranlib warnings
-void header_guards() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <sstream>
+#include <ostream>
+#include <boost/algorithm/string.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include "dogen/cpp/types/formatters/header_guards.hpp"
+
+namespace {
+
+const std::string ifndef("#ifndef ");
+const std::string define("#define ");
+const std::string endif("#endif");
+
+const std::string msvc_line_1("#if defined(_MSC_VER) && (_MSC_VER >= 1200)");
+const std::string msvc_line_2("#pragma once");
+const std::string msvc_line_3("#endif");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+header_guards::header_guards(std::ostream& stream)
+    : stream_(stream) { }
+
+void header_guards::format_start(const std::string& guard_name) {
+    stream_ << ifndef << guard_name;
+    stream_ << std::endl << define << guard_name;
+
+    stream_ << std::endl << std::endl
+            << msvc_line_1 << std::endl
+            << msvc_line_2 << std::endl
+            << msvc_line_3 << std::endl;
+}
+
+void header_guards::format_end() {
+    stream_ << endif << std::endl;
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/include_cmakelists.cpp b/projects/cpp_formatters/src/types/include_cmakelists.cpp
index 8c18c13..90df5c0 100644
--- a/projects/cpp_formatters/src/types/include_cmakelists.cpp
+++ b/projects/cpp_formatters/src/types/include_cmakelists.cpp
@@ -1,2 +1,192 @@
-// dummy function to suppress ranlib warnings
-void include_cmakelists() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <sstream>
+#include <ostream>
+#include <boost/algorithm/string/case_conv.hpp>
+#include "dogen/cpp/types/formatters/include_cmakelists.hpp"
+
+namespace {
+
+const std::string empty("");
+const std::string underscore("_");
+const std::string unnamed_model("unnamed_model");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+include_cmakelists::
+include_cmakelists(std::ostream& stream, const bool odb_enabled,
+    const std::string odb_folder) : stream_(stream),
+                                    odb_enabled_(odb_enabled),
+                                    odb_folder_(odb_folder) {}
+
+void include_cmakelists::format(const cmakelists_info& ci) {
+    const std::string mn(ci.model_name().empty() ?
+        unnamed_model :
+        ci.model_name());
+
+    stream_ << "# -*- mode: cmake; tab-width: 4; indent-tabs-mode: nil -*-"
+            << std::endl
+            << "#" << std::endl
+            << "# Copyright (C) 2012 Kitanda <info@kitanda.co.uk>" << std::endl
+            << "#" << std::endl
+            << "# This program is free software; you can redistribute it and/or"
+            << " modify" << std::endl
+            << "# it under the terms of the GNU General Public License as"
+            << " published by" << std::endl
+            << "# the Free Software Foundation; either version 3 of the License"
+            << ", or" << std::endl
+            << "# (at your option) any later version." << std::endl
+            << "#" << std::endl
+            << "# This program is distributed in the hope that it will be "
+            << " useful," << std::endl
+            << "# but WITHOUT ANY WARRANTY; without even the implied warranty"
+            << " of" << std::endl
+            << "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the"
+            << std::endl
+            << "# GNU General Public License for more details." << std::endl
+            << "#" << std::endl
+            << "# You should have received a copy of the GNU General "
+            << "Public License" << std::endl
+            << "# along with this program; if not, write to the Free Software"
+            << std::endl
+            << "# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,"
+            << std::endl << "# MA 02110-1301, USA." << std::endl
+            << "#" << std::endl
+            << "add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/src)" << std::endl
+            << std::endl;
+
+    positive_indenter_scope s(indenter_);
+    stream_ << "install(" << std::endl
+            << indenter_ << "DIRECTORY include/" << std::endl
+            << indenter_ << "DESTINATION include/" << std::endl
+            << indenter_ << "COMPONENT headers" << std::endl
+            << indenter_ << "FILES_MATCHING PATTERN \"*.hpp\")"
+            << std::endl;
+
+    if (!odb_enabled_)
+        return;
+
+    stream_  << std::endl
+             << "set(include_dir \"${CMAKE_CURRENT_SOURCE_DIR}/include/"
+            << ci.product_name() << "/" << ci.model_name() << "\")"
+            << std::endl;
+
+    stream_ << "set(all_odb_files \"\")" << std::endl;
+    stream_ << "file(GLOB_RECURSE all_odb_files RELATIVE" << std::endl
+            << indenter_ << "\"${include_dir}/" << odb_folder_
+            << "/\"" << std::endl
+            << indenter_ << "\"${include_dir}/" << odb_folder_
+            << "/*_pragmas.hpp\")"
+            << std::endl << std::endl;
+
+    stream_ << "set(src_odb_dir \"${CMAKE_CURRENT_SOURCE_DIR}/src/"
+            << odb_folder_ << "/\")"
+            << std::endl
+            << "if(NOT EXISTS \"${src_odb_dir}\")" << std::endl
+            << indenter_ << "file(MAKE_DIRECTORY \"${src_odb_dir}\")"
+            << std::endl
+            << "endif()" << std::endl << std::endl;
+
+    stream_ << "add_custom_target(codegen_" << ci.model_name()
+            << "_" << odb_folder_ << std::endl
+            << indenter_ << "WORKING_DIRECTORY ${CMAKE_BINARY_DIR}" << std::endl
+            << indenter_
+            << "COMMAND mv ${CMAKE_CURRENT_SOURCE_DIR}/include/"
+            << ci.product_name() << "/"
+            << ci.model_name() << "/"
+            << odb_folder_ << "/*.cpp" << std::endl
+            << indenter_ << "${src_odb_dir})" << std::endl << std::endl;
+
+    stream_ << "set(ignore_file false)" << std::endl
+            << "foreach(odb_file ${all_odb_files})" << std::endl;
+
+    stream_ << indenter_ << "if (odb_file MATCHES \"all_pragmas.hpp\")"
+            << std::endl;
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "set(ignore_file true)" << std::endl;
+    }
+
+    stream_ << indenter_ << "endif()" << std::endl << std::endl
+            << indenter_ << "if(NOT ignore_file)" << std::endl;
+
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "set(type_name \"\")" << std::endl
+                << indenter_ << "string(REPLACE \"_pragmas.hpp\" \"\""
+                << " type_name ${odb_file})" << std::endl
+                << indenter_ << "string(REPLACE \"\\\\\" \"_\""
+                << " type_name ${type_name})" << std::endl
+                << indenter_ << "string(REPLACE \"/\" \"_\""
+                << " type_name ${type_name})" << std::endl << std::endl;
+
+        stream_ << indenter_ << "set(pfh_dir \"$ENV{PFH_LOCATION}\")"
+                << std::endl
+                << indenter_ << "set(target_name \"codegen_"
+                << ci.model_name() << "_odb_${type_name}\")" << std::endl
+                << indenter_ << "add_custom_target(${target_name}"
+                << std::endl;
+
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "WORKING_DIRECTORY ${CMAKE_BINARY_DIR}"
+                    << std::endl
+                    << indenter_ << "COMMAND odb" << std::endl
+                    << indenter_
+                    << "--options-file ${CMAKE_CURRENT_SOURCE_DIR}/src/"
+                    << "options.odb"
+                    << std::endl
+                    << indenter_ << "--std c++11" << std::endl
+                    << indenter_
+                    << "--output-dir ${CMAKE_CURRENT_SOURCE_DIR}/include/"
+                    << ci.product_name() << "/" << ci.model_name()
+                    << "/" << odb_folder_ << "/" << std::endl
+                    << indenter_
+                    << "--odb-epilogue '\\#include \\\""
+                    << ci.product_name() << "/" << ci.model_name()
+                    << "/" << odb_folder_ << "/${odb_file}\\\"'" << std::endl
+                    << indenter_
+                    << "-I ${pfh_dir}/include -I ${CMAKE_CURRENT_SOURCE_DIR}"
+                    << "/include" << std::endl
+                    << indenter_
+                    << "${include_dir}/types/${type_name}.hpp)" << std::endl
+                    << std::endl;
+        }
+
+        stream_ << indenter_
+                << "add_dependencies(codegen_" << ci.model_name()
+                << "_odb ${target_name})" << std::endl;
+    }
+    stream_ << indenter_ << "endif()" << std::endl
+            << indenter_
+            << "add_dependencies(codegen_" << ci.model_name() << "_odb "
+            << "codegen_" << ci.model_name() << ")"
+            << std::endl
+            << indenter_ << "set(ignore_file false)" << std::endl;
+
+    stream_ << "endforeach()" << std::endl;
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/includes.cpp b/projects/cpp_formatters/src/types/includes.cpp
index 0dab51d..b5f51df 100644
--- a/projects/cpp_formatters/src/types/includes.cpp
+++ b/projects/cpp_formatters/src/types/includes.cpp
@@ -1,2 +1,77 @@
-// dummy function to suppress ranlib warnings
-void includes() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include "dogen/cpp/types/boost_model_helper.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+
+namespace {
+
+const bool is_system(true);
+const bool is_user(false);
+
+const std::string include("#include ");
+const std::string open_system("<");
+const std::string close_system(">");
+const std::string open_user("\"");
+const std::string close_user("\"");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+includes::includes(std::ostream& stream, const bool blank_line)
+    : stream_(stream), utility_(stream_, indenter_), blank_line_(blank_line) { }
+
+void includes::format(std::list<std::string> v, bool is_system) {
+    v.sort();
+
+    // FIXME: hacks for headers that must be last
+    boost_model_helper boost_;
+    const auto gd(boost_.include(boost_types::serialization_gregorian_date));
+    const auto i(std::find(v.begin(), v.end(), gd));
+    if (i != v.end())
+        v.splice(v.end(), v, i);
+
+    for (auto i : v) {
+        stream_ << include << (is_system ? open_system : open_user)
+                << i
+                << (is_system ? close_system : close_user)
+                << std::endl;
+    }
+}
+
+void includes::format(const file_info& fi) {
+    const auto sys(fi.system_includes());
+    const auto usr(fi.user_includes());
+
+    if (sys.empty() && usr.empty())
+        return;
+
+    format(fi.system_includes(), is_system);
+    format(fi.user_includes(), is_user);
+
+    if (blank_line_)
+        utility_.blank_line();
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/indenter.cpp b/projects/cpp_formatters/src/types/indenter.cpp
index 6068e06..f158fe3 100644
--- a/projects/cpp_formatters/src/types/indenter.cpp
+++ b/projects/cpp_formatters/src/types/indenter.cpp
@@ -1,2 +1,44 @@
-// dummy function to suppress ranlib warnings
-void indenter() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <string>
+#include "dogen/cpp/types/formatters/indenter.hpp"
+
+namespace  {
+const std::string one_indent("    ");
+}
+
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+void indenter::to_stream(std::ostream& stream) const {
+    for (unsigned int i(0); i < indent_level_; ++i)
+        stream << one_indent;
+}
+
+std::ostream& operator<<(std::ostream& stream, indenter indenter) {
+    indenter.to_stream(stream);
+    return stream;
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/inserter_implementation.cpp b/projects/cpp_formatters/src/types/inserter_implementation.cpp
index 8fd8d47..fd32bab 100644
--- a/projects/cpp_formatters/src/types/inserter_implementation.cpp
+++ b/projects/cpp_formatters/src/types/inserter_implementation.cpp
@@ -1,2 +1,716 @@
-// dummy function to suppress ranlib warnings
-void inserter_implementation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <sstream>
+#include <boost/throw_exception.hpp>
+#include "dogen/cpp/types/formatters/qname.hpp"
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/types/formatters/inserter_implementation.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.inserter_implementation"));
+
+// FIXME: until we add support to indenter.
+const std::string special_indent("  ");
+const std::string parent("__parent_");
+const std::string type("__type__");
+const std::string inserter("<< ");
+const std::string space_inserter(" << ");
+const std::string open_bracket(" {");
+const std::string close_bracket(" }");
+const std::string colon(": ");
+const std::string semi_colon(";");
+const std::string space(" ");
+const std::string underscore("_");
+const std::string spaced_comma(", ");
+
+const std::string invalid_sequence_container(
+    "Sequence containers have exactly one type argument");
+const std::string invalid_optional_type(
+    "Optional types have exactly one type argument");
+const std::string invalid_associative_container(
+    "Associative containers have one or two type arguments");
+const std::string invalid_smart_pointer(
+    "Smart pointers have exactly one type argument");
+const std::string invalid_variant("Variants should have at least one type");
+const std::string invalid_pair_type(
+    "Pair types have exactly two type arguments");
+
+std::string parent_tag(const unsigned int number) {
+    std::ostringstream s;
+    s << parent << number << underscore << underscore;
+    return s.str();
+}
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+inserter_implementation::
+inserter_implementation(std::ostream& stream, indenter& indenter,
+    const bool is_inside_class)
+    : is_inside_class_(is_inside_class), stream_(stream), indenter_(indenter),
+      utility_(stream_, indenter_) {
+}
+
+bool inserter_implementation::
+is_insertable(const nested_type_info& nti) {
+    return !nti.is_sequence_container() && !nti.is_associative_container();
+}
+
+void inserter_implementation::
+sequence_container_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 1) {
+        BOOST_LOG_SEV(lg, error) << invalid_sequence_container;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_sequence_container));
+    }
+
+    const auto container(nti);
+    const auto containee(children.front());
+
+    {
+        namespace_helper ns_helper(stream_, container.namespaces());
+
+        utility_.blank_line();
+        stream_ << indenter_ << "inline std::ostream& operator<<"
+                << "(std::ostream& s, const "
+                << container.complete_name() << "& v) ";
+
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote("[ ") << ";" << std::endl;
+            stream_ << indenter_
+                    << "for (auto i(v.begin()); i != v.end(); ++i) ";
+            utility_.open_scope();
+            {
+                positive_indenter_scope s(indenter_);
+                stream_ << indenter_ << "if (i != v.begin()) s" << space_inserter
+                        << utility_.quote(", ") << ";" << std::endl;
+
+                if (containee.is_string_like()) {
+                    const std::string tus(nti.is_char_like() ? "*i" :
+                        "tidy_up_string(*i)");
+                    stream_ << indenter_ << "s" << space_inserter
+                            << utility_.quote_escaped_streamed(tus)
+                            << ";" << std::endl;
+                } else
+                    stream_ << indenter_ << "s << *i;" << std::endl;
+            }
+            utility_.close_scope();
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote("] ") << ";" << std::endl;
+            stream_ << indenter_ << "return s;" << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void inserter_implementation::
+associative_container_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 1 && children.size() != 2) {
+        BOOST_LOG_SEV(lg, error) << invalid_associative_container;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_associative_container));
+    }
+
+    if (children.size() == 1) {
+        sequence_container_helper(nti);
+        return;
+    }
+
+    const auto container(nti);
+    {
+        namespace_helper ns_helper(stream_, container.namespaces());
+
+        utility_.blank_line();
+        stream_ << indenter_ << "inline std::ostream& operator<<"
+                << "(std::ostream& s, const "
+                << container.complete_name() << "& v) ";
+
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote("[") << ";" << std::endl;
+            stream_ << indenter_
+                    << "for (auto i(v.begin()); i != v.end(); ++i) ";
+            utility_.open_scope();
+            {
+                positive_indenter_scope s(indenter_);
+                stream_ << indenter_ << "if (i != v.begin()) s" << space_inserter
+                        << utility_.quote(", ") << ";" << std::endl;
+
+
+                stream_ << indenter_ << "s" << space_inserter
+                        << utility_.quote("[ { ") << space_inserter
+                        << utility_.quote(utility_.quote_escaped(type) + colon)
+                        << space_inserter
+                        << utility_.quote(utility_.quote_escaped("key"))
+                        << space_inserter << utility_.quote(spaced_comma)
+                        << space_inserter
+                        << utility_.quote(utility_.quote_escaped("data") +
+                            colon) << ";" << std::endl;
+
+                const auto key(children.front());
+                if (key.is_string_like()) {
+                    const std::string tus(nti.is_char_like() ? "i->first" :
+                        "tidy_up_string(i->first)");
+                    stream_ << indenter_ << "s" << space_inserter
+                            << utility_.quote_escaped_streamed(tus)
+                            << ";" << std::endl;
+                } else
+                    stream_ << indenter_ << "s << i->first;" << std::endl;
+
+                stream_ << indenter_ << "s" << space_inserter
+                        << utility_.quote(" }, { ") << space_inserter
+                        << utility_.quote(utility_.quote_escaped(type) + colon)
+                        << space_inserter
+                        << utility_.quote(utility_.quote_escaped("value"))
+                        << space_inserter << utility_.quote(spaced_comma)
+                        << space_inserter
+                        << utility_.quote(utility_.quote_escaped("data") +
+                            colon) << ";" << std::endl;
+
+                const auto value(children.back());
+                if (value.is_string_like()) {
+                    const std::string tus(nti.is_char_like() ? "i->second" :
+                        "tidy_up_string(i->second)");
+                    stream_ << indenter_ << "s" << space_inserter
+                            << utility_.quote_escaped_streamed(tus)
+                            << ";" << std::endl;
+                } else
+                    stream_ << indenter_ << "s << i->second;" << std::endl;
+
+                stream_ << indenter_ << "s" << space_inserter
+                        << utility_.quote(" } ]") << ";"
+                        << std::endl;
+            }
+            utility_.close_scope();
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote(" ] ") << ";" << std::endl;
+            stream_ << indenter_ << "return s;" << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void inserter_implementation::
+smart_pointer_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 1) {
+        BOOST_LOG_SEV(lg, error) << invalid_smart_pointer;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_smart_pointer));
+    }
+
+    const auto container(nti);
+    {
+        namespace_helper ns_helper(stream_, container.namespaces());
+
+        utility_.blank_line();
+        stream_ << indenter_ << "inline std::ostream& operator<<"
+                << "(std::ostream& s, const "
+                << container.complete_name() << "& v) ";
+
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote("{ ") << space_inserter
+                    << utility_.quote(utility_.quote_escaped(type) + colon)
+                    << space_inserter
+                    << utility_.quote(utility_.quote_escaped(nti.name()))
+                    << space_inserter << utility_.quote(spaced_comma)
+                    << std::endl;
+
+            stream_ << indenter_ << special_indent << inserter
+                    << utility_.quote(utility_.quote_escaped("memory") +
+                        colon)
+                    << space_inserter
+                    << utility_.quote_escaped_streamed(
+                        "static_cast<void*>(v.get())")
+                    << space_inserter << utility_.quote(spaced_comma) << ";"
+                    << std::endl;
+
+            utility_.blank_line();
+            stream_ << indenter_ << "if (v)" << std::endl;
+            {
+                positive_indenter_scope s(indenter_);
+                const auto containee(children.front());
+                stream_ << indenter_ << "s" << space_inserter
+                        << utility_.quote(utility_.quote_escaped("data") +
+                            colon);
+                if (containee.is_string_like()) {
+                    const std::string tus(nti.is_char_like() ? "*v" :
+                        "tidy_up_string(*v)");
+
+                    stream_ << space_inserter
+                            << utility_.quote_escaped_streamed(tus)
+                            << ";" << std::endl;
+                } else
+                    stream_ << space_inserter << "*v;" << std::endl;
+            }
+            stream_ << indenter_ << "else" << std::endl;
+            {
+                positive_indenter_scope s(indenter_);
+
+                stream_ << indenter_ << "s" << space_inserter
+                        << utility_.quote(utility_.quote_escaped("data") +
+                            colon)
+                        << utility_.quote(utility_.quote_escaped("<empty>"))
+                        << ";" << std::endl;
+            }
+            stream_ << indenter_ << "s" << inserter << utility_.quote(" }")
+                    << ";";
+            utility_.blank_line();
+            stream_ << indenter_ << "return s;" << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void inserter_implementation::
+optional_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 1) {
+        BOOST_LOG_SEV(lg, error) << invalid_optional_type;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_optional_type));
+    }
+
+    const auto container(nti);
+    {
+        namespace_helper ns_helper(stream_, container.namespaces());
+
+        utility_.blank_line();
+        stream_ << indenter_ << "inline std::ostream& operator<<"
+                << "(std::ostream& s, const "
+                << container.complete_name() << "& v) ";
+
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote("{ ") << space_inserter
+                    << utility_.quote(utility_.quote_escaped(type) + colon)
+                    << space_inserter
+                    << utility_.quote(utility_.quote_escaped(nti.name()))
+                    << space_inserter << utility_.quote(spaced_comma)
+                    << ";"
+                    << std::endl;
+
+            utility_.blank_line();
+            stream_ << indenter_ << "if (v)" << std::endl;
+            {
+                positive_indenter_scope s(indenter_);
+                const auto containee(children.front());
+                stream_ << indenter_ << "s" << space_inserter
+                        << utility_.quote(utility_.quote_escaped("data") +
+                            colon);
+
+                if (containee.is_string_like()) {
+                    const std::string tus(nti.is_char_like() ? "*v" :
+                        "tidy_up_string(*v)");
+
+                    stream_ << space_inserter
+                            << utility_.quote_escaped_streamed(tus)
+                            << ";" << std::endl;
+                } else
+                    stream_ << space_inserter << "*v;" << std::endl;
+            }
+            stream_ << indenter_ << "else" << std::endl;
+            {
+                positive_indenter_scope s(indenter_);
+
+                stream_ << indenter_ << "s" << space_inserter
+                        << utility_.quote(utility_.quote_escaped("data") +
+                            colon)
+                        << utility_.quote(utility_.quote_escaped("<empty>"))
+                        << ";" << std::endl;
+            }
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote(" }")
+                    << ";";
+            utility_.blank_line();
+            stream_ << indenter_ << "return s;" << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void inserter_implementation::
+pair_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.size() != 2) {
+        BOOST_LOG_SEV(lg, error) << invalid_pair_type;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_pair_type));
+    }
+
+    const auto container(nti);
+    {
+        namespace_helper ns_helper(stream_, container.namespaces());
+
+        utility_.blank_line();
+        stream_ << indenter_ << "inline std::ostream& operator<<"
+                << "(std::ostream& s, const "
+                << container.complete_name() << "& v) ";
+
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote("{ ") << space_inserter
+                    << utility_.quote(utility_.quote_escaped(type) + colon)
+                    << space_inserter
+                    << utility_.quote(utility_.quote_escaped(nti.name()))
+                    << space_inserter << utility_.quote(spaced_comma)
+                    << ";"
+                    << std::endl;
+
+            utility_.blank_line();
+            const auto first(children.front());
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote(utility_.quote_escaped("first") + colon);
+
+            if (first.is_string_like()) {
+                const std::string tus(nti.is_char_like() ? "v.first" :
+                    "tidy_up_string(v.first)");
+
+                stream_ << space_inserter
+                        << utility_.quote_escaped_streamed(tus)
+                        << space_inserter << utility_.quote(spaced_comma)
+                        << ";" << std::endl;
+            } else
+                stream_ << space_inserter << "v.first"
+                        << space_inserter << utility_.quote(spaced_comma) << ";"
+                        << std::endl;
+
+            const auto second(children.back());
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote(utility_.quote_escaped("second") + colon);
+
+            if (second.is_string_like()) {
+                const std::string tus(nti.is_char_like() ? "v.second" :
+                    "tidy_up_string(v.second)");
+
+                stream_ << space_inserter
+                        << utility_.quote_escaped_streamed(tus)
+                        << ";" << std::endl;
+            } else
+                stream_ << space_inserter << "v.second;" << std::endl;
+
+            stream_ << indenter_ << "s" << space_inserter
+                    << utility_.quote(" }")
+                    << ";";
+            utility_.blank_line();
+            stream_ << indenter_ << "return s;" << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void inserter_implementation::
+variant_helper(const nested_type_info& nti) {
+    const auto children(nti.children());
+    if (children.empty()) {
+        BOOST_LOG_SEV(lg, error) << invalid_variant;
+        BOOST_THROW_EXCEPTION(formatting_error(invalid_variant));
+    }
+
+    const auto container(nti);
+    {
+        namespace_helper ns_helper(stream_, container.namespaces());
+
+        utility_.blank_line();
+        stream_ << indenter_
+                << "struct " << nti.complete_identifiable_name()
+                << "_visitor : public boost::static_visitor<> ";
+
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << nti.complete_identifiable_name()
+                    << "_visitor(std::ostream& s) : stream_(s) ";
+            utility_.open_scope();
+            {
+                positive_indenter_scope s(indenter_);
+                stream_ << indenter_ << "s" << space_inserter
+                        << utility_.quote("{ ") << space_inserter
+                        << utility_.quote(utility_.quote_escaped(type) + colon)
+                        << space_inserter
+                        << utility_.quote(utility_.quote_escaped(nti.name()))
+                        << space_inserter << utility_.quote(spaced_comma)
+                        << ";"
+                        << std::endl;
+
+                stream_ << indenter_ << "s" << space_inserter
+                        << utility_.quote(utility_.quote_escaped("data") +
+                            colon) << ";" << std::endl;
+            }
+            utility_.close_scope();
+            utility_.blank_line();
+
+            stream_ << indenter_ << "~" << nti.complete_identifiable_name()
+                    << "_visitor() { stream_" << space_inserter
+                    << utility_.quote(" }") << "; }" << std::endl;
+            utility_.blank_line();
+
+            for (const auto& c : children) {
+                stream_ << indenter_
+                        << "void operator()(const " << c.name()
+                        << (c.is_primitive() ? "" : "&")
+                        << " v) const ";
+
+                utility_.open_scope();
+                {
+                    positive_indenter_scope s(indenter_);
+                    if (c.is_primitive()) {
+                        stream_ << indenter_ << "stream_" << space_inserter
+                                << utility_.quote("{ ") << space_inserter
+                                << utility_.quote(utility_.quote_escaped(type) +
+                                    colon)
+                                << space_inserter
+                                << utility_.quote(utility_.quote_escaped(
+                                        c.name()))
+                                << space_inserter << utility_.quote(
+                                    spaced_comma)
+                                << ";" << std::endl;
+
+                        stream_ << indenter_ << "stream_" << space_inserter
+                                << utility_.quote(utility_.quote_escaped("value")
+                                    + colon)
+                                << ";"
+                                << std::endl;
+
+                        stream_ << indenter_ << "stream_" << space_inserter
+                                << "v;" << std::endl;
+
+                        stream_ << indenter_ << "stream_" << space_inserter
+                                << utility_.quote(" }") << ";"
+                                << std::endl;
+                    } else
+                        stream_ << indenter_ << "stream_ << v;" << std::endl;
+                }
+                utility_.close_scope();
+                utility_.blank_line();
+            }
+            utility_.private_access_specifier();
+            stream_ << indenter_ << "std::ostream& stream_;" << std::endl;
+        }
+        stream_ << indenter_ << "};" << std::endl;
+
+        utility_.blank_line();
+        stream_ << indenter_ << "inline std::ostream& operator<<"
+                << "(std::ostream& s, const "
+                << container.complete_name() << "& v) ";
+
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_
+                    << "boost::apply_visitor("
+                    << nti.complete_identifiable_name()
+                    << "_visitor(s), v);" << std::endl;
+            stream_ << indenter_ << "return s;" << std::endl;
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void inserter_implementation::tidy_up_string_method() {
+    utility_.blank_line();
+    stream_ << indenter_ << "inline std::string tidy_up_string"
+            << "(std::string s) ";
+
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_
+                << "boost::replace_all(s, \"\\r\\n\", \"<new_line>\");"
+                << std::endl
+                << indenter_
+                << "boost::replace_all(s, \"\\n\", \"<new_line>\");"
+                << std::endl
+                << indenter_
+                << "boost::replace_all(s, \"\\\"\", \"<quote>\");"
+                << std::endl
+                << indenter_ << "return s;"
+                << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void inserter_implementation::
+recursive_helper_method_creator(const nested_type_info& nti,
+    std::unordered_set<std::string>& types_done) {
+
+    if (types_done.find(nti.complete_identifiable_name()) != types_done.end())
+        return;
+
+    const auto children(nti.children());
+    for (const auto c : children)
+        recursive_helper_method_creator(c, types_done);
+
+    if (nti.is_sequence_container())
+        sequence_container_helper(nti);
+    else if (nti.is_associative_container())
+        associative_container_helper(nti);
+    else if (nti.is_smart_pointer())
+        smart_pointer_helper(nti);
+    else if (nti.is_optional_like())
+        optional_helper(nti);
+    else if (nti.is_pair())
+        pair_helper(nti);
+    else if (nti.is_variant_like())
+        variant_helper(nti);
+    else if (nti.is_string_like() && !nti.is_char_like())
+        tidy_up_string_method();
+
+    types_done.insert(nti.complete_identifiable_name());
+}
+
+void inserter_implementation::
+format_helper_methods(const class_info& ci) {
+    const auto props(ci.properties());
+    if (props.empty())
+        return;
+
+    std::unordered_set<std::string> types_done;
+    for (const auto p : props)
+        recursive_helper_method_creator(p.type(), types_done);
+}
+
+void inserter_implementation::
+format_inserter_implementation(const class_info& ci) {
+    if (ci.requires_stream_manipulators()) {
+        stream_ << indenter_ << "boost::io::ios_flags_saver ifs(s);"
+                << std::endl
+                << indenter_ << "s.setf(std::ios_base::boolalpha);"
+                << std::endl
+                << indenter_ << "s.setf(std::ios::fixed, std::ios::floatfield);"
+                << std::endl
+                << indenter_ << "s.precision(6);"
+                << std::endl
+                << indenter_ << "s.setf(std::ios::showpoint);"
+                << std::endl;
+        utility_.blank_line();
+    }
+
+    stream_ << indenter_ << "s " << inserter
+            << utility_.quote(" { ")
+            << std::endl;
+
+    std::ostringstream ss;
+    qname qname(ss);
+    qname.format(ci);
+
+    stream_ << indenter_ << special_indent << inserter
+            << utility_.quote(utility_.quote_escaped(type) + colon)
+            << space_inserter
+            << utility_.quote(utility_.quote_escaped(ss.str()));
+
+    unsigned int i(0);
+    const auto parents(ci.parents());
+    for (const auto p : parents) {
+        if (i != 0)
+            stream_ << indenter_ << "s";
+
+        stream_ << space_inserter << utility_.quote(spaced_comma) << std::endl;
+
+        stream_ << indenter_ << special_indent << inserter
+                << utility_.quote(utility_.quote_escaped(parent_tag(i)) +
+                    colon) << semi_colon << std::endl;
+
+        stream_ << indenter_ << p.name() << "::to_stream(s);" << std::endl;
+        ++i;
+    }
+
+    const auto props(ci.properties());
+    if (!parents.empty())
+        stream_ << indenter_ << "s";
+
+    for (const auto p : props) {
+        stream_ << space_inserter << utility_.quote(spaced_comma) << std::endl;
+
+        stream_ << indenter_ << special_indent << inserter
+                << utility_.quote(utility_.quote_escaped(p.name())
+                    + colon) << space_inserter;
+
+        std::ostringstream ss;
+        if (p.type().is_string_like() && !p.type().is_char_like())
+            ss << "tidy_up_string(";
+
+        if (is_inside_class_)
+            ss << utility_.as_member_variable(p.name());
+        else
+            ss << "v." << utility_.as_getter(p.name());
+
+        if (p.type().is_filesystem_path()) {
+            ss << ".generic_string()";
+            stream_ << utility_.quote_escaped_streamed(ss.str());
+        } else if (p.type().is_date() || p.type().is_ptime() ||
+            p.type().is_time_duration()) {
+            stream_ << utility_.quote_escaped_streamed(ss.str());
+        } else if (p.type().is_string_like()) {
+
+            if (!p.type().is_char_like())
+                ss << ")";
+
+            stream_ << utility_.quote_escaped_streamed(ss.str());
+        } else if (p.type().is_primitive())
+            stream_ << ss.str();
+        else
+            stream_ << ss.str();
+    }
+
+    if (!props.empty()) {
+        stream_ << std::endl
+                << indenter_ << special_indent << inserter;
+    } else
+        stream_ << space_inserter;
+
+    stream_ << utility_.quote(close_bracket) << semi_colon << std::endl;
+    if (!is_inside_class_)
+        stream_ << indenter_ << "return(s);" << std::endl;
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/io_header.cpp b/projects/cpp_formatters/src/types/io_header.cpp
index a860306..0ab526c 100644
--- a/projects/cpp_formatters/src/types/io_header.cpp
+++ b/projects/cpp_formatters/src/types/io_header.cpp
@@ -1,2 +1,129 @@
-// dummy function to suppress ranlib warnings
-void io_header() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/qname.hpp"
+#include "dogen/cpp/types/formatters/licence.hpp"
+#include "dogen/cpp/types/formatters/io_header.hpp"
+#include "dogen/cpp/types/formatters/header_guards.hpp"
+#include "dogen/cpp/types/formatters/namespace_formatter.hpp"
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.io_header"));
+
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+io_header::
+io_header(std::ostream& stream) :
+    stream_(stream),
+    utility_(stream_, indenter_) {
+}
+
+file_formatter::shared_ptr io_header::create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new io_header(stream));
+}
+
+void io_header::format_class(const file_info& fi) {
+    boost::optional<class_info> o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+
+    {
+        const class_info& ci(*o);
+        namespace_helper helper1(stream_, ci.namespaces());
+        utility_.blank_line();
+
+        stream_ << indenter_ << "std::ostream&" << std::endl
+                << indenter_ << "operator<<(std::ostream& s,"
+                << std::endl;
+
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << " const ";
+
+            qname qname(stream_);
+            qname.format(ci);
+            stream_ << "& v);" << std::endl;
+            utility_.blank_line();
+        }
+    }
+    utility_.blank_line(2);
+}
+
+void io_header::format_enumeration(const file_info& fi) {
+    const auto o(fi.enum_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_enum_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_enum_info));
+    }
+
+    const auto ei(*o);
+    {
+        namespace_helper ns_helper(stream_, ei.namespaces());
+        utility_.blank_line();
+
+        stream_ << indenter_ << "std::ostream& operator<<(std::ostream& s, "
+                << "const " << ei.name() << "& v);" << std::endl;
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void io_header::format(const file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    header_guards guards(stream_);
+    guards.format_start(fi.header_guard());
+    utility_.blank_line();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+
+    guards.format_end();
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/io_implementation.cpp b/projects/cpp_formatters/src/types/io_implementation.cpp
index ff6f16c..b2fed8d 100644
--- a/projects/cpp_formatters/src/types/io_implementation.cpp
+++ b/projects/cpp_formatters/src/types/io_implementation.cpp
@@ -1,2 +1,191 @@
-// dummy function to suppress ranlib warnings
-void io_implementation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/inserter_implementation.hpp"
+#include "dogen/cpp/types/formatters/header_guards.hpp"
+#include "dogen/cpp/types/formatters/licence.hpp"
+#include "dogen/cpp/types/formatters/namespace_formatter.hpp"
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+#include "dogen/cpp/types/formatters/indenter.hpp"
+#include "dogen/cpp/types/formatters/utility.hpp"
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/types/formatters/io_implementation.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.io_implementation"));
+
+const std::string ostream("ostream");
+const std::string spaced_inserter(" << ");
+const std::string type("__type__");
+const std::string colon(": ");
+const std::string comma(", ");
+const std::string semi_colon(";");
+
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+io_implementation::
+io_implementation(std::ostream& stream) :
+    stream_(stream),
+    utility_(stream_, indenter_) { }
+
+file_formatter::shared_ptr io_implementation::create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new io_implementation(stream));
+}
+
+void io_implementation::io_helper_methods(const class_info& ci) {
+    if (ci.is_parent() || !ci.parents().empty())
+        return;
+
+    const bool inside_class(false);
+    inserter_implementation i(stream_, indenter_, inside_class);
+    i.format_helper_methods(ci);
+}
+
+void io_implementation::format_enumeration(const file_info& fi) {
+    const auto o(fi.enum_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_enum_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_enum_info));
+    }
+
+    const auto ei(*o);
+    namespace_helper ns_helper(stream_, ei.namespaces());
+    utility_.blank_line();
+
+    stream_ << "std::ostream& operator<<(std::ostream& s, "
+            << "const " << ei.name() << "& v) ";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "s" << spaced_inserter
+                << utility_.quote("{ ") << spaced_inserter
+                << utility_.quote(utility_.quote_escaped(type) + colon);
+
+        stream_ << spaced_inserter
+                << utility_.quote(utility_.quote_escaped(ei.name()) + comma)
+                << spaced_inserter
+                << utility_.quote(utility_.quote_escaped("value") + colon)
+                << ";" << std::endl;
+        utility_.blank_line();
+
+        stream_ << indenter_ << "std::string attr;" << std::endl;
+        stream_ << indenter_ << "switch (v) ";
+        utility_.open_scope();
+        {
+            for (const auto e : ei.enumerators()) {
+                stream_ << indenter_ << "case " << ei.name()
+                        << "::" << e.name() << ":"
+                        << std::endl;
+                {
+                    positive_indenter_scope s(indenter_);
+                    stream_ << indenter_ << "attr = "
+                            << utility_.quote(utility_.quote_escaped(e.name()))
+                            << semi_colon
+                            << std::endl
+                            << indenter_ << "break;" << std::endl;
+                }
+            }
+            stream_ << indenter_ << "default:" << std::endl;
+            {
+                positive_indenter_scope s(indenter_);
+                stream_ << indenter_ << "throw std::invalid_argument("
+                        << "\"Invalid value for " << ei.name() << "\");"
+                        << std::endl;
+            }
+            utility_.close_scope();
+        }
+        stream_ << indenter_ << "s" << spaced_inserter
+                << "attr"
+                << spaced_inserter << utility_.quote(" }")
+                << semi_colon
+                << std::endl
+                << indenter_ << "return s;" << std::endl;
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void io_implementation::format_class(const file_info& fi) {
+    const auto o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+
+    const class_info& ci(*o);
+    io_helper_methods(ci);
+
+    namespace_helper ns_helper(stream_, ci.namespaces());
+    utility_.blank_line();
+
+    stream_ << "std::ostream& operator<<(std::ostream& s, ";
+    {
+        positive_indenter_scope s(indenter_);
+        const auto parents(ci.parents());
+        const bool no_arg(!ci.is_parent() && parents.empty() &&
+            ci.properties().empty());
+        stream_ << "const " << ci.name() << "&" << (no_arg ? ") " : " v) ");
+        utility_.open_scope();
+
+        if (ci.is_parent() || !parents.empty()) {
+            stream_ << indenter_ << "v.to_stream(s);" << std::endl
+                    << indenter_ << "return(s);" << std::endl;
+        } else {
+            const bool inside_class(false);
+            inserter_implementation i(stream_, indenter_, inside_class);
+            i.format_inserter_implementation(ci);
+        }
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void io_implementation::format(const file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/key_class_declaration.cpp b/projects/cpp_formatters/src/types/key_class_declaration.cpp
index ab58cef..2032e7b 100644
--- a/projects/cpp_formatters/src/types/key_class_declaration.cpp
+++ b/projects/cpp_formatters/src/types/key_class_declaration.cpp
@@ -1,2 +1,61 @@
-// dummy function to suppress ranlib warnings
-void key_class_declaration() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include "dogen/cpp/types/formatters/key_class_declaration.hpp"
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+key_class_declaration::
+key_class_declaration(std::ostream& stream,
+    const bool disable_complete_constructor, const bool disable_io,
+    const bool disable_serialization)
+    : class_declaration(stream, disable_serialization),
+      disable_complete_constructor_(disable_complete_constructor),
+      disable_io_(disable_io) {}
+
+void key_class_declaration::
+hand_crafted_constructors(const class_info& ci) {
+    default_constructor(ci);
+    destructor(ci);
+    if (!disable_complete_constructor_)
+        complete_constructor(ci);
+}
+
+void key_class_declaration::format(const class_info& ci) {
+    open_class(ci);
+    {
+        positive_indenter_scope s(indenter_);
+        compiler_generated_constuctors(ci);
+        hand_crafted_constructors(ci);
+        friends(ci);
+        if (!disable_io_)
+            to_stream(ci);
+        getters_and_setters(ci);
+        equality(ci);
+        swap_and_assignment(ci);
+        member_variables(ci);
+    }
+    close_class();
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/key_class_implementation.cpp b/projects/cpp_formatters/src/types/key_class_implementation.cpp
index 00c5f9e..06baaba 100644
--- a/projects/cpp_formatters/src/types/key_class_implementation.cpp
+++ b/projects/cpp_formatters/src/types/key_class_implementation.cpp
@@ -1,2 +1,52 @@
-// dummy function to suppress ranlib warnings
-void key_class_implementation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <iostream>
+#include "dogen/cpp/types/formatters/key_class_implementation.hpp"
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+key_class_implementation::
+key_class_implementation(std::ostream& stream,
+    bool disable_complete_constructor, bool disable_io) :
+    class_implementation(stream),
+    disable_complete_constructor_(disable_complete_constructor),
+    disable_io_(disable_io) { }
+
+void key_class_implementation::
+hand_crafted_constructors(const class_info& ci) {
+    default_constructor(ci);
+    if (!disable_complete_constructor_)
+        complete_constructor(ci);
+}
+
+void key_class_implementation::format(const class_info& ci) {
+    hand_crafted_constructors(ci);
+    if (!disable_io_)
+        to_stream(ci);
+    swap(ci);
+    equals_operator(ci);
+    assignment_operator(ci);
+    getters_and_setters(ci);
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/licence.cpp b/projects/cpp_formatters/src/types/licence.cpp
index 2936184..f07ee58 100644
--- a/projects/cpp_formatters/src/types/licence.cpp
+++ b/projects/cpp_formatters/src/types/licence.cpp
@@ -1,2 +1,64 @@
-// dummy function to suppress ranlib warnings
-void licence() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include "dogen/cpp/types/formatters/licence.hpp"
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+licence::licence(std::ostream& stream)
+    : stream_(stream) { }
+
+void licence::format() {
+    stream_ << "/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil;"
+            << " c-basic-offset: 4 -*-" << std::endl
+            << " *" << std::endl
+            << " * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>" << std::endl
+            << " *" << std::endl
+            << " * This program is free software; you can redistribute it and/"
+            << "or modify" << std::endl
+            << " * it under the terms of the GNU General Public License as "
+            << "published by" << std::endl
+            << " * the Free Software Foundation; either version 3 of the "
+            << "License, or" << std::endl
+            << " * (at your option) any later version." << std::endl
+            << " *" << std::endl
+            << " * This program is distributed in the hope that it will be"
+            << " useful," << std::endl
+            << " * but WITHOUT ANY WARRANTY; without even the implied warranty "
+            << "of" << std::endl
+            << " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See"
+            << " the" << std::endl
+            << " * GNU General Public License for more details." << std::endl
+            << " *" << std::endl
+            << " * You should have received a copy of the GNU General Public"
+            << " License" << std::endl
+            << " * along with this program; if not, write to the Free Software"
+            << std::endl
+            << " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,"
+            << std::endl
+            << " * MA 02110-1301, USA." << std::endl
+            << " *" << std::endl
+            << " */" << std::endl;
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/namespace_documentation.cpp b/projects/cpp_formatters/src/types/namespace_documentation.cpp
index 47c0482..ce94cba 100644
--- a/projects/cpp_formatters/src/types/namespace_documentation.cpp
+++ b/projects/cpp_formatters/src/types/namespace_documentation.cpp
@@ -1,2 +1,110 @@
-// dummy function to suppress ranlib warnings
-void namespace_documentation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/cpp/types/formatters/doxygen_comments.hpp"
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/qname.hpp"
+#include "dogen/cpp/types/formatters/licence.hpp"
+#include "dogen/cpp/types/formatters/header_guards.hpp"
+#include "dogen/cpp/types/formatters/namespace_formatter.hpp"
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+#include "dogen/cpp/types/formatters/namespace_documentation.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.namespace_documentation"));
+
+const std::string missing_namespace_info("Namespace info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+namespace_documentation::
+namespace_documentation(std::ostream& stream) :
+    stream_(stream),
+    utility_(stream_, indenter_) {
+}
+
+file_formatter::shared_ptr
+namespace_documentation::create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new namespace_documentation(stream));
+}
+
+void namespace_documentation::format_namespace(const file_info& fi) {
+    auto o(fi.namespace_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_namespace_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_namespace_info));
+    }
+
+    {
+        const namespace_info& ni(*o);
+        if (ni.namespaces().empty())
+            return;
+
+        auto other_ns(ni.namespaces());
+        other_ns.pop_back();
+        namespace_formatter nsf(stream_);
+        for (auto ns : other_ns)
+            nsf.format_start(ns);
+        utility_.blank_line();
+
+        doxygen_comments dc(stream_, indenter_);
+        dc.format(ni.documentation());
+        nsf.format_start(ni.namespaces().back());
+
+        bool first(true);
+        for (auto ns : ni.namespaces()) {
+            if (!first)
+                stream_ << " ";
+            nsf.format_end();
+            first = false;
+        }
+    }
+    utility_.blank_line(2);
+}
+
+void namespace_documentation::format(const file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    header_guards guards(stream_);
+    guards.format_start(fi.header_guard());
+    utility_.blank_line();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    if (fi.descriptor().content_type() == content_types::namespace_doc)
+        format_namespace(fi);
+
+    guards.format_end();
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/namespace_formatter.cpp b/projects/cpp_formatters/src/types/namespace_formatter.cpp
index 18aa2e4..d25537a 100644
--- a/projects/cpp_formatters/src/types/namespace_formatter.cpp
+++ b/projects/cpp_formatters/src/types/namespace_formatter.cpp
@@ -1,2 +1,45 @@
-// dummy function to suppress ranlib warnings
-void namespace_formatter() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <sstream>
+#include <ostream>
+#include "dogen/cpp/types/formatters/namespace_formatter.hpp"
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+namespace_formatter::namespace_formatter(std::ostream& stream)
+    : stream_(stream) { }
+
+void namespace_formatter::format_start(const std::string& name) {
+    stream_ << "namespace";
+    if (name.empty())
+        stream_ << " {";
+    else
+        stream_ << " " << name << " {";
+    stream_ << std::endl;
+}
+
+void namespace_formatter::format_end() {
+    stream_ << "}"; // no std::endl by design
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/namespace_helper.cpp b/projects/cpp_formatters/src/types/namespace_helper.cpp
index 53d8b8d..ee6d511 100644
--- a/projects/cpp_formatters/src/types/namespace_helper.cpp
+++ b/projects/cpp_formatters/src/types/namespace_helper.cpp
@@ -1,2 +1,62 @@
-// dummy function to suppress ranlib warnings
-void namespace_helper() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+
+namespace {
+
+const std::string empty;
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+namespace_helper::namespace_helper(std::ostream& stream,
+    const std::list<std::string>& namespaces)
+    : stream_(stream), namespace_formatter_(stream), namespaces_(namespaces) {
+
+    if (namespaces_.empty()) {
+        namespace_formatter_.format_start(empty);
+        return;
+    }
+
+    for (auto ns : namespaces_)
+        namespace_formatter_.format_start(ns);
+}
+
+namespace_helper::~namespace_helper() {
+    if (namespaces_.empty()) {
+        namespace_formatter_.format_end();
+        return;
+    }
+
+    bool first(true);
+    for (auto ns : namespaces_) {
+        if (!first)
+            stream_ << " ";
+        namespace_formatter_.format_end();
+        first = false;
+    }
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/null_formatter.cpp b/projects/cpp_formatters/src/types/null_formatter.cpp
index 8686ab2..5a99aa9 100644
--- a/projects/cpp_formatters/src/types/null_formatter.cpp
+++ b/projects/cpp_formatters/src/types/null_formatter.cpp
@@ -1,2 +1,37 @@
-// dummy function to suppress ranlib warnings
-void null_formatter() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include "dogen/cpp/types/formatters/null_formatter.hpp"
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+file_formatter::shared_ptr null_formatter::
+create(std::ostream&) {
+    return file_formatter::shared_ptr(new null_formatter);
+}
+
+void null_formatter::format(const file_info&) {
+    return;
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/odb_header.cpp b/projects/cpp_formatters/src/types/odb_header.cpp
index 2510e71..99ebff2 100644
--- a/projects/cpp_formatters/src/types/odb_header.cpp
+++ b/projects/cpp_formatters/src/types/odb_header.cpp
@@ -1,2 +1,167 @@
-// dummy function to suppress ranlib warnings
-void odb_header() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+#include "dogen/cpp/types/formatters/licence.hpp"
+#include "dogen/cpp/types/formatters/header_guards.hpp"
+#include "dogen/cpp/types/formatters/namespace_formatter.hpp"
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+#include "dogen/cpp/types/formatters/indenter.hpp"
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/types/formatters/odb_header.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.odb_header"));
+
+const std::string std_ns("std");
+const std::string odb_pragma("#pragma db");
+const std::string odb_key("ODB_PRAGMA");
+
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+odb_header::
+odb_header(std::ostream& stream) :
+    stream_(stream),
+    utility_(stream_, indenter_) {
+}
+
+file_formatter::shared_ptr odb_header::create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new odb_header(stream));
+}
+
+void odb_header::format_enumeration(const file_info& fi) {
+    const auto o(fi.enum_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_enum_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_enum_info));
+    }
+
+    const auto ei(*o);
+    {
+        namespace_helper ns(stream_, ei.namespaces());
+        utility_.blank_line();
+
+        stream_ << indenter_ << "#ifdef ODB_COMPILER" << std::endl;
+        utility_.blank_line();
+        stream_ << indenter_ << "#endif" << std::endl;
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void odb_header::format_class(const file_info& fi) {
+    const auto o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+
+    const auto ei(*o);
+    {
+        if (ei.implementation_specific_parameters().empty()) {
+            stream_ << indenter_ << "// class has no ODB pragmas defined."
+                    << std::endl;
+            utility_.blank_line();
+            return;
+        }
+
+        std::ostringstream odb_stream;
+        bool has_odb_parms(false);
+        odb_stream << indenter_ << "#ifdef ODB_COMPILER" << std::endl
+                   << std::endl;
+
+        for (const auto kvp : ei.implementation_specific_parameters()) {
+            if (kvp.first == odb_key) {
+                has_odb_parms = true;
+                odb_stream << indenter_
+                           << odb_pragma << " object(" << ei.name() << ") "
+                           << kvp.second << std::endl;
+            }
+        }
+
+        odb_stream << std::endl;
+        for (const auto p : ei.properties()) {
+            for (const auto kvp : p.implementation_specific_parameters()) {
+                if (kvp.first == odb_key) {
+                    has_odb_parms = true;
+                    odb_stream << indenter_
+                               << odb_pragma << " member(" << ei.name() << "::"
+                               << utility_.as_member_variable(p.name()) << ") "
+                               << kvp.second << std::endl;
+                }
+            }
+        }
+        odb_stream << std::endl
+                   << indenter_ << "#endif" << std::endl
+                   << std::endl;
+
+        if (!has_odb_parms) {
+            stream_ << indenter_ << "// class has no ODB pragmas defined."
+                    << std::endl;
+            utility_.blank_line();
+            return;
+        }
+
+        {
+            namespace_helper ns(stream_, ei.namespaces());
+            utility_.blank_line();
+            stream_ << odb_stream.str();
+        }
+        utility_.blank_line(2);
+    }
+}
+
+void odb_header::format(const file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    header_guards guards(stream_);
+    guards.format_start(fi.header_guard());
+    stream_ << std::endl;
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+
+    guards.format_end();
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/odb_options.cpp b/projects/cpp_formatters/src/types/odb_options.cpp
index 4bbf68e..cba395b 100644
--- a/projects/cpp_formatters/src/types/odb_options.cpp
+++ b/projects/cpp_formatters/src/types/odb_options.cpp
@@ -1,2 +1,94 @@
-// dummy function to suppress ranlib warnings
-void odb_options() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include <boost/algorithm/string/case_conv.hpp>
+#include "dogen/cpp/types/formatters/odb_options.hpp"
+
+namespace {
+
+const std::string empty("");
+const std::string underscore("_");
+const std::string unnamed_model("unnamed_model");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+odb_options::odb_options(std::ostream& stream) : stream_(stream) {}
+
+void odb_options::format(const odb_options_info& ooi) {
+    const std::string mn(ooi.model_name().empty() ?
+        unnamed_model :
+        ooi.model_name());
+
+
+    stream_ << "# -*- mode: sh; tab-width: 4; indent-tabs-mode: nil -*-"
+            << std::endl << std::endl;
+
+    stream_ << "# enable C++11. FIXME: causes ODB crash in options file."
+            << std::endl
+            << "# --std c++11" << std::endl << std::endl;
+
+    stream_ << "# target postgres" << std::endl
+            << "--database pgsql" << std::endl << std::endl;
+
+    stream_ << "# use the boost profile" << std::endl
+            << "--profile boost" << std::endl << std::endl;
+
+    stream_ << "# generate queries and embedded schemas" << std::endl
+            << "--generate-query" << std::endl
+            << "--generate-schema" << std::endl
+            << "--schema-format embedded" << std::endl << std::endl;
+
+    stream_ << "# use extensions similar to the dogen ones" << std::endl
+            << "# --ixx-suffix .ipp" << std::endl
+            << "# --hxx-suffix .hpp" << std::endl
+            << "--cxx-suffix .cpp" << std::endl << std::endl;
+
+    stream_ << "# fix domain includes" << std::endl
+            << "--include-regex '%(.*).hpp%" << ooi.product_name()
+            << "/" << ooi.model_name() << "/types/$1.hpp%'"
+            << std::endl << std::endl;
+
+    stream_ << "# fix odb generated includes" << std::endl
+            << "--include-regex '%(^[a-zA-Z0-9_]+)-odb.(.*)%"
+            << ooi.product_name() << "/" << ooi.model_name() << "/"
+            << ooi.odb_folder() << "/$1-odb.$2%'" << std::endl
+            << "--include-regex '%" << ooi.product_name()
+            << "/" << ooi.model_name() << "/types/(.*)-odb.(.*)%"
+            << ooi.product_name() << "/" << ooi.model_name()
+            << "/" << ooi.odb_folder() << "/$1-odb.$2%'"
+            << std::endl << std::endl;
+
+    stream_ << "# debug regexes" << std::endl
+            << "# --include-regex-trace" << std::endl << std::endl;
+
+    stream_ << "# make the header guards similar to dogen ones" << std::endl
+            << "--guard-prefix " << boost::to_upper_copy(ooi.product_name())
+            << "_" << boost::to_upper_copy(ooi.model_name()) << "_"
+            << boost::to_upper_copy(ooi.odb_folder())
+            << std::endl;
+
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/qname.cpp b/projects/cpp_formatters/src/types/qname.cpp
index 793526a..70279b2 100644
--- a/projects/cpp_formatters/src/types/qname.cpp
+++ b/projects/cpp_formatters/src/types/qname.cpp
@@ -1,2 +1,56 @@
-// dummy function to suppress ranlib warnings
-void qname() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <ostream>
+#include "dogen/cpp/types/formatters/qname.hpp"
+
+namespace {
+
+const std::string separator("::");
+
+template<typename T>
+void format(std::ostream& s, const T& t) {
+    for(auto n : t.namespaces())
+        s << n << separator;
+    s << t.name();
+}
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+qname::qname(std::ostream& stream)
+    : stream_(stream) { }
+
+void qname::format(const parent_info& pi) {
+    ::format<parent_info>(stream_, pi);
+}
+
+void qname::format(const class_info& ci) {
+    ::format<class_info>(stream_, ci);
+}
+
+void qname::format(const enum_info& ei) {
+    ::format<enum_info>(stream_, ei);
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/registrar_header.cpp b/projects/cpp_formatters/src/types/registrar_header.cpp
index c3ec63b..7ea846a 100644
--- a/projects/cpp_formatters/src/types/registrar_header.cpp
+++ b/projects/cpp_formatters/src/types/registrar_header.cpp
@@ -1,2 +1,83 @@
-// dummy function to suppress ranlib warnings
-void registrar_header() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <boost/throw_exception.hpp>
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/namespace_formatter.hpp"
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+#include "dogen/cpp/types/formatters/licence.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/types/formatters/registrar_header.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.registrar_header"));
+
+const bool is_system(true);
+const bool is_user(false);
+
+const std::string expected_registrar_info(
+    "File view model must contain a registrar view model");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+registrar_header::
+registrar_header(std::ostream& stream) :
+    stream_(stream), utility_(stream_, indenter_) { }
+
+file_formatter::shared_ptr registrar_header::
+create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new registrar_header(stream));
+}
+
+void registrar_header::format(const file_info& fi) {
+    const auto o(fi.registrar_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << expected_registrar_info;
+        BOOST_THROW_EXCEPTION(formatting_error(expected_registrar_info));
+    }
+
+    licence licence(stream_);
+    licence.format();
+
+    const bool blank_line(false);
+    includes includes(stream_, blank_line);
+    includes.format(fi);
+
+    {
+        const auto ri(*o);
+        namespace_helper ns(stream_, ri.namespaces());
+        utility_.blank_line();
+        stream_ << indenter_ << "template<typename Archive>" << std::endl
+                << indenter_ << "void register_types(Archive& ar);"
+                << std::endl;
+        utility_.blank_line();
+    }
+    utility_.blank_line();
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/registrar_implementation.cpp b/projects/cpp_formatters/src/types/registrar_implementation.cpp
index 4494102..5bccfb4 100644
--- a/projects/cpp_formatters/src/types/registrar_implementation.cpp
+++ b/projects/cpp_formatters/src/types/registrar_implementation.cpp
@@ -1,2 +1,151 @@
-// dummy function to suppress ranlib warnings
-void registrar_implementation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <boost/throw_exception.hpp>
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/namespace_formatter.hpp"
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+#include "dogen/cpp/types/formatters/licence.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/types/formatters/registrar_implementation.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.registrar_implementation"));
+
+const bool is_system(true);
+const bool is_user(false);
+
+const std::string boost_ns("boost::archive");
+
+const std::string expected_registrar_info(
+    "File view model must contain a registrar view model");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+registrar_implementation::
+registrar_implementation(std::ostream& stream,
+    const bool disable_xml_serialization) :
+    stream_(stream), utility_(stream_, indenter_),
+    disable_xml_serialization_(disable_xml_serialization) { }
+
+file_formatter::shared_ptr registrar_implementation::
+create(std::ostream& stream, const bool disable_xml_serialization) {
+    return file_formatter::shared_ptr(
+        new registrar_implementation(stream, disable_xml_serialization));
+}
+
+void registrar_implementation::format(const file_info& fi) {
+    const auto o(fi.registrar_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << expected_registrar_info;
+        BOOST_THROW_EXCEPTION(formatting_error(expected_registrar_info));
+    }
+
+    licence licence(stream_);
+    licence.format();
+
+    const bool blank_line(false);
+    includes includes(stream_, blank_line);
+    includes.format(fi);
+
+    // FIXME: massive hack for EOS workaround
+    stream_ << "#ifdef __linux__" << std::endl
+            << "#include \"eos/portable_iarchive.hpp\"" << std::endl
+            << "#include \"eos/portable_oarchive.hpp\"" << std::endl
+            << "#endif" << std::endl;
+    utility_.blank_line();
+
+    {
+        const auto ei(*o);
+        namespace_helper ns(stream_, ei.namespaces());
+
+        const auto deps(ei.model_dependencies());
+        const auto leaves(ei.leaves());
+        const bool has_types(!deps.empty() || !leaves.empty());
+        const std::string arg_name(has_types ? " ar" : "");
+        utility_.blank_line();
+
+        stream_ << indenter_ << "template<typename Archive>" << std::endl
+                << indenter_ << "void register_types(Archive&" << arg_name
+                << ") ";
+        utility_.open_scope();
+        {
+            positive_indenter_scope s(indenter_);
+            for (const auto d : deps) {
+                stream_ << indenter_ << d << "::register_types(ar);"
+                        << std::endl;
+            }
+
+            if (!deps.empty() && !leaves.empty())
+                utility_.blank_line();
+
+            for (const auto l : leaves) {
+                stream_ << indenter_
+                        << "ar.template register_type<" << l << ">();"
+                        << std::endl;
+            }
+        }
+        utility_.close_scope();
+        utility_.blank_line();
+
+        auto lambda([&](const std::string& archive) {
+                stream_ << indenter_ << "template void register_types("
+                        << boost_ns
+                        << "::" << archive << "&" << arg_name << ");"
+                        << std::endl;
+            });
+
+        lambda("polymorphic_oarchive");
+        lambda("polymorphic_iarchive");
+        utility_.blank_line();
+
+        lambda("text_oarchive");
+        lambda("text_iarchive");
+        utility_.blank_line();
+
+        lambda("binary_oarchive");
+        lambda("binary_iarchive");
+        utility_.blank_line();
+
+        if (!disable_xml_serialization_) {
+            lambda("xml_oarchive");
+            lambda("xml_iarchive");
+            utility_.blank_line();
+        }
+
+        stream_ << "#ifdef __linux__" << std::endl
+                << indenter_ << "template void register_types("
+                << "eos::portable_oarchive& ar);" << std::endl;
+        stream_ << indenter_ << "template void register_types("
+                << "eos::portable_iarchive& ar);" << std::endl
+                << "#endif" << std::endl;
+        utility_.blank_line();
+    }
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/serialization_header.cpp b/projects/cpp_formatters/src/types/serialization_header.cpp
index 31fa753..0f141ea 100644
--- a/projects/cpp_formatters/src/types/serialization_header.cpp
+++ b/projects/cpp_formatters/src/types/serialization_header.cpp
@@ -1,2 +1,192 @@
-// dummy function to suppress ranlib warnings
-void serialization_header() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <string>
+#include <list>
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/licence.hpp"
+#include "dogen/cpp/types/formatters/header_guards.hpp"
+#include "dogen/cpp/types/formatters/namespace_formatter.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+#include "dogen/cpp/types/formatters/qname.hpp"
+#include "dogen/cpp/types/formatters/indenter.hpp"
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/types/formatters/serialization_header.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.serialization_header"));
+
+const std::string boost_ns("boost");
+const std::string serialization_ns("serialization");
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+serialization_header::
+serialization_header(std::ostream& stream,
+    const bool disable_xml_serialization) :
+    stream_(stream), utility_(stream_, indenter_),
+    disable_xml_serialization_(disable_xml_serialization) { }
+
+file_formatter::shared_ptr
+serialization_header::create(std::ostream& stream,
+    const bool disable_xml_serialization) {
+    return file_formatter::shared_ptr(
+        new serialization_header(stream, disable_xml_serialization));
+}
+
+void serialization_header::load_and_save_functions(const class_info& ci) {
+    qname qname(stream_);
+    stream_ << indenter_ << "template<typename Archive>" << std::endl
+            << indenter_ << "void save(Archive& ar, const ";
+    qname.format(ci);
+    stream_ << "& v, unsigned int version);" << std::endl;
+    utility_.blank_line();
+
+    stream_ << indenter_ << "template<typename Archive>" << std::endl
+            << indenter_ << "void load(Archive& ar" << ", ";
+    qname.format(ci);
+    stream_ << "& v, unsigned int version);" << std::endl;
+}
+
+void serialization_header::format_class(const file_info& fi) {
+    const auto o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+
+    const class_info& ci(*o);
+    qname qname(stream_);
+    const auto parents(ci.parents());
+    if (!ci.is_parent() && !parents.empty())
+    {
+        {
+            std::list<std::string> ns { boost_ns };
+            namespace_helper nsh(stream_, ns);
+            utility_.blank_line();
+
+            for (const auto p : parents) {
+                stream_ << indenter_ << "template<>struct" << std::endl
+                        << indenter_ << "is_virtual_base_of<" << std::endl;
+                {
+                    positive_indenter_scope s(indenter_);
+                    stream_ << indenter_;
+                    qname.format(p);
+                    stream_ << "," << std::endl
+                            << indenter_;
+                    qname.format(ci);
+                    stream_ << std::endl;
+                }
+                stream_ << indenter_ << "> : public mpl::true_ {};"
+                        << std::endl;
+                utility_.blank_line();
+            }
+        }
+        utility_.blank_line(2);
+    }
+
+    stream_ << indenter_ << "BOOST_SERIALIZATION_SPLIT_FREE(";
+    qname.format(ci);
+    stream_ << ")" << std::endl;
+
+    if (ci.is_parent()) {
+        stream_ << indenter_ << "BOOST_SERIALIZATION_ASSUME_ABSTRACT(";
+        qname.format(ci);
+        stream_ << ")" << std::endl;
+        utility_.blank_line();
+    }
+
+    {
+        std::list<std::string> ns { boost_ns, serialization_ns };
+        namespace_helper nsh(stream_, ns);
+        utility_.blank_line();
+        load_and_save_functions(ci);
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void serialization_header::format_enumeration(const file_info& fi) {
+    const auto o(fi.enum_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_enum_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_enum_info));
+    }
+
+    const auto ei(*o);
+    stream_ << indenter_ << "template<class Archive>" << std::endl
+            << "void serialize(Archive& ar, ";
+
+    qname qnf(stream_);
+    qnf.format(ei);
+
+    stream_ << "& v, unsigned int /*version*/)";
+    utility_.open_scope();
+    {
+        positive_indenter_scope s(indenter_);
+        if (disable_xml_serialization_) {
+            stream_ << indenter_ << "ar & v;" << std::endl;
+        } else {
+            stream_ << indenter_ << "using boost::serialization::make_nvp;"
+                    << std::endl
+                    << indenter_ << "ar & make_nvp(\""
+                    << ei.name() << "\", v);" << std::endl;
+        }
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void serialization_header::format(const file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    header_guards guards(stream_);
+    guards.format_start(fi.header_guard());
+    utility_.blank_line();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+
+    guards.format_end();
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/serialization_implementation.cpp b/projects/cpp_formatters/src/types/serialization_implementation.cpp
index bba8d8a..5e16d75 100644
--- a/projects/cpp_formatters/src/types/serialization_implementation.cpp
+++ b/projects/cpp_formatters/src/types/serialization_implementation.cpp
@@ -1,2 +1,331 @@
-// dummy function to suppress ranlib warnings
-void serialization_implementation() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <list>
+#include <string>
+#include <ostream>
+#include <boost/throw_exception.hpp>
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+#include "dogen/cpp/types/formatters/licence.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+#include "dogen/cpp/types/formatters/qname.hpp"
+#include "dogen/cpp/types/formatters/indenter.hpp"
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/cpp/types/formatters/serialization_implementation.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.serialization_implementation"));
+
+const std::string boost_ns("boost");
+const std::string serialization_ns("serialization");
+const std::string missing_class_info("Class info is empty");
+const std::string missing_enum_info("Enumeration info is empty");
+const std::string enum_info_not_supported(
+    "Enumerations do not have an implementation");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+serialization_implementation::
+serialization_implementation(std::ostream& stream,
+    const bool disable_xml_serialization) :
+    stream_(stream),
+    utility_(stream_, indenter_),
+    disable_xml_serialization_(disable_xml_serialization) { }
+
+file_formatter::shared_ptr
+serialization_implementation::create(std::ostream& stream,
+    const bool disable_xml_serialization) {
+    return file_formatter::shared_ptr(
+        new serialization_implementation(stream, disable_xml_serialization));
+}
+
+void serialization_implementation::save_function(const class_info& ci) {
+    const auto parents(ci.parents());
+    const auto props(ci.properties());
+    const bool has_properties(!props.empty());
+    const bool has_parents(!parents.empty());
+    const bool has_properties_or_parents(has_properties || has_parents);
+
+    stream_ << indenter_ << "template<typename Archive>" << std::endl
+            << indenter_ << "void save(Archive& "
+            << (has_properties_or_parents ? "ar," : "/*ar*/,")
+            << std::endl;
+
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_ << "const ";
+        qname qname(stream_);
+        qname.format(ci);
+
+        stream_ << (has_properties_or_parents ? "& v," : "& /*v*/,")
+                << std::endl
+                << indenter_ << "const unsigned int /*version*/) ";
+
+        utility_.open_scope();
+        {
+            for (const auto p : parents) {
+                if (disable_xml_serialization_) {
+                    stream_ << indenter_ << "ar << base_object<";
+                    qname.format(p);
+                    stream_ << ">(v);" << std::endl;
+                } else {
+                    stream_ << indenter_ << "ar << make_nvp("
+                            << utility_.quote(p.name()) << ", base_object<";
+                    qname.format(p);
+                    stream_ << ">(v));" << std::endl;
+                }
+            }
+
+            if (has_properties && has_parents)
+                utility_.blank_line();
+
+            for (const auto p : props) {
+                std::ostringstream s;
+                s << "v." << utility_.as_member_variable(p.name());
+                if (p.type().is_filesystem_path())
+                    s << ".generic_string()";
+
+                if (disable_xml_serialization_) {
+                    stream_ << indenter_ << "ar << " << s.str() << ";"
+                            << std::endl;
+                } else {
+                    stream_ << indenter_ << "ar << make_nvp("
+                            << utility_.quote(p.name())
+                            << ", " << s.str() << ");"
+                            << std::endl;
+                }
+            }
+        }
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void serialization_implementation::load_function(const class_info& ci) {
+    const auto parents(ci.parents());
+    const auto props(ci.properties());
+    const bool has_properties(!props.empty());
+    const bool has_parents(!parents.empty());
+    const bool has_properties_or_parents(has_properties || has_parents);
+
+    stream_ << indenter_ << "template<typename Archive>" << std::endl
+            << indenter_ << "void load(Archive& "
+            << (has_properties_or_parents ? "ar," : "/*ar*/,")
+            << std::endl;
+
+    {
+        positive_indenter_scope s(indenter_);
+        stream_ << indenter_;
+        qname qname(stream_);
+        qname.format(ci);
+
+        stream_ << (has_properties_or_parents ? "& v," : "& /*v*/,")
+                << std::endl
+                << indenter_ << "const unsigned int /*version*/) ";
+
+        utility_.open_scope();
+        {
+            for (const auto p : parents) {
+                if (disable_xml_serialization_) {
+                    stream_ << indenter_
+                            << "ar >> "
+                            << utility_.quote(p.name())
+                            << ", base_object<";
+                    qname.format(p);
+                    stream_ << ">(v);" << std::endl;
+                } else {
+                    stream_ << indenter_
+                            << "ar >> make_nvp("
+                            << utility_.quote(p.name())
+                            << ", base_object<";
+                    qname.format(p);
+                    stream_ << ">(v));" << std::endl;
+                }
+            }
+
+            if (has_properties && has_parents)
+                utility_.blank_line();
+
+            for (const auto p : props) {
+                std::ostringstream s;
+                if (p.type().is_filesystem_path()) {
+                    s << p.name() + "_tmp";
+                    stream_ << indenter_ << "std::string " << s.str() << ";"
+                            << std::endl;
+                } else
+                    s << "v." << utility_.as_member_variable(p.name());
+
+                if (disable_xml_serialization_) {
+                    stream_ << indenter_ << "ar >> " << s.str() << ";"
+                            << std::endl;
+                } else {
+                    stream_ << indenter_ << "ar >> make_nvp("
+                            << utility_.quote(p.name())
+                            << ", " << s.str() << ");"
+                            << std::endl;
+                }
+
+                if (p.type().is_filesystem_path()) {
+                    stream_ << indenter_ << "v."
+                            << utility_.as_member_variable(p.name())
+                            << " = " << s.str() << ";"
+                            << std::endl;
+                }
+            }
+        }
+    }
+    utility_.close_scope();
+    utility_.blank_line();
+}
+
+void serialization_implementation::
+template_instantiations(const class_info& ci) {
+    stream_ << indenter_ << "template void save("
+            << "archive::polymorphic_oarchive& ar, const ";
+    qname qname(stream_);
+    qname.format(ci);
+    stream_ << "& v, unsigned int version);" << std::endl;
+    stream_ << indenter_ << "template void load("
+            << "archive::polymorphic_iarchive& ar, ";
+    qname.format(ci);
+    stream_ << "& v, unsigned int version);" << std::endl;
+    utility_.blank_line();
+
+    stream_ << indenter_ << "template void save(archive::text_oarchive& ar, "
+            << "const ";
+    qname.format(ci);
+    stream_ << "& v, unsigned int version);" << std::endl;
+    stream_ << indenter_ << "template void load(archive::text_iarchive& ar, ";
+    qname.format(ci);
+    stream_ << "& v, unsigned int version);" << std::endl;
+    utility_.blank_line();
+
+    stream_ << indenter_ << "template void save(archive::binary_oarchive& ar, "
+            << "const ";
+    qname.format(ci);
+    stream_ << "& v, unsigned int version);" << std::endl;
+    stream_ << indenter_ << "template void load(archive::binary_iarchive& ar, ";
+    qname.format(ci);
+    stream_ << "& v, unsigned int version);" << std::endl;
+    utility_.blank_line();
+
+    if (!disable_xml_serialization_) {
+        stream_ << indenter_ << "template void save(archive::xml_oarchive& ar, "
+                << "const ";
+        qname.format(ci);
+        stream_ << "& v, unsigned int version);" << std::endl;
+        stream_ << indenter_ << "template void load(archive::xml_iarchive& ar, ";
+        qname.format(ci);
+        stream_ << "& v, unsigned int version);" << std::endl;
+        utility_.blank_line();
+    }
+
+    stream_ << "#ifdef __linux__" << std::endl
+            << indenter_ << "template void save(eos::portable_oarchive& ar, "
+            << "const ";
+    qname.format(ci);
+    stream_ << "& v, unsigned int version);" << std::endl;
+    stream_ << indenter_ << "template void load(eos::portable_iarchive& ar, ";
+    qname.format(ci);
+    stream_ << "& v, unsigned int version);" << std::endl
+            << "#endif" << std::endl;
+    utility_.blank_line();
+}
+
+void serialization_implementation::format_class(const file_info& fi) {
+    const auto o(fi.class_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_class_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_class_info));
+    }
+
+    const class_info& ci(*o);
+    qname qname(stream_);
+    if (ci.is_parent() || !ci.parents().empty()) {
+        stream_ << indenter_ << "BOOST_CLASS_TRACKING(" << std::endl;
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_;
+            qname.format(ci);
+            stream_ << "," << std::endl;
+            stream_ << indenter_ << "boost::serialization"
+                    << "::track_selectively)"
+                    << std::endl;
+        }
+        utility_.blank_line();
+    }
+
+    {
+        std::list<std::string> ns { boost_ns, serialization_ns };
+        namespace_helper nsh(stream_, ns);
+        utility_.blank_line();
+        save_function(ci);
+        load_function(ci);
+    }
+    utility_.blank_line(2);
+
+    {
+        std::list<std::string> ns { boost_ns, serialization_ns };
+        namespace_helper nsh(stream_, ns);
+        utility_.blank_line();
+        template_instantiations(ci);
+    }
+}
+
+void serialization_implementation::
+format_enumeration(const file_info&) {
+    BOOST_LOG_SEV(lg, error) << enum_info_not_supported;
+    BOOST_THROW_EXCEPTION(
+        formatting_error(enum_info_not_supported));
+}
+
+void serialization_implementation::format(const file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    // FIXME: massive hack for EOS workaround
+    stream_ << "#ifdef __linux__" << std::endl
+            << "#include \"eos/portable_iarchive.hpp\"" << std::endl
+            << "#include \"eos/portable_oarchive.hpp\"" << std::endl
+            << "#endif" << std::endl;
+    utility_.blank_line();
+
+    if (fi.descriptor().content_type() == content_types::unversioned_key ||
+        fi.descriptor().content_type() == content_types::versioned_key ||
+        fi.descriptor().content_type() == content_types::value_object ||
+        fi.descriptor().content_type() == content_types::entity ||
+        fi.descriptor().content_type() == content_types::keyed_entity)
+        format_class(fi);
+    else if (fi.descriptor().content_type() == content_types::enumeration)
+        format_enumeration(fi);
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/src_cmakelists.cpp b/projects/cpp_formatters/src/types/src_cmakelists.cpp
index c6636c9..5783107 100644
--- a/projects/cpp_formatters/src/types/src_cmakelists.cpp
+++ b/projects/cpp_formatters/src/types/src_cmakelists.cpp
@@ -1,2 +1,93 @@
-// dummy function to suppress ranlib warnings
-void src_cmakelists() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <sstream>
+#include <ostream>
+#include <boost/algorithm/string/case_conv.hpp>
+#include "dogen/cpp/types/formatters/src_cmakelists.hpp"
+
+namespace {
+
+const std::string empty("");
+const std::string underscore("_");
+const std::string unnamed_model("unnamed_model");
+
+}
+
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+src_cmakelists::src_cmakelists(std::ostream& stream) : stream_(stream) {
+}
+
+void src_cmakelists::format(const cmakelists_info& ci) {
+    const std::string mn(ci.model_name().empty() ?
+        unnamed_model :
+        ci.model_name());
+
+    stream_ << "# -*- mode: cmake; tab-width: 4; indent-tabs-mode: nil -*-"
+            << std::endl
+            << "#" << std::endl
+            << "# Copyright (C) 2012 Kitanda <info@kitanda.co.uk>" << std::endl
+            << "#" << std::endl
+            << "# This program is free software; you can redistribute it and/or"
+            << " modify" << std::endl
+            << "# it under the terms of the GNU General Public License as"
+            << " published by" << std::endl
+            << "# the Free Software Foundation; either version 3 of the License"
+            << ", or" << std::endl
+            << "# (at your option) any later version." << std::endl
+            << "#" << std::endl
+            << "# This program is distributed in the hope that it will be "
+            << " useful," << std::endl
+            << "# but WITHOUT ANY WARRANTY; without even the implied warranty"
+            << " of" << std::endl
+            << "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the"
+            << std::endl
+            << "# GNU General Public License for more details." << std::endl
+            << "#" << std::endl
+            << "# You should have received a copy of the GNU General "
+            << "Public License" << std::endl
+            << "# along with this program; if not, write to the Free Software"
+            << std::endl
+            << "# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,"
+            << std::endl << "# MA 02110-1301, USA." << std::endl
+            << "#" << std::endl
+            << "set(all_files \"\")" << std::endl
+            << "file(GLOB_RECURSE all_files RELATIVE" << std::endl
+            << "    \"${CMAKE_CURRENT_SOURCE_DIR}/\"" << std::endl
+            << "    \"${CMAKE_CURRENT_SOURCE_DIR}/*.cpp\")" << std::endl
+            << std::endl
+            << "add_library(" << mn << " STATIC ${all_files})"
+            << std::endl
+            << "set_target_properties(" << mn << " PROPERTIES"
+            << std::endl << "    OUTPUT_NAME " << ci.product_name()
+            << (ci.product_name().empty() ? empty : underscore) << mn << ")";
+
+    stream_ << std::endl
+            << std::endl
+            << "install(TARGETS " << mn << " ARCHIVE DESTINATION lib "
+            << "COMPONENT libraries)"
+            << std::endl;
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/utility.cpp b/projects/cpp_formatters/src/types/utility.cpp
index fafa80e..bd33273 100644
--- a/projects/cpp_formatters/src/types/utility.cpp
+++ b/projects/cpp_formatters/src/types/utility.cpp
@@ -1,2 +1,101 @@
-// dummy function to suppress ranlib warnings
-void utility() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <sstream>
+#include <ostream>
+#include "dogen/cpp/types/formatters/utility.hpp"
+
+namespace  {
+
+const std::string member_variable_postfix("_");
+const std::string open_bracket("{");
+const std::string close_bracket("}");
+const std::string function_brackets("()");
+const std::string quote_escaped("\\\"");
+const std::string quote("\"");
+const std::string inserter("<< ");
+const std::string space(" ");
+
+const std::string public_access_specifier("public:");
+const std::string protected_access_specifier("protected:");
+const std::string private_access_specifier("private:");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+void utility::public_access_specifier() {
+    negative_indenter_scope s(indenter_);
+    stream_ << ::public_access_specifier << std::endl;
+}
+
+void utility::protected_access_specifier() {
+    negative_indenter_scope s(indenter_);
+    stream_ << ::protected_access_specifier << std::endl;
+}
+
+void utility::private_access_specifier() {
+    negative_indenter_scope s(indenter_);
+    stream_ << ::private_access_specifier << std::endl;
+}
+
+void utility::open_scope() {
+    stream_ << open_bracket << std::endl;
+}
+
+void utility::close_scope() {
+    stream_ << indenter_ << close_bracket << std::endl;
+}
+
+void utility::blank_line(unsigned int how_many) {
+    for (unsigned int i(0); i < how_many; ++i)
+        stream_ << std::endl;
+}
+
+std::string
+utility::as_member_variable(const std::string& property_name) const {
+    return property_name + member_variable_postfix;
+}
+
+std::string
+utility::as_getter(const std::string& property_name) const {
+    return property_name + function_brackets;
+}
+
+std::string utility::quote(const std::string& original) const {
+    return ::quote + original + ::quote;
+}
+
+std::string utility::quote_escaped(const std::string& original) const {
+    return ::quote_escaped + original + ::quote_escaped;
+}
+
+std::string
+utility::quote_escaped_streamed(const std::string& original) const {
+    std::ostringstream s;
+    s << ::quote << ::quote_escaped << ::quote << space
+      << inserter << original << space
+      << inserter << ::quote << ::quote_escaped << ::quote;
+    return s.str();
+}
+
+} } }
diff --git a/projects/cpp_formatters/src/types/visitor.cpp b/projects/cpp_formatters/src/types/visitor.cpp
index fb50cc6..4e6164d 100644
--- a/projects/cpp_formatters/src/types/visitor.cpp
+++ b/projects/cpp_formatters/src/types/visitor.cpp
@@ -1,2 +1,132 @@
-// dummy function to suppress ranlib warnings
-void visitor() { }
+/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * Copyright (C) 2012 Kitanda <info@kitanda.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ *
+ */
+#include <boost/throw_exception.hpp>
+#include "dogen/utility/log/logger.hpp"
+#include "dogen/utility/exception/invalid_enum_value.hpp"
+#include "dogen/cpp/types/formatters/doxygen_comments.hpp"
+#include "dogen/cpp/types/formatters/formatting_error.hpp"
+#include "dogen/cpp/types/formatters/qname.hpp"
+#include "dogen/cpp/types/formatters/licence.hpp"
+#include "dogen/cpp/types/formatters/header_guards.hpp"
+#include "dogen/cpp/types/formatters/namespace_formatter.hpp"
+#include "dogen/cpp/types/formatters/namespace_helper.hpp"
+#include "dogen/cpp/types/formatters/includes.hpp"
+#include "dogen/cpp/types/formatters/visitor.hpp"
+
+using namespace dogen::utility::log;
+
+namespace {
+
+auto lg(logger_factory("cpp.formatters.visitor"));
+const std::string missing_visitor_info("Visitor view model is empty");
+const std::string comments("Accept visits for type ");
+
+}
+
+namespace dogen {
+namespace cpp {
+namespace formatters {
+
+visitor::visitor(std::ostream& stream)
+    : stream_(stream), utility_(stream_, indenter_) { }
+
+file_formatter::shared_ptr visitor::create(std::ostream& stream) {
+    return file_formatter::shared_ptr(new visitor(stream));
+}
+
+void visitor::format(const visitor_info& vi) {
+    {
+        namespace_helper ns(stream_, vi.namespaces());
+        utility_.blank_line();
+
+        doxygen_comments dc(stream_, indenter_);
+        dc.format(vi.documentation());
+        stream_ << indenter_ << "class " << vi.name() << " {" << std::endl;
+        utility_.public_access_specifier();
+        {
+            positive_indenter_scope s(indenter_);
+            stream_ << indenter_ << "virtual ~" << vi.name()
+                    << "() noexcept = 0;"
+                    << std::endl;
+            utility_.blank_line();
+        }
+
+        utility_.public_access_specifier();
+        {
+            positive_indenter_scope s(indenter_);
+            bool is_first(true);
+            for (const auto& t : vi.types()) {
+                if (!is_first)
+                    utility_.blank_line();
+
+                dc.format(comments + t);
+                dc.format_start_block(comments);
+
+                stream_ << indenter_ << "virtual void visit(const " << t
+                        << "&) const { }"
+                        << std::endl;
+                stream_ << indenter_ << "virtual void visit(const " << t
+                        << "&) { }"
+                        << std::endl;
+                stream_ << indenter_ << "virtual void visit(" << t
+                        << "&) const { }"
+                        << std::endl;
+                stream_ << indenter_ << "virtual void visit(" << t
+                        << "&) { }"
+                        << std::endl;
+
+                dc.format_end_block(comments);
+                is_first = false;
+            }
+        }
+
+        stream_ << indenter_ << "};" << std::endl;
+        utility_.blank_line();
+
+        stream_ << indenter_ << "inline " << vi.name() << "::~"<< vi.name()
+                << "() noexcept { }" << std::endl;
+        utility_.blank_line();
+    }
+    utility_.blank_line(2);
+}
+
+void visitor::format(const file_info& fi) {
+    licence licence(stream_);
+    licence.format();
+
+    header_guards guards(stream_);
+    guards.format_start(fi.header_guard());
+    utility_.blank_line();
+
+    includes includes(stream_);
+    includes.format(fi);
+
+    const auto o(fi.visitor_info());
+    if (!o) {
+        BOOST_LOG_SEV(lg, error) << missing_visitor_info;
+        BOOST_THROW_EXCEPTION(formatting_error(missing_visitor_info));
+    }
+    format(*o);
+
+    guards.format_end();
+}
+
+} } }
