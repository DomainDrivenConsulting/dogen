diff --git a/projects/formatters/include/dogen/formatters/types/meta_data/general_settings_factory.hpp b/projects/formatters/include/dogen/formatters/types/meta_data/general_settings_factory.hpp
index 217a199..f21d8a5 100644
--- a/projects/formatters/include/dogen/formatters/types/meta_data/general_settings_factory.hpp
+++ b/projects/formatters/include/dogen/formatters/types/meta_data/general_settings_factory.hpp
@@ -31,6 +31,7 @@
 #include <boost/optional.hpp>
 #include <boost/filesystem/path.hpp>
 #include <boost/property_tree/ptree.hpp>
+#include "dogen/dynamic/types/object.hpp"
 #include "dogen/formatters/types/general_settings.hpp"
 #include "dogen/formatters/types/modeline_group.hpp"
 #include "dogen/formatters/types/licence.hpp"
@@ -65,27 +66,43 @@ private:
      */
     void throw_missing_item(const std::string& msg, const std::string& n) const;
 
+private:
     /**
-     * @brief Extracts a licence using meta-data in the Taggable.
+     * @brief Extracts a licence from the meta-data.
      */
     boost::optional<licence> extract_licence(
         const boost::property_tree::ptree& md) const;
 
     /**
-     * @brief Extracts a modeline using meta-data in the Taggable.
+     * @brief Extracts a modeline from the meta-data.
      */
     boost::optional<modeline> extract_modeline(
         const boost::property_tree::ptree& meta_data) const;
 
     /**
-     * @brief Extracts a code generation marker using meta-data in the
-     * Taggable.
+     * @brief Extracts a code generation marker from the meta-data.
      */
     std::string extract_marker(
         const boost::property_tree::ptree& meta_data) const;
 
 private:
     /**
+     * @brief Extracts a licence from the dynamic object.
+     */
+    boost::optional<licence> extract_licence(const dynamic::object& o) const;
+
+    /**
+     * @brief Extracts a modeline the dynamic object.
+     */
+    boost::optional<modeline> extract_modeline(const dynamic::object& o) const;
+
+    /**
+     * @brief Extracts a code generation marker the dynamic object.
+     */
+    std::string extract_marker(const dynamic::object& o) const;
+
+private:
+    /**
      * @brief Creates the actual list of directories used by hydrators
      * to load data.
      */
@@ -102,11 +119,6 @@ private:
      */
     void hydrate_licences();
 
-    /**
-     * @brief Creates the code generation marker.
-     */
-    void create_marker(const boost::property_tree::ptree& meta_data);
-
 public:
     /**
      * @brief Returns true if there is any reference data at all in the
@@ -129,6 +141,13 @@ public:
      */
     general_settings build(const boost::property_tree::ptree& meta_data) const;
 
+    /**
+     * @brief Generates general settings from the dynamic object.
+     *
+     * @pre load reference data must have been called.
+     */
+    general_settings build(const dynamic::object& o) const;
+
 private:
     const std::forward_list<boost::filesystem::path>& data_files_directories_;
     std::unordered_map<std::string, modeline_group> modeline_groups_;
diff --git a/projects/formatters/src/types/meta_data/general_settings_factory.cpp b/projects/formatters/src/types/meta_data/general_settings_factory.cpp
index 8677204..00152af 100644
--- a/projects/formatters/src/types/meta_data/general_settings_factory.cpp
+++ b/projects/formatters/src/types/meta_data/general_settings_factory.cpp
@@ -21,6 +21,8 @@
 #include "dogen/utility/log/logger.hpp"
 #include "dogen/utility/io/unordered_map_io.hpp"
 #include "dogen/sml/types/meta_data/reader.hpp"
+#include "dogen/dynamic/types/object_extensions.hpp"
+#include "dogen/formatters/types/meta_data/field_definitions.hpp"
 #include "dogen/formatters/types/meta_data/traits.hpp"
 #include "dogen/formatters/types/hydration_workflow.hpp"
 #include "dogen/formatters/io/modeline_group_io.hpp"
@@ -111,6 +113,59 @@ extract_marker(const boost::property_tree::ptree& meta_data) const {
     return f.build();
 }
 
+boost::optional<licence>
+general_settings_factory::extract_licence(const dynamic::object& o) const {
+    if (!dynamic::has_field(o, field_definitions::licence_name()))
+        return boost::optional<licence>();
+
+    const auto licence_name(reader.get(traits::licence_name()));
+    const auto i(licences_.find(licence_name));
+    if (i == licences_.end())
+        throw_missing_item("Licence not found: ", licence_name);
+
+    licence l(i->second);
+    if (reader.has_key(traits::copyright_holder())) {
+        const auto copyright_holder(reader.get(traits::copyright_holder()));
+        l.copyright_holders().push_back(copyright_holder);
+    }
+    return l;
+}
+
+boost::optional<modeline>
+general_settings_factory::extract_modeline(const dynamic::object& o) const {
+    sml::meta_data::reader reader(meta_data);
+    if (!reader.has_key(traits::modeline_group_name()))
+        return boost::optional<modeline>();
+
+    const auto name(reader.get(traits::modeline_group_name()));
+    const auto i(modeline_groups_.find(name));
+    if (i == modeline_groups_.end())
+        throw_missing_item("Modeline group not found: ", name);
+
+    const auto modeline_group(i->second);
+    const auto j(modeline_group.modelines().find("c++"));
+    if (j == modeline_group.modelines().end())
+        throw_missing_item("Modeline not found: ", name);
+
+    return j->second;
+}
+
+std::string
+general_settings_factory::extract_marker(const dynamic::object& o) const {
+    sml::meta_data::reader reader(meta_data);
+
+    using cgm = traits::code_generation_marker;
+    const std::string message(reader.get(cgm::message()));
+    if (message.empty())
+        return std::string();
+
+    const bool add_date_time(reader.is_true(cgm::add_date_time()));
+    const bool add_warning(reader.is_true(cgm::add_warning()));
+    code_generation_marker_factory f(add_date_time, add_warning, message);
+
+    return f.build();
+}
+
 std::forward_list<boost::filesystem::path> general_settings_factory::
 create_directory_list(const std::string& for_whom) const {
     std::forward_list<boost::filesystem::path> r;
@@ -170,4 +225,15 @@ build(const boost::property_tree::ptree& meta_data) const {
     return general_settings(generate_preamble, a);
 }
 
+general_settings
+general_settings_factory::build(const dynamic::object& o) const {
+    const auto modeline(extract_modeline(o));
+    const auto licence(extract_licence(o));
+    const auto marker(extract_marker(o));
+    const annotation a(modeline, licence, marker);
+
+    const bool generate_preamble(false); // FIXME: read from meta_data
+    return general_settings(generate_preamble, a);
+}
+
 } } }
