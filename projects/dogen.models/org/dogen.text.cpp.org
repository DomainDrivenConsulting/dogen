#+title: dogen.text.cpp
#+options: <:nil c:nil todo:nil ^:nil d:nil date:nil author:nil
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.model_modules: dogen.text.cpp
:masd.injection.reference: cpp.builtins
:masd.injection.reference: cpp.boost
:masd.injection.reference: cpp.std
:masd.injection.reference: dogen
:masd.injection.reference: dogen.variability
:masd.injection.reference: dogen.tracing
:masd.injection.reference: dogen.logical
:masd.injection.reference: dogen.text
:masd.injection.reference: masd
:masd.injection.reference: masd.variability
:masd.injection.reference: dogen.profiles
:masd.injection.input_technical_space: cpp
:masd.variability.profile: dogen.profiles.base.default_profile
:END:

Provides the C++ backend for the default physical meta-model.

* transforms
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.physical.backend_name: cpp
:masd.physical.major_technical_space: cpp
:masd.label.test: lbl
:masd.injection.stereotypes: masd::physical::backend
:END:

Formatters for the C++ model.

Takes types in the C++ model and creates a file
representation of these types according to the
grammar of the C++ technical space.

** transforms::types
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.label.test: some_label
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters for the types facet of the
C++ technical space.

*** transforms::types::class_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.label.roles: type_declaration
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_header_configuration
:END:

Generates header files for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    using logical::entities::structural::object;
    const auto& o(assistant::as<object>(e));
    auto builder(f.make());

    // algorithm: domain headers need it for the swap function.
    builder.add(inclusion_constants::std::algorithm());

    const auto io_arch(transforms::io::traits::class_header_archetype_qn());
    const bool in_inheritance(o.is_parent() || o.is_child());
    const bool io_enabled(builder.is_enabled(o.name(), io_arch));
    const bool requires_io(io_enabled && in_inheritance);

    const auto ios(inclusion_constants::std::iosfwd());
    if (requires_io)
        builder.add(ios);

    using ser = transforms::serialization::traits;
    const auto ser_fwd_arch(ser::class_forward_declarations_archetype_qn());
    builder.add(o.name(), ser_fwd_arch);

    const auto carch(traits::canonical_archetype());
    builder.add(o.transparent_associations(), carch);

    const auto fwd_arch(traits::class_forward_declarations_archetype_qn());
    builder.add(o.opaque_associations(), fwd_arch);

    const auto self_arch(class_header_transform::static_archetype().meta_name().qualified());
    builder.add(o.parents(), self_arch);

    using hash = transforms::hash::traits;
    const auto hash_carch(hash::traits::canonical_archetype());
    builder.add(o.associative_container_keys(), hash_carch);

    if (o.is_visitation_root()) {
        /*
         * On the header files of the visitation root we only care
         * about the base visitor; as such we can get away with a
         * forward declaration. For the visitation leaves, since we
         * must include the parent we do not need any additional
         * includes.
         */
        const auto visitor_fwd_arch(traits::visitor_forward_declarations_archetype_qn());
        builder.add(*o.base_visitor(), visitor_fwd_arch);
    }
    return builder.build();
}

void class_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(o.documentation());
            if (o.parents().empty()) {
#>
class <#= sn #> <#= ast.make_final_keyword_text(o) #>{
<#+
            } else {
                const auto& pn(o.parents().front());
                const auto pqn(ast.get_qualified_name(pn));
#>
class <#= sn #> <#= ast.make_final_keyword_text(o) #>: public <#= pqn #> {
<#+
            }

            /*
             * Compiler generated constructors and destructors.
             */
            if (ast.supports_defaulted_functions()) {
#>
public:
<#+
                if (!ast.requires_manual_default_constructor())
#>
    <#= sn #>() = default;
    <#= sn #>(const <#= sn #>&) = default;
<#+
                if (!ast.requires_manual_move_constructor())
#>
    <#= sn #>(<#= sn #>&&) = default;
<#+
                if (!o.in_inheritance_relationship())
#>
    ~<#= sn #>() = default;
<#+
                if (o.is_immutable())
#>
    <#= sn #>& operator=(const <#= sn #>&) = delete;
<#+
                else if (o.all_attributes().empty())
#>
    <#= sn #>& operator=(const <#= sn #>&) = default;

<#+
            }

            /*
             * Manually generated default constructor.
             */
            if (ast.requires_manual_default_constructor()) {
#>
public:
    <#= sn #>();

<#+
            }

            /*
             * Manually generated destructor.
             *
             * according to MEC++, item 33, base classes should always be
             * abstract. this avoids all sorts of tricky problems with
             * assignment and swap.
             *
             * incidentally, this also fixes some strange clang errors:
             * undefined reference to `vtable.
             */
            if (o.is_parent()) {
#>
    virtual ~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> = 0;

<#+
            } else if (o.is_child() != 0) {
#>
    virtual ~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> { }

<#+
            }

            /*
             * Manually generated move constructor.
             */
            if (ast.requires_manual_move_constructor()) {
#>
public:
    <#= sn #>(<#= sn #>&& rhs);

<#+
            }

            /*
             * Manually generated complete constructor.
             */
            if (!o.all_attributes().empty()) {
#>
public:
<#+
                const auto attr_count(o.all_attributes().size());
                if (attr_count == 1) {
                    const auto attr(*o.all_attributes().begin());
#>
    explicit <#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>);
<#+
                } else {
#>
    <#= sn #>(
<#+
                    utility::formatters::sequence_formatter sf(attr_count);
                    sf.postfix_configuration().last(");");
                    for (const auto& attr : o.all_attributes()) {
#>
        const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #><#= sf.postfix() #>
<#+
                        sf.next();
                    }
                }
#>

<#+
            }

            /*
             * Serialisaton Friends
             */
            if (ast.is_serialization_enabled()) {
#>
private:
    template<typename Archive>
    friend void boost::serialization::save(Archive& ar, const <#= qn #>& v, unsigned int version);

    template<typename Archive>
    friend void boost::serialization::load(Archive& ar, <#= qn #>& v, unsigned int version);

<#+
            }

            /*
             * Visitation.
             */
            if (o.is_visitation_root()) {
                const auto vsn(o.base_visitor()->simple());
#>
public:
    virtual void accept(const <#= vsn #>& v) const = 0;
    virtual void accept(<#= vsn #>& v) const = 0;
    virtual void accept(const <#= vsn #>& v) = 0;
    virtual void accept(<#= vsn #>& v) = 0;

<#+
            } else if (o.is_visitation_leaf()) {
                std::string bvn;
                std::string rpn;
                if (o.derived_visitor()) {
                    bvn = ast.get_qualified_name(*o.base_visitor());
                    rpn = ast.get_qualified_name(o.root_parents().front());
                } else {
                    bvn = o.base_visitor()->simple();
                    rpn = o.root_parents().front().simple();
                }
#>
public:
    using <#= rpn #>::accept;

    virtual void accept(const <#= bvn #>& v) const<#= ast.make_override_keyword_text() #>;
    virtual void accept(<#= bvn #>& v) const<#= ast.make_override_keyword_text() #>;
    virtual void accept(const <#= bvn #>& v)<#= ast.make_override_keyword_text() #>;
    virtual void accept(<#= bvn #>& v)<#= ast.make_override_keyword_text() #>;
<#+
            }

            /*
             * Streaming
             */
            if (ast.is_io_enabled()) {
                if (o.is_parent()) {
#>
public:
    virtual void to_stream(std::ostream& s) const;

<#+
                } else if (!o.parents().empty()) {
#>
public:
    void to_stream(std::ostream& s) const<#= ast.make_override_keyword_text() #>;

<#+
                }
            }

            /*
             * Getters and setters.
             */
            if (!o.local_attributes().empty()) {
#>
public:
<#+
                for (const auto& attr : o.local_attributes()) {
                    ast.comment_start_method_group(attr.documentation(), !attr.is_immutable());

                    if (attr.parsed_type().is_current_simple_type()) {
#>
    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #>() const;
<#+
                        if (attr.is_immutable()) {
#>

<#+
                            continue;
                        }
#>
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);
<#+
                    } else {
#>
    const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= attr.name().simple() #>() const;
<#+
                        if (attr.is_immutable()) {
#>

<#+
                            continue;
                        }
#>
    <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>();
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);
<#+
                        if (ast.supports_move_operator()) {
#>
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v);
<#+
                        }
                    }
                    ast.comment_end_method_group(attr.documentation(), !attr.is_immutable());
#>

<#+
                }
            }

            /*
             * Equality.
             *
             * Equality is only public in leaf classes - MEC++-33.
             */
            if (o.is_parent()) {
#>
protected:
    bool compare(const <#= sn #>& rhs) const;
<#+
            } else {
#>
public:
    bool operator==(const <#= sn #>& rhs) const;
    bool operator!=(const <#= sn #>& rhs) const {
        return !this->operator==(rhs);
    }

<#+
            }

            if (o.in_inheritance_relationship()) {
#>
public:
<#+
                if (o.is_parent() && !o.is_child()) {
#>
    virtual bool equals(const <#= sn #>& other) const = 0;
<#+
                } else if (o.is_parent()) {
                    const auto rpn(o.root_parents().front());
#>
    virtual bool equals(const <#= ast.get_qualified_name(rpn) #>& other) const = 0;
<#+
                } else if (!o.root_parents().empty()) {
                    const auto rpn(o.root_parents().front());
#>
    bool equals(const <#= ast.get_qualified_name(rpn) #>& other) const<#= ast.make_override_keyword_text() #>;
<#+
                }
#>

<#+
             }

            /*
             * Swap and assignment.
             *
             * Swap and assignment are only public in leaf classes - MEC++-33
             */
            if ((!o.all_attributes().empty() || o.is_parent()) && !o.is_immutable()) {
                if (o.is_parent()) {
#>
protected:
<#+
                } else {
#>
public:
<#+
                }
#>
    void swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #>;
<#+
                if (!o.is_parent() && !o.is_immutable()) {
#>
    <#= sn #>& operator=(<#= sn #> other);
<#+
                }
#>

<#+
            }

            /*
             * Member variables.
             */
            if (!o.local_attributes().empty()) {
#>
private:
<#+
                for (const auto& attr : o.local_attributes()) {
#>
    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.member_variable_name() #>;
<#+
                }
            }
#>
};

<#+
            /*
             * Destructor implementation.
             */
            if (o.is_parent()) {
#>
inline <#= sn #>::~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> { }

<#+
            }

            /*
             * Global equality operator implementation.
             */
            if (o.is_parent()) {
#>
inline bool operator==(const <#= sn #>& lhs, const <#= sn #>& rhs) {
    return lhs.equals(rhs);
}

<#+
            }
        }

        if (!o.all_attributes().empty() && !o.is_parent() && !o.is_immutable()) {
#>

namespace std {

template<>
inline void swap(
    <#= qn #>& lhs,
    <#= qn #>& rhs) {
    lhs.swap(rhs);
}

}
<#+
        }
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::types::exception_header
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.exception
:masd.wale.kvp.class.simple_name: exception_header_transform
:masd.wale.kvp.archetype.simple_name: exception_header
:masd.wale.kvp.meta_element: exception
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.label.roles: type_declaration
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for exceptions.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/exception.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/exception_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/exception_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> exception_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& /*e*/) const {
    auto builder(f.make());
    builder.add(inclusion_constants::std::string());
    builder.add(inclusion_constants::boost::exception::info());
    return builder.build();
}

void exception_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "exception header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& ye(ast.as<logical::entities::structural::exception>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(ye.documentation());
#>
class <#= ye.name().simple() #> : public virtual std::exception, public virtual boost::exception {
public:
<#+
            if (ast.is_cpp_standard_98()) {
#>
    <#= ye.name().simple() #>() {}
    ~<#= ye.name().simple() #>() {}
<#+
            } else {
#>
    <#= ye.name().simple() #>() = default;
    ~<#= ye.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> = default;
<#+
            }
#>

public:
    explicit <#= ye.name().simple() #>(const std::string& message) : message_(message) { }

public:
<#+
            if (ast.is_cpp_standard_98()) {
                // Note: we are using BOOST_NOEXCEPT here by design. The problem is
                // users may include this header in a C++ 98 project or in a C++ > 11 project;
                // and we need to have different behaviours. Depending on this inclusion.
                // If we do not, we will cause compilation errors when including C++ 98 code
                // on a C++ 11 project. This is because the standard library will have noexcept
                // but we won't (as we were generated for C++ 98), so we'd be weakening the exception
                // guarantees. By using the boost macro we will do the right thing hopefully.
                // And since we already need boost for exception, we should be ok.
#>
    const char* what() const BOOST_NOEXCEPT { return(message_.c_str()); }
<#+
            } else {
#>
    const char* what() const<#= ast.make_noexcept_keyword_text() #> { return(message_.c_str()); }
<#+
            }
#>

private:
    const std::string message_;
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::enum_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.label.roles: type_declaration
:masd.injection.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
:END:

Generates header files for enumerations.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> enum_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    using logical::entities::structural::enumeration;
    const auto& en(assistant::as<enumeration>(e));
    auto builder(f.make());
    const auto arch(traits::canonical_archetype());
    builder.add(en.underlying_element(), arch);
    return builder.build();
}

void enum_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(e.documentation());
            if (ast.is_cpp_standard_98()) {
#>
enum <#= ye.name().simple() #> {
<#+
            } else {
                if (ye.use_implementation_defined_underlying_element())
#>
enum class <#= ye.name().simple() #> {
<#+
                else
#>
enum class <#= ye.name().simple() #> : <#= ast.get_qualified_name(ye.underlying_element()) #> {
<#+
            }

            utility::formatters::sequence_formatter sf(ye.enumerators().size());
            for (const auto& en : ye.enumerators()) {
                if (ye.use_implementation_defined_enumerator_values())
#>
    <#= en.name().simple() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>
<#+
                else
#>
    <#= en.name().simple() #> = <#= en.value() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>
<#+
                sf.next();
            }
#>
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::namespace_header
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.module
:masd.wale.kvp.class.simple_name: namespace_header_transform
:masd.wale.kvp.archetype.simple_name: namespace_header
:masd.wale.kvp.meta_element: module
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for namespaces.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/module.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/namespace_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/namespace_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> namespace_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void namespace_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "namespace header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& m(ast.as<logical::entities::structural::module>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            if (ast.requires_nested_namespaces()) {
                ast.comment(m.documentation());
                const auto ns(ast.make_namespaces(e.name(),
                        false/*detect_model_name*/));
                auto snf(ast.make_scoped_namespace_formatter(ns));
            } else {
                const auto ns(ast.make_namespaces(m.name()));
                auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
                ast.comment(m.documentation());
#>
namespace <#= m.name().simple() #> {
}

<#+
            }
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::visitor_header
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.visitor
:masd.wale.kvp.class.simple_name: visitor_header_transform
:masd.wale.kvp.archetype.simple_name: visitor_header
:masd.wale.kvp.meta_element: visitor
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.label.roles: type_declaration
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for visitors.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/visitor.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/visitor_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/visitor_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> visitor_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    using logical::entities::structural::visitor;
    const auto& v(assistant::as<visitor>(e));
    auto builder(f.make());
    builder.add(v.visits(), traits::class_forward_declarations_archetype_qn());

    if (v.parent())
        builder.add(*v.parent(), traits::visitor_header_archetype_qn());

    return builder.build();
}

void visitor_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "visitor header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& v(ast.as<logical::entities::structural::visitor>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(v.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(v.documentation());
            if (!v.parent())
#>
class <#= v.name().simple() #> {
<#+
            else {
                const auto& pn(*v.parent());
                const auto pqn(ast.get_qualified_name(pn));
#>
class <#= v.name().simple() #> : public <#= pqn #> {
<#+
            }
#>
public:
    virtual ~<#= v.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> = 0;

public:
<#+
            if (v.parent()) {
                const auto& pn(*v.parent());
                const auto pqn(ast.get_qualified_name(pn));
#>
    using <#= pqn #>::visit;

<#+
            }

            bool is_first(true);
            for (const auto& t : v.visits()) {
                if (!is_first)
#>

<#+
                const auto qn(ast.get_qualified_name(t));
                const auto doc("Accept visits for type " + qn);
                ast.comment_start_method_group(doc);
#>
    virtual void visit(const <#= qn #>&) const { }
    virtual void visit(const <#= qn #>&) { }
    virtual void visit(<#= qn #>&) const { }
    virtual void visit(<#= qn #>&) { }
<#+
                ast.comment_end_method_group(doc);
                is_first = false;
            }
#>
};

inline <#= v.name().simple() #>::~<#= v.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> { }

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::class_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_implementation_configuration
:END:

Generates implementation files for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    using logical::entities::structural::object;
    const auto& o(assistant::as<object>(e));
    auto builder(f.make());

    const auto ch_arch(traits::class_header_archetype_qn());
    builder.add(o.name(), ch_arch);
    builder.add(o.opaque_associations(), ch_arch);

    const auto io_arch(transforms::io::traits::class_header_archetype_qn());
    const bool in_inheritance(o.is_parent() || o.is_child());
    const bool io_enabled(builder.is_enabled(o.name(), io_arch));
    const bool requires_io(io_enabled && in_inheritance);

    if (!requires_io)
        return builder.build();

    const auto os(inclusion_constants::std::ostream());
    builder.add(os);

    const auto io_carch(io::traits::canonical_archetype());
    builder.add(o.transparent_associations(), io_carch);
    builder.add(o.opaque_associations(), io_carch);
    builder.add(o.parents(), io_carch);

    if (o.is_visitation_leaf()) {
        /*
         * Only leaves have a visitation implementation. Note that we
         * don't bother including the base if we are already including
         * the derived visitor.
         */
        const auto v_arch(traits::visitor_header_archetype_qn());
        if (o.derived_visitor())
            builder.add(*o.derived_visitor(), v_arch);
        else
            builder.add(*o.base_visitor(), v_arch);
    }

    return builder.build();
}

void class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        ast.add_helper_methods(o.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));

            /*
             * Default constructor.
             */
            if (ast.requires_manual_default_constructor()) {
#>

<#= sn #>::<#= sn #>()
<#+
                // FIXME: this was just too hard to hack with a sequence.
                // FIXME: indentation is all off too.
                std::ostringstream ss;
                bool is_first(true);
                bool found(false);
                for (const auto& attr : o.local_attributes()) {
                    if (!attr.parsed_type().is_current_simple_type())
                        continue;

                    found = true;
                    if (!is_first)
                        ss << "," << std::endl << "      ";

                    ss << attr.member_variable_name()
                       << "(static_cast<" << ast.get_qualified_name(attr.parsed_type())
                       << ">(0))";

                    is_first = false;
                }
                ss << " { }";
                const std::string out(ss.str());
#>
    <#= (found ? ": " : "") #><#= out #>
<#+
            }

            /*
             * Move constructor.
             */
            if (ast.requires_manual_move_constructor()) {
#>

<#= sn #>::<#= sn #>(<#= sn #>&& rhs)
<#+
                const auto size(o.parents().size() + o.local_attributes().size());

                utility::formatters::sequence_formatter sf(size);
                sf.prefix_configuration().first(": ").not_first("  ");
                sf.postfix_configuration().last(" { }");
                if (!o.parents().empty()) {
                    const auto& pn(o.parents().front());
                    const auto pqn(ast.get_qualified_name(pn));
#>
    <#= sf.prefix() #><#= pqn #>(
        std::forward<<#= pqn #>>(rhs))<#= sf.postfix() #>
<#+
                    sf.next();
                }

                for (const auto& attr : o.local_attributes()) {
#>
    <#= sf.prefix() #><#= attr.member_variable_name() #>(std::move(rhs.<#= attr.member_variable_name() #>))<#= sf.postfix() #>
<#+
                    sf.next();
                }
            }

            /*
             * Complete constructor.
             */
            if (!o.all_attributes().empty()) {
                const auto attr_count(o.all_attributes().size());
                if (attr_count == 1) {
                     const auto attr(*o.all_attributes().begin());
#>

<#= sn #>::<#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>)
<#+
                } else {
#>

<#= sn #>::<#= sn #>(
<#+

                    utility::formatters::sequence_formatter sf(attr_count);
                    sf.postfix_configuration().last(")");
                    for (const auto& attr : o.all_attributes()) {
#>
    const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #><#= sf.postfix() #>
<#+
                        sf.next();
                    }
                }

                auto sequence_size(o.local_attributes().size() + o.parents().size());
                for (const auto& pair : o.inherited_attributes()) {
                    const auto& pattrs(pair.second);
                    sequence_size += (pattrs.size() > 1 ? pattrs.size() : 0);
                }

                utility::formatters::sequence_formatter sf(sequence_size);
                sf.postfix_configuration().last(" { }");
                sf.prefix_configuration().first(": ").not_first("  ");
                for (const auto& pair : o.inherited_attributes()) {
                    const auto pqn(ast.get_qualified_name(pair.first));
                    const auto& pattrs(pair.second);
                    if (pattrs.size() <= 1) {
#>
    <#= sf.prefix() #><#= pqn #>(<#= (pattrs.empty() ? "" : pattrs.front().name().simple()) #>)<#= sf.postfix() #>
<#+
                        sf.next();
                    } else {
#>
    <#= sf.prefix() #><#= pqn #>(<#= sf.postfix(true/*skip*/) #>
<#+
                        sf.next();
                        utility::formatters::sequence_formatter sf2(pattrs.size());
                        sf2.element_separator("");

                        sf2.prefix_configuration().first("  ").not_first("  ");
                        sf2.postfix_configuration().last(")");
                        for (const auto& attr : pattrs) {
#>
    <#= sf2.prefix() #><#= attr.name().simple() #><#= sf2.postfix() #><#= sf.postfix() #>
<#+
                            sf2.next();
                            sf.next();
                        }
                    }
                }

                for (const auto& attr : o.local_attributes()) {
#>
    <#= sf.prefix() #><#= attr.member_variable_name() #>(<#= attr.name().simple() #>)<#= sf.postfix() #>
<#+
                    sf.next();
                }
            }

            /*
             * Visitation.
             */
            if (o.is_visitation_leaf()) {
                std::string bvn;
                std::string dvn;
                std::string rpn;
                if (o.derived_visitor()) {
                    bvn = ast.get_qualified_name(*o.base_visitor());
                    dvn = o.derived_visitor()->simple();
                    rpn = ast.get_qualified_name(o.root_parents().front());
                } else {
                    bvn = o.base_visitor()->simple();
                    rpn = o.root_parents().front().simple();
                }
#>

void <#= sn #>::accept(const <#= bvn #>& v) const {
<#+
                if (o.derived_visitor()) {
#>
    typedef const <#= dvn #>* derived_ptr;
    const auto dv(dynamic_cast<derived_ptr>(&v));
    if (dv)
        dv->visit(*this);
<#+
                } else {
#>
    v.visit(*this);
<#+
                }
#>
}

void <#= sn #>::accept(<#= bvn #>& v) const {
<#+
                if (o.derived_visitor()) {
#>
    typedef <#= dvn #>* derived_ptr;
    const auto dv(dynamic_cast<derived_ptr>(&v));
    if (dv)
        dv->visit(*this);
<#+
                } else {
#>
    v.visit(*this);
<#+
                }
#>
    }

void <#= sn #>::accept(const <#= bvn #>& v) {
<#+
                if (o.derived_visitor()) {
#>
    typedef const <#= dvn #>* derived_ptr;
    const auto dv(dynamic_cast<derived_ptr>(&v));
    if (dv)
        dv->visit(*this);
<#+
                } else {
#>
    v.visit(*this);
<#+
                }
#>
}

void <#= sn #>::accept(<#= bvn #>& v) {
<#+
                if (o.derived_visitor()) {
#>
    typedef <#= dvn #>* derived_ptr;
    const auto dv(dynamic_cast<derived_ptr>(&v));
    if (dv)
        dv->visit(*this);
<#+
                } else {
#>
    v.visit(*this);
<#+
                }
#>
}
<#+
            }

            /*
             * Streaming
             */
            if (ast.is_io_enabled()) {
                if (o.in_inheritance_relationship()) {
#>

void <#= sn #>::to_stream(std::ostream& s) const {
<#+
                io::inserter_implementation_helper(ast, o, true/*inside_class*/);
#>
}
<#+
                }
            }

            /*
             * Swap
             */
            if (!o.is_immutable() && (!o.all_attributes().empty() || o.is_parent())) {
                const bool empty(o.all_attributes().empty() && o.parents().empty());
#>

void <#= sn #>::swap(<#= sn #>&<#= (empty ? "" : " other") #>)<#= ast.make_noexcept_keyword_text() #> {
<#+
               if (!o.parents().empty()) {
                    const auto& pn(o.parents().front());
                    const auto pqn(ast.get_qualified_name(pn));
#>
    <#= pqn #>::swap(other);

<#+

               }

               if (!o.local_attributes().empty()) {
#>
    using std::swap;
<#+
                   for (const auto& attr : o.local_attributes())
#>
    swap(<#= attr.member_variable_name() #>, other.<#= attr.member_variable_name() #>);
<#+
               }
#>
}
<#+
            }

            /*
             * Equals method
             */
            // FIXME: looking at root_parent as a hack due to service leafs not
            // FIXME: being processed atm.
            if (!o.is_parent() && !o.parents().empty() && !o.root_parents().empty()) {
                const auto rpn(o.root_parents().front());
#>

bool <#= sn #>::equals(const <#= ast.get_qualified_name(rpn) #>& other) const {
    const <#= sn #>* const p(dynamic_cast<const <#= sn #>* const>(&other));
    if (!p) return false;
    return *this == *p;
}
<#+
            }

            /*
             * Equals operator
             */
            std::string method_name;
            if (o.is_parent())
                method_name = "compare";
            else
                method_name = "operator==";
#>

bool <#= sn #>::<#= method_name #>(const <#= sn #>& <#= (o.all_attributes().empty() ? "/*rhs*/" : "rhs") #>) const {
<#+

            if (o.all_attributes().empty())
#>
    return true;
<#+
            else {
                utility::formatters::sequence_formatter sf(o.parents().size());
                sf.element_separator("");
                sf.prefix_configuration().first("return ").not_first("    ");
                sf.postfix_configuration().not_last(" &&");
                if (o.local_attributes().empty())
                    sf.postfix_configuration().last(";");
                else
                    sf.postfix_configuration().last(" &&");

                if (!o.parents().empty()) {
                    const auto& pn(o.parents().front());
                    const auto pqn(ast.get_qualified_name(pn));
#>
    <#= sf.prefix() #><#= pqn #>::compare(rhs)<#= sf.postfix() #>
<#+
                    sf.next();
                }
                sf.reset(o.local_attributes().size());
                sf.element_separator("");
                if (o.parents().empty())
                   sf.prefix_configuration().first("return ");
                else
                   sf.prefix_configuration().first("    ");
                sf.prefix_configuration().not_first("    ");
                sf.postfix_configuration().last(";").not_last(" &&");
                for (const auto& attr : o.local_attributes()) {
#>
    <#= sf.prefix() #><#= attr.member_variable_name() #> == rhs.<#= attr.member_variable_name() #><#= sf.postfix() #>
<#+
                    sf.next();
                }
            }
#>
}
<#+

            /*
             * Assignment
             */
            if (!o.all_attributes().empty() && !o.is_parent() && !o.is_immutable()) {
#>

<#= sn #>& <#= sn #>::operator=(<#= sn #> other) {
    using std::swap;
    swap(*this, other);
    return *this;
}
<#+
            }

            /*
             * Getters and setters
             */
             for (const auto& attr : o.local_attributes()) {
                 if (attr.parsed_type().is_current_simple_type()) {
#>

<#= ast.get_qualified_name(attr.parsed_type()) #> <#= sn #>::<#= attr.name().simple() #>() const {
    return <#= attr.member_variable_name() #>;
}
<#+
                    if (!o.is_immutable()) {
#>

<#= (attr.is_fluent() ? sn + "&" : "void") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #> v) {
    <#= attr.member_variable_name() #> = v;
<#+
                        if (attr.is_fluent()) {
#>
    return *this;
<#+
                        }
#>
}
<#+
                    }
                } else {
#>

const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() const {
    return <#= attr.member_variable_name() #>;
}
<#+
                    if (!o.is_immutable()) {
#>

<#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() {
    return <#= attr.member_variable_name() #>;
}

<#= (o.is_fluent() ? sn + "&" : "void") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>& v) {
    <#= attr.member_variable_name() #> = v;
<#+
                        if (o.is_fluent()) {
#>
    return *this;
<#+
                        }
#>
}
<#+
                        if (ast.supports_move_operator()) {
#>

<#= (o.is_fluent() ? sn + "&" : "void") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v) {
    <#= attr.member_variable_name() #> = std::move(v);
<#+
                            if (o.is_fluent()) {
#>
    return *this;
<#+
                            }
#>
}
<#+
                        }
                    }
                }
            }
#>

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::types::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::types::builtin_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.label.roles: type_declaration
:masd.injection.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
:END:

Generates header files for builtins.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> builtin_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static const std::list<std::string> r;
    return r;
}

void builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    a.logical_name().simple(e.name().simple());
    a.logical_name().qualified(e.name().qualified().dot());
    a.origin_sha1_hash(e.origin_sha1_hash());
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::smart_pointer_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::types::primitive_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.label.roles: type_declaration
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
:END:

Generates header files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> primitive_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    using logical::entities::structural::primitive;
    const auto& p(assistant::as<primitive>(e));
    auto builder(f.make());

    // algorithm: domain headers need it for the swap function.
    builder.add(inclusion_constants::std::algorithm());

    using ser = transforms::serialization::traits;
    const auto ser_fwd_arch(ser::primitive_forward_declarations_archetype_qn());
    builder.add(p.name(), ser_fwd_arch);

    const auto carch(traits::canonical_archetype());
    builder.add(p.value_attribute().parsed_type().current(), carch);

    return builder.build();
}

void primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto attr(p.value_attribute());

            ast.comment(p.documentation());
#>
class <#= sn #> final {
public:
<#+
            /*
             * Compiler generated constructors and destructors.
             */
            if (!ast.requires_manual_default_constructor())
#>
    <#= sn #>() = default;
    <#= sn #>(const <#= sn #>&) = default;
<#+
            if (!ast.requires_manual_move_constructor())
#>
    <#= sn #>(<#= sn #>&&) = default;
    ~<#= sn #>() = default;
<#+
            if (p.is_immutable())
#>
    <#= sn #>& operator=(const <#= sn #>&) = delete;
<#+
            /*
             * Manually generated default constructor.
             */
            if (ast.requires_manual_default_constructor()) {
#>
public:
    <#= sn #>();

<#+
            }

            /*
             * Manually generated move constructor.
             */
            if (ast.requires_manual_move_constructor()) {
#>
public:
    <#= sn #>(<#= sn #>&& rhs);

<#+
            }

            /*
             * Manually generated complete constructor.
             */
#>
public:
    explicit <#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>);

<#+
            /*
             * Serialisaton Friends
             */
            if (ast.is_serialization_enabled()) {
#>
private:
    template<typename Archive>
    friend void boost::serialization::save(Archive& ar, const <#= qn #>& v, unsigned int version);

    template<typename Archive>
    friend void boost::serialization::load(Archive& ar, <#= qn #>& v, unsigned int version);

<#+
            }

            /*
             * Getters and setters.
             */
#>
public:
<#+
            ast.comment_start_method_group(attr.documentation(), !attr.is_immutable());
            if (attr.parsed_type().is_current_simple_type()) {
#>
    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #>() const;
<#+
                if (attr.is_immutable()) {
#>

<#+

                } else {
#>
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);
<#+
                }
            } else {
#>
    const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= attr.name().simple() #>() const;
<#+
                if (attr.is_immutable()) {
#>

<#+
                } else {
#>
    <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>();
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v);
<#+
                }
            }
            ast.comment_end_method_group(attr.documentation(), !attr.is_immutable());

            /*
             * Explicit cast.
             */
#>

public:
    explicit operator <#= ast.get_qualified_name(attr.parsed_type()) #>() const {
        return <#= attr.member_variable_name() #>;
    }
<#+
            /*
             * Equality.
             */
#>

public:
    bool operator==(const <#= sn #>& rhs) const;
    bool operator!=(const <#= sn #>& rhs) const {
        return !this->operator==(rhs);
    }

<#+
            /*
             * Swap and assignment.
             */
#>
public:
    void swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #>;
<#+
            if (!p.is_immutable()) {
#>
    <#= sn #>& operator=(<#= sn #> other);
<#+
            }

            /*
             * Member variables.
             */
#>

private:
    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.member_variable_name() #>;
};

<#+
        } // snf

        if (!p.is_immutable()) {
#>

namespace std {

template<>
inline void swap(
    <#= qn #>& lhs,
    <#= qn #>& rhs) {
    lhs.swap(rhs);
}

}
<#+
        }
#>

<#+
    } //ah  sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::primitive_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_implementation_configuration
:END:

Generates implementation files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/primitive_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/primitive_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string>
primitive_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    using logical::entities::structural::primitive;
    const auto& o(assistant::as<primitive>(e));
    auto builder(f.make());

    const auto ch_arch(traits::primitive_header_archetype_qn());
    builder.add(o.name(), ch_arch);
    return builder.build();
}

void primitive_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto attr(p.value_attribute());

            /*
             * Default constructor.
             */
            if (ast.requires_manual_default_constructor()) {
#>

<#= sn #>::<#= sn #>()
    : <#= attr.member_variable_name() #>(static_cast<<#= ast.get_qualified_name(attr.parsed_type()) #>>(0)) { }
<#+
            }

            /*
             * Move constructor.
             */
            if (ast.requires_manual_move_constructor()) {
#>

<#= sn #>::<#= sn #>(<#= sn #>&& rhs)
    : <#= attr.member_variable_name() #>(std::move(rhs.<#= attr.member_variable_name() #>)) { }
<#+
            }

            /*
             * Complete constructor.
             */
#>

<#= sn #>::<#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>)
    : <#= attr.member_variable_name() #>(<#= attr.name().simple() #>) { }

<#+
            /*
             * Getters and setters
             */
             if (attr.parsed_type().is_current_simple_type()) {
#>
<#= ast.get_qualified_name(attr.parsed_type()) #> <#= sn #>::<#= attr.name().simple() #>() const {
    return <#= attr.member_variable_name() #>;
}

<#+
                if (!p.is_immutable()) {
#>
void <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #> v) {
    <#= attr.member_variable_name() #> = v;
}

<#+
                }
            } else {
#>
const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() const {
    return <#= attr.member_variable_name() #>;
}
<#+
                if (!p.is_immutable()) {
#>

<#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() {
    return <#= attr.member_variable_name() #>;
}

void <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>& v) {
    <#= attr.member_variable_name() #> = v;
}

void <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v) {
    <#= attr.member_variable_name() #> = std::move(v);
}

<#+
                }
            }

            /*
             * Equality.
             */
#>
bool <#= sn #>::operator==(const <#= sn #>& rhs) const {
    return <#= attr.member_variable_name() #> == rhs.<#= attr.member_variable_name() #>;
}

<#+
            /*
             * Swap and assignment.
             */
            if (!p.is_immutable()) {
#>
void <#= sn #>::swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #> {
    using std::swap;
    swap(<#= attr.member_variable_name() #>, other.<#= attr.member_variable_name() #>);
}

<#= sn #>& <#= sn #>::operator=(<#= sn #> other) {
    using std::swap;
    swap(*this, other);
    return *this;
}

<#+
            }
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::types::feature_template_bundle_header
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.variability_feature_template_bundle
:masd.wale.kvp.class.simple_name: feature_template_bundle_header_transform
:masd.wale.kvp.archetype.simple_name: feature_template_bundle_header
:masd.wale.kvp.meta_element: variability_feature_template_bundle
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates implementation files for feature template bundles

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/string/splitter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/feature_template_bundle.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/feature_template_bundle_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/feature_template_bundle_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> feature_template_bundle_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    using logical::entities::variability::feature_template_bundle;

    const auto& fb(assistant::as<feature_template_bundle>(e));
    auto builder(f.make());

    builder.add(inclusion_constants::std::list());
    builder.add_as_user("dogen.variability/types/entities/feature_template.hpp");

    if (fb.generate_static_configuration()) {
        builder.add_as_user("dogen.variability/types/entities/feature_model.hpp");
        builder.add_as_user("dogen.variability/types/entities/configuration.hpp");
        builder.add_as_user("dogen.variability/types/entities/feature.hpp");

        const auto ch_arch(traits::class_header_archetype_qn());
        builder.add(fb.transparent_associations(), ch_arch);

        const auto fwd_arch(traits::class_forward_declarations_archetype_qn());
        builder.add(fb.opaque_associations(), fwd_arch);
    }

    return builder.build();
}

void feature_template_bundle_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "feature template bundle header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& fb(ast.as<logical::entities::variability::feature_template_bundle>(e));

    {
        const auto sn(fb.name().simple());
        const auto qn(ast.get_qualified_name(fb.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(fb));
        ast.add_helper_methods(fb.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(fb.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            using utility::string::splitter;
#>

<#+
            ast.comment(fb.documentation());
#>
class <#= sn #> final {
<#+
            if (fb.generate_static_configuration()) {
#>
public:
    struct feature_group {
<#+
                for (const auto& fb_ft : fb.feature_templates()) {
                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());
#>
        variability::entities::feature <#= simple_key #>;
<#+
                }
#>
    };

    static feature_group
    make_feature_group(const variability::entities::feature_model& fm);

public:
    struct static_configuration {
<#+
                for (const auto& fb_ft : fb.feature_templates()) {
                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());
#>
        <#= ast.get_qualified_name(fb_ft.parsed_type()) #> <#= simple_key #>;
<#+
                }

                if (fb.requires_manual_default_constructor()) {
                    bool is_first(true);
                    std::ostringstream ss;
                    for (const auto& fb_ft : fb.feature_templates()) {
                        if (!fb_ft.parsed_type().is_current_simple_type())
                            continue;

                        const auto simple_key(splitter::split_scoped(fb_ft.key()).back());

                        if (!is_first)
                            ss << "," << std::endl << "            ";

                        ss << simple_key << "()";
                        is_first = false;
                    }
#>

        static_configuration() :
            <#= ss.str() #> {}
<#+
                }
#>
    };

    static static_configuration make_static_configuration(
        const feature_group& fg,
        const variability::entities::configuration& cfg);

    template<typename Configurable>
    static static_configuration make_static_configuration(
        const feature_group& fg, const Configurable& c) {
        return make_static_configuration(fg, *c.configuration());
    }
<#+
            }

            if (fb.generate_registration()) {
#>

public:
    static std::list<dogen::variability::entities::feature_template>
    make_templates();
<#+
            }
#>
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::types::feature_template_bundle_implementation
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.variability_feature_template_bundle
:masd.wale.kvp.class.simple_name: feature_template_bundle_implementation_transform
:masd.wale.kvp.archetype.simple_name: feature_template_bundle_implementation
:masd.wale.kvp.meta_element: variability_feature_template_bundle
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation files for feature templates.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/string/splitter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.variability/types/helpers/enum_mapper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/feature_template_bundle.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/feature_template_bundle_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/feature_template_bundle_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> feature_template_bundle_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    using logical::entities::variability::feature_template_bundle;
    const auto& fb(assistant::as<feature_template_bundle>(e));
    auto builder(f.make());

    const auto ch_arch(traits::feature_template_bundle_header_archetype_qn());
    builder.add(fb.name(), ch_arch);
    builder.add_as_user("dogen.variability/types/helpers/value_factory.hpp");

    if (fb.generate_static_configuration()) {
        builder.add_as_user("dogen.variability/types/helpers/feature_selector.hpp");
        builder.add_as_user("dogen.variability/types/helpers/configuration_selector.hpp");
    }

    return builder.build();
}

void feature_template_bundle_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "feature template bundle implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& ftb(ast.as<logical::entities::variability::feature_template_bundle>(e));

    {
        const auto sn(ftb.name().simple());
        const auto qn(ast.get_qualified_name(ftb.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(ftb));
        ast.add_helper_methods(ftb.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(ftb.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            using namespace variability::helpers;
            using utility::string::splitter;

            if (ftb.generate_registration()) {
#>

namespace {
<#+
                for (const auto& ft : ftb.feature_templates()) {
                    const auto simple_key(splitter::split_scoped(ft.key()).back());
                    const bool has_qualified_name(simple_key != ft.key());
#>

dogen::variability::entities::feature_template
make_<#= ft.identifiable_key() #>() {
    using namespace dogen::variability::entities;
    feature_template r;
    r.name().simple("<#= simple_key #>");
<#+
                    if (has_qualified_name) {
#>
    r.name().qualified("<#= ft.key() #>");
<#+
                    }
#>
    r.description(R"(<#= ft.documentation() #>
)");
    const auto vt(<#= enum_mapper::from_value_type(ft.value_type()) #>);
    r.value_type(vt);
    r.binding_point(<#= enum_mapper::from_binding_point(*ft.binding_point()) #>);
    r.instantiation_domain_name("<#= ftb.instantiation_domain_name() #>");
<#+

                    if (!ft.default_value().empty()) {
#>
    dogen::variability::helpers::value_factory f;
    r.default_value(f.make(vt, std::list<std::string>{ <#= ft.default_value() #> }));
<#+
                        for (const auto& dvo : ft.default_value_overrides()) {
#>
    r.default_value_overrides().push_back(
        default_value_override("<#= dvo.key_ends_with() #>",
            f.make(vt, std::list<std::string>{ <#= dvo.default_value() #> })));
<#+
                       }
                   }
#>
    return r;
}
<#+
                }
#>

}

<#+
            }

            if (ftb.generate_static_configuration()) {
#>
<#= sn #>::feature_group
<#= sn #>::make_feature_group(const dogen::variability::entities::feature_model& fm) {
    feature_group r;
    const dogen::variability::helpers::feature_selector s(fm);

<#+
                for (const auto& ft : ftb.feature_templates()) {
                    const auto simple_key(splitter::split_scoped(ft.key()).back());
#>
    r.<#= simple_key #> = s.get_by_name("<#= ft.key() #>");
<#+
                }
#>

    return r;
}

<#= sn #>::static_configuration <#= sn #>::make_static_configuration(
    const feature_group& fg,
    const dogen::variability::entities::configuration& cfg) {

    static_configuration r;
    const dogen::variability::helpers::configuration_selector s(cfg);
<#+
                for (const auto& ft : ftb.feature_templates()) {
                    const auto simple_key(splitter::split_scoped(ft.key()).back());

                    const bool has_default_value(!ft.default_value().empty());
                    if (has_default_value) {
#>
    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content_or_default(fg.<#= simple_key #>);
<#+
                    } else if (ft.is_optional()) {
#>
    if (s.has_configuration_point(fg.<#= simple_key #>))
        r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);
<#+
                    } else {
#>
    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);
<#+
                    }
                }
#>
    return r;
}
<#+
            }

            if (ftb.generate_registration()) {

#>

std::list<dogen::variability::entities::feature_template>
<#= sn #>::make_templates() {
    using namespace dogen::variability::entities;
    std::list<dogen::variability::entities::feature_template> r;
<#+

                for (const auto& ft : ftb.feature_templates()) {
#>
    r.push_back(make_<#= ft.identifiable_key() #>());
<#+
                }
#>
    return r;
}

<#+
            }
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::variability_initializer_header
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.variability_initializer
:masd.wale.kvp.class.simple_name: variability_initializer_header_transform
:masd.wale.kvp.archetype.simple_name: variability_initializer_header
:masd.wale.kvp.meta_element: variability_initializer
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for feature bundles.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/initializer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/variability_initializer_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/variability_initializer_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> variability_initializer_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& /*e*/) const {

    using logical::entities::variability::initializer;
    auto builder(f.make());
    builder.add_as_user("dogen.variability/types/entities/feature_template.hpp");
    builder.add_as_user("dogen.variability/types/helpers/registrar.hpp");

    return builder.build();
}

void variability_initializer_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "variability initializer header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::variability::initializer>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Registers all of the available feature templates with registrar.
 */
class <#= sn #> final {
public:
    static void register_entities(variability::helpers::registrar& rg);
};

<#+
        }
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::types::variability_initializer_implementation
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.variability_initializer
:masd.wale.kvp.class.simple_name: variability_initializer_implementation_transform
:masd.wale.kvp.archetype.simple_name: variability_initializer_implementation
:masd.wale.kvp.meta_element: variability_initializer
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates header files for feature bundles.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/initializer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/variability_initializer_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/variability_initializer_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> variability_initializer_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    using logical::entities::variability::initializer;
    const auto& o(assistant::as<initializer>(e));
    auto builder(f.make());

    const auto ch_arch(traits::variability_initializer_header_archetype_qn());
    builder.add(o.name(), ch_arch);

    const auto ftb_arch(traits::feature_template_bundle_header_archetype_qn());
    builder.add(o.feature_template_bundles(), ftb_arch);

    const auto fb_arch(traits::feature_bundle_header_archetype_qn());
    builder.add(o.feature_bundles(), fb_arch);

    return builder.build();
}

void variability_initializer_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "variability initializer implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::variability::initializer>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        ast.add_helper_methods(o.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

void <#= sn #>::
register_entities(variability::helpers::registrar& rg) {
<#+
            for (const auto& n : o.feature_template_bundles())
#>
    rg.register_templates(<#= n.qualified().colon() #>::make_templates());
<#+
            if (!o.feature_bundles().empty()) {
                for (const auto& n : o.feature_bundles())
#>
    rg.register_features(<#= n.qualified().colon() #>::make_features());
<#+
            }
#>
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::class_forward_declarations
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.object
:masd.wale.kvp.class.simple_name: class_forward_declarations_transform
:masd.wale.kvp.archetype.simple_name: class_forward_declarations
:masd.wale.kvp.class.inclusion_support_type: regular_support
:masd.physical.referencing_status: referable
:masd.wale.kvp.meta_element: object
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.label.roles: forward declaration
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_configuration
:END:

Generates forward declarations for classes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/class_forward_declarations_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/class_forward_declarations_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_forward_declarations_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void class_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class forward declarations transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= o.name().simple() #>;

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::visitor_forward_declarations
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.visitor
:masd.wale.kvp.class.simple_name: visitor_forward_declarations_transform
:masd.wale.kvp.archetype.simple_name: visitor_forward_declarations
:masd.physical.referencing_status: referable
:masd.wale.kvp.class.inclusion_support_type: regular_support
:masd.wale.kvp.meta_element: visitor
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.label.roles: forward declaration
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_configuration
:END:

Generates forward declarations for visitors.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/visitor.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/visitor_forward_declarations_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/visitor_forward_declarations_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> visitor_forward_declarations_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void visitor_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "visitor forward declarations transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::visitor>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= o.name().simple() #>;

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::primitive_forward_declarations
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.primitive
:masd.wale.kvp.class.simple_name: primitive_forward_declarations_transform
:masd.wale.kvp.archetype.simple_name: primitive_forward_declarations
:masd.wale.kvp.class.inclusion_support_type: regular_support
:masd.physical.referencing_status: referable
:masd.wale.kvp.meta_element: primitive
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.label.roles: forward declaration
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_configuration
:END:

Generates forward declarations for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/primitive_forward_declarations_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/primitive_forward_declarations_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> primitive_forward_declarations_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void primitive_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive forward declarations transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(p));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= p.name().simple() #>;

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::main
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.entry_point
:masd.wale.kvp.class.simple_name: main_transform
:masd.wale.kvp.archetype.simple_name: main
:masd.wale.kvp.meta_element: entry_point
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation file for entry point.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/entry_point.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/main_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/main_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> main_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void main_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "main transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::entry_point>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

int main(int /*argc*/, char* /*argv*/[]) {
    return 0;
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::feature_bundle_header
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.variability_feature_bundle
:masd.wale.kvp.class.simple_name: feature_bundle_header_transform
:masd.wale.kvp.archetype.simple_name: feature_bundle_header
:masd.wale.kvp.meta_element: variability_feature_bundle
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for feature bundles.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/string/splitter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/feature_bundle.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/feature_bundle_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/feature_bundle_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> feature_bundle_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    using logical::entities::variability::feature_bundle;

    const auto& fb(assistant::as<feature_bundle>(e));
    auto builder(f.make());

    builder.add(inclusion_constants::std::list());
    builder.add_as_user("dogen.variability/types/entities/feature.hpp");

    if (fb.generate_static_configuration()) {
        builder.add_as_user("dogen.variability/types/entities/feature_model.hpp");
        builder.add_as_user("dogen.variability/types/entities/configuration.hpp");

        const auto ch_arch(traits::class_header_archetype_qn());
        builder.add(fb.transparent_associations(), ch_arch);

        const auto fwd_arch(traits::class_forward_declarations_archetype_qn());
        builder.add(fb.opaque_associations(), fwd_arch);
    }

    return builder.build();
}

void feature_bundle_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "feature bundle header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& fb(ast.as<logical::entities::variability::feature_bundle>(e));

    {
        const auto sn(fb.name().simple());
        const auto qn(ast.get_qualified_name(fb.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(fb));
        ast.add_helper_methods(fb.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(fb.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            using utility::string::splitter;
#>

<#+
            ast.comment(fb.documentation());
#>
class <#= sn #> final {
<#+
            if (fb.generate_static_configuration()) {
#>
public:
    struct feature_group {
<#+
                for (const auto& fb_ft : fb.features()) {
                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());
#>
        variability::entities::feature <#= simple_key #>;
<#+
                }
#>
    };

    static feature_group
    make_feature_group(const variability::entities::feature_model& fm);

public:
    struct static_configuration {
<#+
                for (const auto& fb_ft : fb.features()) {
                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());
#>
        <#= ast.get_qualified_name(fb_ft.parsed_type()) #> <#= simple_key #>;
<#+
                }

                if (fb.requires_manual_default_constructor()) {
                    bool is_first(true);
                    std::ostringstream ss;
                    for (const auto& fb_ft : fb.features()) {
                        if (!fb_ft.parsed_type().is_current_simple_type())
                            continue;

                        const auto simple_key(splitter::split_scoped(fb_ft.key()).back());

                        if (!is_first)
                            ss << "," << std::endl << "            ";

                        ss << simple_key << "()";
                        is_first = false;
                    }
#>

        static_configuration() :
            <#= ss.str() #> {}
<#+
                }
#>
    };

    static static_configuration make_static_configuration(
        const feature_group& fg,
        const variability::entities::configuration& cfg);

    template<typename Configurable>
    static static_configuration make_static_configuration(
        const feature_group& fg, const Configurable& c) {
        return make_static_configuration(fg, *c.configuration());
    }
<#+
            }
#>

<#+
            if (fb.generate_registration()) {
#>
public:
    static std::list<dogen::variability::entities::feature>
    make_features();
<#+
            }
#>
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::types::feature_bundle_implementation
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.variability_feature_bundle
:masd.wale.kvp.class.simple_name: feature_bundle_implementation_transform
:masd.wale.kvp.archetype.simple_name: feature_bundle_implementation
:masd.wale.kvp.meta_element: variability_feature_bundle
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation files for feature bundles.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/string/splitter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.variability/types/helpers/enum_mapper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/feature_bundle.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/feature_bundle_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/feature_bundle_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> feature_bundle_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    using logical::entities::variability::feature_bundle;
    const auto& fb(assistant::as<feature_bundle>(e));
    auto builder(f.make());

    const auto ch_arch(traits::feature_bundle_header_archetype_qn());
    builder.add(fb.name(), ch_arch);
    builder.add_as_user("dogen.variability/types/helpers/value_factory.hpp");

    if (fb.generate_static_configuration()) {
        builder.add_as_user("dogen.variability/types/helpers/feature_selector.hpp");
        builder.add_as_user("dogen.variability/types/helpers/configuration_selector.hpp");
    }

    return builder.build();
}

void feature_bundle_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "feature bundle implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& fb(ast.as<logical::entities::variability::feature_bundle>(e));

    {
        const auto sn(fb.name().simple());
        const auto qn(ast.get_qualified_name(fb.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(fb));
        ast.add_helper_methods(fb.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(fb.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            using namespace variability::helpers;
            using utility::string::splitter;

            if (fb.generate_registration()) {
#>

namespace {
<#+
                for (const auto& f : fb.features()) {
                    const auto simple_key(splitter::split_scoped(f.key()).back());
                    const bool has_qualified_name(simple_key != f.key());
#>

dogen::variability::entities::feature
make_<#= f.identifiable_key() #>() {
    using namespace dogen::variability::entities;
    feature r;
    r.name().simple("<#= simple_key #>");
<#+
                   if (has_qualified_name) {
#>
    r.name().qualified("<#= f.key() #>");
<#+
                   }
#>
    r.description(R"(<#= f.documentation() #>
)");
    const auto vt(<#= enum_mapper::from_value_type(f.value_type()) #>);
    r.value_type(vt);
<#+
                   if (f.unparsed_type() == "masd::variability::key_value_pair") {
#>
    r.is_partially_matchable(true);
<#+
                   }
#>
    r.binding_point(<#= enum_mapper::from_binding_point(*f.binding_point()) #>);
<#+
                   if (!f.default_value().empty()) {
#>
    dogen::variability::helpers::value_factory f;
    r.default_value(f.make(vt, std::list<std::string>{ <#= f.default_value() #> }));
<#+
                   }
#>
    return r;
}
<#+
                }
#>

}

<#+
            }

            if (fb.generate_static_configuration()) {
#>
<#= sn #>::feature_group
<#= sn #>::make_feature_group(const dogen::variability::entities::feature_model& fm) {
    feature_group r;
    const dogen::variability::helpers::feature_selector s(fm);

<#+
                for (const auto& f : fb.features()) {
                    const auto simple_key(splitter::split_scoped(f.key()).back());
#>
    r.<#= simple_key #> = s.get_by_name("<#= f.key() #>");
<#+
                }
#>

    return r;
}

<#= sn #>::static_configuration <#= sn #>::make_static_configuration(
    const feature_group& fg,
    const dogen::variability::entities::configuration& cfg) {

    static_configuration r;
    const dogen::variability::helpers::configuration_selector s(cfg);
<#+
                for (const auto& f : fb.features()) {
                    const auto simple_key(splitter::split_scoped(f.key()).back());

                    const bool has_default_value(!f.default_value().empty());
                    if (has_default_value) {
#>
    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content_or_default(fg.<#= simple_key #>);
<#+
                    } else if (f.is_optional()) {
#>
    if (s.has_configuration_point(fg.<#= simple_key #>))
        r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);
<#+
                    } else {
#>
    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);
<#+
                    }
                }
#>
    return r;
}
<#+
            }

            if (fb.generate_registration()) {
#>

std::list<dogen::variability::entities::feature>
<#= sn #>::make_features() {
    using namespace dogen::variability::entities;
    std::list<dogen::variability::entities::feature> r;
<#+

                for (const auto& f : fb.features()) {
#>
    r.push_back(make_<#= f.identifiable_key() #>());
<#+
                }
#>
    return r;
}

<#+
            }
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::archetype_class_header_transform
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype
:masd.wale.kvp.class.simple_name: archetype_class_header_transform_transform
:masd.wale.kvp.archetype.simple_name: archetype_class_header_transform
:masd.wale.kvp.meta_element: physical_archetype
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for archetypes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_class_header_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_class_header_transform_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> archetype_class_header_transform_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    const auto& arch(assistant::as<logical::entities::physical::archetype>(e));

    auto builder(f.make());
    using logical::entities::technical_space;
    if (arch.major_technical_space() == technical_space::cpp) {
        builder.add_as_user(
            "dogen.text.cpp/types/transforms/model_to_text_transform.hpp");
    } else if (arch.major_technical_space() == technical_space::csharp) {
        builder.add_as_user(
            "dogen.text.csharp/types/transforms/model_to_text_transform.hpp");
    }

    return builder.build();
}

void archetype_class_header_transform_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "types archetype class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::physical::archetype>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(o.name().simple() + "_transform");
#>

class <#= sn #> final : public model_to_text_transform {
public:
    static const physical::entities::archetype& static_archetype();
    const physical::entities::archetype& archetype() const override;

public:
<#+
            using logical::entities::technical_space;
            if (o.major_technical_space() == technical_space::cpp) {
#>
    std::list<std::string> inclusion_dependencies(
        const formattables::dependencies_builder_factory& f,
        const logical::entities::element& e) const override;

    inclusion_support_types inclusion_support_type() const override;

    boost::filesystem::path inclusion_path(
        const formattables::locator& l,
        const logical::entities::name& n) const override;

    boost::filesystem::path full_path(
        const formattables::locator& l,
        const logical::entities::name& n) const override;
<#+
            } else if (o.major_technical_space() == technical_space::csharp) {
#>
    std::list<std::string> inclusion_dependencies(
        const logical::entities::element& e) const override;

    boost::filesystem::path full_path(
        const formattables::locator& l, const logical::entities::name& n) const override;
<#+
            }
#>

public:
    void apply(const context& ctx, const logical::entities::element& e,
        physical::entities::artefact& a) const override;
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}

#>

#+end_src
*** transforms::types::archetype_class_implementation_transform
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype
:masd.wale.kvp.class.simple_name: archetype_class_implementation_transform_transform
:masd.wale.kvp.archetype.simple_name: archetype_class_implementation_transform
:masd.wale.kvp.meta_element: physical_archetype
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation files for archetypes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_class_implementation_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_class_implementation_transform_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> archetype_class_implementation_transform_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void archetype_class_implementation_transform_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "archetype class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& arch(ast.as<logical::entities::physical::archetype>(e));
    ast.update_artefact();
    a.content(arch.rendered_stitch_template());
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::facet_class_header_transform
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_facet
:masd.wale.kvp.class.simple_name: facet_class_header_transform_transform
:masd.wale.kvp.archetype.simple_name: facet_class_header_transform
:masd.wale.kvp.meta_element: physical_facet
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for facet transforms.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/facet_class_header_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/facet_class_header_transform_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> facet_class_header_transform_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    const auto& fct(assistant::as<logical::entities::physical::facet>(e));

    auto builder(f.make());
    builder.add_as_user("dogen.physical/types/entities/facet.hpp");
    using logical::entities::technical_space;
    if (fct.major_technical_space() == technical_space::cpp) {
        builder.add_as_user(
            "dogen.text.cpp/types/transforms/registrar.hpp");
    } else if (fct.major_technical_space() == technical_space::csharp) {
        builder.add_as_user(
            "dogen.text.csharp/types/transforms/registrar.hpp");
    }
    const auto ch_arch(traits::class_header_archetype_qn());
    return builder.build();
}

void facet_class_header_transform_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "facet class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& fct(ast.as<logical::entities::physical::facet>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(fct));
        {
            const auto ns(ast.make_namespaces(e.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(fct.documentation());
#>
class <#= fct.name().simple() #>_facet_chain final {
public:
    static const physical::entities::facet& static_facet();
    const physical::entities::facet& facet() const;

public:
    static void initialise(registrar& r);
};
<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::types::facet_class_implementation_transform
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_facet
:masd.wale.kvp.class.simple_name: facet_class_implementation_transform_transform
:masd.wale.kvp.archetype.simple_name: facet_class_implementation_transform
:masd.wale.kvp.meta_element: physical_facet
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation files for facet transforms.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/entities/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/facet_class_implementation_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/facet_class_implementation_transform_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> facet_class_implementation_transform_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    const auto& fct(assistant::as<logical::entities::physical::facet>(e));
    auto builder(f.make());
    const auto ch_arch(traits::canonical_archetype());
    builder.add(fct.name(), ch_arch);
    builder.add(fct.archetypes(), ch_arch);
    builder.add_as_user("dogen.physical/types/helpers/meta_name_builder.hpp");
    builder.add_as_user("dogen.utility/types/log/logger.hpp");
    builder.add_as_user("dogen.text/types/transforms/transformation_error.hpp");

    return builder.build();
}

void facet_class_implementation_transform_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "facet class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& fct(ast.as<logical::entities::physical::facet>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(fct));
        {
            const auto ns(ast.make_namespaces(fct.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(fct.name().simple() + "_facet_chain");
#>
namespace {

using namespace dogen::utility::log;
static logger lg(logger_factory("<#= fct.name().qualified().dot() #>"));

physical::entities::facet make_facet() {
    physical::helpers::meta_name_builder b;
    b.meta_model("<#= fct.meta_model_name() #>");
    b.backend("<#= fct.backend_name() #>");
    b.facet("<#= fct.name().simple() #>");

    physical::entities::facet r;
    r.meta_name(b.build());
    return r;
}

}

const physical::entities::facet& <#= sn #>::static_facet() {
    static const auto r(make_facet());
    return r;
}

const physical::entities::facet& <#= sn #>::facet() const {
    return static_facet();
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::types::backend_class_header_transform
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_backend
:masd.wale.kvp.class.simple_name: backend_class_header_transform_transform
:masd.wale.kvp.archetype.simple_name: backend_class_header_transform
:masd.wale.kvp.meta_element: physical_backend
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for archetypes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/backend.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/backend_class_header_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/backend_class_header_transform_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> backend_class_header_transform_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    const auto& be(assistant::as<logical::entities::physical::backend>(e));

    auto builder(f.make());
    builder.add_as_user("dogen.physical/types/entities/backend.hpp");
    using logical::entities::technical_space;
    if (be.major_technical_space() == technical_space::cpp) {
        builder.add_as_user(
            "dogen.text.cpp/types/transforms/registrar.hpp");
    } else if (be.major_technical_space() == technical_space::csharp) {
        builder.add_as_user(
            "dogen.text.csharp/types/transforms/registrar.hpp");
    }
    const auto ch_arch(traits::class_header_archetype_qn());
    return builder.build();
}

void backend_class_header_transform_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "backend class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& be(ast.as<logical::entities::physical::backend>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(be));
        {
            const auto ns(ast.make_namespaces(be.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(be.documentation());
#>
class <#= be.name().simple() #>_backend_chain final {
public:
    static const physical::entities::backend& static_backend();
    const physical::entities::backend& backend() const;

public:
    static void initialise(transforms::registrar& r);
};
<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::backend_class_implementation_transform
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_backend
:masd.wale.kvp.class.simple_name: backend_class_implementation_transform_transform
:masd.wale.kvp.archetype.simple_name: backend_class_implementation_transform
:masd.wale.kvp.meta_element: physical_backend
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation files for archetypes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/backend.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/backend_class_implementation_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/backend_class_implementation_transform_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> backend_class_implementation_transform_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    auto builder(f.make());
    const auto ch_arch(traits::canonical_archetype());
    const auto& be(assistant::as<logical::entities::physical::backend>(e));

    builder.add(be.name(), ch_arch);
    builder.add(be.facets(), ch_arch);
    builder.add_as_user("dogen.physical/types/helpers/meta_name_builder.hpp");
    builder.add_as_user("dogen.utility/types/log/logger.hpp");
    builder.add_as_user("dogen.text/types/transforms/transformation_error.hpp");

    return builder.build();
}

void backend_class_implementation_transform_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "backend class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& be(ast.as<logical::entities::physical::backend>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(be));
        {
            const auto ns(ast.make_namespaces(be.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(be.name().simple() + "_backend_chain");
#>
namespace {

using namespace dogen::utility::log;
static logger lg(logger_factory("<#= be.name().qualified().dot() #>"));

physical::entities::backend make_backend() {
    physical::helpers::meta_name_builder b;
    b.meta_model("<#= be.meta_model_name() #>");
    b.backend("<#= be.backend_name() #>");

    physical::entities::backend r;
    r.meta_name(b.build());

    const auto lambda([&](const auto& fct) {
        const auto id(fct.meta_name().qualified());
        const auto pair(std::make_pair(id, fct));
        const auto inserted(r.facets().insert(pair).second);
        if (!inserted) {
            using text::transforms::transformation_error;
            const std::string duplicate_facet("Duplicate facet: ");
            BOOST_LOG_SEV(lg, error) << duplicate_facet << id;
            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + id));
        }
    });

<#+
            for (const auto& n : be.facets()) {
#>
    lambda(<#= n.simple() #>::<#= n.simple() #>_facet_chain::static_facet());
<#+
            }
#>
    return r;
}

}

const physical::entities::backend& <#= sn #>::static_backend() {
    static const auto r(make_backend());
    return r;
}

const physical::entities::backend& <#= sn #>::backend() const {
    return static_backend();
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}
#>

#+end_src
*** transforms::types::part_class_header_transform
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_part
:masd.wale.kvp.class.simple_name: part_class_header_transform_transform
:masd.wale.kvp.archetype.simple_name: part_class_header_transform
:masd.wale.kvp.meta_element: physical_part
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for archetypes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/part.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/part_class_header_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/part_class_header_transform_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> part_class_header_transform_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void part_class_header_transform_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "part class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::physical::part>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= o.name().simple() #> final : public model_to_text_transform {
public:
<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::part_class_implementation_transform
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_part
:masd.wale.kvp.class.simple_name: part_class_implementation_transform_transform
:masd.wale.kvp.archetype.simple_name: part_class_implementation_transform
:masd.wale.kvp.meta_element: physical_part
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation files for archetypes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/part.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/part_class_implementation_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/part_class_implementation_transform_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> part_class_implementation_transform_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void part_class_implementation_transform_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "part class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::archetype_kind_class_header_transform
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype_kind
:masd.wale.kvp.class.simple_name: archetype_kind_class_header_transform_transform
:masd.wale.kvp.archetype.simple_name: archetype_kind_class_header_transform
:masd.wale.kvp.meta_element: physical_archetype_kind
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for archetypes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype_kind.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_kind_class_header_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_kind_class_header_transform_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> archetype_kind_class_header_transform_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void archetype_kind_class_header_transform_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "archetype kind class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::physical::archetype_kind>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= o.name().simple() #> final : public model_to_text_transform {
public:
<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::archetype_kind_class_implementation_transform
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype_kind
:masd.wale.kvp.class.simple_name: archetype_kind_class_implementation_transform_transform
:masd.wale.kvp.archetype.simple_name: archetype_kind_class_implementation_transform
:masd.wale.kvp.meta_element: physical_archetype_kind
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation files for archetypes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype_kind.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_kind_class_implementation_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_kind_class_implementation_transform_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> archetype_kind_class_implementation_transform_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void archetype_kind_class_implementation_transform_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "archetype kind class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::archetype_class_header_factory
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype
:masd.wale.kvp.class.simple_name: archetype_class_header_factory_transform
:masd.wale.kvp.archetype.simple_name: archetype_class_header_factory
:masd.wale.kvp.meta_element: physical_archetype
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.wale.kvp.class.inclusion_support_type: regular_support
:masd.physical.referencing_status: referable
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_configuration
:END:

Generates header files for archetype factories.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_class_header_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_class_header_factory_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> archetype_class_header_factory_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& /*e*/) const {
    auto builder(f.make());
    builder.add_as_user("dogen.physical/types/entities/archetype.hpp");
    return builder.build();
}

void archetype_class_header_factory_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "types archetype class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::physical::archetype>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Creates a physical representation for the archetype
 * <#= o.name().simple() #>.
 *
 * Archetype documentation: <#= o.documentation() #>
 */
class <#= o.name().simple() #>_factory final {
public:
    /**
     * @brief Makes the archetype.
     */
    static physical::entities::archetype make();
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}

#>

#+end_src
*** transforms::types::archetype_class_implementation_factory
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype
:masd.wale.kvp.class.simple_name: archetype_class_implementation_factory_transform
:masd.wale.kvp.archetype.simple_name: archetype_class_implementation_factory
:masd.wale.kvp.meta_element: physical_archetype
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation files for archetype factories.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_class_implementation_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/archetype_class_implementation_factory_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> archetype_class_implementation_factory_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    const auto& arch(assistant::as<logical::entities::physical::archetype>(e));
    auto builder(f.make());
    const auto ch_arch(traits::archetype_class_header_factory_archetype_qn());
    builder.add(arch.name(), ch_arch);
    builder.add_as_user("dogen.physical/types/helpers/meta_name_factory.hpp");
    return builder.build();
}

void archetype_class_implementation_factory_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "archetype class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& arch(ast.as<logical::entities::physical::archetype>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(arch));
        {
            const auto ns(ast.make_namespaces(arch.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(arch.name().simple() + "_factory");
#>

physical::entities::archetype <#= sn #>::make() {
    physical::entities::archetype r;
    using pmnf = physical::helpers::meta_name_factory;
    r.meta_name(pmnf::make("<#= arch.backend_name() #>", "<#= arch.facet_name() #>", "<#= arch.name().simple() #>"));
    r.logical_meta_element_id("<#= arch.logical_meta_element_id() #>");
    r.referencing_status(physical::entities::referencing_status::<#= arch.referencing_status() #>);
<#+
            for(const auto& l : arch.labels()) {
#>
    r.labels().push_back(physical::entities::label("<#= l.key() #>", "<#= l.value() #>"));
<#+
            }
#>
    return r;
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::types::facet_class_header_factory
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_facet
:masd.wale.kvp.class.simple_name: facet_class_header_factory_transform
:masd.wale.kvp.archetype.simple_name: facet_class_header_factory
:masd.wale.kvp.meta_element: physical_facet
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.wale.kvp.class.inclusion_support_type: regular_support
:masd.physical.referencing_status: referable
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_configuration
:END:

Generates header files for facet factories.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/facet_class_header_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/facet_class_header_factory_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> facet_class_header_factory_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& /*e*/) const {
    auto builder(f.make());
    builder.add_as_user("dogen.physical/types/entities/facet.hpp");
    return builder.build();
}

void facet_class_header_factory_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "facet class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& fct(ast.as<logical::entities::physical::facet>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(fct));
        {
            const auto ns(ast.make_namespaces(e.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Creates a physical representation for the facet
 * <#= fct.name().simple() #>.
 *
 * Facet documentation: <#= fct.documentation() #>
 */
class <#= fct.name().simple() #>_factory final {
public:
    static physical::entities::facet make();
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::types::facet_class_implementation_factory
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_facet
:masd.wale.kvp.class.simple_name: facet_class_implementation_factory_transform
:masd.wale.kvp.archetype.simple_name: facet_class_implementation_factory
:masd.wale.kvp.meta_element: physical_facet
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation files for facet factory.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/entities/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/facet_class_implementation_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/facet_class_implementation_factory_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> facet_class_implementation_factory_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    const auto& fct(assistant::as<logical::entities::physical::facet>(e));
    auto builder(f.make());
    const auto fct_ch_arch(traits::facet_class_header_factory_archetype_qn());
    builder.add(fct.name(), fct_ch_arch);

    const auto ch_arch(traits::archetype_class_header_factory_archetype_qn());
    builder.add(fct.archetypes(), ch_arch);
    builder.add_as_user("dogen.utility/types/log/logger.hpp");
    builder.add_as_user("dogen.text/types/transforms/transformation_error.hpp");
    builder.add_as_user("dogen.physical/types/helpers/meta_name_builder.hpp");

    return builder.build();
}

void facet_class_implementation_factory_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "facet class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& fct(ast.as<logical::entities::physical::facet>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(fct));
        {
            const auto ns(ast.make_namespaces(fct.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(fct.name().simple() + "_factory");
#>
namespace {

using namespace dogen::utility::log;
static logger lg(logger_factory("<#= fct.name().qualified().dot() #>"));

}

physical::entities::facet <#= sn #>::make() {
    physical::helpers::meta_name_builder b;
    b.meta_model("<#= fct.meta_model_name() #>");
    b.backend("<#= fct.backend_name() #>");
    b.facet("<#= fct.name().simple() #>");

    physical::entities::facet r;
    r.meta_name(b.build());
<#+
            for(const auto& l : fct.labels()) {
#>
    r.labels().push_back(physical::entities::label("<#= l.key() #>", "<#= l.value() #>"));
<#+
            }
#>

    const auto lambda([&](const auto& arch) {
        const auto id(arch.meta_name().qualified());
        const auto pair(std::make_pair(id, arch));
        const auto inserted(r.archetypes().insert(pair).second);
        if (!inserted) {
            using text::transforms::transformation_error;
            const std::string duplicate_archetype("Duplicate archetype: ");
            BOOST_LOG_SEV(lg, error) << duplicate_archetype << id;
            BOOST_THROW_EXCEPTION(transformation_error(duplicate_archetype + id));
        }
    });

<#+
            for (const auto& n : fct.archetypes()) {
#>
    lambda(<#= n.simple() #>_factory::make());
<#+
            }
#>
    return r;
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::types::backend_class_header_factory
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_backend
:masd.wale.kvp.class.simple_name: backend_class_header_factory_transform
:masd.wale.kvp.archetype.simple_name: backend_class_header_factory
:masd.wale.kvp.meta_element: physical_backend
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.wale.kvp.class.inclusion_support_type: regular_support
:masd.physical.referencing_status: referable
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_configuration
:END:

Generates header files for backend factories.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/backend.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/backend_class_header_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/backend_class_header_factory_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> backend_class_header_factory_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& /*e*/) const {
    auto builder(f.make());
    builder.add_as_user("dogen.physical/types/entities/backend.hpp");
    const auto ch_arch(traits::class_header_archetype_qn());
    return builder.build();
}

void backend_class_header_factory_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "backend class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& be(ast.as<logical::entities::physical::backend>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(be));
        {
            const auto ns(ast.make_namespaces(be.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Creates a physical representation for the backend
 * <#= be.name().simple() #>.
 *
 * Backend documentation: <#= be.documentation() #>
 */
class <#= be.name().simple() #>_factory final {
public:
    static physical::entities::backend make();
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::types::backend_class_implementation_factory
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.physical_backend
:masd.wale.kvp.class.simple_name: backend_class_implementation_factory_transform
:masd.wale.kvp.archetype.simple_name: backend_class_implementation_factory
:masd.wale.kvp.meta_element: physical_backend
:masd.wale.kvp.containing_namespace: text.cpp.transforms.types
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates implementation files for backend factories.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/backend.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/backend_class_implementation_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/backend_class_implementation_factory_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> backend_class_implementation_factory_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    auto builder(f.make());
    const auto& be(assistant::as<logical::entities::physical::backend>(e));
    const auto be_ch_arch(traits::backend_class_header_factory_archetype_qn());
    builder.add(be.name(), be_ch_arch);

    const auto ch_arch(traits::facet_class_header_factory_archetype_qn());
    builder.add(be.facets(), ch_arch);

    builder.add_as_user("dogen.physical/types/helpers/meta_name_builder.hpp");
    builder.add_as_user("dogen.utility/types/log/logger.hpp");
    builder.add_as_user("dogen.text/types/transforms/transformation_error.hpp");

    return builder.build();
}

void backend_class_implementation_factory_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "backend class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& be(ast.as<logical::entities::physical::backend>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(be));
        {
            const auto ns(ast.make_namespaces(be.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(be.name().simple() + "_factory");
#>
namespace {

using namespace dogen::utility::log;
static logger lg(logger_factory("<#= be.name().qualified().dot() #>"));

}

physical::entities::backend <#= sn #>::make() {
    physical::helpers::meta_name_builder b;
    b.meta_model("<#= be.meta_model_name() #>");
    b.backend("<#= be.backend_name() #>");

    physical::entities::backend r;
    r.meta_name(b.build());
<#+
            for(const auto& l : be.labels()) {
#>
    r.labels().push_back(physical::entities::label("<#= l.key() #>", "<#= l.value() #>"));
<#+
            }
#>

    const auto lambda([&](const auto& fct) {
        const auto id(fct.meta_name().qualified());
        const auto pair(std::make_pair(id, fct));
        const auto inserted(r.facets().insert(pair).second);
        if (!inserted) {
            using text::transforms::transformation_error;
            const std::string duplicate_facet("Duplicate facet: ");
            BOOST_LOG_SEV(lg, error) << duplicate_facet << id;
            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + id));
        }
    });

<#+
            for (const auto& n : be.facets()) {
#>
    lambda(<#= n.simple() #>::<#= n.simple() #>_factory::make());
<#+
            }
#>
    return r;
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}
#>

#+end_src
** transforms::model_to_text_transform
:PROPERTIES:
:masd.cpp.types.class_forward_declarations.enabled: true
:masd.injection.stereotypes: dogen::handcrafted::typeable::header_only
:END:
** transforms::hash
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters for the hash facet of the
C++ technical space.

*** transforms::hash::class_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.hash
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_header_configuration
:END:

Generates header files for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/formattables/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    auto builder(f.make());
    builder.add(inclusion_constants::std::functional());
    builder.add(e.name(), types::traits::canonical_archetype());
    return builder.build();
}

void class_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "FIXME",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    const auto sn(o.name().simple());
    const auto qn(ast.get_qualified_name(o.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

struct <#= sn #>_hasher {
public:
    static std::size_t hash(const <#= sn #>& v);
};

<#+
        } // snf
#>

namespace std {

template<>
struct hash<<#= qn #>> {
public:
    size_t operator()(const <#= qn #>& v) const {
        return <#= qn #>_hasher::hash(v);
    }
};

}
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::hash::class_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.hash
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_implementation_configuration
:END:

Generates implementation files for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    const auto& o(assistant::as<logical::entities::structural::object>(e));
    const auto carch(traits::canonical_archetype());
    auto builder(f.make());
    builder.add(o.name(), carch);

    builder.add(o.transparent_associations(), carch);
    builder.add(o.opaque_associations(), carch);
    builder.add(o.parents(), carch);

    return builder.build();
}

void class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "FIXME",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>

namespace {

<#+
        if (!o.local_attributes().empty() || !o.parents().empty()) {
#>
template <typename HashableType>
inline void combine(std::size_t& seed, const HashableType& value) {
    std::hash<HashableType> hasher;
    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
<#+
        }

        ast.add_helper_methods(o.name().qualified().dot());
#>

}

<#+
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(o.name().simple());
            const auto qn(ast.get_qualified_name(o.name()));

#>

std::size_t <#= sn #>_hasher::hash(const <#= sn #>&<#= ((o.local_attributes().empty() && o.parents().empty()) ? "" : " v") #>) {
    std::size_t seed(0);
<#+
            if (!o.parents().empty()) {
#>

<#+
                const auto& pn(o.parents().front());
                const auto pqn(ast.get_qualified_name(pn));
#>
    combine(seed, dynamic_cast<const <#= pqn #>&>(v));
<#+
            }

            if (!o.local_attributes().empty()) {
#>

<#+
                for (const auto& attr : o.local_attributes()) {
                    if (ast.requires_hashing_helper_method(attr))
#>
    combine(seed, hash_<#= attr.parsed_type().qualified().identifiable() #>(v.<#= attr.name().simple() #>()));
<#+
                    else
#>
    combine(seed, v.<#= attr.name().simple() #>());
<#+
                }

                if (o.local_attributes().size() > 1)
#>

<#+
            }
#>
    return seed;
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::hash::enum_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.hash
:masd.injection.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
:END:

Generates header files for enumerations.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> enum_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());
    builder.add(inclusion_constants::std::functional());
    builder.add(e.name(), types::traits::enum_header_archetype_qn());
    return builder.build();
}

void enum_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>

namespace std {

template<>
struct hash<<#= ast.get_qualified_name(ye.name()) #>> {
public:
    size_t operator()(const <#= ast.get_qualified_name(ye.name()) #>& v) const {
        return std::hash<unsigned int>()(static_cast<unsigned int>(v));
    }
};

}

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::hash::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::hash::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::hash::builtin_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.hash
:masd.injection.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
:END:

Generates header files for builtins.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> builtin_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static const std::list<std::string> r;
    return r;
}

void builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    a.logical_name().simple(e.name().simple());
    a.logical_name().qualified(e.name().qualified().dot());
    a.origin_sha1_hash(e.origin_sha1_hash());
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::hash::smart_pointer_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::time_duration_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::ptree_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::associative_container_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::date_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::optional_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::path_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::pair_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::sequence_container_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::ptime_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::variant_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::hash::primitive_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.hash
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
:END:

Generates header files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> primitive_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    auto builder(f.make());
    builder.add(inclusion_constants::std::functional());
    builder.add(e.name(), types::traits::canonical_archetype());
    return builder.build();
}

void primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

struct <#= sn #>_hasher {
public:
    static std::size_t hash(const <#= sn #>& v);
};

<#+
        } // snf
#>

namespace std {

template<>
struct hash<<#= qn #>> {
public:
    size_t operator()(const <#= qn #>& v) const {
        return <#= qn #>_hasher::hash(v);
    }
};

}
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::hash::primitive_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.hash
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_implementation_configuration
:END:

Generates implementation files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/primitive_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/primitive_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string>
primitive_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    using logical::entities::structural::primitive;
    const auto& p(assistant::as<primitive>(e));
    const auto carch(traits::canonical_archetype());
    auto builder(f.make());
    builder.add(p.name(), carch);

    return builder.build();
}

void primitive_implementation_transform::
apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>

namespace {

template <typename HashableType>
inline void combine(std::size_t& seed, const HashableType& value) {
    std::hash<HashableType> hasher;
    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
<#+

        ast.add_helper_methods(p.name().qualified().dot());
#>

}

<#+
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(p.name().simple());
            const auto qn(ast.get_qualified_name(p.name()));
            const auto attr(p.value_attribute());
#>

std::size_t <#= sn #>_hasher::hash(const <#= sn #>& v) {
    std::size_t seed(0);
<#+
            if (ast.requires_hashing_helper_method(attr))
#>
    combine(seed, hash_<#= attr.parsed_type().qualified().identifiable() #>(v.<#= attr.name().simple() #>()));
<#+
            else
#>
    combine(seed, v.<#= attr.name().simple() #>());
    return seed;
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
** transforms::io
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters for the io facet of the
C++ technical space.

*** transforms::io::class_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.io
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_header_configuration
:END:

Generates header files for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());
    builder.add(inclusion_constants::std::iosfwd());

    using traits = transforms::types::traits;
    builder.add(e.name(), traits::canonical_archetype());

    return builder.build();
}

void class_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto qn(ast.get_qualified_name(o.name()));
#>

std::ostream&
operator<<(std::ostream& s,
     const <#= qn #>& v);

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::io::class_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.io
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_implementation_configuration
:END:

Generates implementation files for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    const auto& o(assistant::as<logical::entities::structural::object>(e));
    auto builder(f.make());
    const auto ch_fn(traits::class_header_archetype_qn());
    builder.add(o.name(), ch_fn);

    builder.add(o.opaque_associations(), ch_fn);

    const auto io_carch(transforms::io::traits::canonical_archetype());
    const auto self_fn(class_implementation_transform::static_archetype().meta_name().qualified());
    const bool io_enabled(builder.is_enabled(o.name(), self_fn));

    if (!io_enabled)
        return builder.build();

    const auto os(inclusion_constants::std::ostream());
    builder.add(os);
    builder.add(o.transparent_associations(), io_carch);
    builder.add(o.opaque_associations(), io_carch);
    builder.add(o.parents(), io_carch);

    return builder.build();
}

void class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        ast.add_helper_methods(o.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(o.name().simple());
            const auto qn(ast.get_qualified_name(o.name()));
            const bool no_arg(!o.is_parent() && o.parents().empty() &&
                o.local_attributes().empty());
#>

std::ostream& operator<<(std::ostream& s, const <#= sn #>&<#= (no_arg ? "" : " v")  #>) {
<#+
            if (o.is_parent() || !o.parents().empty()) {
#>
    v.to_stream(s);
    return(s);
<#+
            } else
                io::inserter_implementation_helper(ast, o, false/*inside_class*/);
#>
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::io::enum_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.io
:masd.injection.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
:END:

Generates header files for enumerations.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> enum_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());

    builder.add(inclusion_constants::std::iosfwd());

    const auto eh_fn(types::traits::enum_header_archetype_qn());
    builder.add(e.name(), eh_fn);
    return builder.build();
}

void enum_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

std::ostream& operator<<(std::ostream& s, const <#= ye.name().simple() #>& v);

<#+
         } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::io::enum_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.io
:masd.injection.stereotypes: masd::physical::archetype, dogen::enumeration_implementation_configuration
:END:

Generates implementation files for enumerations.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/enum_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/enum_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> enum_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());

    builder.add(inclusion_constants::std::ostream());
    builder.add(inclusion_constants::std::stdexcept());
    builder.add(inclusion_constants::std::string());

    const auto eh_fn(traits::enum_header_archetype_qn());
    builder.add(e.name(), eh_fn);
    return builder.build();
}

void enum_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

std::ostream& operator<<(std::ostream& s, const <#= ye.name().simple() #>& v) {
    s << "{ " << "\"__type__\": " << "\"<#= ye.name().simple() #>\", " << "\"value\": ";

    std::string attr;
    switch (v) {
<#+
            for (const auto& en : ye.enumerators()) {
                if (ast.is_cpp_standard_98())
#>
    case <#= en.name().simple() #>:
<#+
                else
#>
    case <#= ye.name().simple() #>::<#= en.name().simple() #>:
        attr = "\"<#= en.name().simple() #>\"";
        break;
<#+
            }
#>
    default:
        throw std::invalid_argument("Invalid value for <#= ye.name().simple() #>");
    }
    s << attr << " }";
    return s;
}

<#+
         } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::io::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::io::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::io::builtin_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.io
:masd.injection.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
:END:

Generates header files for builtins.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> builtin_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static const std::list<std::string> r;
    return r;
}

void builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "FIXME",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    a.logical_name().simple(e.name().simple());
    a.logical_name().qualified(e.name().qualified().dot());
    a.origin_sha1_hash(e.origin_sha1_hash());
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::io::associative_container_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::io::smart_pointer_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::io::ptree_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::io::optional_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::io::pair_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::io::sequence_container_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::io::variant_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::io::string_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::io::inserter_implementation_helper
:PROPERTIES:
:masd.cpp.types.class_implementation.formatting_style: stitch
:masd.cpp.types.class_implementation.overwrite: true
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::io::primitive_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.io
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
:END:

Generates header files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> primitive_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());
    builder.add(inclusion_constants::std::iosfwd());

    using traits = transforms::types::traits;
    builder.add(e.name(), traits::canonical_archetype());

    return builder.build();
}

void primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "FIXME",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto qn(ast.get_qualified_name(p.name()));
#>

std::ostream&
operator<<(std::ostream& s, const <#= qn #>& v);

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::io::primitive_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.io
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_implementation_configuration
:END:

Generates implementation files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/primitive_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/primitive_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string>
primitive_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    using logical::entities::structural::primitive;
    const auto& p(assistant::as<primitive>(e));
    auto builder(f.make());
    const auto ph_fn(traits::primitive_header_archetype_qn());
    builder.add(p.name(), ph_fn);

    const auto io_carch(transforms::io::traits::canonical_archetype());
    const auto self_fn(primitive_implementation_transform::static_archetype().meta_name().qualified());
    const bool io_enabled(builder.is_enabled(p.name(), self_fn));

    if (!io_enabled)
        return builder.build();

    const auto os(inclusion_constants::std::ostream());
    builder.add(os);
    builder.add(p.value_attribute().parsed_type().current(), io_carch);

    return builder.build();
}

void primitive_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        ast.add_helper_methods(p.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(p.name().simple());
            const auto qn(ast.get_qualified_name(p.name()));
            const auto attr(p.value_attribute());
#>

std::ostream& operator<<(std::ostream& s, const <#= sn #>& v) {
<#+
            if (ast.requires_stream_manipulators()) {
#>
    boost::io::ios_flags_saver ifs(s);
    s.setf(std::ios_base::boolalpha);
    s.setf(std::ios::fixed, std::ios::floatfield);
    s.precision(6);
    s.setf(std::ios::showpoint);
<#+
            }

            const std::string variable_name = "v." + attr.getter_setter_name() + "()";
#>

    s << " { "
      << "\"__type__\": " << "\"<#= qn #>\"" << ", "
      << "\"<#= attr.name().simple() #>\": " << <#= ast.streaming_for_type(attr.parsed_type().current(), variable_name) #>
      << " }";

    return s;
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
** transforms::serialization
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters for the boost serialisation
facet of the C++ technical space.

*** transforms::serialization::class_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.serialization
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_header_configuration
:END:

Generates header files for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    using logical::entities::structural::object;
    const auto& o(assistant::as<object>(e));
    auto builder(f.make());
    builder.add(o.name(), types::traits::class_header_archetype_qn());

    using ic = inclusion_constants;
    builder.add(ic::boost::serialization::split_free());

    if (o.is_parent())
        builder.add(ic::boost::serialization::assume_abstract());

    if (!o.is_parent() && o.is_child())
        builder.add(ic::boost::type_traits::is_virtual_base_of());

    return builder.build();
}

void class_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));

        if (!o.is_parent() && !o.parents().empty()) {
            const auto& pn(o.parents().front());
            const auto pqn(ast.get_qualified_name(pn));
#>
namespace boost {

template<>struct
is_virtual_base_of<
    <#= pqn #>,
    <#= qn #>
> : public mpl::true_ {};

}
<#+
        }
#>

BOOST_SERIALIZATION_SPLIT_FREE(<#= qn #>)
<#+
        if (o.is_parent()) {
#>
BOOST_SERIALIZATION_ASSUME_ABSTRACT(<#= qn #>)

<#+
        }
#>
namespace boost {
namespace serialization {

template<typename Archive>
void save(Archive& ar, const <#= qn #>& v, unsigned int version);

template<typename Archive>
void load(Archive& ar, <#= qn #>& v, unsigned int version);

} }

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::serialization::class_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.serialization
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_implementation_configuration
:END:

Generates implementation files for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    const auto& o(assistant::as<logical::entities::structural::object>(e));
    auto builder(f.make());

    const auto ch_fn(traits::class_header_archetype_qn());
    builder.add(o.name(), ch_fn);

    using ic = inclusion_constants;
    builder.add(ic::boost::archive::text_iarchive());
    builder.add(ic::boost::archive::text_oarchive());
    builder.add(ic::boost::archive::binary_iarchive());
    builder.add(ic::boost::archive::binary_oarchive());
    builder.add(ic::boost::archive::polymorphic_iarchive());
    builder.add(ic::boost::archive::polymorphic_oarchive());

    // XML serialisation
    builder.add(ic::boost::serialization::nvp());
    builder.add(ic::boost::archive::xml_iarchive());
    builder.add(ic::boost::archive::xml_oarchive());

    const auto carch(traits::canonical_archetype());
    builder.add(o.transparent_associations(), carch);
    builder.add(o.opaque_associations(), carch);
    builder.add(o.parents(), carch);
    builder.add(o.leaves(), carch);

    return builder.build();
}

void class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        ast.add_helper_methods(o.name().qualified().dot());

        const auto qn(ast.get_qualified_name(o.name()));
        const bool has_attributes(!o.local_attributes().empty());
        const bool has_parent(!o.parents().empty());
        const bool has_attributes_or_parent(has_attributes || has_parent);

        if (o.is_parent() || !o.parents().empty()) {
#>

BOOST_CLASS_TRACKING(
    <#= qn #>,
    boost::serialization::track_selectively)
<#+
        }
#>

namespace boost {
namespace serialization {
<#+

        /*
         * Save function
         */
#>

template<typename Archive>
void save(Archive& <#= (has_attributes_or_parent ? "ar" : "/*ar*/") #>,
    const <#= qn #>& <#= (has_attributes_or_parent ? "v" : "/*v*/") #>,
    const unsigned int /*version*/) {
<#+
        if (!o.parents().empty()) {
            const auto& pn(o.parents().front());
            const auto pqn(ast.get_qualified_name(pn));
#>
    ar << make_nvp("<#= pn.simple() #>", base_object<<#= pqn #>>(v));
<#+
        }

        if (has_attributes && has_parent)
#>

<#+
        for (const auto& attr : o.local_attributes()) {
#>
    ar << make_nvp("<#= attr.name().simple() #>", v.<#= attr.member_variable_name() #>);
<#+
        }
#>
}

<#+
        /*
         * Load function
         */
#>
template<typename Archive>
void load(Archive& <#= (has_attributes_or_parent ? "ar," : "/*ar*/,") #>
    <#= qn #>& <#= (has_attributes_or_parent ? "v" : "/*v*/") #>,
    const unsigned int /*version*/) {
<#+
        if (!o.parents().empty()) {
            const auto& pn(o.parents().front());
            const auto pqn(ast.get_qualified_name(pn));
#>
    ar >> make_nvp("<#= pn.simple() #>", base_object<<#= pqn #>>(v));
<#+
            if (has_attributes && has_parent)
#>

<#+
        }

        for (const auto& attr : o.local_attributes()) {
#>
    ar >> make_nvp("<#= attr.name().simple() #>", v.<#= attr.member_variable_name() #>);
<#+
        }
#>
}

} }

namespace boost {
namespace serialization {

template void save(archive::polymorphic_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::polymorphic_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::text_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::text_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::binary_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::binary_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::xml_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::xml_iarchive& ar, <#= qn #>& v, unsigned int version);

} }
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::serialization::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::serialization::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::serialization::enum_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.serialization
:masd.injection.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
:END:

Generates header files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> enum_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());
    builder.add(e.name(), types::traits::enum_header_archetype_qn());
    builder.add(inclusion_constants::boost::serialization::nvp());
    return builder.build();
}

void enum_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>

template<class Archive>
void serialize(Archive& ar, <#= ast.get_qualified_name(ye.name()) #>& v, unsigned int /*version*/){
    using boost::serialization::make_nvp;
    ar & make_nvp("<#= ye.name().simple() #>", v);
}

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::serialization::builtin_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.serialization
:masd.injection.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
:END:

Generates header files for builtins.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> builtin_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static const std::list<std::string> r;
    return r;
}

void builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    a.logical_name().simple(e.name().simple());
    a.logical_name().qualified(e.name().qualified().dot());
    a.origin_sha1_hash(e.origin_sha1_hash());
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::serialization::path_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::serialization::primitive_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.serialization
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
:END:

Generates header files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> primitive_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    using logical::entities::structural::primitive;
    const auto& p(assistant::as<primitive>(e));
    auto builder(f.make());
    builder.add(p.name(), types::traits::primitive_header_archetype_qn());

    using ic = inclusion_constants;
    builder.add(ic::boost::serialization::split_free());

    return builder.build();
}

void primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>
BOOST_SERIALIZATION_SPLIT_FREE(<#= qn #>)

namespace boost {
namespace serialization {

template<typename Archive>
void save(Archive& ar, const <#= qn #>& v, unsigned int version);

template<typename Archive>
void load(Archive& ar, <#= qn #>& v, unsigned int version);

} }

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::serialization::primitive_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.serialization
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_implementation_configuration
:END:

Generates header files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/primitive_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/primitive_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string>
primitive_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    using logical::entities::structural::primitive;
    const auto& p(assistant::as<primitive>(e));
    auto builder(f.make());

    const auto ph_fn(traits::primitive_header_archetype_qn());
    builder.add(p.name(), ph_fn);

    using ic = inclusion_constants;
    builder.add(ic::boost::archive::text_iarchive());
    builder.add(ic::boost::archive::text_oarchive());
    builder.add(ic::boost::archive::binary_iarchive());
    builder.add(ic::boost::archive::binary_oarchive());
    builder.add(ic::boost::archive::polymorphic_iarchive());
    builder.add(ic::boost::archive::polymorphic_oarchive());

    // XML serialisation
    builder.add(ic::boost::serialization::nvp());
    builder.add(ic::boost::archive::xml_iarchive());
    builder.add(ic::boost::archive::xml_oarchive());

    const auto carch(traits::canonical_archetype());
    builder.add(p.value_attribute().parsed_type().current(), carch);

    return builder.build();
}

void primitive_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        const auto attr(p.value_attribute());
#>

namespace boost {
namespace serialization {
<#+

        /*
         * Save function
         */
#>

template<typename Archive>
void save(Archive& ar, const <#= qn #>& v, const unsigned int /*version*/) {
    ar << make_nvp("<#= attr.name().simple() #>", v.<#= attr.member_variable_name() #>);
}

<#+
        /*
         * Load function
         */
#>
template<typename Archive>
void load(Archive& ar, <#= qn #>& v, const unsigned int /*version*/) {
    ar >> make_nvp("<#= attr.name().simple() #>", v.<#= attr.member_variable_name() #>);
}

} }

namespace boost {
namespace serialization {

template void save(archive::polymorphic_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::polymorphic_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::text_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::text_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::binary_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::binary_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::xml_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::xml_iarchive& ar, <#= qn #>& v, unsigned int version);

} }
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::serialization::class_forward_declarations
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.object
:masd.wale.kvp.class.simple_name: class_forward_declarations_transform
:masd.wale.kvp.archetype.simple_name: class_forward_declarations
:masd.wale.kvp.class.inclusion_support_type: regular_support
:masd.physical.referencing_status: referable
:masd.wale.kvp.meta_element: object
:masd.wale.kvp.containing_namespace: text.cpp.transforms.serialization
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_configuration
:END:

Generates forward declarations for classes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/class_forward_declarations_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/class_forward_declarations_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_forward_declarations_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());

    using tp = transforms::types::traits;
    const auto tp_fn(tp::class_forward_declarations_archetype_qn());
    builder.add(e.name(), tp_fn);

    return builder.build();
}

void class_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class forward declarations transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        const auto qn(ast.get_qualified_name(o.name()));
#>

namespace boost {
namespace serialization {

template<class Archive>
void save(Archive& ar, const <#= qn #>& v, unsigned int version);

template<class Archive>
void load(Archive& ar, <#= qn #>& v, unsigned int version);

} }

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::serialization::primitive_forward_declarations
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.primitive
:masd.wale.kvp.class.simple_name: primitive_forward_declarations_transform
:masd.wale.kvp.archetype.simple_name: primitive_forward_declarations
:masd.wale.kvp.class.inclusion_support_type: regular_support
:masd.physical.referencing_status: referable
:masd.wale.kvp.meta_element: primitive
:masd.wale.kvp.containing_namespace: text.cpp.transforms.serialization
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_configuration
:END:

Generates forward declarations for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/primitive_forward_declarations_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/primitive_forward_declarations_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> primitive_forward_declarations_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());

    using tp = transforms::types::traits;
    const auto tp_fn(tp::primitive_forward_declarations_archetype_qn());
    builder.add(e.name(), tp_fn);

    return builder.build();
}

void primitive_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive forward declarations transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(p));
        const auto qn(ast.get_qualified_name(p.name()));
#>

namespace boost {
namespace serialization {

template<class Archive>
void save(Archive& ar, const <#= qn #>& v, unsigned int version);

template<class Archive>
void load(Archive& ar, <#= qn #>& v, unsigned int version);

} }

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::serialization::type_registrar_header
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.serialization_type_registrar
:masd.wale.kvp.class.simple_name: type_registrar_header_transform
:masd.wale.kvp.archetype.simple_name: type_registrar_header
:masd.wale.kvp.meta_element: serialization_type_registrar
:masd.wale.kvp.containing_namespace: text.cpp.transforms.serialization
:masd.injection.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
:END:

Generates header files for type registrars.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/serialization/type_registrar.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/type_registrar_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/type_registrar_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> type_registrar_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void type_registrar_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "type registrar header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& rg(ast.as<logical::entities::serialization::type_registrar>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(rg.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(e.name().simple());
#>

class <#= sn #> {
public:

template<typename Archive>
static void register_types(Archive& ar);

};
<#+
        } // snf
#>

<#+

    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::serialization::type_registrar_implementation
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.serialization_type_registrar
:masd.wale.kvp.class.simple_name: type_registrar_implementation_transform
:masd.wale.kvp.archetype.simple_name: type_registrar_implementation
:masd.wale.kvp.meta_element: serialization_type_registrar
:masd.wale.kvp.containing_namespace: text.cpp.transforms.serialization
:masd.injection.stereotypes: masd::physical::archetype, dogen::implementation_configuration
:END:

Generates header files for feature bundles.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/serialization/type_registrar.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/type_registrar_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/type_registrar_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> type_registrar_implementation_transform::
inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    const auto& rg(assistant::as<logical::entities::serialization::type_registrar>(e));
    auto builder(f.make());

    const auto rh_fn(traits::type_registrar_header_archetype_qn());
    builder.add(rg.name(), rh_fn);

    using ic = inclusion_constants;
    builder.add(ic::boost::archive::text_iarchive());
    builder.add(ic::boost::archive::text_oarchive());
    builder.add(ic::boost::archive::binary_iarchive());
    builder.add(ic::boost::archive::binary_oarchive());
    builder.add(ic::boost::archive::polymorphic_iarchive());
    builder.add(ic::boost::archive::polymorphic_oarchive());

    // XML serialisation
    builder.add(ic::boost::archive::xml_iarchive());
    builder.add(ic::boost::archive::xml_oarchive());

    const auto ch_fn(traits::class_header_archetype_qn());
    builder.add(rg.leaves(), ch_fn);

    const auto carch(traits::canonical_archetype());
    builder.add(rg.registrar_dependencies(), carch);
    return builder.build();
}

void type_registrar_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
   physical::entities::artefact& a) const {
   tracing::scoped_transform_tracer stp(lg, "type registrar implementationtransform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& rg(ast.as<logical::entities::serialization::type_registrar>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(rg.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto deps(rg.registrar_dependencies());
            const auto carch(traits::canonical_archetype());
            const auto leaves(ast.names_with_enabled_archetype(carch, rg.leaves()));
            const bool has_types(!deps.empty() || !leaves.empty());
            const std::string arg_name(has_types ? " ar" : "");
            const auto sn(e.name().simple());
#>

template<typename Archive>
void <#= sn #>::register_types(Archive&<#= arg_name #>) {
<#+
            if (has_types) {
                for (const auto& d : deps) {
                    const auto dqn(ast.get_qualified_name(d));
#>
    <#= dqn #>::register_types(ar);
<#+
                }

                if (!deps.empty() && !leaves.empty())
#>

<#+
                for (const auto& l : leaves) {
                    const auto lqn(ast.get_qualified_name(l));
#>
    ar.template register_type<<#= lqn #>>();
<#+
                }
            }
#>
}

template void <#= sn #>::register_types(boost::archive::polymorphic_oarchive&<#= arg_name #>);
template void <#= sn #>::register_types(boost::archive::polymorphic_iarchive&<#= arg_name #>);

template void <#= sn #>::register_types(boost::archive::text_oarchive&<#= arg_name #>);
template void <#= sn #>::register_types(boost::archive::text_iarchive&<#= arg_name #>);

template void <#= sn #>::register_types(boost::archive::binary_oarchive&<#= arg_name #>);
template void <#= sn #>::register_types(boost::archive::binary_iarchive&<#= arg_name #>);

template void <#= sn #>::register_types(boost::archive::xml_oarchive&<#= arg_name #>);
template void <#= sn #>::register_types(boost::archive::xml_iarchive&<#= arg_name #>);

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
** transforms::test_data
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters for the test_data facet
of the C++ technical space.

*** transforms::test_data::class_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.test_data
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_header_configuration
:END:

Generates header files for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());
    builder.add(e.name(), types::traits::class_header_archetype_qn());
    return builder.build();
}

void class_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto sn(o.name().simple());
            const auto qn(ast.get_qualified_name(o.name()));
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= sn #>_generator {
<#+
            if (!o.is_parent()) {
#>
public:
    <#= sn #>_generator();

<#+
            }
#>
public:
    typedef <#= qn #> result_type;

public:
<#+
            if (!o.is_immutable())
#>
    static void populate(const unsigned int position, result_type& v);
<#+
            if (!o.is_parent()) {
#>
    static result_type create(const unsigned int position);
    result_type operator()();

private:
    unsigned int position_;
<#+
            }
#>
public:
    static result_type* create_ptr(const unsigned int position);
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::test_data::class_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.test_data
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_implementation_configuration
:END:

Generates implementation files for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    const auto& o(assistant::as<logical::entities::structural::object>(e));
    auto builder(f.make());
    builder.add(o.name(), traits::class_header_archetype_qn());

    const auto carch(traits::canonical_archetype());
    builder.add(o.transparent_associations(), carch);
    builder.add(o.opaque_associations(), carch);
    builder.add(o.parents(), carch);
    builder.add(o.leaves(), carch);

    return builder.build();
}

void class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        if (!o.local_attributes().empty()) {
#>
namespace {
<#+
        ast.add_helper_methods(o.name().qualified().dot());
#>

}

<#+
        }

        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));

            /*
             * Default constructor.
             */
            if (!o.is_parent()) {
#>

<#= sn #>_generator::<#= sn #>_generator() : position_(0) { }
<#+
            }

            /*
             * Populate method.
             */
            if (!o.is_immutable()) {
                bool no_args(o.local_attributes().empty() && o.parents().empty());
                if (no_args) {
#>

void <#= sn #>_generator::
populate(const unsigned int /*position*/, result_type& /*v*/) {
<#+
                } else {
#>

void <#= sn #>_generator::
populate(const unsigned int position, result_type& v) {
<#+
                }

                if (!o.parents().empty()) {
                    const auto& pn(o.parents().front());
                    const auto pqn(ast.get_qualified_name(pn));
#>
    <#= pqn #>_generator::populate(position, v);
<#+
                }
                unsigned int i(0);
                for (const auto& attr : o.local_attributes()) {
#>
    v.<#= attr.name().simple() #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + <#= i #>));
<#+
                    ++i;
                }
#>
}
<#+
            }

            /*
             * Create method.
             */
            if (!o.is_parent()) {
                 const bool no_arg(o.all_attributes().empty());
#>

<#= sn #>_generator::result_type
<#= sn #>_generator::create(const unsigned int<#= (no_arg ? "/*position*/" : " position") #>) {
<#+
                if (o.is_immutable()) {
#>
    return <#= sn #>(
<#+
                    if (o.local_attributes().empty())
#>

<#+
                    else {
                        utility::formatters::sequence_formatter sf(o.local_attributes().size());
                        for (const auto& attr : o.local_attributes()) {
#>
        create_<#= attr.parsed_type().qualified().identifiable() #>(position + <#= sf.current_position() #>)<#= sf.postfix() #>
<#+
                            sf.next();
                        }
                    }
#>
        );
<#+
                } else {
#>
    <#= sn #> r;
<#+
                    if (!o.all_attributes().empty())
#>
    <#= sn #>_generator::populate(position, r);
    return r;
<#+
                }
#>
}
<#+
            }

            /*
             * Create method ptr.
             */
#>

<#= sn #>_generator::result_type*
<#= sn #>_generator::create_ptr(const unsigned int position) {
<#+
            if (o.leaves().empty()) {
                if (o.is_immutable())
#>
    return new <#= sn #>(create(position));
<#+
                else {
#>
    <#= sn #>* p = new <#= sn #>();
    <#= sn #>_generator::populate(position, *p);
    return p;
<#+
                }
            } else {
                auto leaves(o.leaves());
                const auto front(leaves.front());
                leaves.pop_front();
                unsigned int i(0);
                const auto total(static_cast<unsigned int>(leaves.size()));
                for (const auto& l : leaves) {
#>
    if ((position % <#= total #>) == <#= i++ #>)
        return <#= ast.get_qualified_name(l) #>_generator::create_ptr(position);
<#+
                }
#>
    return <#= ast.get_qualified_name(front) #>_generator::create_ptr(position);
<#+
            }
#>
}
<#+
            /*
             * Function operator
             */
             if (!o.is_parent()) {
#>

<#= sn #>_generator::result_type
<#= sn #>_generator::operator()() {
    return create(position_++);
}
<#+
            }
#>

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::test_data::enum_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.test_data
:masd.injection.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
:END:

Generates header files for enumerations.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> enum_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());

    builder.add(e.name(), types::traits::enum_header_archetype_qn());
    return builder.build();
}

void enum_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= ye.name().simple() #>_generator {
public:
    <#= ye.name().simple() #>_generator();

public:
    typedef <#= ast.get_qualified_name(ye.name()) #> result_type;

public:
    static void populate(const unsigned int position, result_type& v);
    static result_type create(const unsigned int position);
    result_type operator()();

private:
    unsigned int position_;
};

<#+
         } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::test_data::enum_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.test_data
:masd.injection.stereotypes: masd::physical::archetype, dogen::enumeration_implementation_configuration
:END:

Generates implementation files for enumerations.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/enum_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/enum_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> enum_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());

    builder.add(e.name(), traits::enum_header_archetype_qn());
    return builder.build();
}

void enum_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#= ye.name().simple() #>_generator::<#= ye.name().simple() #>_generator() : position_(0) { }
void <#= ye.name().simple() #>_generator::
populate(const unsigned int position, result_type& v) {
    v = static_cast<<#= ye.name().simple() #>>(position % <#= ye.enumerators().size() #>);
}

<#= ye.name().simple() #>_generator::result_type
<#= ye.name().simple() #>_generator::create(const unsigned int  position) {
    result_type r;
    <#= ye.name().simple() #>_generator::populate(position, r);
    return r;
}

<#= ye.name().simple() #>_generator::result_type
<#= ye.name().simple() #>_generator::operator()() {
    return create(position_++);
}

<#+
         } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::test_data::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::test_data::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::test_data::builtin_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.test_data
:masd.injection.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
:END:

Generates header files for builtins.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> builtin_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static const std::list<std::string> r;
    return r;
}

void builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    a.logical_name().simple(e.name().simple());
    a.logical_name().qualified(e.name().qualified().dot());
    a.origin_sha1_hash(e.origin_sha1_hash());
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::test_data::associative_container_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::char_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::bool_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::date_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::domain_type_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::number_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::optional_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::pair_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::path_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::ptime_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::ptree_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::sequence_container_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::smart_pointer_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::string_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::time_duration_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::variant_helper
:PROPERTIES:
:masd.injection.stereotypes: dogen::cpp::helper_transform
:END:
*** transforms::test_data::primitive_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.test_data
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
:END:

Generates header files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> primitive_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());
    builder.add(e.name(), types::traits::primitive_header_archetype_qn());
    return builder.build();
}

void primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= sn #>_generator {
public:
    <#= sn #>_generator();

public:
    typedef <#= qn #> result_type;

public:
<#+
            if (!p.is_immutable())
#>
    static void populate(const unsigned int position, result_type& v);
    static result_type create(const unsigned int position);
    result_type operator()();

private:
    unsigned int position_;

public:
    static result_type* create_ptr(const unsigned int position);
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::test_data::primitive_implementation
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.test_data
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_implementation_configuration
:END:

Generates implementation files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/primitive_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/primitive_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> primitive_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    const auto& p(assistant::as<logical::entities::structural::primitive>(e));
    auto builder(f.make());
    builder.add(p.name(), traits::primitive_header_archetype_qn());

    const auto carch(traits::canonical_archetype());
    builder.add(p.value_attribute().parsed_type().current(), carch);

    return builder.build();
}

void primitive_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>
namespace {
<#+
        ast.add_helper_methods(p.name().qualified().dot());
#>

}

<#+
        {
            const auto attr(p.value_attribute());
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));

            /*
             * Default constructor.
             */
#>

<#= sn #>_generator::<#= sn #>_generator() : position_(0) { }
<#+
            /*
             * Populate method.
             */
            if (!p.is_immutable()) {
#>

void <#= sn #>_generator::
populate(const unsigned int position, result_type& v) {
    v.<#= attr.name().simple() #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + 1));
}
<#+
            }

            /*
             * Create method.
             */
#>

<#= sn #>_generator::result_type
<#= sn #>_generator::create(const unsigned int position) {
<#+
            if (p.is_immutable()) {
#>
    return <#= sn #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + 1));
<#+
            } else {
#>
    <#= sn #> r;
    <#= sn #>_generator::populate(position, r);
    return r;
<#+
            }
#>
}
<#+
            /*
             * Create method ptr.
             */
#>

<#= sn #>_generator::result_type*
<#= sn #>_generator::create_ptr(const unsigned int position) {
<#+
            if (p.is_immutable())
#>
    return new <#= sn #>(create(position));
<#+
            else {
#>
    <#= sn #>* r = new <#= sn #>();
    <#= sn #>_generator::populate(position, *r);
    return r;
<#+
            }
#>
}
<#+
            /*
             * Function operator
             */
#>

<#= sn #>_generator::result_type
<#= sn #>_generator::operator()() {
    return create(position_++);
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
** transforms::odb
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters for the odb facet of the
C++ technical space.

*** transforms::odb::class_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.odb
:masd.injection.stereotypes: masd::physical::archetype, dogen::object_header_configuration
:END:

Generates header files for archetypes.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    using logical::entities::structural::object;
    const auto& o(assistant::as<object>(e));
    auto builder(f.make());
    builder.add(o.name(), types::traits::class_header_archetype_qn());

    const auto carch(traits::canonical_archetype());
    builder.add(o.transparent_associations(), carch);
    builder.add(o.opaque_associations(), carch);

    const auto self_fn(class_header_transform::static_archetype().meta_name().qualified());
    builder.add(o.parents(), self_fn);

    return builder.build();
}

void class_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));

        if (!o.orm_properties() || o.orm_properties()->odb_pragmas().empty()) {
#>
// class has no ODB pragmas defined.

<#+
        } else {
            {
                const auto ns(ast.make_namespaces(o.name()));
                auto snf(ast.make_scoped_namespace_formatter(ns));
#>

#ifdef ODB_COMPILER

<#+
                for (const auto& pg : o.orm_properties()->odb_pragmas())
#>
<#= pg #>
<#+

                bool is_first(true);
                for (const auto& attr : o.local_attributes()) {
                    if (!attr.orm_properties() ||
                        attr.orm_properties()->odb_pragmas().empty())
                        continue;

                    const auto attr_level_pragmas(attr.orm_properties()->odb_pragmas());
                    for (const auto& pg : attr_level_pragmas) {
                        if (is_first)
#>

<#+
                        is_first = false;
#>
<#= pg #>
<#+
                    }
                }
#>

#endif

<#+
            }
#>

<#+
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::odb::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::odb::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::odb::enum_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.odb
:masd.injection.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
:END:

Generates header files for enumerations.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> enum_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());
    builder.add(e.name(), types::traits::enum_header_archetype_qn());
    return builder.build();
}

void enum_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

#ifdef ODB_COMPILER

#endif

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::odb::builtin_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.odb
:masd.injection.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
:END:

Generates header files for builtins.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> builtin_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static const std::list<std::string> r;
    return r;
}

void builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    a.logical_name().simple(e.name().simple());
    a.logical_name().qualified(e.name().qualified().dot());
    a.origin_sha1_hash(e.origin_sha1_hash());
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::odb::primitive_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.odb
:masd.injection.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
:END:

Generates header files for primitives.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> primitive_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    using logical::entities::structural::primitive;
    const auto& p(assistant::as<primitive>(e));
    auto builder(f.make());
    builder.add(p.name(), types::traits::primitive_header_archetype_qn());

    return builder.build();
}

void primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    {
        const auto sn(p.name().simple());
        const auto qn(ast.get_qualified_name(p.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        const auto attr(p.value_attribute());

        if (!p.orm_properties() || p.orm_properties()->odb_pragmas().empty()) {
#>
// class has no ODB pragmas defined.

<#+
        } else {
            {
                const auto ns(ast.make_namespaces(p.name()));
                auto snf(ast.make_scoped_namespace_formatter(ns));
#>

#ifdef ODB_COMPILER

<#+
                for (const auto& pg : p.orm_properties()->odb_pragmas())
#>
<#= pg #>
<#+

                bool is_first(true);
                if (p.value_attribute().orm_properties() &&
                    !p.value_attribute().orm_properties()->odb_pragmas().empty()) {
                    for (const auto& pg : p.value_attribute().orm_properties()->odb_pragmas()) {
                        if (is_first)
#>

<#+
                            is_first = false;
#>
<#= pg #>
<#+
                    }
#>

#endif

<#+
                }
            }
#>

<#+
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::odb::object_odb_options
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.object
:masd.wale.kvp.class.simple_name: object_odb_options_transform
:masd.wale.kvp.archetype.simple_name: object_odb_options
:masd.wale.kvp.meta_element: object
:masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
:masd.physical.part_id: masd.cpp.implementation
:masd.wale.kvp.locator_function: make_full_path_for_odb_options
:masd.wale.kvp.containing_namespace: text.cpp.transforms.odb
:masd.physical.wale_template_reference: cpp_artefact_transform_implementation
:masd.physical.referencing_status: not_referable
:masd.injection.stereotypes: masd::physical::archetype
:END:

Generates object options for odb.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/object_odb_options_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/object_odb_options_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> object_odb_options_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void object_odb_options_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "object odb options transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto ts(logical::entities::technical_space::odb);
        ast.make_decoration_preamble(e, ts);

        if (!o.orm_properties()) {
#>

#
# class has no ODB options defined.
#
<#+
        } else {
            const auto ooo(o.orm_properties()->odb_options());
#>
# epilogue
--odb-epilogue <#= ooo.epilogue() #>

<#+
            if (!ooo.include_regexes().empty()) {
#>
# regexes
<#+
                for (const auto& regex : ooo.include_regexes())
#>
--include-regex <#= regex #>

# debug regexes
# --include-regex-trace

# make the header guards similar to dogen ones
--guard-prefix <#= ooo.header_guard_prefix() #>
<#+
            }
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::odb::primitive_odb_options
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.primitive
:masd.wale.kvp.class.simple_name: primitive_odb_options_transform
:masd.wale.kvp.archetype.simple_name: primitive_odb_options
:masd.wale.kvp.meta_element: primitive
:masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
:masd.physical.part_id: masd.cpp.implementation
:masd.wale.kvp.locator_function: make_full_path_for_odb_options
:masd.wale.kvp.containing_namespace: text.cpp.transforms.odb
:masd.physical.wale_template_reference: cpp_artefact_transform_implementation
:masd.physical.referencing_status: not_referable
:masd.injection.stereotypes: masd::physical::archetype
:END:

Generates object options for odb.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/primitive_odb_options_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/primitive_odb_options_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> primitive_odb_options_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void primitive_odb_options_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive odb options transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    {
        const auto ts(logical::entities::technical_space::odb);
        ast.make_decoration_preamble(e, ts);

        if (!p.orm_properties()) {
#>

#
# class has no ODB options defined.
#
<#+
        } else {
            const auto ooo(p.orm_properties()->odb_options());
#>
# epilogue
--odb-epilogue <#= ooo.epilogue() #>

<#+
            if (!ooo.include_regexes().empty()) {
#>
# regexes
<#+
                for (const auto& regex : ooo.include_regexes())
#>
--include-regex <#= regex #>

# debug regexes
# --include-regex-trace

# make the header guards similar to dogen ones
--guard-prefix <#= ooo.header_guard_prefix() #>
<#+
            }
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::odb::common_odb_options
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.orm_common_odb_options
:masd.wale.kvp.class.simple_name: common_odb_options_transform
:masd.wale.kvp.archetype.simple_name: common_odb_options
:masd.wale.kvp.meta_element: orm_common_odb_options
:masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
:masd.physical.part_id: masd.cpp.implementation
:masd.wale.kvp.locator_function: make_full_path_for_odb_options
:masd.wale.kvp.containing_namespace: text.cpp.transforms.odb
:masd.physical.wale_template_reference: cpp_artefact_transform_implementation
:masd.physical.referencing_status: not_referable
:masd.injection.stereotypes: masd::physical::archetype
:END:

Generates object options for odb.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/orm/common_odb_options.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/common_odb_options_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/odb/common_odb_options_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> common_odb_options_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void common_odb_options_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "common odb options transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    using logical::entities::orm::common_odb_options;
    const auto& o(ast.as<common_odb_options>(e));

    {
        const auto ts(logical::entities::technical_space::odb);
        ast.make_decoration_preamble(e, ts);

        if (!ast.is_cpp_standard_98()) {
#>
# enable C++11
--std c++11

<#+
        }

        if (!o.sql_name_case().empty()) {
#>
# casing
--sql-name-case <#= o.sql_name_case() #>

<#+
        }

        if (o.databases().size() > 1) {
#>
# enable multi-database support
--multi-database static

<#+
        }

        if (!o.databases().empty()) {
#>
# target databases
<#+

            for (const auto& d : o.databases())
#>
--database <#= d #>

<#+
        }
#>
# use the boost profile
--profile boost

# generate queries and embedded schemas
--generate-query
--generate-schema
--schema-format embedded

# force odb extensions to be different from dogen ones just in case.
--ixx-suffix .ixx
--hxx-suffix .hxx
--cxx-suffix .cxx

# debug regexes
# --include-regex-trace
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
** transforms::registrar
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** transforms::registrar_error
:PROPERTIES:
:masd.injection.stereotypes: masd::exception
:END:

There was an error in the registrar.

** transforms::formatting_error
:PROPERTIES:
:masd.injection.stereotypes: masd::exception
:END:

An error occurred whilst formatting.

** transforms::repository
:PROPERTIES:
:masd.cpp.io.enabled: true
:masd.cpp.io.overwrite: false
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** stock_artefact_formatters_by_meta_name
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, std::forward_list<std::shared_ptr<transforms::model_to_text_transform>>>
:END:
*** stock_artefact_formatters_by_archetype
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, std::shared_ptr<transforms::model_to_text_transform>>
:END:
*** stock_artefact_formatters
:PROPERTIES:
:masd.injection.type: std::forward_list<std::shared_ptr<transforms::model_to_text_transform>>
:END:
*** helper_formatters
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, std::unordered_map<std::string, std::list<std::shared_ptr<transforms::helper_transform>>>>
:END:
** transforms::workflow
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** registrar_
:PROPERTIES:
:masd.injection.type: transforms::registrar
:END:
** transforms::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** transforms::inclusion_constants
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** transforms::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** transforms::assistant
:PROPERTIES:
:masd.cpp.types.class_forward_declarations.enabled: true
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** stream_
:PROPERTIES:
:masd.injection.type: std::ostringstream
:END:
** transforms::context
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:

Supplies additional information required for formatting.

*** enabled_archetype_for_element
:PROPERTIES:
:masd.injection.type: std::unordered_set<text::entities::element_archetype>
:END:
*** element_properties
:PROPERTIES:
:masd.injection.type: formattables::element_properties
:END:
*** model
:PROPERTIES:
:masd.injection.type: formattables::model
:END:
*** helpers
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, std::unordered_map<std::string, std::list<std::shared_ptr<transforms::helper_transform>>>>
:END:
*** tracer
:PROPERTIES:
:masd.injection.type: boost::shared_ptr<tracing::tracer>
:END:
** transforms::helper_transform
:PROPERTIES:
:masd.cpp.types.class_forward_declarations.enabled: true
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** transforms::building_error
:PROPERTIES:
:masd.injection.stereotypes: masd::exception
:END:

An error occurred whilst the factory was building.

** transforms::inclusion_support_types
:PROPERTIES:
:masd.injection.stereotypes: masd::enumeration
:END:
*** not_supported
This formatter does not export an inclusion directive.

*** regular_support
This formatter exports a regular inclusion directive.

*** canonical_support
This formatter exports a regular inclusion directive and is the default for its facet
and element.

** transforms::wale_transform
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** transforms::stitch_transform
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** transforms::repository_factory
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** transforms::tests
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters that generate tests for generated
code.

*** transforms::tests::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::tests::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::tests::class_implementation
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.object
:masd.wale.kvp.class.simple_name: class_implementation_transform
:masd.wale.kvp.archetype.simple_name: class_implementation
:masd.wale.kvp.meta_element: object
:masd.wale.kvp.containing_namespace: text.cpp.transforms.tests
:masd.injection.stereotypes: masd::physical::archetype, dogen::tests_configuration
:END:

Generates tests for objects.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::tests #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> class_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    using logical::entities::structural::object;
    const auto& o(assistant::as<object>(e));
    auto builder(f.make());
    builder.add(o.name(), types::traits::class_header_archetype_qn());
    builder.add(o.name(), test_data::traits::class_header_archetype_qn());

    using ic = inclusion_constants;
    builder.add(ic::std::string());
    builder.add(ic::boost::test::unit_test());

    if (o.is_parent())
        builder.add(ic::boost::shared_ptr());

    const auto io_arch(io::traits::class_header_archetype_qn());
    const bool io_enabled(builder.is_enabled(o.name(), io_arch));
    if (io_enabled) {
        builder.add(o.name(), io_arch);
        builder.add(ic::std::sstream());
        builder.add(ic::boost::property_tree::ptree());
        builder.add(ic::boost::property_tree::json_parser());
    }

    using ser = transforms::serialization::traits;
    const auto ser_arch(ser::class_header_archetype_qn());
    const bool ser_enabled(builder.is_enabled(o.name(), ser_arch));
    if (ser_enabled) {
        builder.add(o.name(), ser_arch);

        if (o.type_registrar())
            builder.add(o.type_registrar(), ser::type_registrar_header_archetype_qn());

        builder.add(ic::boost::archive::text_iarchive());
        builder.add(ic::boost::archive::text_oarchive());
        builder.add(ic::boost::archive::binary_iarchive());
        builder.add(ic::boost::archive::binary_oarchive());
        builder.add(ic::boost::archive::polymorphic_iarchive());
        builder.add(ic::boost::archive::polymorphic_oarchive());
        builder.add(ic::boost::serialization::nvp());
        builder.add(ic::boost::archive::xml_iarchive());
        builder.add(ic::boost::archive::xml_oarchive());

        if (o.is_parent())
            builder.add(ic::boost::serialization::shared_ptr());
    }

    using hash = transforms::hash::traits;
    const auto hash_arch(hash::class_header_archetype_qn());
    const bool hash_enabled(builder.is_enabled(o.name(), hash_arch));
    if (hash_enabled)
        builder.add(o.name(), hash_arch);

    return builder.build();
}

void class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& o(ast.as<logical::entities::structural::object>(e));
    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        const auto qn(ast.get_qualified_name(o.name()));
        auto list(e.name().location().internal_modules());
        list.push_back(o.name().simple());
        const std::string test_suite_name(boost::join(list, "_"));

        std::string type_name("auto");
        if (ast.is_cpp_standard_98())
            type_name = qn;

#>
BOOST_AUTO_TEST_SUITE(<#= test_suite_name #>_tests)

<#+
        /*
         * If we have no attributes at all, we cannot test this
         * type. Similarly, if test data is not enabled, none of the
         * tests can be generated. In either case, we need to insert a
         * fake test for now. The real solution will be to filter
         * based on element state.
         */
        if (o.all_attributes().empty() || !ast.is_test_data_enabled()) {
            /*
             * No tests.
             */
#>
BOOST_AUTO_TEST_CASE(fake_test) {
    BOOST_CHECK(true);
}

<#+
        } else {
            /*
             * Types tests. These cannot be performed to parents as
             * they are abstract.
             */
            if (!o.is_parent()) {
#>
BOOST_AUTO_TEST_CASE(identical_objects_are_equal) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());
    const <#= type_name #> b(a);

    BOOST_CHECK(a == b);
    BOOST_CHECK(b == a);
    BOOST_CHECK(!(a != b));
}

BOOST_AUTO_TEST_CASE(an_object_is_equal_to_itself) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    BOOST_CHECK(a == a);
    BOOST_CHECK(!(a != a));
}

BOOST_AUTO_TEST_CASE(distinct_objects_are_unequal) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());
    const <#= type_name #> b(g());

    BOOST_CHECK(!(a == b));
    BOOST_CHECK(a != b);
}

<#+
                if (!o.is_immutable()) {
#>
BOOST_AUTO_TEST_CASE(assigning_an_object_to_itself_results_in_the_same_object) {
#if defined(__clang__) && !defined(__apple_build_version__)  && (__clang_major__ >= 7)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wself-assign-overloaded"
#endif
    <#= qn #>_generator g;
    <#= type_name #> a(g());
    const <#= type_name #> b(a);
    const <#= type_name #> c(g());

    a = a;
    BOOST_CHECK(a == b);
    BOOST_CHECK(a != c);
#if defined(__clang__) && !defined(__apple_build_version__)  && (__clang_major__ >= 7)
#pragma clang diagnostic pop
#endif
}

<#+
                }

                // FIXME: should be 11 or greater.
                if (!ast.is_cpp_standard_98()) {
#>
BOOST_AUTO_TEST_CASE(moved_objects_are_equal) {
    <#= qn #>_generator g;
    g();
    <#= type_name #> a(g());
    const <#= type_name #> b = <#= qn #>();
    const <#= type_name #> c(a);
    BOOST_CHECK(a != b);
    BOOST_CHECK(a == c);

    const <#= type_name #> d = std::move(a);
    BOOST_CHECK(d == c);
    BOOST_CHECK(d != b);
}

<#+
                }

                if (!o.is_immutable()) {
#>
BOOST_AUTO_TEST_CASE(assigned_objects_are_equal) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    <#= qn #> b;
    BOOST_CHECK(a != b);

    b = a;
    BOOST_CHECK(a == b);
}

BOOST_AUTO_TEST_CASE(copy_constructed_objects_are_equal) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    <#= type_name #> b(a);
    BOOST_CHECK(a == b);

    b = <#= qn #>();
    BOOST_CHECK(a != b);
}

BOOST_AUTO_TEST_CASE(swapping_objects_results_in_the_expected_state) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());
    const <#= type_name #> b(g());

    <#= type_name #> c(a);
    <#= type_name #> d(b);
    BOOST_CHECK(c == a);
    BOOST_CHECK(d == b);

    std::swap(c, d);
    BOOST_CHECK(c == b);
    BOOST_CHECK(d == a);
}

<#+
                }
            }

            if (ast.is_io_enabled()) {
                /*
                 * IO tests.
                 */
#>
BOOST_AUTO_TEST_CASE(inserter_operator_produces_valid_json) {
<#+
                if (o.is_parent()) {
#>
    <#= qn #>_generator g;
    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));
    std::stringstream s;
    s << *a;

    boost::property_tree::ptree pt;
    BOOST_REQUIRE_NO_THROW(read_json(s, pt));
<#+
                } else {
#>
    <#= qn #>_generator g;
    const <#= type_name #> a(g());
    std::stringstream s;
    s << a;

    boost::property_tree::ptree pt;
    BOOST_REQUIRE_NO_THROW(read_json(s, pt));
<#+
                }
#>
}

<#+
            }

            if (ast.is_serialization_enabled()) {
                /*
                 * Serialization tests.
                 */
                 const auto registrar_qn(o.type_registrar() ?
                     ast.get_qualified_name(*o.type_registrar()) : std::string());

                if (o.is_parent()) {
#>
BOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));

    using namespace boost::archive;
    std::ostringstream os;
    {
        xml_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<xml_oarchive>(oa);
<#+
                    }
#>

        oa << BOOST_SERIALIZATION_NVP(a);
    }

    boost::shared_ptr<<#= qn #>> b;
    std::istringstream is(os.str());
    {
        xml_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<xml_iarchive>(ia);
<#+
                    }
#>
        ia >> BOOST_SERIALIZATION_NVP(b);
    }

    BOOST_REQUIRE(a);
    BOOST_REQUIRE(b);
    BOOST_CHECK(*a == *b);
}

BOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));

    using namespace boost::archive;
    std::ostringstream os;
    {
        text_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<text_oarchive>(oa);
<#+
                    }
#>
        oa << a;
    }

    boost::shared_ptr<<#= qn #>> b;
    std::istringstream is(os.str());
    {
        text_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<text_iarchive>(ia);
<#+
                    }
#>
        ia >> b;
    }

    BOOST_REQUIRE(a);
    BOOST_REQUIRE(b);
    BOOST_CHECK(*a == *b);
}

BOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));

    using namespace boost::archive;
    std::ostringstream os;
    {
        binary_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<binary_oarchive>(oa);
<#+
                    }
#>
        oa << a;
    }

    boost::shared_ptr<<#= qn #>> b;
    std::istringstream is(os.str());
    {
        binary_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<binary_iarchive>(ia);
<#+
                    }
#>
        ia >> b;
    }

    BOOST_REQUIRE(a);
    BOOST_REQUIRE(b);
    BOOST_CHECK(*a == *b);
}

<#+
                } else {

#>
BOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        xml_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<xml_oarchive>(oa);
<#+
                    }
#>
        oa << BOOST_SERIALIZATION_NVP(a);
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        xml_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<xml_iarchive>(ia);
<#+
                    }
#>
        ia >> BOOST_SERIALIZATION_NVP(b);
    }

    BOOST_CHECK(a == b);
}

BOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        text_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<text_oarchive>(oa);
<#+
                    }
#>
        oa << a;
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        text_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<text_iarchive>(ia);
<#+
                    }
#>
        ia >> b;
    }

    BOOST_CHECK(a == b);
}

BOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        binary_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<binary_oarchive>(oa);
<#+
                    }
#>
        oa << a;
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        binary_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<binary_iarchive>(ia);
<#+
                    }
#>
        ia >> b;
    }

    BOOST_CHECK(a == b);
}
<#+
                }
            }

            if (ast.is_hash_enabled() && !o.is_parent()) {
                /*
                 * hash tests.
                 */
#>
BOOST_AUTO_TEST_CASE(equal_objects_generate_the_same_hash) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    const <#= type_name #> b(a);

    std::hash<<#= qn #>> hasher;
    BOOST_CHECK(hasher(a) == hasher(b));
}

BOOST_AUTO_TEST_CASE(different_objects_generate_different_hashes) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    const <#= type_name #> b(g());

    std::hash<<#= qn #>> hasher;
    BOOST_CHECK(hasher(a) != hasher(b));
}

<#+
            }
        }
#>
BOOST_AUTO_TEST_SUITE_END()
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::tests::enum_implementation
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.enumeration
:masd.wale.kvp.class.simple_name: enum_implementation_transform
:masd.wale.kvp.archetype.simple_name: enum_implementation
:masd.wale.kvp.meta_element: enumeration
:masd.wale.kvp.containing_namespace: text.cpp.transforms.tests
:masd.injection.stereotypes: masd::physical::archetype, dogen::tests_configuration
:END:

Generates tests for enumeration.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::tests #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/predef.h>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/lexical_cast/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/serialization/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/enum_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/enum_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> enum_implementation_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {

    auto builder(f.make());
    builder.add(e.name(), types::traits::enum_header_archetype_qn());
    builder.add(e.name(), test_data::traits::enum_header_archetype_qn());

    using ic = inclusion_constants;
    builder.add(ic::std::string());
    builder.add(ic::boost::test::unit_test());
    builder.add(ic::boost::predef());

    const auto io_arch(io::traits::enum_header_archetype_qn());
    const bool io_enabled(builder.is_enabled(e.name(), io_arch));
    if (io_enabled) {
        builder.add(e.name(), io_arch);
        builder.add(ic::std::sstream());
        builder.add(ic::boost::property_tree::ptree());
        builder.add(ic::boost::property_tree::json_parser());
    }

    const auto lc_arch(lexical_cast::traits::enum_header_archetype_qn());
    const bool lc_enabled(builder.is_enabled(e.name(), lc_arch));
    if (lc_enabled) {
        builder.add(e.name(), lc_arch);
        builder.add(ic::boost::lexical_cast());
    }

    using ser = transforms::serialization::traits;
    const auto ser_arch(ser::enum_header_archetype_qn());
    const bool ser_enabled(builder.is_enabled(e.name(), ser_arch));
    if (ser_enabled) {
        builder.add(e.name(), ser_arch);

        builder.add(ic::boost::archive::text_iarchive());
        builder.add(ic::boost::archive::text_oarchive());
        builder.add(ic::boost::archive::binary_iarchive());
        builder.add(ic::boost::archive::binary_oarchive());
        builder.add(ic::boost::archive::polymorphic_iarchive());
        builder.add(ic::boost::archive::polymorphic_oarchive());
        builder.add(ic::boost::serialization::nvp());
        builder.add(ic::boost::archive::xml_iarchive());
        builder.add(ic::boost::archive::xml_oarchive());
    }

    using hash = transforms::hash::traits;
    const auto hash_arch(hash::enum_header_archetype_qn());
    const bool hash_enabled(builder.is_enabled(e.name(), hash_arch));
    if (hash_enabled)
        builder.add(e.name(), hash_arch);

    return builder.build();
}

void enum_implementation_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum implementation transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& enm(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        const auto qn(ast.get_qualified_name(e.name()));
        const auto sn(e.name().simple());
        std::string type_name("auto");
        if (ast.is_cpp_standard_98())
            type_name = qn;
#>
BOOST_AUTO_TEST_SUITE(<#= e.name().simple() #>_tests)

<#+
        /*
         * If test data is not enabled, none of the tests can be
         * generated. We need to insert a fake test for now. The real
         * solution will be to filter based on element state.
         */
        if (!ast.is_test_data_enabled()) {
            /*
             * No tests.
             */
#>
BOOST_AUTO_TEST_CASE(fake_test) {
    BOOST_CHECK(true);
}

<#+
        } else {
            if (ast.is_io_enabled()) {
                /*
                 * IO tests.
                 */
#>
BOOST_AUTO_TEST_CASE(inserter_operator_produces_valid_json) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());
    std::stringstream s;
    s << a;

    boost::property_tree::ptree pt;
    BOOST_REQUIRE_NO_THROW(read_json(s, pt));
}

<#+
            }

            if (ast.is_lexical_cast_enabled()) {
                /*
                 * Lexical cast tests.
                 */
#>
BOOST_AUTO_TEST_CASE(casting_valid_strings_produces_expected_enumeration) {
    using <#= qn #>;
    <#= sn #> r;
<#+
        for (const auto& enu : enm.enumerators()) {
            const auto enu_sn(enu.name().simple());
            std::string enu_qn;
            if (ast.is_cpp_standard_98())
                enu_qn = ast.get_qualified_namespace(enm.name()) + "::" + enu_sn;
            else
                enu_qn = sn + "::" + enu_sn;
#>

    r = boost::lexical_cast<<#= sn #>>(std::string("<#= enu_sn #>"));
    BOOST_CHECK(r == <#= enu_qn #>);
    r = boost::lexical_cast<<#= sn #>>(std::string("<#= sn + "::" + enu_sn #>"));
    BOOST_CHECK(r == <#= enu_qn #>);
<#+
        }
#>
}

BOOST_AUTO_TEST_CASE(casting_invalid_string_throws) {
    using <#= qn #>;
    BOOST_CHECK_THROW(boost::lexical_cast<<#= sn #>>(std::string("DOGEN_THIS_IS_INVALID_DOGEN")),
        boost::bad_lexical_cast);
}

BOOST_AUTO_TEST_CASE(casting_valid_enumerations_produces_expected_strings) {
    using <#= qn #>;
    std::string r;
<#+
        for (const auto& enu : enm.enumerators()) {
            const auto enu_sn(enu.name().simple());
            std::string enu_qn;
            if (ast.is_cpp_standard_98())
                enu_qn = ast.get_qualified_namespace(enm.name()) + "::" + enu_sn;
            else
                enu_qn = sn + "::" + enu_sn;

#>

    r = boost::lexical_cast<std::string>(<#= enu_qn #>);
    BOOST_CHECK(r == "<#= sn + "::" + enu_sn #>");
<#+
        }
#>
}

BOOST_AUTO_TEST_CASE(casting_invalid_enumeration_throws) {
#if BOOST_COMP_GNUC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    using <#= qn #>;
    const <#= sn #> r(static_cast<<#= sn #>>(<#= enm.enumerators().size() + 10 #>));
#if BOOST_COMP_GNUC
#pragma GCC diagnostic pop
#endif
    BOOST_CHECK_THROW(boost::lexical_cast<std::string>(r),
        boost::bad_lexical_cast);
}

<#+
            }

            if (ast.is_serialization_enabled()) {
                /*
                 * Serialization tests.
                 */
#>
BOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        xml_oarchive oa(os);
        oa << BOOST_SERIALIZATION_NVP(a);
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        xml_iarchive ia(is);
        ia >> BOOST_SERIALIZATION_NVP(b);
    }
    BOOST_CHECK(a == b);
}

BOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        xml_oarchive oa(os);
        oa << BOOST_SERIALIZATION_NVP(a);
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        xml_iarchive ia(is);
        ia >> BOOST_SERIALIZATION_NVP(b);
    }
    BOOST_CHECK(a == b);
}

BOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        text_oarchive oa(os);
        oa << a;
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        text_iarchive ia(is);
        ia >> b;
    }
    BOOST_CHECK(a == b);
}

<#+
            }

             if (ast.is_hash_enabled()) {
                 /*
                  * hash tests.
                  */
#>
BOOST_AUTO_TEST_CASE(equal_enums_generate_the_same_hash) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    const <#= type_name #> b(a);

    std::hash<<#= qn #>> hasher;
    BOOST_CHECK(hasher(a) == hasher(b));
}

BOOST_AUTO_TEST_CASE(different_enums_generate_different_hashes) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    const <#= type_name #> b(g());

    std::hash<<#= qn #>> hasher;
    BOOST_CHECK(hasher(a) != hasher(b));
}

<#+
            }
        }
#>
BOOST_AUTO_TEST_SUITE_END()
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
*** transforms::tests::main
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.entry_point
:masd.wale.kvp.class.simple_name: main_transform
:masd.wale.kvp.archetype.simple_name: main
:masd.wale.kvp.meta_element: entry_point
:masd.wale.kvp.containing_namespace: text.cpp.transforms.tests
:masd.injection.stereotypes: masd::physical::archetype, dogen::tests_configuration
:END:

Generates entry point for tests.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::tests #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/entry_point.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/test_data/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/main_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/main_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> main_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& /*e*/) const {

    using logical::entities::structural::object;
    auto builder(f.make());

    using ic = inclusion_constants;
    builder.add(ic::boost::test::unit_test());
    builder.add(ic::boost::test::unit_test_monitor());
    builder.add(ic::boost::exception::info());
    builder.add(ic::std::iostream());
    builder.add(ic::boost::exception::diagnostic_information());

    return builder.build();
}

void main_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "main transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    using logical::entities::structural::entry_point;
    const auto& ep(ast.as<entry_point>(e));
    const auto qn(ast.get_qualified_name(ep.name()));
#>
#define BOOST_TEST_MODULE <#= qn #>

<#+
    {
        auto sbf(ast.make_scoped_boilerplate_formatter(ep));
#>

namespace  {

const std::string error_msg("Error during test.");

inline void translate(const boost::exception& e) {
    std::cerr << std::endl << boost::diagnostic_information(e);
    throw std::runtime_error(error_msg);
}

struct exception_fixture {
    exception_fixture() {
        using boost::exception;
        using boost::unit_test::unit_test_monitor;
        unit_test_monitor.register_exception_translator<exception>(&translate);
    }
};

}

BOOST_GLOBAL_FIXTURE(exception_fixture);
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::tests::cmakelists
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.build_cmakelists
:masd.wale.kvp.class.simple_name: cmakelists_transform
:masd.wale.kvp.archetype.simple_name: cmakelists
:masd.wale.kvp.meta_element: build_cmakelists
:masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
:masd.physical.part_id: masd.cpp.testing
:masd.wale.kvp.locator_function: make_full_path_for_tests_cmakelists
:masd.wale.kvp.containing_namespace: text.cpp.transforms.tests
:masd.physical.wale_template_reference: cpp_artefact_transform_implementation
:masd.physical.referencing_status: not_referable
:masd.injection.stereotypes: masd::physical::archetype
:END:

Generates cmakelists for tests.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::tests #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/build/cmakelists.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/cmakelists_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/tests/cmakelists_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> cmakelists_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void cmakelists_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "cmakelists transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    using logical::entities::build::cmakelists;
    const auto& c(ast.as<cmakelists>(e));

    {

        const auto ts(logical::entities::technical_space::cmake);
        ast.make_decoration_preamble(e, ts);
        const auto model_name(ast.get_dot_separated_model_name(c.name()));
        const auto product_name(ast.get_product_name(c.name()));
#>
set(name "<#= model_name #>")
set(lib_target_name ${name}.lib)
set(tests_binary_name ${name}.<#= c.tests_directory_name() #>)
set(tests_target_name ${name}.<#= c.tests_directory_name() #>)

set(files "")
file(GLOB_RECURSE files RELATIVE
    "${CMAKE_CURRENT_SOURCE_DIR}/"
    "${CMAKE_CURRENT_SOURCE_DIR}/*.<#= c.implementation_file_extension() #>")

add_executable(${tests_target_name} ${files})

set_target_properties(${tests_target_name} PROPERTIES
<#+
        if (ast.is_cpp_standard_98()) {
#>
    CXX_STANDARD 98
<#+
        }
#>
    OUTPUT_NAME ${tests_binary_name})

<#+
        if (ast.is_cpp_standard_98()) {
#>
target_compile_options(${tests_target_name} PRIVATE
    $<$<OR:$<CXX_COMPILER_ID:Clang>,$<CXX_COMPILER_ID:AppleClang>,$<CXX_COMPILER_ID:GNU>>:
    -Wno-c99-extensions>)
<#+
        }
#>

target_link_libraries(${tests_target_name}
    ${lib_target_name}
    ${CMAKE_REQUIRED_LIBRARIES}
    ${CMAKE_THREAD_LIBS_INIT}
    ${Boost_LIBRARIES})

set(command $<TARGET_FILE:${tests_target_name}> ${boost_test_parameters})

add_custom_target(run_${tests_target_name}
    COMMENT "Running ${tests_target_name}" VERBATIM
    COMMAND ${command}
    WORKING_DIRECTORY ${stage_bin_dir}
    DEPENDS ${tests_target_name})

add_dependencies(run_all_tests run_${tests_target_name})

if(WITH_BENCHMARKS)
    set(benchmark_file
        ${benchmark_directory}/${benchmark_prefix}${tests_target_name}.csv)
    add_custom_target(benchmark_${tests_target_name}
        COMMENT "Benchmarking testing ${tests_target_name}" VERBATIM
        COMMAND ${benchmark_command} ${benchmark_repeats} ${benchmark_file}
        ${command}
        WORKING_DIRECTORY ${stage_bin_dir}
        DEPENDS ${tests_target_name})

    add_dependencies(benchmark_all benchmark_${tests_target_name})
endif()

add_boost_tests(${tests_binary_name} ${files})

install(TARGETS ${tests_target_name} RUNTIME DESTINATION bin COMPONENT tests)
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
** transforms::global_features
:PROPERTIES:
:masd.variability.generate_static_configuration: false
:masd.variability.key_prefix: masd.cpp
:masd.injection.stereotypes: masd::variability::feature_bundle
:END:
*** headers_output_directory
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::text
:END:

Override location of public c++ headers.

*** directory
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::text
:masd.injection.value: "cpp"
:END:

Directory in which to place code for the C++ backend.

*** inclusion_required
:PROPERTIES:
:masd.variability.binding_point: element
:masd.injection.type: masd::variability::boolean
:masd.injection.value: "true"
:END:

If true, inclusion is required for this modeling element.

*** source_directory_name
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::text
:masd.injection.value: "src"
:END:

Directory in which to place C++ source files.

*** include_directory_name
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::text
:masd.injection.value: "include"
:END:

Directory in which to place include headers.

*** tests_directory_name
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::text
:masd.injection.value: "generated_tests"
:END:

Directory in which to place c++ tests.

*** templates_directory_name
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::text
:masd.injection.value: "templates"
:END:

Directory in which to place text templates.

*** header_file_extension
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::text
:masd.injection.value: "hpp"
:END:

Extension to use for C++ header files.

*** implementation_file_extension
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::text
:masd.injection.value: "cpp"
:END:

Extension to use for C++ implementation files.

*** templates_file_extension
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::text
:masd.injection.value: "wale"
:END:

Extension to use for text templates.

*** enable_unique_file_names
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::boolean
:masd.injection.value: "true"
:END:

If true, make all file names unique within a model.

*** aspect.requires_manual_default_constructor
:PROPERTIES:
:masd.variability.binding_point: element
:masd.injection.type: masd::variability::boolean
:masd.injection.value: "false"
:END:

If true, the modeling element requires a manual defaul constructor.

*** aspect.requires_manual_move_constructor
:PROPERTIES:
:masd.variability.binding_point: element
:masd.injection.type: masd::variability::boolean
:masd.injection.value: "false"
:END:

If true, the modeling element requires a manual move constructor.

*** aspect.requires_stream_manipulators
:PROPERTIES:
:masd.variability.binding_point: element
:masd.injection.type: masd::variability::boolean
:masd.injection.value: "false"
:END:

If true, the modeling element requires stream manipulators.

*** disable_facet_directories
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::boolean
:masd.injection.value: "false"
:END:

If true, facet directories will not be used.

*** standard
:PROPERTIES:
:masd.variability.binding_point: global
:masd.injection.type: masd::variability::text
:masd.injection.value: "c++-14"
:END:

Which version of C++ to use.

*** helper.family
:PROPERTIES:
:masd.variability.binding_point: element
:masd.injection.type: masd::variability::text
:masd.injection.value: "Default"
:END:

Which family of helpers to use for this modeling element.

*** streaming.string_conversion_method
:PROPERTIES:
:masd.variability.binding_point: element
:masd.injection.type: masd::variability::text
:masd.injection.value: ""
:END:

Which conversion method to use to convert strings.

*** streaming.requires_quoting
:PROPERTIES:
:masd.variability.binding_point: element
:masd.injection.type: masd::variability::boolean
:masd.injection.value: "false"
:END:

If true, streaming this type must be preceeded by quoting.

*** streaming.remove_unprintable_characters
:PROPERTIES:
:masd.variability.binding_point: element
:masd.injection.type: masd::variability::boolean
:masd.injection.value: "false"
:END:

If true, streaming this type requires removing unprintable characters.

** transforms::archetype_features
:PROPERTIES:
:masd.variability.default_binding_point: element
:masd.variability.instantiation_domain_name: masd.cpp.archetype
:masd.injection.stereotypes: masd::variability::feature_template_bundle
:END:
*** primary_inclusion_directive
:PROPERTIES:
:masd.injection.type: masd::variability::text
:END:
*** secondary_inclusion_directive
:PROPERTIES:
:masd.injection.type: masd::variability::text_collection
:END:
** transforms::lexical_cast
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters related to conversions from and to
string.

*** transforms::lexical_cast::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::lexical_cast::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::lexical_cast::enum_header
:PROPERTIES:
:masd.wale.kvp.containing_namespace: text.cpp.transforms.lexical_cast
:masd.injection.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
:END:

Generates header files for enumerations.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::lexical_cast #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/lexical_cast/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/lexical_cast/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/lexical_cast/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> enum_header_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& f,
    const logical::entities::element& e) const {
    auto builder(f.make());

    const auto eh_fn(types::traits::enum_header_archetype_qn());
    builder.add(e.name(), eh_fn);
    builder.add(inclusion_constants::boost::lexical_cast());

    return builder.build();
}

void enum_header_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    const auto& enm(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(enm));
        const auto qn(ast.get_qualified_name(enm.name()));
        const auto sn(enm.name().simple());
#>

namespace boost {

template<>
inline std::string lexical_cast(const <#= qn #>& v) {
<#+
        if (!ast.is_cpp_standard_98()) {
#>
    using <#= qn #>;

<#+
        }
#>
    switch (v) {
<#+
        for (const auto& enu : enm.enumerators()) {
            const auto enu_sn(enu.name().simple());
            std::string enu_qn;
            if (ast.is_cpp_standard_98())
                enu_qn = ast.get_qualified_namespace(enm.name()) + "::" + enu_sn;
            else
                enu_qn = sn + "::" + enu_sn;
#>
    case <#= enu_qn #>:
        return "<#= sn + "::" + enu_sn #>";
<#+
        }
#>
    default:
        throw boost::bad_lexical_cast();
    }
}

template<>
inline <#= qn #> lexical_cast(const std::string & s) {
<#+
        if (!ast.is_cpp_standard_98()) {
#>
    using <#= qn #>;

<#+
        }

        for (const auto& enu : enm.enumerators()) {
           const auto enu_sn(enu.name().simple());
           std::string enu_qn;
           if (ast.is_cpp_standard_98())
               enu_qn = ast.get_qualified_namespace(enm.name()) + "::" + enu_sn;
           else
               enu_qn = sn + "::" + enu_sn;
#>
    if (s == "<#= enu_sn #>" || s == "<#= sn + "::" + enu_sn #>")
        return <#= enu_qn #>;
<#+
        }
#>
    throw boost::bad_lexical_cast();
}

}

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>

#+end_src
** transforms::templates
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters related to templating.

*** transforms::templates::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::templates::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::templates::logic_less_template
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.templating_logic_less_templates
:masd.wale.kvp.class.simple_name: logic_less_template_transform
:masd.wale.kvp.archetype.simple_name: logic_less_template
:masd.wale.kvp.meta_element: templating_logic_less_templates
:masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
:masd.physical.part_id: masd.cpp.templating
:masd.wale.kvp.locator_function: make_full_path_for_templates
:masd.wale.kvp.containing_namespace: text.cpp.transforms.templates
:masd.physical.wale_template_reference: cpp_artefact_transform_implementation
:masd.physical.referencing_status: not_referable
:masd.injection.stereotypes: masd::physical::archetype
:END:

Generates logic-less templates.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::templates #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/templating/logic_less_template.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/templates/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/templates/logic_less_template_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/templates/logic_less_template_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> logic_less_template_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    std::list<std::string> r;
    return r;
}

void logic_less_template_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "logic less template transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    ast.update_artefact();
    a.overwrite(false);
    stp.end_transform(a);
}
#>

#+end_src
** transforms::visual_studio
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters related to Visual Studio support.

*** transforms::visual_studio::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::visual_studio::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::visual_studio::project
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.visual_studio_project
:masd.wale.kvp.class.simple_name: project_transform
:masd.wale.kvp.archetype.simple_name: project
:masd.wale.kvp.meta_element: visual_studio_project
:masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
:masd.physical.part_id: masd.cpp.project
:masd.wale.kvp.locator_function: make_full_path_for_visual_studio_project
:masd.wale.kvp.containing_namespace: text.cpp.transforms.visual_studio
:masd.physical.wale_template_reference: cpp_artefact_transform_implementation
:masd.physical.referencing_status: not_referable
:masd.injection.stereotypes: masd::physical::archetype
:END:

Generates visual studio project.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::visual_studio #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/visual_studio/project.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/visual_studio/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/visual_studio/project_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/visual_studio/project_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> project_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void project_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "project transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    using logical::entities::visual_studio::project;
    const auto& proj(ast.as<project>(e));

#>
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{<#= proj.guid() #>}</ProjectGuid>
    <OutputType>Library</OutputType>
    <RootNamespace><#= proj.project_name() #></RootNamespace>
    <AssemblyName><#= proj.project_name() #></AssemblyName>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug</OutputPath>
    <DefineConstants>DEBUG;</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <ConsolePause>false</ConsolePause>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>full</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <ConsolePause>false</ConsolePause>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
  </ItemGroup>
<#+
        for (const auto& ig : proj.item_groups()) {
#>
  <ItemGroup>
<#+
            for (const auto& i : ig.items())
#>
    <<#= i.name() #> Include="<#= i.include() #>" />
  </ItemGroup>
<#+
        }
#>
  <Import Project="$(MSBuildBinPath)\Microsoft.Cpp.targets" />
</Project>
<#+
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::visual_studio::solution
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.visual_studio_solution
:masd.wale.kvp.class.simple_name: solution_transform
:masd.wale.kvp.archetype.simple_name: solution
:masd.wale.kvp.meta_element: visual_studio_solution
:masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
:masd.physical.part_id: masd.cpp.project
:masd.wale.kvp.locator_function: make_full_path_for_visual_studio_solution
:masd.wale.kvp.containing_namespace: text.cpp.transforms.visual_studio
:masd.physical.wale_template_reference: cpp_artefact_transform_implementation
:masd.physical.referencing_status: not_referable
:masd.injection.stereotypes: masd::physical::archetype
:END:

Generates visual studio solutions.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::visual_studio #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/visual_studio/solution.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/visual_studio/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/visual_studio/solution_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/visual_studio/solution_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> solution_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void solution_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "solution transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    using logical::entities::visual_studio::solution;
    const auto& sln(ast.as<solution>(e));
#>
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
<#+
    for (const auto& ppb : sln.project_persistence_blocks()) {
#>
Project("{<#= ppb.type_guid() #>}") = "<#= ppb.name() #>", "<#= ppb.name() #>.csproj", "{<#= ppb.guid() #>}"
EndProject
<#+
    }
#>
Global
    GlobalSection(SolutionConfigurationPlatforms) = preSolution
        Debug|Any CPU = Debug|Any CPU
        Release|Any CPU = Release|Any CPU
    EndGlobalSection
    GlobalSection(ProjectConfigurationPlatforms) = postSolution
<#+
    for (const auto& ppb : sln.project_persistence_blocks()) {
#>
        {<#= ppb.guid() #>}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {<#= ppb.guid() #>}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {<#= ppb.guid() #>}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {<#= ppb.guid() #>}.Release|Any CPU.Build.0 = Release|Any CPU
<#+
    }
#>
    EndGlobalSection
    GlobalSection(MonoDevelopProperties) = preSolution
        StartupItem = CppModel.vcxroj
    EndGlobalSection
EndGlobal
<#+
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::visual_studio::msbuild_targets
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.visual_studio_msbuild_targets
:masd.wale.kvp.class.simple_name: msbuild_targets_transform
:masd.wale.kvp.archetype.simple_name: msbuild_targets
:masd.wale.kvp.meta_element: visual_studio_msbuild_targets
:masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
:masd.physical.part_id: masd.cpp.project
:masd.wale.kvp.locator_function: make_full_path_for_msbuild_targets
:masd.wale.kvp.containing_namespace: text.cpp.transforms.visual_studio
:masd.physical.wale_template_reference: cpp_artefact_transform_implementation
:masd.physical.referencing_status: not_referable
:masd.injection.stereotypes: masd::physical::archetype
:END:

Generates msbuild targets.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::visual_studio #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/visual_studio/msbuild_targets.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/visual_studio/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/visual_studio/msbuild_targets_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/visual_studio/msbuild_targets_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> msbuild_targets_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void msbuild_targets_transform::apply(const context& ctx, const logical::entities::element& e,
    physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "msbuild targets transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    using logical::entities::visual_studio::msbuild_targets;
    const auto& c(ast.as<msbuild_targets>(e));

    {
        const auto ts(logical::entities::technical_space::xml);
        ast.make_decoration_preamble(e, ts);
        const auto model_name(ast.get_identifiable_model_name(c.name()));
        const auto product_name(ast.get_product_name(c.name()));
        const auto targets(c.odb_targets());
#>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">

    <!--[
        .NAME: odb.targets

        .SYNOPSIS:
            Generates all of the ODB files for this project.

        .DESCRIPTION:
            Calls the ODB compiler against each of the files in this Dogen model that require
            ODB compilation. Also moves the generated files to their correct location.

        .INPUTS:

        .OUTPUTS:
    ]-->
    <Target Name="<#= targets.main_target_name() #>"
<#+
            utility::formatters::sequence_formatter sf(targets.targets().size());
            sf.prefix_configuration().first("          DependsOnTargets=\"")
                                     .not_first("                            ");
            sf.postfix_configuration().last("\">");
            sf.element_separator(";");
            for (const auto& target : targets.targets()) {
#>
<#= sf.prefix() #><#= target.name() #><#= sf.postfix() #>
<#+
                sf.next();
            }
#>
        <Message Importance="high" Text="ODB <#= model_name #> "/>
    </Target>

<#+
            for (const auto& target : targets.targets()) {
#>
    <Target Name="<#= target.name() #>">
        <Message Importance="high" Text="<#= target.comment() #>"/>
        <Exec WorkingDirectory="$(OutputDirectory)" Command="&quot;$(OdbPath)&quot; -D_SECURE_SCL=0 $(OdbIncludeDirectories) --options-file $(MSBuildThisFileDirectory)<#= targets.common_odb_options() #> --options-file $(MSBuildThisFileDirectory)<#= target.object_odb_options() #> --output-dir $(MSBuildThisFileDirectory)<#= target.output_directory() #> $(MSBuildThisFileDirectory)<#= target.types_file() #>" />
<#+
                for (const auto& pair : target.move_parameters()) {
#>
        <Move
            SourceFiles="$(MSBuildThisFileDirectory)<#= pair.first #>"
            DestinationFolder="$(MSBuildThisFileDirectory)<#= pair.second #>" />
<#+
                }
#>
    </Target>
<#+
            }
#>
</Project>
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
** transforms::build
:PROPERTIES:
:masd.injection.dia.comment: true
:masd.injection.stereotypes: masd::physical::facet
:END:

Formatters related to build files.

*** transforms::build::source_cmakelists
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.build_cmakelists
:masd.wale.kvp.class.simple_name: source_cmakelists_transform
:masd.wale.kvp.archetype.simple_name: source_cmakelists
:masd.wale.kvp.meta_element: build_cmakelists
:masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
:masd.physical.part_id: masd.cpp.project
:masd.wale.kvp.locator_function: make_full_path_for_source_cmakelists
:masd.wale.kvp.containing_namespace: text.cpp.transforms.build
:masd.physical.wale_template_reference: cpp_artefact_transform_implementation
:masd.physical.referencing_status: not_referable
:masd.injection.stereotypes: masd::physical::archetype
:END:

Generates cmakelists for tests.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::build #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/build/cmakelists.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/build/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/build/source_cmakelists_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/build/source_cmakelists_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> source_cmakelists_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void source_cmakelists_transform::apply(const context& ctx,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "source cmakelists transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    using logical::entities::build::cmakelists;
    const auto& c(ast.as<cmakelists>(e));

    {
        const auto ts(logical::entities::technical_space::cmake);
        ast.make_decoration_preamble(e, ts);
        const auto model_name(ast.get_dot_separated_model_name(c.name()));
        const auto product_name(ast.get_product_name(c.name()));
#>
set(name "<#= model_name #>")
set(lib_binary_name ${name})
set(lib_target_name ${name}.lib)

set(files "")
file(GLOB_RECURSE files RELATIVE
    "${CMAKE_CURRENT_SOURCE_DIR}/"
    "${CMAKE_CURRENT_SOURCE_DIR}/*.<#= c.implementation_file_extension() #>")

<#+
        if (ast.is_odb_facet_enabled() && !c.odb_targets().targets().empty()) {
#>
set(odb_files "")
file(GLOB_RECURSE odb_files RELATIVE
   "${CMAKE_CURRENT_SOURCE_DIR}/"
   "${CMAKE_CURRENT_SOURCE_DIR}/*.cxx")
set(files ${files} ${odb_files})

<#+
        }
#>
set(lib_files ${files})
add_library(${lib_target_name} ${lib_files})
set_target_properties(${lib_target_name} PROPERTIES
<#+
        if (ast.is_cpp_standard_98()) {
#>
    CXX_STANDARD 98
<#+
        }
#>
    OUTPUT_NAME ${lib_binary_name})

install(TARGETS ${lib_target_name}
    ARCHIVE DESTINATION lib
    LIBRARY DESTINATION lib
    COMPONENT libraries)
<#+
        if (ast.is_odb_facet_enabled() && !c.odb_targets().targets().empty()) {
            const auto targets(c.odb_targets());
#>

#
# ODB Executable Targets
#
if (ODB_EXECUTABLE)
    # Top-level targets
    add_custom_target(<#= targets.main_target_name() #>)
    add_dependencies(odb_all <#= targets.main_target_name() #>)

    if (NOT ODB_EXECUTABLE_GLOBAL_ARGS)
        message(WARNING "ODB_EXECUTABLE_GLOBAL_ARGS not defined. Inclusion errors likely when running ODB targets.")
    endif()

<#+
            for (const auto& target : targets.targets()) {
#>

    add_custom_target(<#= target.name() #>
        COMMENT "<#= target.comment() #>"
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        COMMAND ${ODB_EXECUTABLE}
            --options-file ${CMAKE_CURRENT_SOURCE_DIR}/<#= targets.common_odb_options() #>
            --options-file ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.object_odb_options() #>
            --output-dir ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.output_directory() #>
            ${ODB_EXECUTABLE_GLOBAL_ARGS}
            ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.types_file() #>
<#+
                for (const auto& pair : target.move_parameters())
#>
        COMMAND mv ${CMAKE_CURRENT_SOURCE_DIR}/<#= pair.first #> ${CMAKE_CURRENT_SOURCE_DIR}/<#= pair.second #>
        VERBATIM
    )
    add_dependencies(<#= targets.main_target_name() #> <#= target.name() #>)
<#+
            }
#>
endif()
<#+
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::build::include_cmakelists
:PROPERTIES:
:masd.physical.logical_meta_element_id: dogen.logical.entities.build_cmakelists
:masd.wale.kvp.class.simple_name: include_cmakelists_transform
:masd.wale.kvp.archetype.simple_name: include_cmakelists
:masd.wale.kvp.meta_element: build_cmakelists
:masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
:masd.physical.part_id: masd.cpp.project
:masd.wale.kvp.locator_function: make_full_path_for_include_cmakelists
:masd.wale.kvp.containing_namespace: text.cpp.transforms.build
:masd.physical.wale_template_reference: cpp_artefact_transform_implementation
:masd.physical.referencing_status: not_referable
:masd.injection.stereotypes: masd::physical::archetype
:END:

Generates cmakelists for tests.

**** stitch_template_content
#+begin_src stitch
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::build #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/build/cmakelists.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/build/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/build/include_cmakelists_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/build/include_cmakelists_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

std::list<std::string> include_cmakelists_transform::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

void include_cmakelists_transform::apply(const context& ctx,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "include cmakelists transform",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);
    using logical::entities::build::cmakelists;
    const auto& c(ast.as<cmakelists>(e));

    {
        const auto ts(logical::entities::technical_space::cmake);
        ast.make_decoration_preamble(e, ts);
#>
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/<#= c.source_directory_name() #>)
<#+
       if (ast.is_tests_enabled()) {
#>
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/<#= c.tests_directory_name() #>)
<#+
       }
#>

install(
    DIRECTORY <#= c.include_directory_path() #>/
    DESTINATION <#= c.include_directory_path() #>/
    COMPONENT headers
    FILES_MATCHING PATTERN "*.<#= c.header_file_extension() #>")
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>

#+end_src
*** transforms::build::initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
*** transforms::build::traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** transforms::public_headers
:PROPERTIES:
:masd.injection.stereotypes: masd::physical::part
:END:

Contains the header files that are publicly visible.

*** external_modules_path_contribution
:PROPERTIES:
:masd.injection.value: none
:END:
*** model_modules_path_contribution
:PROPERTIES:
:masd.injection.value: as_path_components
:END:
*** facet_path_contribution
:PROPERTIES:
:masd.injection.value: as_directories
:END:
*** internal_modules_path_contribution
:PROPERTIES:
:masd.injection.value: as_directories
:END:
*** requires_relative_path
:PROPERTIES:
:masd.injection.value: true
:END:
** transforms::standard_header_file
:PROPERTIES:
:masd.injection.stereotypes: masd::physical::archetype_kind
:END:

Header file generated by Dogen.

*** file_extension
:PROPERTIES:
:masd.injection.value: hpp
:END:
** transforms::implementation
:PROPERTIES:
:masd.injection.stereotypes: masd::physical::part
:END:

Contains the implementation files.

*** external_modules_path_contribution
:PROPERTIES:
:masd.injection.value: none
:END:
*** model_modules_path_contribution
:PROPERTIES:
:masd.injection.value: as_path_components
:END:
*** facet_path_contribution
:PROPERTIES:
:masd.injection.value: as_directories
:END:
*** requires_relative_path
:PROPERTIES:
:masd.injection.value: false
:END:
** transforms::testing
:PROPERTIES:
:masd.injection.stereotypes: masd::physical::part
:END:

Contains the test files.

*** external_modules_path_contribution
:PROPERTIES:
:masd.injection.value: none
:END:
*** model_modules_path_contribution
:PROPERTIES:
:masd.injection.value: as_path_components
:END:
*** facet_path_contribution
:PROPERTIES:
:masd.injection.value: as_directories
:END:
*** requires_relative_path
:PROPERTIES:
:masd.injection.value: false
:END:
** transforms::base_archetype_configuration
:PROPERTIES:
:masd.injection.stereotypes: masd::variability::profile
:END:

Contains the configuration common to all archetypes.

** transforms::tests_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::tests_configuration
:masd.injection.parent: transforms::base_archetype_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:

Contains the configuration common to most archetypes in tests.

*** masd.physical.part_id
:PROPERTIES:
:masd.injection.value: masd.cpp.testing
:END:
*** masd.wale.kvp.locator_function
:PROPERTIES:
:masd.injection.value: make_full_path_for_tests_cpp_implementation
:END:
*** masd.physical.wale_template_reference
:PROPERTIES:
:masd.injection.value: cpp_artefact_transform_implementation
:END:
*** masd.physical.referencing_status
:PROPERTIES:
:masd.injection.value: not_referable
:END:
** transforms::header_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::header_configuration
:masd.injection.parent: transforms::base_archetype_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:

Contains the configuration common to all c++ header archetypes.

*** masd.physical.part_id
:PROPERTIES:
:masd.injection.value: masd.cpp.public_headers
:END:
*** masd.wale.kvp.locator_function
:PROPERTIES:
:masd.injection.value: make_full_path_for_cpp_header
:END:
*** masd.physical.wale_template_reference
:PROPERTIES:
:masd.injection.value: cpp_artefact_transform_implementation_header
:END:
** transforms::header_facet_default_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::header_facet_default_configuration
:masd.injection.parent: transforms::header_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:
*** masd.wale.kvp.class.inclusion_support_type
:PROPERTIES:
:masd.injection.value: canonical_support
:END:
*** masd.physical.referencing_status
:PROPERTIES:
:masd.injection.value: facet_default
:END:
** transforms::object_header_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::object_header_configuration
:masd.injection.parent: transforms::header_facet_default_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:

Contains the configuration common to all object header archetypes.

*** masd.physical.logical_meta_element_id
:PROPERTIES:
:masd.injection.value: dogen.logical.entities.object
:END:
*** masd.wale.kvp.class.simple_name
:PROPERTIES:
:masd.injection.value: class_header_transform
:END:
*** masd.wale.kvp.archetype.simple_name
:PROPERTIES:
:masd.injection.value: class_header
:END:
*** masd.wale.kvp.meta_element
:PROPERTIES:
:masd.injection.value: object
:END:
** transforms::enumeration_header_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::enumeration_header_configuration
:masd.injection.parent: transforms::header_facet_default_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:

Contains the configuration common to all enumeration header archetypes.

*** masd.physical.logical_meta_element_id
:PROPERTIES:
:masd.injection.value: dogen.logical.entities.enumeration
:END:
*** masd.wale.kvp.class.simple_name
:PROPERTIES:
:masd.injection.value: enum_header_transform
:END:
*** masd.wale.kvp.archetype.simple_name
:PROPERTIES:
:masd.injection.value: enum_header
:END:
*** masd.wale.kvp.meta_element
:PROPERTIES:
:masd.injection.value: enumeration
:END:
** transforms::implementation_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::implementation_configuration
:masd.injection.parent: transforms::base_archetype_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:

Contains the configuration common to all c++ implementation archetypes.

*** masd.physical.part_id
:PROPERTIES:
:masd.injection.value: masd.cpp.implementation
:END:
*** masd.wale.kvp.locator_function
:PROPERTIES:
:masd.injection.value: make_full_path_for_cpp_implementation
:END:
*** masd.physical.wale_template_reference
:PROPERTIES:
:masd.injection.value: cpp_artefact_transform_implementation
:END:
*** masd.physical.referencing_status
:PROPERTIES:
:masd.injection.value: not_referable
:END:
** transforms::object_implementation_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::object_implementation_configuration
:masd.injection.parent: transforms::implementation_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:
*** masd.physical.logical_meta_element_id
:PROPERTIES:
:masd.injection.value: dogen.logical.entities.object
:END:
*** masd.wale.kvp.class.simple_name
:PROPERTIES:
:masd.injection.value: class_implementation_transform
:END:
*** masd.wale.kvp.archetype.simple_name
:PROPERTIES:
:masd.injection.value: class_implementation
:END:
*** masd.wale.kvp.meta_element
:PROPERTIES:
:masd.injection.value: object
:END:
** transforms::builtin_header_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::builtin_header_configuration
:masd.injection.parent: transforms::header_facet_default_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:

Contains the configuration common to all built header archetypes.

*** masd.physical.logical_meta_element_id
:PROPERTIES:
:masd.injection.value: dogen.logical.entities.builtin
:END:
*** masd.wale.kvp.class.simple_name
:PROPERTIES:
:masd.injection.value: builtin_header_transform
:END:
*** masd.wale.kvp.archetype.simple_name
:PROPERTIES:
:masd.injection.value: builtin_header
:END:
*** masd.wale.kvp.meta_element
:PROPERTIES:
:masd.injection.value: builtin
:END:
** transforms::primitive_header_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::primitive_header_configuration
:masd.injection.parent: transforms::header_facet_default_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:

Contains the configuration common to all built header archetypes.

*** masd.physical.logical_meta_element_id
:PROPERTIES:
:masd.injection.value: dogen.logical.entities.primitive
:END:
*** masd.wale.kvp.class.simple_name
:PROPERTIES:
:masd.injection.value: primitive_header_transform
:END:
*** masd.wale.kvp.archetype.simple_name
:PROPERTIES:
:masd.injection.value: primitive_header
:END:
*** masd.wale.kvp.meta_element
:PROPERTIES:
:masd.injection.value: primitive
:END:
** transforms::primitive_implementation_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::primitive_implementation_configuration
:masd.injection.parent: transforms::implementation_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:
*** masd.physical.logical_meta_element_id
:PROPERTIES:
:masd.injection.value: dogen.logical.entities.primitive
:END:
*** masd.wale.kvp.class.simple_name
:PROPERTIES:
:masd.injection.value: primitive_implementation_transform
:END:
*** masd.wale.kvp.archetype.simple_name
:PROPERTIES:
:masd.injection.value: primitive_implementation
:END:
*** masd.wale.kvp.meta_element
:PROPERTIES:
:masd.injection.value: primitive
:END:
** transforms::project
:PROPERTIES:
:masd.injection.stereotypes: masd::physical::part
:END:

Top-level project part.

*** external_modules_path_contribution
:PROPERTIES:
:masd.injection.value: none
:END:
*** model_modules_path_contribution
:PROPERTIES:
:masd.injection.value: none
:END:
*** facet_path_contribution
:PROPERTIES:
:masd.injection.value: none
:END:
*** requires_relative_path
:PROPERTIES:
:masd.injection.value: false
:END:
** transforms::enumeration_implementation_configuration
:PROPERTIES:
:masd.variability.binding_point: entity
:masd.variability.stereotype: dogen::enumeration_implementation_configuration
:masd.injection.parent: transforms::implementation_configuration
:masd.injection.stereotypes: masd::variability::profile
:END:
*** masd.physical.logical_meta_element_id
:PROPERTIES:
:masd.injection.value: dogen.logical.entities.enumeration
:END:
*** masd.wale.kvp.class.simple_name
:PROPERTIES:
:masd.injection.value: enum_implementation_transform
:END:
*** masd.wale.kvp.archetype.simple_name
:PROPERTIES:
:masd.injection.value: enum_implementation
:END:
*** masd.wale.kvp.meta_element
:PROPERTIES:
:masd.injection.value: enumeration
:END:
** transforms::templating
:PROPERTIES:
:masd.injection.stereotypes: masd::physical::part
:END:
*** external_modules_path_contribution
:PROPERTIES:
:masd.injection.value: none
:END:
*** model_modules_path_contribution
:PROPERTIES:
:masd.injection.value: none
:END:
*** facet_path_contribution
:PROPERTIES:
:masd.injection.value: none
:END:
*** requires_relative_path
:PROPERTIES:
:masd.injection.value: false
:END:
** transforms::transformation_error
:PROPERTIES:
:masd.injection.stereotypes: masd::exception
:END:

An error occurred whilst applying a transform.

* model_to_text_cpp_chain
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
* workflow_error
:PROPERTIES:
:masd.injection.stereotypes: masd::exception
:END:
* traits
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
* formattables
:PROPERTIES:
:masd.injection.dia.comment: true
:END:

Formattables contains all types required by the formatters
and those used to generate them.

** formattables::workflow
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::locator
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::dependencies_builder
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::building_error
:PROPERTIES:
:masd.injection.stereotypes: masd::exception
:END:

An error occurred while the factory was building.

** formattables::artefact_properties
*** file_path
:PROPERTIES:
:masd.injection.type: boost::filesystem::path
:END:
*** header_guard
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** inclusion_dependencies
:PROPERTIES:
:masd.injection.type: std::list<std::string>
:END:
** formattables::dependencies_builder_factory
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::helper_descriptor
*** family
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** namespaces
:PROPERTIES:
:masd.injection.type: std::list<std::string>
:END:
*** name_identifiable
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** name_qualified
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** name_tree_qualified
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** name_tree_identifiable
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** streaming_properties
:PROPERTIES:
:masd.injection.type: boost::optional<formattables::streaming_properties>
:END:
*** is_simple_type
:PROPERTIES:
:masd.injection.type: bool
:END:
*** requires_hashing_helper
:PROPERTIES:
:masd.injection.type: bool
:END:
*** is_circular_dependency
:PROPERTIES:
:masd.injection.type: bool
:END:
*** is_pointer
:PROPERTIES:
:masd.injection.type: bool
:END:
** formattables::helper_properties
*** current
:PROPERTIES:
:masd.injection.type: formattables::helper_descriptor
:END:
*** direct_descendants
:PROPERTIES:
:masd.injection.type: std::list<formattables::helper_descriptor>
:END:
*** in_inheritance_relationship
:PROPERTIES:
:masd.injection.type: bool
:END:
** formattables::element_properties
All of the properties associated with an element.

*** aspect_properties
:PROPERTIES:
:masd.injection.type: formattables::aspect_properties
:END:
*** artefact_properties
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, formattables::artefact_properties>
:END:
*** helper_properties
:PROPERTIES:
:masd.injection.type: std::list<formattables::helper_properties>
:END:
*** canonical_archetype_to_archetype
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, std::string>
:END:
*** attribute_level_test_data_properties
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, test_data_properties>
:END:
** formattables::aspect_properties
*** requires_manual_default_constructor
:PROPERTIES:
:masd.injection.type: bool
:END:
*** requires_manual_move_constructor
:PROPERTIES:
:masd.injection.type: bool
:END:
*** requires_stream_manipulators
:PROPERTIES:
:masd.injection.type: bool
:END:
** formattables::formattable
*** element
:PROPERTIES:
:masd.injection.type: boost::shared_ptr<logical::entities::element>
:END:
*** element_properties
:PROPERTIES:
:masd.injection.type: formattables::element_properties
:END:
*** artefacts
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, boost::shared_ptr<physical::entities::artefact>>
:END:
** formattables::adapter
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::inclusion_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::reducer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::model_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::file_path_and_guard_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::aspect_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::helper_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::adaptation_error
:PROPERTIES:
:masd.injection.stereotypes: masd::exception
:END:

An error occurred during adaptation.

** formattables::expansion_error
:PROPERTIES:
:masd.injection.stereotypes: masd::exception
:END:
** formattables::odb_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::model
*** name
:PROPERTIES:
:masd.injection.type: logical::entities::name
:END:
*** streaming_properties
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, formattables::streaming_properties>
:END:
*** formattables
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, formattables::formattable>
:END:
*** facet_properties
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, formattables::facet_properties>
:END:
*** cpp_standard
:PROPERTIES:
:masd.injection.type: formattables::cpp_standards
:END:
*** odb_databases
:PROPERTIES:
:masd.injection.type: std::list<std::string>
:END:
*** odb_sql_name_case
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** project_items
:PROPERTIES:
:masd.injection.type: std::list<std::string>
:END:
** formattables::facet_properties
*** directory
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** enabled
:PROPERTIES:
:masd.injection.type: bool
:END:
** formattables::facet_directory_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::canonical_archetype_resolver
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::canonical_archetype_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::resolution_error
:PROPERTIES:
:masd.injection.stereotypes: masd::exception
:END:
** formattables::streaming_properties
*** requires_quoting
:PROPERTIES:
:masd.injection.type: bool
:END:
*** string_conversion_method
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** remove_unprintable_characters
:PROPERTIES:
:masd.injection.type: bool
:END:
** formattables::streaming_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::locator_configuration
*** facet_configurations
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, formattables::locator_facet_configuration>
:END:
*** archetype_configurations
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, formattables::locator_archetype_configuration>
:END:
*** include_directory_name
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** source_directory_name
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** disable_facet_directories
:PROPERTIES:
:masd.injection.type: bool
:END:
*** header_file_extension
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** implementation_file_extension
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** backend_directory_name
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** tests_directory_name
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** templates_directory_name
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** templates_file_extension
:PROPERTIES:
:masd.injection.type: std::string
:END:
** formattables::locator_facet_configuration
*** directory
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** postfix
:PROPERTIES:
:masd.injection.type: std::string
:END:
** formattables::locator_archetype_configuration
*** facet_directory
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** facet_postfix
:PROPERTIES:
:masd.injection.type: std::string
:END:
*** archetype_postfix
:PROPERTIES:
:masd.injection.type: std::string
:END:
** formattables::location_error
:PROPERTIES:
:masd.injection.stereotypes: masd::exception
:END:

An error occurred while the locator was creating a path.

** formattables::helper_configuration
*** helper_families
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, std::string>
:END:
*** streaming_properties
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, formattables::streaming_properties>
:END:
** formattables::directive_group_repository
*** by_id
:PROPERTIES:
:masd.injection.type: std::unordered_map<std::string, std::unordered_map<std::string, formattables::directive_group>>
:END:
** formattables::directive_group_repository_factory
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::directive_group
Represents the group of inclusion directives associated with a name and an archetype.

*** primary
:PROPERTIES:
:masd.injection.type: std::string
:END:

The main inclusion directive needed for this element.

*** secondary
:PROPERTIES:
:masd.injection.type: std::list<std::string>
:END:

Any other directives that are also needed for this element.

** formattables::build_files_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::cpp_standards
:PROPERTIES:
:masd.injection.stereotypes: masd::enumeration
:END:
*** cpp_98
*** cpp_11
*** cpp_14
*** cpp_17
** formattables::cpp_standard_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::header_guard_factory
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
** formattables::test_data_properties
*** maximum_size
:PROPERTIES:
:masd.injection.type: unsigned int
:END:
*** prefix
:PROPERTIES:
:masd.injection.type: std::string
:END:
** formattables::test_data_properties_expander
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
* initializer
:PROPERTIES:
:masd.injection.stereotypes: dogen::handcrafted::typeable
:END:
* feature_initializer
:PROPERTIES:
:masd.injection.stereotypes: masd::variability::initializer
:END:
* cpp_artefact_transform_header
:PROPERTIES:
:masd.cpp.templates.logic_less_template.overwrite: false
:masd.injection.stereotypes: masd::templating::logic_less_templates
:END:
** content
#+begin_src mustache
class {{class.simple_name}} final : public model_to_text_transform {
public:
    static physical::entities::archetype static_archetype();
    const physical::entities::archetype& archetype() const override;

public:
    std::list<std::string> inclusion_dependencies(
        const formattables::dependencies_builder_factory& f,
        const logical::entities::element& e) const override;

    inclusion_support_types inclusion_support_type() const override;

    boost::filesystem::path inclusion_path(
        const formattables::locator& l,
        const logical::entities::name& n) const override;

    boost::filesystem::path full_path(
        const formattables::locator& l,
        const logical::entities::name& n) const override;

public:
    void apply(const context& ctx, const logical::entities::element& e,
        physical::entities::artefact& a) const override;
};

#+end_src
* cpp_artefact_transform_implementation
:PROPERTIES:
:masd.cpp.templates.logic_less_template.overwrite: false
:masd.injection.stereotypes: masd::templating::logic_less_templates
:END:
** content
#+begin_src mustache
namespace {

const std::string transform_id("{{containing_namespace}}.{{class.simple_name}}");

using namespace dogen::utility::log;
auto lg(logger_factory(transform_id));

}

const physical::entities::archetype& {{class.simple_name}}::static_archetype() {
    static auto r({{archetype.simple_name}}_factory::make());
    return r;
}

const physical::entities::archetype& {{class.simple_name}}::archetype() const {
    return static_archetype();
}

inclusion_support_types {{class.simple_name}}::inclusion_support_type() const {
    return inclusion_support_types::not_supported;
}

boost::filesystem::path {{class.simple_name}}::inclusion_path(
    const formattables::locator& /*l*/, const logical::entities::name& n) const {

    using namespace dogen::utility::log;
    static logger lg(logger_factory(archetype().meta_name().qualified()));
    static const std::string not_supported("Inclusion path is not supported: ");

    BOOST_LOG_SEV(lg, error) << not_supported << n.qualified().dot();
    BOOST_THROW_EXCEPTION(formatting_error(not_supported + n.qualified().dot()));
}

boost::filesystem::path {{class.simple_name}}::full_path(
    const formattables::locator& l, const logical::entities::name& n) const {
    return l.{{locator_function}}(n, archetype().meta_name().qualified());
}

#+end_src
* cpp_artefact_transform_implementation_header
:PROPERTIES:
:masd.cpp.templates.logic_less_template.overwrite: false
:masd.injection.stereotypes: masd::templating::logic_less_templates
:END:
** content
#+begin_src mustache
namespace {

const std::string transform_id("{{containing_namespace}}.{{class.simple_name}}");

using namespace dogen::utility::log;
auto lg(logger_factory(transform_id));

}

const physical::entities::archetype& {{class.simple_name}}::static_archetype() {
    static auto r({{archetype.simple_name}}_factory::make());
    return r;
}

const physical::entities::archetype& {{class.simple_name}}::archetype() const {
    return static_archetype();
}

inclusion_support_types {{class.simple_name}}::inclusion_support_type() const {
    return inclusion_support_types::{{class.inclusion_support_type}};
}

boost::filesystem::path {{class.simple_name}}::inclusion_path(
    const formattables::locator& l, const logical::entities::name& n) const {
    return l.make_inclusion_path_for_cpp_header(n, archetype().meta_name().qualified());
}

boost::filesystem::path {{class.simple_name}}::full_path(
    const formattables::locator& l, const logical::entities::name& n) const {
    return l.{{locator_function}}(n, archetype().meta_name().qualified());
}

#+end_src
* cpp_helper_transform_header
:PROPERTIES:
:masd.cpp.templates.logic_less_template.overwrite: false
:masd.injection.stereotypes: masd::templating::logic_less_templates
:END:
** content
#+begin_src mustache
class {{class.simple_name}} : public helper_transform {
public:
    std::string id() const override;
    std::string family() const override;
    std::list<std::string> owning_formatters() const override;
    std::list<std::string> owning_facets() const override;
    std::string helper_name() const override;
    bool is_enabled(const assistant& a,
        const formattables::helper_properties& hc) const override;
    void apply(assistant& a,
        const formattables::helper_properties& hc) const override;
};

#+end_src
* cpp_helper_transform_implementation
:PROPERTIES:
:masd.cpp.templates.logic_less_template.overwrite: false
:masd.injection.stereotypes: masd::templating::logic_less_templates
:END:
** content
#+begin_src mustache
std::string {{class.simple_name}}::id() const {
    static auto r(std::string("<") + traits::facet_qn() + std::string(">") +
        std::string("<") + helper_name() + std::string(">"));
    return r;
}

std::string {{class.simple_name}}::family() const {
    static std::string r("{{helper.family}}");
    return r;
}

std::list<std::string>
{{class.simple_name}}::owning_formatters() const {
    static auto r(std::list<std::string> {
        io::traits::class_implementation_archetype_qn(),
        io::traits::primitive_implementation_archetype_qn(),
        types::traits::class_implementation_archetype_qn(),
        types::traits::primitive_implementation_archetype_qn()
    });
    return r;
}

std::list<std::string>
{{class.simple_name}}::owning_facets() const {
    static auto r(std::list<std::string> {
        io::traits::facet_qn(), types::traits::facet_qn()
    });
    return r;
}

std::string {{class.simple_name}}::helper_name() const {
    static std::string r("{{class.simple_name}}");
    return r;
}

bool {{class.simple_name}}::is_enabled(const assistant& a,
    const formattables::helper_properties& hp) const {
    return a.is_streaming_enabled(hp);
}

#+end_src
* cpp_helper_transform_implementation_enabled
:PROPERTIES:
:masd.cpp.templates.logic_less_template.overwrite: false
:masd.injection.stereotypes: masd::templating::logic_less_templates
:END:
** content
#+begin_src mustache
std::string {{class.simple_name}}::id() const {
    static auto r(std::string("<") + traits::facet_qn() + std::string(">") +
        std::string("<") + helper_name() + std::string(">"));
    return r;
}

std::string {{class.simple_name}}::family() const {
    static std::string r("{{helper.family}}");
    return r;
}

std::list<std::string>
{{class.simple_name}}::owning_formatters() const {
    static auto r(std::list<std::string> {
        traits::class_implementation_archetype_qn(),
        traits::primitive_implementation_archetype_qn()
    });
    return r;
}

std::list<std::string>
{{class.simple_name}}::owning_facets() const {
    static auto r(std::list<std::string> {
        traits::facet_qn()
    });
    return r;
}

std::string {{class.simple_name}}::helper_name() const {
    static std::string r("{{class.simple_name}}");
    return r;
}

bool {{class.simple_name}}::is_enabled(const assistant& /*a*/,
    const formattables::helper_properties& /*hp*/) const {
    return true;
}

#+end_src
* registrar
:PROPERTIES:
:masd.injection.stereotypes: masd::serialization::type_registrar
:END:
* main
:PROPERTIES:
:masd.injection.stereotypes: masd::entry_point, dogen::untypable
:END:
* CMakeLists
:PROPERTIES:
:masd.injection.stereotypes: masd::build::cmakelists, dogen::handcrafted::cmake
:END:
