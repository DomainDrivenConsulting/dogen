{
  "documentation": "Coding is the core Dogen meta-model representing software entities.\n\n@section assets_0 Overview\n\nAssets is a meta-model that strives to provide a technical-space agnostic\ntype representation, designed for code generation. Injection models\nare obtained via frontends and processed until they form a cohesive\nwhole. They are then suitable to be sent down the pipeline for further\nprocessing.\n\n@section asset_1 Mission\n\nAssets objectives are:\n\n@li to represent all high-level entities that exist across a number\nof technical spaces used in software engineering. These entities\nare not necessarily limited to programming entities, though, of course,\nthese form the core set of elements we're interested in. Additional\nentities such as build sytems and high-level patterns such as GoF\nand others are also captured.\n\n@li to provide the tooling required to combine multiple assets\nmodels together into a bigger model - called the @e merged model.\n\n@li to ensure the consistency of the merged model via validation\nrules (such as verifying that all types have a definitions,\netc.).\n",
  "tagged_values": {
    "masd.injection.dia.comment": "true",
    "masd.injection.model_modules": "dogen.assets",
    "masd.injection.reference": "cpp.builtins",
    "masd.injection.reference": "cpp.std",
    "masd.injection.reference": "cpp.boost",
    "masd.injection.reference": "dogen",
    "masd.injection.reference": "dogen.variability",
    "masd.injection.reference": "dogen.tracing",
    "masd.injection.reference": "dogen.extraction",
    "masd.injection.reference": "masd",
    "masd.injection.reference": "masd.variability",
    "masd.injection.reference": "dogen.profiles",
    "masd.injection.input_technical_space": "cpp",
    "masd.extraction.ignore_files_matching_regex": ".*/CMakeLists.txt",
    "masd.extraction.ignore_files_matching_regex": ".*/test/.*",
    "masd.extraction.ignore_files_matching_regex": ".*/tests/.*",
    "masd.extraction.delete_extra_files": "true",
    "masd.extraction.delete_empty_directories": "true",
    "masd.generation.cpp.enabled": "true",
    "masd.generation.cpp.standard": "c++-17",
    "masd.generation.cpp.msbuild.enabled": "false",
    "masd.generation.cpp.visual_studio.project.enabled": "false",
    "masd.generation.cpp.visual_studio.solution.enabled": "false",
    "masd.generation.csharp.enabled": "false",
    "masd.variability.profile": "dogen.profiles.base.default_profile"
  },
  "elements": [
    {
      "name": "meta_model",
      "fallback_element_type": "masd::module"
    },
    {
      "name": "meta_model::attribute",
      "documentation": "Represents an attribute in an object.\n",
      "stereotypes": [
        "Documentable",
        "Configurable",
        "Nameable",
        "Stereotypable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "unparsed_type",
          "type": "std::string",
          "documentation": "Original type name as it appeared in the source, without any parsing.\n\nName must be in one of the supported notations.\n"
        },
        {
          "name": "parsed_type",
          "type": "name_tree",
          "documentation": "Tree of names that represent the type of the attribute, after suitable parsing.\n"
        },
        {
          "name": "is_immutable",
          "type": "bool",
          "documentation": "If true, the attribute can only be read but not set.\n"
        },
        {
          "name": "is_fluent",
          "type": "bool",
          "documentation": "If true, the attribute's setter will return the object iteself.\n"
        },
        {
          "name": "orm_properties",
          "type": "boost::optional<orm::attribute_properties>"
        }
      ]
    },
    {
      "name": "meta_model::name_tree",
      "documentation": "Adds support for name composition as a tree-like structure.\n\nA name tree has the responsibility of representing an instantiation of a generic\ntype with all of its type parameters, which themselves can also be generic types\nand so on. It may also represent the simpler case of a non-generic type, in which\ncase only the parent name is populated and there are no children.\n",
      "stereotypes": [
        "Qualifiable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "current",
          "type": "name",
          "documentation": "Name for the current level of the tree.\n"
        },
        {
          "name": "children",
          "type": "std::list<name_tree>",
          "documentation": "Names of the child elements.\n"
        },
        {
          "name": "are_children_opaque",
          "type": "bool",
          "documentation": "If true, the association with its children can be opaque.\n\nChildren are considered opaque when the parent does not require knowledge\nabout the childs' internal structure. This is the case, for example, with C and\nC++ pointers, references and so on.\n"
        },
        {
          "name": "is_circular_dependency",
          "type": "bool",
          "documentation": "If true, the presence of the current name causes a circular dependency.\n"
        },
        {
          "name": "is_current_simple_type",
          "type": "bool",
          "documentation": "Returns true if @e current is a simple type such as a built-in or an enumeration.\n"
        },
        {
          "name": "is_floating_point",
          "type": "bool",
          "documentation": "If true, \"current\" stores a floating point type.\n"
        }
      ]
    },
    {
      "name": "meta_model::Nameable",
      "documentation": "Ability to have a name.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "name",
          "type": "name",
          "documentation": "Fully qualified name.\n"
        }
      ]
    },
    {
      "name": "meta_model::Documentable",
      "documentation": "Ability to provide documentation.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "documentation",
          "type": "std::string",
          "documentation": "Code comments.\n\nThese are expected to follow the grammar of the comment processing tools\nof the technical space in question, e.g. Doxygen for C++, JavaDoc for Java,\netc.\n"
        }
      ]
    },
    {
      "name": "meta_model::DeterminableOrigin",
      "documentation": "A unit of assets that can be code generated.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "origin_type",
          "type": "origin_types",
          "documentation": "How was this model element originated.\n"
        }
      ]
    },
    {
      "name": "meta_model::Containable",
      "documentation": "The ability to be contained inside a module.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "contained_by",
          "type": "std::string",
          "documentation": "Name of the module in which we are contained, if any.\n"
        },
        {
          "name": "in_global_module",
          "type": "bool",
          "documentation": "If true, the element is located in the global module.\n"
        }
      ]
    },
    {
      "name": "meta_model::Stereotypable",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "static_stereotypes",
          "type": "std::list<static_stereotypes>",
          "documentation": "Stereotypes that are part of the dogen UML profile, and so are well-known to the\nmodel.\n"
        },
        {
          "name": "dynamic_stereotypes",
          "type": "std::list<std::string>",
          "documentation": "Stereotypes that are not part of the masd UML profile. These are user defined.\n"
        }
      ]
    },
    {
      "name": "meta_model::MetaNameable",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "meta_name",
          "type": "name",
          "documentation": "Name of the element in the meta-model that this instance conforms to.\n"
        }
      ]
    },
    {
      "name": "meta_model::TechnicalSpaceRelationship",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "intrinsic_technical_space",
          "type": "technical_space",
          "documentation": "Describes the intrinsic nature of the modeling element with regards to technical\nspaces.\n\nIf the element can be mapped to a technical space then its intrinsic nature is\nagnostic. Otherwise, the element belongs to a concrete technical space.\n"
        }
      ]
    },
    {
      "name": "meta_model::Configurable",
      "documentation": "Ability to have meta-data associated.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "configuration",
          "type": "boost::shared_ptr<variability::meta_model::configuration>",
          "documentation": "Configuration for this element.\n"
        }
      ]
    },
    {
      "name": "meta_model::Element",
      "parents": [
        "meta_model::Nameable",
        "meta_model::Documentable",
        "meta_model::DeterminableOrigin",
        "meta_model::Containable",
        "meta_model::Stereotypable",
        "meta_model::MetaNameable",
        "meta_model::TechnicalSpaceRelationship",
        "meta_model::Configurable"
      ],
      "documentation": "A unit of coding that can be code generated.\n\nWe define the Element object template purely to make our life easier\nwhen creating the element class. It is not required for any other\npurpose.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::name",
      "documentation": "Name of an element in asset space.\n\nA name represents a point in asset space, and this point can only be\nused by one asset element. Names can be uniquely identified by their\nqualified ID.\n\nName has the following properties: a) two different points in element space\ncannot have the same name and b) the same point in element space can only\nhave one and only one name.\n\nNames are required in addition to just using the qualfied ID representation\nbecause we use them to infer all sorts of properties for an element (namespaces,\nnaming files, etc).\n",
      "stereotypes": [
        "dogen::hashable",
        "Qualifiable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "simple",
          "type": "std::string",
          "documentation": "Simple (non-qualified) name of the assets element at this address.\n\nThe simple name must be unique for a given location.\n"
        },
        {
          "name": "location",
          "type": "location",
          "documentation": "Where the name is located in element space.\n"
        }
      ]
    },
    {
      "name": "meta_model::origin_types",
      "documentation": "What originated the model element.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "target",
          "type": "",
          "documentation": "The element is part of the target model.\n"
        },
        {
          "name": "proxy_reference",
          "type": "",
          "documentation": "The element was part of a reference model which is a proxy model.\n\nProxy models expose types from existing code such as STL, boost, etc,\nproviding a way to expose third party code into Dogen so that we\ncan make use of these types.\n"
        },
        {
          "name": "non_proxy_reference",
          "type": "",
          "documentation": "The element was part of a reference model which is regular dogen model.\n"
        },
        {
          "name": "not_yet_determined",
          "type": "",
          "documentation": "The origin of the element is not yet known\n"
        }
      ]
    },
    {
      "name": "meta_model::Stateful",
      "documentation": "Ability to have a state.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "all_attributes",
          "type": "std::list<attribute>",
          "documentation": "All attributes associated with this type.\n\nThis is a union of the following sets:\n\n@li the set of all attributes obtained via inheritance relationships;\n@li the set of all attributes obtained via instantiating object templates,\n    including their inheritance tree;\n@li the set of all attributes directly associated with the type (local).\n\nThe first and third sets are cached in this object. The second isn't as we do\nnot have a need for it.\n"
        },
        {
          "name": "local_attributes",
          "type": "std::list<attribute>",
          "documentation": "The set of all attributes directly associated with the type.\n"
        },
        {
          "name": "inherited_attributes",
          "type": "std::unordered_map<name, std::list<attribute>>",
          "documentation": "The set of all attributes obtained via inheritance, by parent name.\n\nNote that we are using name as a key by design (instead of id); it is required for\nformatting.\n"
        },
        {
          "name": "is_immutable",
          "type": "bool",
          "documentation": "If true, do not generate setters for the element's attributes.\n"
        },
        {
          "name": "is_fluent",
          "type": "bool",
          "documentation": "If true, generate fluent setters.\n"
        }
      ]
    },
    {
      "name": "meta_model::location",
      "documentation": "Identifies a hierarchy of containment within the asset space.\n\nElements exist at unique points within the asset space called @e\naddresses.  However, certain elements have the ability to contain\nother elements, creating in effect new dimensions in assets space. The\nlocation class keeps track of these dimensions. Note that the\nattributes of this class are hierarchical, i.e.  external modules\ncontain model modules and so forth. These attributes are best thought\nof as a single linked list, where segments of that linked list have\ndifferent meaning. However, because we care about these meanings, we\nimplemented the type with a number of linked lists, one per meaning.\n\nA location is not necessarily connected to modules, although these are\nthe main model elements that provide containment. For example, inner\nclasses are contained within classes; in assets terms it means a\nlocation should also have an \"object\" attribute to represent this\nrelationship.\n\nAlso, note that the location class itself encodes the address of the\nelement that owns that location; returning to the linked list idea,\nthe tail of the linked list is the name of the element, and the\nremaining linked list provides the location of the element.\n",
      "stereotypes": [
        "dogen::hashable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules",
          "type": "std::list<std::string>",
          "documentation": "All modules external to the model itself.\n\nIt is sometimes useful to create a model within a set of existing\nmodules. In this case, the model does not own the existing modules and\nthey are considered \"external\" to the model. This is useful, for\nexample, when declaring a model within a larger project such as @e\ndogen::assets. In this case, @e dogen is the external module.\n"
        },
        {
          "name": "model_modules",
          "type": "std::list<std::string>",
          "documentation": "Modules related to just the model itself.\n\nIt is only different from the model name if the model name is composite;\nthat is, if the model name has multiple fields separated by dots, e.g. @ a.b.\n"
        },
        {
          "name": "internal_modules",
          "type": "std::list<std::string>",
          "documentation": "Sub-modules within a model.\n"
        },
        {
          "name": "element",
          "type": "std::string",
          "documentation": "Name of the owning element, if any.\n\nFor coding elements which are located within other assets elements\nthat are not modules, such as attributes, inner classes, etc.\n"
        }
      ]
    },
    {
      "name": "meta_model::element",
      "documentation": "Represents a generic assets construct.\n\nAn element is anything of interest in a problem domain which needs to be\nexpressed in code generation. It covers both types (objects, enumerations, etc),\nmeta-types (object templates) and non-types (modules and backend specific entities).\n",
      "stereotypes": [
        "masd::visitable",
        "Element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "is_element_extension",
          "type": "bool",
          "documentation": "If true, this element extends another element with the same id.\n"
        },
        {
          "name": "artefact_properties",
          "type": "std::unordered_map<std::string, artefact_properties>"
        },
        {
          "name": "archetype_location_properties",
          "type": "std::unordered_map<std::string, local_archetype_location_properties>"
        },
        {
          "name": "decoration",
          "type": "boost::optional<decoration::element_properties>",
          "documentation": "If set, decoration to be added to each generated file.\n"
        }
      ]
    },
    {
      "name": "meta_model::model",
      "documentation": "Intermediate representation of a masd model.\n",
      "stereotypes": [
        "Nameable",
        "MetaNameable",
        "DeterminableOrigin"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "references",
          "type": "std::unordered_map<name,origin_types>",
          "documentation": "All other intermediate models that this model depends on, mapped to their\norigin.\n"
        },
        {
          "name": "leaves",
          "type": "std::unordered_set<name>",
          "documentation": "All leaf types in this model.\n\nLeaves are types concrete types which have a parent.\n"
        },
        {
          "name": "root_module",
          "type": "boost::shared_ptr<structural::module>"
        },
        {
          "name": "input_technical_space",
          "type": "technical_space",
          "documentation": "Technical space in which this model was written.\n"
        },
        {
          "name": "output_technical_spaces",
          "type": "std::list<technical_space>",
          "documentation": "Technical spaces into which to extract the final model.\n"
        },
        {
          "name": "orm_properties",
          "type": "boost::optional<orm::model_properties>"
        },
        {
          "name": "extraction_properties",
          "type": "extraction_properties"
        },
        {
          "name": "structural_elements",
          "type": "structural::element_repository",
          "documentation": "All structural elements in this model.\n"
        },
        {
          "name": "decoration_elements",
          "type": "decoration::element_repository",
          "documentation": "All decoration elements in this model.\n"
        },
        {
          "name": "variability_elements",
          "type": "variability::element_repository",
          "documentation": "All variability elements in this model.\n"
        },
        {
          "name": "mapping_elements",
          "type": "mapping::element_repository",
          "documentation": "Model elements related to element mapping.\n"
        },
        {
          "name": "templating_elements",
          "type": "templating::element_repository"
        }
      ]
    },
    {
      "name": "meta_model::elements_traversal",
      "stereotypes": [
        "dogen::handcrafted::typeable::header_only"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::TraversalVisitor",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::Visitable",
      "documentation": "The ability to handle visitation.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "base_visitor",
          "type": "boost::optional<name>",
          "documentation": "Base class of the visitor that visits the current element, if any.\n"
        },
        {
          "name": "derived_visitor",
          "type": "boost::optional<name>",
          "documentation": "Derived class of the visitor that visits the current element, if any.\n"
        },
        {
          "name": "is_visitation_root",
          "type": "bool"
        },
        {
          "name": "is_visitation_leaf",
          "type": "bool"
        }
      ]
    },
    {
      "name": "meta_model::Associatable",
      "documentation": "The element has the ability to associate itself with other elements.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "transparent_associations",
          "type": "std::list<name>",
          "documentation": "Elements that are involved in aggregation or composition relationships.\n"
        },
        {
          "name": "opaque_associations",
          "type": "std::list<name>",
          "documentation": "Elements that are involved in aggregation or composition relationships via\nindirection.\n\nThis is used to break cycles where required.\n"
        },
        {
          "name": "associative_container_keys",
          "type": "std::list<name>",
          "documentation": "Elements that are keys in an associative container.\n"
        }
      ]
    },
    {
      "name": "meta_model::Generalizable",
      "documentation": "The element has the ability to be part of a generalization relationship.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "is_parent",
          "type": "bool",
          "documentation": "True if this element is the parent of one or more elements, false otherwise.\n"
        },
        {
          "name": "is_child",
          "type": "bool",
          "documentation": "If true, the element has at least one parent.\n"
        },
        {
          "name": "is_leaf",
          "type": "bool",
          "documentation": "True if the type has a parent but no children.\n"
        },
        {
          "name": "is_final",
          "type": "bool",
          "documentation": "If true, the element cannot be inherited from.\n"
        },
        {
          "name": "is_abstract",
          "type": "bool",
          "documentation": "If true, the type is an abstract type.\n"
        },
        {
          "name": "in_inheritance_relationship",
          "type": "bool",
          "documentation": "True if the object is related to at least one other object as a parent or a child.\n"
        },
        {
          "name": "root_parents",
          "type": "std::list<name>",
          "documentation": "Top-most parents at the root of the inheritance hierarchy, if any.\n"
        },
        {
          "name": "parents",
          "type": "std::list<name>",
          "documentation": "Direct parent of this element, if any.\n"
        },
        {
          "name": "leaves",
          "type": "std::list<name>",
          "documentation": "Elements that are at the bottom of the inheritance tree.\n"
        }
      ]
    },
    {
      "name": "meta_model::Relatable",
      "parents": [
        "meta_model::Containable",
        "meta_model::Visitable",
        "meta_model::Associatable",
        "meta_model::Generalizable"
      ],
      "documentation": "Element has the ability to have relationships with other elements.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::Parameterisable",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "type_parameters",
          "type": "type_parameters"
        }
      ]
    },
    {
      "name": "meta_model::type_parameters",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "variable_number_of_parameters",
          "type": "bool"
        },
        {
          "name": "count",
          "type": "unsigned int"
        },
        {
          "name": "always_in_heap",
          "type": "bool"
        }
      ]
    },
    {
      "name": "traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::technical_space",
      "documentation": "Models need to declare upfront the technical space they will target.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "tagged_values": {
        "masd.generation.cpp.hash.enabled": "true"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "agnostic",
          "type": "",
          "documentation": "Abstract technical space which is mapped to concrete technical spaces.\n"
        },
        {
          "name": "cpp",
          "type": "",
          "documentation": "The C++ programming language.\n"
        },
        {
          "name": "csharp",
          "type": "",
          "documentation": "The C# programming language.\n"
        },
        {
          "name": "cmake",
          "type": "",
          "documentation": "CMake meta build system.\n"
        },
        {
          "name": "xml",
          "type": "",
          "documentation": "Extensible Markup Language.\n"
        },
        {
          "name": "odb",
          "type": "",
          "documentation": "ODB options.\n"
        },
        {
          "name": "sln",
          "type": "",
          "documentation": "Visual studio solution.\n"
        }
      ]
    },
    {
      "name": "meta_model::artefact_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "enabled",
          "type": "bool"
        },
        {
          "name": "overwrite",
          "type": "bool"
        },
        {
          "name": "file_path",
          "type": "boost::filesystem::path"
        },
        {
          "name": "formatting_style",
          "type": "formatting_styles"
        },
        {
          "name": "formatting_input",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "meta_model::formatting_styles",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stock",
          "type": ""
        },
        {
          "name": "wale",
          "type": ""
        },
        {
          "name": "stitch",
          "type": ""
        }
      ]
    },
    {
      "name": "transforms",
      "documentation": "Houses all of the transformations supported by assets.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::context",
      "documentation": "\nContext for all assets transformations.\n\nContains all of the external data required for the transformations\nto execute. It's not ideal to have a huge \"global\" class, with lots\nof unrelated state; however, over time, we found that a number of\narguments were being supplied across the call graph, resulting in a\nlot of repetitive code. The context gathers together all of these.\n",
      "stereotypes": [
        "dogen::typeable",
        "dogen::pretty_printable"
      ],
      "tagged_values": {
        "masd.generation.cpp.types.forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "feature_model",
          "type": "boost::shared_ptr<variability::meta_model::feature_model>"
        },
        {
          "name": "archetype_location_repository",
          "type": "boost::shared_ptr<archetypes::location_repository>"
        },
        {
          "name": "mapping_repository",
          "type": "boost::shared_ptr<helpers::mapping_set_repository>"
        },
        {
          "name": "tracer",
          "type": "boost::shared_ptr<tracing::tracer>"
        }
      ]
    },
    {
      "name": "transforms::pre_assembly_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::model_production_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::assembly_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::post_assembly_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::merge_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::modules_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::origin_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::technical_space_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::type_params_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::parsing_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::primitives_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::generalization_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::stereotypes_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::object_templates_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::global_module_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::orm_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::resolver_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::attributes_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::associations_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::transformation_error",
      "documentation": "An error occurred whilst applying a transformation.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::enumerations_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers",
      "fallback_element_type": "masd::module"
    },
    {
      "name": "helpers::decomposition_result",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "names",
          "type": "std::list<std::pair<std::string, meta_model::name>>"
        },
        {
          "name": "meta_names",
          "type": "std::list<std::pair<std::string, meta_model::name>>"
        },
        {
          "name": "name_trees",
          "type": "std::list<std::pair<std::string, meta_model::name_tree>>"
        },
        {
          "name": "injected_names",
          "type": "std::list<std::pair<std::string, meta_model::name>>"
        }
      ]
    },
    {
      "name": "helpers::decomposer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::post_assembly_validator",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::validation_error",
      "documentation": "An error occurred during validation.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::pre_assembly_validator",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::indices",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "objects_always_in_heap",
          "type": "std::unordered_set<std::string>"
        },
        {
          "name": "elements_referable_by_attributes",
          "type": "std::unordered_set<std::string>"
        },
        {
          "name": "primitive_underliers",
          "type": "std::unordered_set<std::string>"
        },
        {
          "name": "enumeration_underliers",
          "type": "std::unordered_set<std::string>"
        },
        {
          "name": "abstract_elements",
          "type": "std::unordered_set<std::string>"
        }
      ]
    },
    {
      "name": "helpers::indexing_error",
      "documentation": "A fatal error has occurred while indexing.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::indexer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::resolver",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::resolution_error",
      "documentation": "An error occurred while trying to resolve a type.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::mapping_error",
      "documentation": "An error has occurred while mapping element names.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::mapper",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::mapping_context",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "translations",
          "type": "std::unordered_map<std::string, meta_model::name>"
        },
        {
          "name": "erasures",
          "type": "std::unordered_set<std::string>"
        },
        {
          "name": "injections",
          "type": "std::unordered_map<std::string, meta_model::name>"
        }
      ]
    },
    {
      "name": "helpers::mapping_set",
      "documentation": "Consistent unit of mapping that can be used to translate a model from one technical\nspace to another.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "name",
          "type": "std::string"
        },
        {
          "name": "by_agnostic_id",
          "type": "std::unordered_map<meta_model::technical_space, std::unordered_map<std::string, meta_model::name>>"
        },
        {
          "name": "erasures_by_technical_space",
          "type": "std::unordered_map<meta_model::technical_space, std::unordered_set<std::string>>"
        }
      ]
    },
    {
      "name": "helpers::mapping_set_repository",
      "documentation": "Stores all available mapping sets.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "default_mapping_set",
          "type": "mapping_set"
        },
        {
          "name": "by_name",
          "type": "std::unordered_map<std::string, mapping_set>"
        }
      ]
    },
    {
      "name": "helpers::mappings_validator",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::mapping",
      "documentation": "Stores the mapping of a key (the element id) to its values, organised by technical\nspace.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "agnostic_id",
          "type": "std::string",
          "documentation": "Technical space agnostic ID of the element we're mapping from.\n"
        },
        {
          "name": "by_technical_space",
          "type": "std::unordered_map<meta_model::technical_space, mapping_value>",
          "documentation": "Values of the mapping, by technical space.\n"
        }
      ]
    },
    {
      "name": "helpers::mapping_value",
      "documentation": "Value of a mapping.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "mapping_action",
          "type": "mapping_actions"
        },
        {
          "name": "default_name",
          "type": "boost::optional<meta_model::name>"
        }
      ]
    },
    {
      "name": "helpers::mapping_actions",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "translate",
          "type": ""
        },
        {
          "name": "erase",
          "type": ""
        }
      ]
    },
    {
      "name": "transforms::extensible_mapping_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::printing_error",
      "documentation": "An error occurred whilst pretty printing.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::pretty_printer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::separators",
      "documentation": "Available separators to be used by the pretty printer.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "angle_brackets",
          "type": "",
          "documentation": "Enclose name elements in '<' and '>'.\n"
        },
        {
          "name": "double_colons",
          "type": "",
          "documentation": "Separate name elements with a '::'.\n"
        },
        {
          "name": "dots",
          "type": "",
          "documentation": "Separate name elements with a '.'.\n"
        }
      ]
    },
    {
      "name": "helpers::node",
      "documentation": "Node in a tree of names.\n\nTemporary data structure used to build trees of names.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "parent",
          "type": "boost::shared_ptr<node>",
          "documentation": "Parent in a tree.\n"
        },
        {
          "name": "data",
          "type": "meta_model::name",
          "documentation": "Current node.\n"
        },
        {
          "name": "children",
          "type": "std::list<boost::shared_ptr<node>>",
          "documentation": "Child nodes in a tree.\n"
        }
      ]
    },
    {
      "name": "helpers::string_processor",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::building_error",
      "documentation": "An error occurred whilst building.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::name_tree_builder",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "top_level_modules_",
          "type": "std::unordered_set<std::string>"
        },
        {
          "name": "model_location_",
          "type": "meta_model::location"
        },
        {
          "name": "names",
          "type": "std::list<std::string>"
        },
        {
          "name": "root",
          "type": "std::shared_ptr<node>"
        },
        {
          "name": "current",
          "type": "std::shared_ptr<node>"
        }
      ]
    },
    {
      "name": "helpers::legacy_name_tree_parser",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "modules",
          "type": "std::unordered_set<std::string>"
        },
        {
          "name": "external_modules",
          "type": "std::list<std::string>"
        },
        {
          "name": "model_name",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "helpers::new_name_tree_parser",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::parsing_error",
      "documentation": "A fatal error has occurred while parsing.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::fully_qualified_representation_builder",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::name_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::name_builder",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "name_",
          "type": "meta_model::name"
        }
      ]
    },
    {
      "name": "helpers::name_flattener",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::meta_naming_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::meta_name_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::location_builder",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "location_",
          "type": "meta_model::location"
        }
      ]
    },
    {
      "name": "meta_model::local_archetype_location_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "facet_enabled",
          "type": "boost::optional<bool>"
        },
        {
          "name": "archetype_enabled",
          "type": "boost::optional<bool>"
        },
        {
          "name": "facet_overwrite",
          "type": "boost::optional<bool>"
        },
        {
          "name": "archetype_overwrite",
          "type": "boost::optional<bool>"
        }
      ]
    },
    {
      "name": "meta_model::static_stereotypes",
      "documentation": "Lists all stereotypes defined in the masd UML profile.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "object",
          "type": ""
        },
        {
          "name": "object_template",
          "type": ""
        },
        {
          "name": "exception",
          "type": ""
        },
        {
          "name": "primitive",
          "type": ""
        },
        {
          "name": "enumeration",
          "type": ""
        },
        {
          "name": "module",
          "type": ""
        },
        {
          "name": "builtin",
          "type": ""
        },
        {
          "name": "visitable",
          "type": ""
        },
        {
          "name": "fluent",
          "type": ""
        },
        {
          "name": "immutable",
          "type": ""
        },
        {
          "name": "orm_object",
          "type": ""
        },
        {
          "name": "orm_value",
          "type": ""
        },
        {
          "name": "modeline_group",
          "type": ""
        },
        {
          "name": "modeline",
          "type": ""
        },
        {
          "name": "generation_marker",
          "type": ""
        },
        {
          "name": "licence",
          "type": ""
        },
        {
          "name": "variability_profile_template",
          "type": ""
        },
        {
          "name": "variability_feature_bundle",
          "type": ""
        },
        {
          "name": "variability_feature_template_initializer",
          "type": ""
        },
        {
          "name": "mapping_fixed_mappable",
          "type": ""
        },
        {
          "name": "mapping_extensible_mappable",
          "type": ""
        },
        {
          "name": "templating_logic_less_template",
          "type": ""
        }
      ]
    },
    {
      "name": "meta_model::extraction_properties",
      "documentation": "Properties related to extraction.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "cpp_headers_output_directory",
          "type": "boost::filesystem::path",
          "documentation": "Directory in which to place C++ header files. Must be a relative path.\n"
        },
        {
          "name": "enabled_backends",
          "type": "std::unordered_set<std::string>"
        },
        {
          "name": "enable_backend_directories",
          "type": "bool"
        }
      ]
    },
    {
      "name": "transforms::extraction_properties_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::model_set",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "target",
          "type": "model"
        },
        {
          "name": "references",
          "type": "std::list<model>"
        },
        {
          "name": "fixed_mappings",
          "type": "std::unordered_map<std::string, std::string>",
          "documentation": "Maps a fixed mappable name, using the scope notation, to its destination.\n"
        }
      ]
    },
    {
      "name": "transforms::modelines_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::fully_qualified_representation",
      "documentation": "Fully qualified representation for a assets identifier such as a name or name tree.\n",
      "stereotypes": [
        "dogen::hashable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "dot",
          "type": "std::string",
          "documentation": "Qualified identifier using \".\" as the separator.\n"
        },
        {
          "name": "colon",
          "type": "std::string",
          "documentation": "Qualified identifier using \"::\" as the separator.\n"
        },
        {
          "name": "identifiable",
          "type": "std::string",
          "documentation": "Representation of the identifier that can usable as an identifier on all of the\nsupported technical spaces, using the entire name structure.\n"
        }
      ]
    },
    {
      "name": "meta_model::Qualifiable",
      "documentation": "The model entity can have a qualified representation.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "qualified",
          "type": "fully_qualified_representation"
        }
      ]
    },
    {
      "name": "transforms::containment_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::Container",
      "documentation": "Has the ability to contain other elements.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "contains",
          "type": "std::unordered_set<std::string>"
        }
      ]
    },
    {
      "name": "transforms::variability_feature_bundle_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::decoration",
      "documentation": "Houses all of the meta-modeling elements and\nproperties related to decorations.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "meta_model::decoration::licence",
      "documentation": "Represents legal licence for software projects.\n",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "short_form",
          "type": "std::string",
          "documentation": "Short version of the licence, for inclusion in project files.\n"
        },
        {
          "name": "long_form",
          "type": "std::string",
          "documentation": "Long form of the licence text, suitable for generation of LICENCE files.\n"
        }
      ]
    },
    {
      "name": "meta_model::meta_element",
      "stereotypes": [
        "masd::variability::profile_template"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "element",
        "masd.variability.labels": "assets::meta_element"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.generalization.parent",
          "type": "",
          "value": "dogen::assets::meta_model::element",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance"
          }
        }
      ]
    },
    {
      "name": "meta_model::decoration::modeline_group",
      "documentation": "Group of modelines, logically associated.\n\nFor example, one may choose to have a set of modelines for @e emacs , or for\n@e vi, etc.\n",
      "stereotypes": [
        "assets::meta_element",
        "Container"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "modelines",
          "type": "std::list<boost::shared_ptr<modeline>>",
          "documentation": "Modelines that make up the group.\n"
        }
      ]
    },
    {
      "name": "meta_model::decoration::modeline",
      "documentation": "Groups all the fields representing editor variables for emacs, vi, etc.\n\nA field is a key-value pair (KVP), where name is the first element and its value\nthe second.\n\nExample: -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n\nIn this particular case, both prefix and postfix are @e -*-; @e mode is the first\nfield name and its value is @e c++; the KVP separator is @e : and the field\nseparator is @e ;.\n",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "editor",
          "type": "editor",
          "documentation": "The modeline will use the syntax for this editor.\n"
        },
        {
          "name": "location",
          "type": "modeline_location",
          "documentation": "Where to place the modeline.\n"
        },
        {
          "name": "fields",
          "type": "std::list<modeline_field>",
          "documentation": "List of all the parameters in the preamble, in order of appearence.\n"
        },
        {
          "name": "technical_space",
          "type": "technical_space",
          "documentation": "Technical space that this modeline targets.\n"
        }
      ]
    },
    {
      "name": "meta_model::decoration::editor",
      "documentation": "Supported editors for modelines.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "emacs",
          "type": "",
          "documentation": "The emacs editor.\n"
        },
        {
          "name": "vi",
          "type": "",
          "documentation": "The generic vi editor.\n"
        },
        {
          "name": "vim",
          "type": "",
          "documentation": "The vi-like editor vim.\n"
        },
        {
          "name": "ex",
          "type": "",
          "documentation": "The old ex editor.\n"
        }
      ]
    },
    {
      "name": "meta_model::decoration::modeline_field",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "name",
          "type": "std::string",
          "documentation": "Name of the field.\n"
        },
        {
          "name": "value",
          "type": "std::string",
          "documentation": "Value of the field.\n"
        }
      ]
    },
    {
      "name": "meta_model::decoration::modeline_location",
      "documentation": "Location in the file to place the modeline.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "top",
          "type": "",
          "documentation": "Very first line in file.\n"
        },
        {
          "name": "bottom",
          "type": "",
          "documentation": "Very last line in file.\n"
        }
      ]
    },
    {
      "name": "meta_model::decoration::generation_marker",
      "documentation": "Properties of the \"generation marker\" to add to generated files.\n\nThese are also known as \"location strings\".\n",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "add_date_time",
          "type": "bool",
          "documentation": "If true, the location strings will include the date and time of generation.\n\nThis is not recomended for models that are generated often as it will trigger\nrebuilds for no good reason.\n"
        },
        {
          "name": "add_dogen_version",
          "type": "bool",
          "documentation": "If true, adds the version of dogen used to generate the code.\n"
        },
        {
          "name": "add_model_to_text_transform_details",
          "type": "bool",
          "documentation": "If true, adds information about the transform used to generate the file.\n"
        },
        {
          "name": "add_warning",
          "type": "bool",
          "documentation": "If true, warns users that the file was code-generated.\n"
        },
        {
          "name": "message",
          "type": "std::string",
          "documentation": "Custom message to add to each generated file.\n"
        }
      ]
    },
    {
      "name": "meta_model::variability",
      "documentation": "Houses all of the meta-modeling elements related\nto variability.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "meta_model::variability::profile_template",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "labels",
          "type": "std::unordered_set<std::string>"
        },
        {
          "name": "entries",
          "type": "std::list<profile_template_entry>"
        },
        {
          "name": "parents",
          "type": "std::list<name>",
          "documentation": "Parents of this profile template.\n"
        }
      ]
    },
    {
      "name": "meta_model::variability::profile_template_entry",
      "stereotypes": [
        "Documentable",
        "Configurable",
        "Nameable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "key",
          "type": "std::string"
        },
        {
          "name": "value",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "meta_model::variability::feature_bundle",
      "stereotypes": [
        "assets::meta_element",
        "Associatable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "feature_templates",
          "type": "std::list<feature_template>"
        },
        {
          "name": "generate_static_configuration",
          "type": "bool",
          "documentation": "If true, the code generator will output a class to represent the static configuration.\n"
        }
      ]
    },
    {
      "name": "meta_model::variability::feature_template",
      "stereotypes": [
        "Documentable",
        "Configurable",
        "Nameable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "key",
          "type": "std::string"
        },
        {
          "name": "identifiable_key",
          "type": "std::string",
          "documentation": "Post-processed key, suitable for use as an identifier.\n"
        },
        {
          "name": "unparsed_type",
          "type": "std::string"
        },
        {
          "name": "value",
          "type": "std::string"
        },
        {
          "name": "location",
          "type": "archetypes::location"
        },
        {
          "name": "value_type",
          "type": "variability::meta_model::value_type"
        },
        {
          "name": "binding_point",
          "type": "variability::meta_model::binding_point"
        },
        {
          "name": "template_kind",
          "type": "variability::meta_model::template_kind"
        },
        {
          "name": "mapped_type",
          "type": "std::string"
        },
        {
          "name": "parsed_type",
          "type": "name_tree"
        }
      ]
    },
    {
      "name": "meta_model::variability::feature_template_initializer",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "bundles",
          "type": "std::list<name>"
        }
      ]
    },
    {
      "name": "meta_model::orm",
      "documentation": "Houses all of the properties related to ORM\nsupport in Dogen.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "meta_model::orm::model_properties",
      "stereotypes": [
        "Schemable",
        "Caseable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "database_systems",
          "type": "std::vector<database_system>"
        }
      ]
    },
    {
      "name": "meta_model::orm::database_system",
      "stereotypes": [
        "masd::enumeration",
        "dogen::hashable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "mysql",
          "type": ""
        },
        {
          "name": "postgresql",
          "type": ""
        },
        {
          "name": "oracle",
          "type": ""
        },
        {
          "name": "sql_server",
          "type": ""
        },
        {
          "name": "sqlite",
          "type": ""
        }
      ]
    },
    {
      "name": "meta_model::orm::letter_case",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "upper_case",
          "type": ""
        },
        {
          "name": "lower_case",
          "type": ""
        }
      ]
    },
    {
      "name": "meta_model::orm::object_properties",
      "stereotypes": [
        "Schemable",
        "Caseable",
        "Mappeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "table_name",
          "type": "std::string",
          "documentation": "Name of the table to map this element to.\n"
        },
        {
          "name": "is_value",
          "type": "bool",
          "documentation": "If true, treat this object as a value type (e.g. simple type) rather than as an object.\n"
        },
        {
          "name": "has_primary_key",
          "type": "bool",
          "documentation": "True if the object has an attribute marked as a primary key, false otherwise.\n"
        }
      ]
    },
    {
      "name": "meta_model::orm::primitive_properties",
      "stereotypes": [
        "Schemable",
        "Caseable",
        "Mappeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::orm::module_properties",
      "stereotypes": [
        "Schemable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::orm::attribute_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "column_name",
          "type": "std::string",
          "documentation": "Name of the column to use for this attribute. If populated, will override the attribute name.\n"
        },
        {
          "name": "is_primary_key",
          "type": "bool",
          "documentation": "If true, this attribute is a primary key for the relation.\n"
        },
        {
          "name": "is_nullable",
          "type": "boost::optional<bool>",
          "documentation": "If true, the attribute can be NULL.\n"
        },
        {
          "name": "type_overrides",
          "type": "std::unordered_map<database_system, std::string>",
          "documentation": "Override the default type for this attribute for a given database system.\n"
        },
        {
          "name": "is_composite",
          "type": "bool",
          "documentation": "If true, the value of this attribute is a composite value.\n"
        }
      ]
    },
    {
      "name": "meta_model::orm::Schemable",
      "documentation": "Model element can belong to a relational database schema.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "schema_name",
          "type": "std::string",
          "documentation": "Name of the database schema in which to place this element.\n"
        }
      ]
    },
    {
      "name": "meta_model::orm::Caseable",
      "documentation": "The model element supports configuration related to casing.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "letter_case",
          "type": "boost::optional<letter_case>",
          "documentation": "What case to use for the database identifiers.\n"
        }
      ]
    },
    {
      "name": "meta_model::orm::Mappeable",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "generate_mapping",
          "type": "bool",
          "documentation": "If true, object-relational mapping will be generated for this element.\n"
        }
      ]
    },
    {
      "name": "meta_model::decoration::element_properties",
      "documentation": "Decoration for this element.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "preamble",
          "type": "std::string",
          "documentation": "Preamble for all artefacts created from this element.\n\nThe preamble is located at the top of an artefact and includes elements such as a\nmodeline, licence,  copyrights, etc.\n"
        },
        {
          "name": "postamble",
          "type": "std::string",
          "documentation": "Postamble for all artefacts created from this element.\n\nThe postamble is located at the bottom of an artefact and includes elements such\nas a modeline.\n"
        }
      ]
    },
    {
      "name": "meta_model::structural",
      "documentation": "Houses all of the meta-modeling elements related\nto structural modeling.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "meta_model::structural::object_template",
      "documentation": "Represents a structural template for masd objects.\n",
      "stereotypes": [
        "assets::meta_element",
        "Stateful"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "parents",
          "type": "std::list<name>",
          "documentation": "List of object templates that this object template inherits from, if any.\n"
        },
        {
          "name": "is_child",
          "type": "bool",
          "documentation": "If true, the object template has at least one parent.\n"
        }
      ]
    },
    {
      "name": "meta_model::structural::object",
      "documentation": "Representation of the class notion in the OOP paradigm.\n\nThe @e object is equivalent to a meta-class, but we decided against this\nname because all elements should also have the prefix meta - after all, assets\nis ameta-model. Since the word class cannot be used in c++ to name types, we\ndecided instead to use the word object.\n",
      "stereotypes": [
        "assets::meta_element",
        "Stateful",
        "Relatable",
        "Parameterisable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "is_associative_container",
          "type": "bool",
          "documentation": "Object is an associative container.\n"
        },
        {
          "name": "object_templates",
          "type": "std::list<name>",
          "documentation": "All object templates associated with this object.\n"
        },
        {
          "name": "provides_opaqueness",
          "type": "bool",
          "documentation": "If true, this type provides opaqueness to any type parameters it may have.\n"
        },
        {
          "name": "can_be_primitive_underlier",
          "type": "bool",
          "documentation": "If true, this object can be the underlying element of a primitive.\n"
        },
        {
          "name": "orm_properties",
          "type": "boost::optional<dogen::assets::meta_model::orm::object_properties>"
        }
      ]
    },
    {
      "name": "meta_model::structural::builtin",
      "documentation": "Represents a value type that is built-in at the hardware level.\n",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "is_default_enumeration_type",
          "type": "bool",
          "documentation": "If true, this built-in is the default type to be used on enumerations.\n"
        },
        {
          "name": "is_floating_point",
          "type": "bool",
          "documentation": "If true, this built-in represents a floating point number.\n"
        },
        {
          "name": "can_be_enumeration_underlier",
          "type": "bool",
          "documentation": "If true, this element can be the underlying element of an enumeration.\n"
        },
        {
          "name": "can_be_primitive_underlier",
          "type": "bool",
          "documentation": "If true, this built-in can be the underlying element of a primitive.\n"
        }
      ]
    },
    {
      "name": "meta_model::structural::exception",
      "documentation": "Represents an exception which can be thrown.\n",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::structural::visitor",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "visits",
          "type": "std::list<name>",
          "documentation": "Elements that are visitable by the visitor.\n"
        },
        {
          "name": "parent",
          "type": "boost::optional<name>"
        }
      ]
    },
    {
      "name": "meta_model::structural::primitive",
      "documentation": "Defines an element created by the user to wrap another element, most likely a built-in.\n",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "is_nullable",
          "type": "bool",
          "documentation": "If true, this element can be null (empty).\n"
        },
        {
          "name": "value_attribute",
          "type": "attribute",
          "documentation": "Attribute that represents the value of the primitive.\n"
        },
        {
          "name": "use_type_aliasing",
          "type": "bool",
          "documentation": "If set to true, and if the owning technical space supports it, use type aliasing.\n"
        },
        {
          "name": "is_immutable",
          "type": "bool",
          "documentation": "If true, do not generate modifiable operations.\n"
        },
        {
          "name": "orm_properties",
          "type": "boost::optional<dogen::assets::meta_model::orm::primitive_properties>"
        }
      ]
    },
    {
      "name": "meta_model::structural::module",
      "documentation": "Container for other assets elements.\n\nAggregates a group of logically related elements into a unit.\n",
      "stereotypes": [
        "assets::meta_element",
        "Container"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "is_root",
          "type": "bool",
          "documentation": "If true, this module is thee root module of the model.\n"
        },
        {
          "name": "is_global_module",
          "type": "bool",
          "documentation": "If true, this module is the pseudo module that models the global namespace.\n"
        },
        {
          "name": "orm_properties",
          "type": "boost::optional<dogen::assets::meta_model::orm::module_properties>"
        }
      ]
    },
    {
      "name": "meta_model::structural::enumeration",
      "documentation": "Defines a bounded set of logically related values for a built-in type\nor a string.\n",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "underlying_element",
          "type": "name",
          "documentation": "Underlying element of each instance of the enumeration.\n"
        },
        {
          "name": "enumerators",
          "type": "std::vector<enumerator>",
          "documentation": "Enumerators for this enumeration.\n"
        },
        {
          "name": "use_implementation_defined_underlying_element",
          "type": "bool",
          "documentation": "If true, we will use the implementation specific default enumeration type.\n"
        },
        {
          "name": "use_implementation_defined_enumerator_values",
          "type": "bool",
          "documentation": "If true, we will rely on compiler generated enumeration values.\n"
        },
        {
          "name": "add_invalid_enumerator",
          "type": "bool",
          "documentation": "If true, an enumerator for \"invalid\" will be added.\n"
        }
      ]
    },
    {
      "name": "meta_model::structural::enumerator",
      "documentation": "One of a set of valid values that an enumeration can assume.\n\nThe enumerator defines an element in the domain of the enumeration.\n",
      "stereotypes": [
        "Documentable",
        "Nameable",
        "Configurable",
        "Stereotypable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "value",
          "type": "std::string",
          "documentation": "Value for the enumerator.\n\nIt must be castable to instance of the type defined in the enumeration.\n"
        }
      ]
    },
    {
      "name": "meta_model::decoration::element_repository",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "modeline_groups",
          "type": "std::unordered_map<std::string, boost::shared_ptr<modeline_group>>"
        },
        {
          "name": "modelines",
          "type": "std::unordered_map<std::string, boost::shared_ptr<modeline>>"
        },
        {
          "name": "licences",
          "type": "std::unordered_map<std::string, boost::shared_ptr<licence>>"
        },
        {
          "name": "generation_markers",
          "type": "std::unordered_map<std::string, boost::shared_ptr<generation_marker>>"
        }
      ]
    },
    {
      "name": "meta_model::variability::element_repository",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "profile_templates",
          "type": "std::unordered_map<std::string, boost::shared_ptr<profile_template>>"
        },
        {
          "name": "feature_bundles",
          "type": "std::unordered_map<std::string, boost::shared_ptr<feature_bundle>>"
        },
        {
          "name": "feature_template_initializer",
          "type": "boost::shared_ptr<feature_template_initializer>"
        }
      ]
    },
    {
      "name": "meta_model::structural::element_repository",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "modules",
          "type": "std::unordered_map<std::string, boost::shared_ptr<module>>"
        },
        {
          "name": "object_templates",
          "type": "std::unordered_map<std::string, boost::shared_ptr<object_template>>"
        },
        {
          "name": "builtins",
          "type": "std::unordered_map<std::string, boost::shared_ptr<builtin>>"
        },
        {
          "name": "enumerations",
          "type": "std::unordered_map<std::string, boost::shared_ptr<enumeration>>"
        },
        {
          "name": "primitives",
          "type": "std::unordered_map<std::string, boost::shared_ptr<primitive>>"
        },
        {
          "name": "objects",
          "type": "std::unordered_map<std::string, boost::shared_ptr<object>>"
        },
        {
          "name": "exceptions",
          "type": "std::unordered_map<std::string, boost::shared_ptr<exception>>"
        },
        {
          "name": "visitors",
          "type": "std::unordered_map<std::string, boost::shared_ptr<visitor>>"
        }
      ]
    },
    {
      "name": "features",
      "documentation": "Defines all features used by the assets model.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "features::type_parameters",
      "documentation": "Parameters to configure generic types.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.type_parameters.variable_number_of_parameters",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.type_parameters.variable_number_of_parameters"
          }
        },
        {
          "name": "masd.type_parameters.count",
          "type": "masd::variability::number",
          "value": "\"0\"",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.type_parameters.count"
          }
        },
        {
          "name": "masd.type_parameters.always_in_heap",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.type_parameters.always_in_heap"
          }
        }
      ]
    },
    {
      "name": "features::initializer",
      "stereotypes": [
        "masd::variability::feature_template_initializer"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "features::enumeration",
      "documentation": "Parameters related to enumerations.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.enumeration.use_implementation_defined_underlying_element",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, it uses the default implementation defined underlying element for the\ntechnical space targeted.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.enumeration.use_implementation_defined_underlying_element"
          }
        },
        {
          "name": "masd.enumeration.underlying_element",
          "type": "masd::variability::text",
          "documentation": "Name of the underlying element to use for the enumeration.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.enumeration.underlying_element"
          }
        },
        {
          "name": "masd.enumeration.use_implementation_defined_enumerator_values",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, uses the enumeration values supplied by the underlying technical space.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.enumeration.use_implementation_defined_enumerator_values"
          }
        }
      ]
    },
    {
      "name": "features::enumerator",
      "documentation": "Parameters related to enumerators.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.enumeration.add_invalid_enumerator",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, adds an enumerator to represent an invalid choice.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.enumeration.add_invalid_enumerator"
          }
        },
        {
          "name": "masd.enumerator.value",
          "type": "masd::variability::text",
          "documentation": "Value to use for this enumerator. Must be unique for an enumeration.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.enumerator.value"
          }
        }
      ]
    },
    {
      "name": "features::generalization",
      "documentation": "Features related to the generalization relationship.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.generalization.is_final",
          "type": "masd::variability::boolean",
          "documentation": "Whether to mark a type as final or not.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.generalization.is_final"
          }
        },
        {
          "name": "masd.generalization.parent",
          "type": "masd::variability::text",
          "documentation": "Name of the parent of the current element.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.generalization.parent"
          }
        }
      ]
    },
    {
      "name": "features::origin",
      "documentation": "Features related to the origin of the model.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.injection.is_proxy_model",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, sets the origin of the model to \"proxy model\".\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "global",
            "masd.variability.qualified_name": "masd.injection.is_proxy_model"
          }
        }
      ]
    },
    {
      "name": "features::output_technical_space",
      "documentation": "Features related to the output technical space.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.extraction.output_technical_space",
          "type": "masd::variability::text_collection",
          "documentation": "Set of output technical spaces that this model targets.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "global",
            "masd.variability.qualified_name": "masd.extraction.output_technical_space"
          }
        }
      ]
    },
    {
      "name": "features::primitive",
      "documentation": "Features related to primitive elements.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.primitive.underlying_element",
          "type": "masd::variability::text",
          "documentation": "Name of the underlying element to use for the primitive.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.primitive.underlying_element"
          }
        },
        {
          "name": "masd.primitive.is_nullable",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, the primitive can be null.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.primitive.is_nullable"
          }
        },
        {
          "name": "masd.primitive.use_type_aliasing",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, use type aliasing to implement the primitive if the technical space supports\nit.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.primitive.use_type_aliasing"
          }
        }
      ]
    },
    {
      "name": "features::orm",
      "documentation": "Features related to ORM support.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.orm.database_system",
          "type": "masd::variability::text_collection",
          "documentation": "Database system to target for ORM support.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "global",
            "masd.variability.qualified_name": "masd.orm.database_system"
          }
        },
        {
          "name": "masd.orm.table_name",
          "type": "masd::variability::text",
          "documentation": "Name of the database table for this element.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.orm.table_name"
          }
        },
        {
          "name": "masd.orm.schema_name",
          "type": "masd::variability::text",
          "documentation": "Name of the database schema for this modeling element.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "any",
            "masd.variability.qualified_name": "masd.orm.schema_name"
          }
        },
        {
          "name": "masd.orm.is_primary_key",
          "type": "masd::variability::boolean",
          "documentation": "If true, this property will be used for the primary key.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.orm.is_primary_key"
          }
        },
        {
          "name": "masd.orm.column_name",
          "type": "masd::variability::text",
          "documentation": "Overrides the name of the column name for the database table.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.orm.column_name"
          }
        },
        {
          "name": "masd.orm.is_nullable",
          "type": "masd::variability::boolean",
          "documentation": "If true, the column can be null.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.orm.is_nullable"
          }
        },
        {
          "name": "masd.orm.is_composite",
          "type": "masd::variability::boolean",
          "documentation": "If true, the primary key is a composite key.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.orm.is_composite"
          }
        },
        {
          "name": "masd.orm.letter_case",
          "type": "masd::variability::text",
          "documentation": "Determines the casing to use for identifiers.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "global",
            "masd.variability.qualified_name": "masd.orm.letter_case"
          }
        },
        {
          "name": "masd.orm.type_override",
          "type": "masd::variability::text_collection",
          "documentation": "Overrides to use for the relational type, for a given database system.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.orm.type_override"
          }
        }
      ]
    },
    {
      "name": "features::decoration_modeline",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.decoration.modeline.editor",
          "type": "masd::variability::text",
          "documentation": "Editor to use in this modeline.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "any",
            "masd.variability.qualified_name": "masd.decoration.modeline.editor"
          }
        },
        {
          "name": "masd.decoration.modeline.location",
          "type": "masd::variability::text",
          "documentation": "Where to place the modeline.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "any",
            "masd.variability.qualified_name": "masd.decoration.modeline.location"
          }
        },
        {
          "name": "masd.decoration.modeline.technical_space",
          "type": "masd::variability::text",
          "documentation": "Technical space targeted by the modeline.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "any",
            "masd.variability.qualified_name": "masd.decoration.modeline.technical_space"
          }
        }
      ]
    },
    {
      "name": "features::variability_templates",
      "documentation": "Features related to the processing of variability for feature and profile templates.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.variability.binding_point",
          "type": "masd::variability::text",
          "documentation": "Where does this configuration bind.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "any",
            "masd.variability.qualified_name": "masd.variability.binding_point"
          }
        },
        {
          "name": "masd.variability.labels",
          "type": "masd::variability::text_collection",
          "documentation": "Labels to apply to this profile. These are used for binding, via stereotypes.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.variability.labels"
          }
        },
        {
          "name": "masd.variability.archetype_location.kernel",
          "type": "masd::variability::text",
          "documentation": "Kernel for a facet or profile template.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.variability.archetype_location.kernel"
          }
        },
        {
          "name": "masd.variability.archetype_location.backend",
          "type": "masd::variability::text",
          "documentation": "Kernel for a facet or profile template.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.variability.archetype_location.backend"
          }
        },
        {
          "name": "masd.variability.archetype_location.facet",
          "type": "masd::variability::text",
          "documentation": "Facet for a facet or profile template.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.variability.archetype_location.facet"
          }
        },
        {
          "name": "masd.variability.archetype_location.archetype",
          "type": "masd::variability::text",
          "documentation": "Archetype for a facet or profile template.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.variability.archetype_location.archetype"
          }
        },
        {
          "name": "masd.variability.template_kind",
          "type": "masd::variability::text",
          "documentation": "Template kind for a facet or profile template.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.variability.template_kind"
          }
        },
        {
          "name": "masd.variability.value",
          "type": "masd::variability::text_collection",
          "documentation": "Value for a facet or profile template.\n\nValue as meta-data should be used only for collections, for single values prefer\nthe default value field if available.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.variability.value"
          }
        },
        {
          "name": "masd.variability.qualified_name",
          "type": "masd::variability::text",
          "documentation": "Qualified name for this feature template.\n\nShould only be supplied for instance templates.\n",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "property",
            "masd.variability.qualified_name": "masd.variability.qualified_name"
          }
        },
        {
          "name": "masd.variability.generate_static_configuration",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "element",
            "masd.variability.qualified_name": "masd.variability.generate_static_configuration"
          }
        }
      ]
    },
    {
      "name": "meta_model::mapping",
      "documentation": "Meta-model elements related to mapping domains.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "meta_model::mapping::extensible_mappable",
      "documentation": "A mappable meta-model element for the general purpose of mapping.\n\nMappables can be used to create a Platform Independent Model (PIM), which is then\nmapped to concrete types to form a Platform Specific Model (PSM). Users can\nextend the mappings as required.\n",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "destinations",
          "type": "std::list<destination>",
          "documentation": "All the destinations that this source has been mapped to.\n"
        }
      ]
    },
    {
      "name": "meta_model::mapping::element_repository",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "extensible_mappables",
          "type": "std::unordered_map<std::string, boost::shared_ptr<extensible_mappable>>"
        },
        {
          "name": "fixed_mappables",
          "type": "std::unordered_map<std::string, boost::shared_ptr<fixed_mappable>>"
        }
      ]
    },
    {
      "name": "meta_model::mapping::destination",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "name",
          "type": "name"
        },
        {
          "name": "technical_space",
          "type": "technical_space"
        }
      ]
    },
    {
      "name": "features::mapping",
      "documentation": "Meta-data related to element mapping.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.mapping.target",
          "type": "masd::variability::text",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "any",
            "masd.variability.qualified_name": "masd.mapping.target"
          }
        },
        {
          "name": "masd.mapping.destination",
          "type": "masd::variability::text",
          "tagged_values": {
            "masd.variability.archetype_location.kernel": "masd",
            "masd.variability.template_kind": "instance",
            "masd.variability.binding_point": "any",
            "masd.variability.qualified_name": "masd.mapping.destination"
          }
        }
      ]
    },
    {
      "name": "transforms::mapping_source_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::mapping::fixed_mappable",
      "documentation": "A mappable meta-model element for a special purpose.\n\nAt present, the only fixed mappables used by Dogen are related to the mapping of\nvariability types.\n",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "destination",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "meta_model::templating",
      "documentation": "Meta-model elements related to templating .\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "meta_model::templating::logic_less_template",
      "documentation": "Represents a logic-less template.\n\nAt present the system only supports wale templates.\n",
      "stereotypes": [
        "assets::meta_element"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "meta_model::templating::element_repository",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "logic_less_templates",
          "type": "std::unordered_map<std::string, boost::shared_ptr<logic_less_template>>"
        }
      ]
    },
    {
      "name": "transforms::mapping_elements_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    }
  ]
}
