{
  "documentation": "Provides the C++ backend for the default physical meta-model.\n",
  "tagged_values": {
    "masd.injection.dia.comment": "true",
    "masd.injection.model_modules": "dogen.text.cpp",
    "masd.injection.reference": "cpp.builtins",
    "masd.injection.reference": "cpp.boost",
    "masd.injection.reference": "cpp.std",
    "masd.injection.reference": "dogen",
    "masd.injection.reference": "dogen.variability",
    "masd.injection.reference": "dogen.tracing",
    "masd.injection.reference": "dogen.logical",
    "masd.injection.reference": "dogen.text",
    "masd.injection.reference": "masd",
    "masd.injection.reference": "masd.variability",
    "masd.injection.reference": "dogen.profiles",
    "masd.injection.input_technical_space": "cpp",
    "masd.variability.profile": "dogen.profiles.base.default_profile"
  },
  "elements": [
    {
      "name": "transforms",
      "documentation": "Formatters for the C++ model.\n\nTakes types in the C++ model and creates a file\nrepresentation of these types according to the\ngrammar of the C++ technical space.\n",
      "stereotypes": [
        "masd::physical::backend"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true",
        "masd.physical.backend_name": "cpp",
        "masd.physical.major_technical_space": "cpp",
        "masd.label.test": "lbl"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::types",
      "documentation": "Formatters for the types facet of the\nC++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true",
        "masd.label.test": "some_label"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::types::class_header",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::object;\n    const auto& o(assistant::as<object>(e));\n    auto builder(f.make());\n\n    // algorithm: domain headers need it for the swap function.\n    builder.add(inclusion_constants::std::algorithm());\n\n    const auto io_arch(transforms::io::traits::class_header_archetype_qn());\n    const bool in_inheritance(o.is_parent() || o.is_child());\n    const bool io_enabled(builder.is_enabled(o.name(), io_arch));\n    const bool requires_io(io_enabled && in_inheritance);\n\n    const auto ios(inclusion_constants::std::iosfwd());\n    if (requires_io)\n        builder.add(ios);\n\n    using ser = transforms::serialization::traits;\n    const auto ser_fwd_arch(ser::class_forward_declarations_archetype_qn());\n    builder.add(o.name(), ser_fwd_arch);\n\n    const auto carch(traits::canonical_archetype());\n    builder.add(o.transparent_associations(), carch);\n\n    const auto fwd_arch(traits::class_forward_declarations_archetype_qn());\n    builder.add(o.opaque_associations(), fwd_arch);\n\n    const auto self_arch(class_header_transform::static_archetype().meta_name().qualified());\n    builder.add(o.parents(), self_arch);\n\n    using hash = transforms::hash::traits;\n    const auto hash_carch(hash::traits::canonical_archetype());\n    builder.add(o.associative_container_keys(), hash_carch);\n\n    if (o.is_visitation_root()) {\n        /*\n         * On the header files of the visitation root we only care\n         * about the base visitor; as such we can get away with a\n         * forward declaration. For the visitation leaves, since we\n         * must include the parent we do not need any additional\n         * includes.\n         */\n        const auto visitor_fwd_arch(traits::visitor_forward_declarations_archetype_qn());\n        builder.add(*o.base_visitor(), visitor_fwd_arch);\n    }\n    return builder.build();\n}\n\nvoid class_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(o.documentation());\n            if (o.parents().empty()) {\n#>\nclass <#= sn #> <#= ast.make_final_keyword_text(o) #>{\n<#+\n            } else {\n                const auto& pn(o.parents().front());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\nclass <#= sn #> <#= ast.make_final_keyword_text(o) #>: public <#= pqn #> {\n<#+\n            }\n\n            /*\n             * Compiler generated constructors and destructors.\n             */\n            if (ast.supports_defaulted_functions()) {\n#>\npublic:\n<#+\n                if (!ast.requires_manual_default_constructor())\n#>\n    <#= sn #>() = default;\n    <#= sn #>(const <#= sn #>&) = default;\n<#+\n                if (!ast.requires_manual_move_constructor())\n#>\n    <#= sn #>(<#= sn #>&&) = default;\n<#+\n                if (!o.in_inheritance_relationship())\n#>\n    ~<#= sn #>() = default;\n<#+\n                if (o.is_immutable())\n#>\n    <#= sn #>& operator=(const <#= sn #>&) = delete;\n<#+\n                else if (o.all_attributes().empty())\n#>\n    <#= sn #>& operator=(const <#= sn #>&) = default;\n\n<#+\n            }\n\n            /*\n             * Manually generated default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\npublic:\n    <#= sn #>();\n\n<#+\n            }\n\n            /*\n             * Manually generated destructor.\n             *\n             * according to MEC++, item 33, base classes should always be\n             * abstract. this avoids all sorts of tricky problems with\n             * assignment and swap.\n             *\n             * incidentally, this also fixes some strange clang errors:\n             * undefined reference to `vtable.\n             */\n            if (o.is_parent()) {\n#>\n    virtual ~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> = 0;\n\n<#+\n            } else if (o.is_child() != 0) {\n#>\n    virtual ~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> { }\n\n<#+\n            }\n\n            /*\n             * Manually generated move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\npublic:\n    <#= sn #>(<#= sn #>&& rhs);\n\n<#+\n            }\n\n            /*\n             * Manually generated complete constructor.\n             */\n            if (!o.all_attributes().empty()) {\n#>\npublic:\n<#+\n                const auto attr_count(o.all_attributes().size());\n                if (attr_count == 1) {\n                    const auto attr(*o.all_attributes().begin());\n#>\n    explicit <#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>);\n<#+\n                } else {\n#>\n    <#= sn #>(\n<#+\n                    utility::formatters::sequence_formatter sf(attr_count);\n                    sf.postfix_configuration().last(\");\");\n                    for (const auto& attr : o.all_attributes()) {\n#>\n        const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #><#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n                }\n#>\n\n<#+\n            }\n\n            /*\n             * Serialisaton Friends\n             */\n            if (ast.is_serialization_enabled()) {\n#>\nprivate:\n    template<typename Archive>\n    friend void boost::serialization::save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\n    template<typename Archive>\n    friend void boost::serialization::load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n<#+\n            }\n\n            /*\n             * Visitation.\n             */\n            if (o.is_visitation_root()) {\n                const auto vsn(o.base_visitor()->simple());\n#>\npublic:\n    virtual void accept(const <#= vsn #>& v) const = 0;\n    virtual void accept(<#= vsn #>& v) const = 0;\n    virtual void accept(const <#= vsn #>& v) = 0;\n    virtual void accept(<#= vsn #>& v) = 0;\n\n<#+\n            } else if (o.is_visitation_leaf()) {\n                std::string bvn;\n                std::string rpn;\n                if (o.derived_visitor()) {\n                    bvn = ast.get_qualified_name(*o.base_visitor());\n                    rpn = ast.get_qualified_name(o.root_parents().front());\n                } else {\n                    bvn = o.base_visitor()->simple();\n                    rpn = o.root_parents().front().simple();\n                }\n#>\npublic:\n    using <#= rpn #>::accept;\n\n    virtual void accept(const <#= bvn #>& v) const<#= ast.make_override_keyword_text() #>;\n    virtual void accept(<#= bvn #>& v) const<#= ast.make_override_keyword_text() #>;\n    virtual void accept(const <#= bvn #>& v)<#= ast.make_override_keyword_text() #>;\n    virtual void accept(<#= bvn #>& v)<#= ast.make_override_keyword_text() #>;\n<#+\n            }\n\n            /*\n             * Streaming\n             */\n            if (ast.is_io_enabled()) {\n                if (o.is_parent()) {\n#>\npublic:\n    virtual void to_stream(std::ostream& s) const;\n\n<#+\n                } else if (!o.parents().empty()) {\n#>\npublic:\n    void to_stream(std::ostream& s) const<#= ast.make_override_keyword_text() #>;\n\n<#+\n                }\n            }\n\n            /*\n             * Getters and setters.\n             */\n            if (!o.local_attributes().empty()) {\n#>\npublic:\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    ast.comment_start_method_group(attr.documentation(), !attr.is_immutable());\n\n                    if (attr.parsed_type().is_current_simple_type()) {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #>() const;\n<#+\n                        if (attr.is_immutable()) {\n#>\n\n<#+\n                            continue;\n                        }\n#>\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n<#+\n                    } else {\n#>\n    const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= attr.name().simple() #>() const;\n<#+\n                        if (attr.is_immutable()) {\n#>\n\n<#+\n                            continue;\n                        }\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>();\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n<#+\n                        if (ast.supports_move_operator()) {\n#>\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v);\n<#+\n                        }\n                    }\n                    ast.comment_end_method_group(attr.documentation(), !attr.is_immutable());\n#>\n\n<#+\n                }\n            }\n\n            /*\n             * Equality.\n             *\n             * Equality is only public in leaf classes - MEC++-33.\n             */\n            if (o.is_parent()) {\n#>\nprotected:\n    bool compare(const <#= sn #>& rhs) const;\n<#+\n            } else {\n#>\npublic:\n    bool operator==(const <#= sn #>& rhs) const;\n    bool operator!=(const <#= sn #>& rhs) const {\n        return !this->operator==(rhs);\n    }\n\n<#+\n            }\n\n            if (o.in_inheritance_relationship()) {\n#>\npublic:\n<#+\n                if (o.is_parent() && !o.is_child()) {\n#>\n    virtual bool equals(const <#= sn #>& other) const = 0;\n<#+\n                } else if (o.is_parent()) {\n                    const auto rpn(o.root_parents().front());\n#>\n    virtual bool equals(const <#= ast.get_qualified_name(rpn) #>& other) const = 0;\n<#+\n                } else if (!o.root_parents().empty()) {\n                    const auto rpn(o.root_parents().front());\n#>\n    bool equals(const <#= ast.get_qualified_name(rpn) #>& other) const<#= ast.make_override_keyword_text() #>;\n<#+\n                }\n#>\n\n<#+\n             }\n\n            /*\n             * Swap and assignment.\n             *\n             * Swap and assignment are only public in leaf classes - MEC++-33\n             */\n            if ((!o.all_attributes().empty() || o.is_parent()) && !o.is_immutable()) {\n                if (o.is_parent()) {\n#>\nprotected:\n<#+\n                } else {\n#>\npublic:\n<#+\n                }\n#>\n    void swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #>;\n<#+\n                if (!o.is_parent() && !o.is_immutable()) {\n#>\n    <#= sn #>& operator=(<#= sn #> other);\n<#+\n                }\n#>\n\n<#+\n            }\n\n            /*\n             * Member variables.\n             */\n            if (!o.local_attributes().empty()) {\n#>\nprivate:\n<#+\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.member_variable_name() #>;\n<#+\n                }\n            }\n#>\n};\n\n<#+\n            /*\n             * Destructor implementation.\n             */\n            if (o.is_parent()) {\n#>\ninline <#= sn #>::~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> { }\n\n<#+\n            }\n\n            /*\n             * Global equality operator implementation.\n             */\n            if (o.is_parent()) {\n#>\ninline bool operator==(const <#= sn #>& lhs, const <#= sn #>& rhs) {\n    return lhs.equals(rhs);\n}\n\n<#+\n            }\n        }\n\n        if (!o.all_attributes().empty() && !o.is_parent() && !o.is_immutable()) {\n#>\n\nnamespace std {\n\ntemplate<>\ninline void swap(\n    <#= qn #>& lhs,\n    <#= qn #>& rhs) {\n    lhs.swap(rhs);\n}\n\n}\n<#+\n        }\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::model_to_text_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable::header_only"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "model_to_text_cpp_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash",
      "documentation": "Formatters for the hash facet of the\nC++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::hash::class_header",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/formattables/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    auto builder(f.make());\n    builder.add(inclusion_constants::std::functional());\n    builder.add(e.name(), types::traits::canonical_archetype());\n    return builder.build();\n}\n\nvoid class_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"FIXME\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    const auto sn(o.name().simple());\n    const auto qn(ast.get_qualified_name(o.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nstruct <#= sn #>_hasher {\npublic:\n    static std::size_t hash(const <#= sn #>& v);\n};\n\n<#+\n        } // snf\n#>\n\nnamespace std {\n\ntemplate<>\nstruct hash<<#= qn #>> {\npublic:\n    size_t operator()(const <#= qn #>& v) const {\n        return <#= qn #>_hasher::hash(v);\n    }\n};\n\n}\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::hash::class_implementation",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    const auto& o(assistant::as<logical::entities::structural::object>(e));\n    const auto carch(traits::canonical_archetype());\n    auto builder(f.make());\n    builder.add(o.name(), carch);\n\n    builder.add(o.transparent_associations(), carch);\n    builder.add(o.opaque_associations(), carch);\n    builder.add(o.parents(), carch);\n\n    return builder.build();\n}\n\nvoid class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"FIXME\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\n\nnamespace {\n\n<#+\n        if (!o.local_attributes().empty() || !o.parents().empty()) {\n#>\ntemplate <typename HashableType>\ninline void combine(std::size_t& seed, const HashableType& value) {\n    std::hash<HashableType> hasher;\n    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n<#+\n        }\n\n        ast.add_helper_methods(o.name().qualified().dot());\n#>\n\n}\n\n<#+\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(o.name().simple());\n            const auto qn(ast.get_qualified_name(o.name()));\n\n#>\n\nstd::size_t <#= sn #>_hasher::hash(const <#= sn #>&<#= ((o.local_attributes().empty() && o.parents().empty()) ? \"\" : \" v\") #>) {\n    std::size_t seed(0);\n<#+\n            if (!o.parents().empty()) {\n#>\n\n<#+\n                const auto& pn(o.parents().front());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\n    combine(seed, dynamic_cast<const <#= pqn #>&>(v));\n<#+\n            }\n\n            if (!o.local_attributes().empty()) {\n#>\n\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    if (ast.requires_hashing_helper_method(attr))\n#>\n    combine(seed, hash_<#= attr.parsed_type().qualified().identifiable() #>(v.<#= attr.name().simple() #>()));\n<#+\n                    else\n#>\n    combine(seed, v.<#= attr.name().simple() #>());\n<#+\n                }\n\n                if (o.local_attributes().size() > 1)\n#>\n\n<#+\n            }\n#>\n    return seed;\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::exception_header",
      "documentation": "Generates header files for exceptions.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.exception",
        "masd.wale.kvp.class.simple_name": "exception_header_transform",
        "masd.wale.kvp.archetype.simple_name": "exception_header",
        "masd.wale.kvp.meta_element": "exception",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/exception.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/exception_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/exception_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> exception_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& /*e*/) const {\n    auto builder(f.make());\n    builder.add(inclusion_constants::std::string());\n    builder.add(inclusion_constants::boost::exception::info());\n    return builder.build();\n}\n\nvoid exception_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"exception header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::exception>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(ye.documentation());\n#>\nclass <#= ye.name().simple() #> : public virtual std::exception, public virtual boost::exception {\npublic:\n<#+\n            if (ast.is_cpp_standard_98()) {\n#>\n    <#= ye.name().simple() #>() {}\n    ~<#= ye.name().simple() #>() {}\n<#+\n            } else {\n#>\n    <#= ye.name().simple() #>() = default;\n    ~<#= ye.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> = default;\n<#+\n            }\n#>\n\npublic:\n    explicit <#= ye.name().simple() #>(const std::string& message) : message_(message) { }\n\npublic:\n<#+\n            if (ast.is_cpp_standard_98()) {\n                // Note: we are using BOOST_NOEXCEPT here by design. The problem is\n                // users may include this header in a C++ 98 project or in a C++ > 11 project;\n                // and we need to have different behaviours. Depending on this inclusion.\n                // If we do not, we will cause compilation errors when including C++ 98 code\n                // on a C++ 11 project. This is because the standard library will have noexcept\n                // but we won't (as we were generated for C++ 98), so we'd be weakening the exception\n                // guarantees. By using the boost macro we will do the right thing hopefully.\n                // And since we already need boost for exception, we should be ok.\n#>\n    const char* what() const BOOST_NOEXCEPT { return(message_.c_str()); }\n<#+\n            } else {\n#>\n    const char* what() const<#= ast.make_noexcept_keyword_text() #> { return(message_.c_str()); }\n<#+\n            }\n#>\n\nprivate:\n    const std::string message_;\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::enumeration;\n    const auto& en(assistant::as<enumeration>(e));\n    auto builder(f.make());\n    const auto arch(traits::canonical_archetype());\n    builder.add(en.underlying_element(), arch);\n    return builder.build();\n}\n\nvoid enum_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(e.documentation());\n            if (ast.is_cpp_standard_98()) {\n#>\nenum <#= ye.name().simple() #> {\n<#+\n            } else {\n                if (ye.use_implementation_defined_underlying_element())\n#>\nenum class <#= ye.name().simple() #> {\n<#+\n                else\n#>\nenum class <#= ye.name().simple() #> : <#= ast.get_qualified_name(ye.underlying_element()) #> {\n<#+\n            }\n\n            utility::formatters::sequence_formatter sf(ye.enumerators().size());\n            for (const auto& en : ye.enumerators()) {\n                if (ye.use_implementation_defined_enumerator_values())\n#>\n    <#= en.name().simple() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                else\n#>\n    <#= en.name().simple() #> = <#= en.value() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                sf.next();\n            }\n#>\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::namespace_header",
      "documentation": "Generates header files for namespaces.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.module",
        "masd.wale.kvp.class.simple_name": "namespace_header_transform",
        "masd.wale.kvp.archetype.simple_name": "namespace_header",
        "masd.wale.kvp.meta_element": "module",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/module.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/namespace_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/namespace_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> namespace_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid namespace_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"namespace header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& m(ast.as<logical::entities::structural::module>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            if (ast.requires_nested_namespaces()) {\n                ast.comment(m.documentation());\n                const auto ns(ast.make_namespaces(e.name(),\n                        false/*detect_model_name*/));\n                auto snf(ast.make_scoped_namespace_formatter(ns));\n            } else {\n                const auto ns(ast.make_namespaces(m.name()));\n                auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n                ast.comment(m.documentation());\n#>\nnamespace <#= m.name().simple() #> {\n}\n\n<#+\n            }\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::visitor_header",
      "documentation": "Generates header files for visitors.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visitor",
        "masd.wale.kvp.class.simple_name": "visitor_header_transform",
        "masd.wale.kvp.archetype.simple_name": "visitor_header",
        "masd.wale.kvp.meta_element": "visitor",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/visitor.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/visitor_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/visitor_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> visitor_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::structural::visitor;\n    const auto& v(assistant::as<visitor>(e));\n    auto builder(f.make());\n    builder.add(v.visits(), traits::class_forward_declarations_archetype_qn());\n\n    if (v.parent())\n        builder.add(*v.parent(), traits::visitor_header_archetype_qn());\n\n    return builder.build();\n}\n\nvoid visitor_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"visitor header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& v(ast.as<logical::entities::structural::visitor>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(v.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(v.documentation());\n            if (!v.parent())\n#>\nclass <#= v.name().simple() #> {\n<#+\n            else {\n                const auto& pn(*v.parent());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\nclass <#= v.name().simple() #> : public <#= pqn #> {\n<#+\n            }\n#>\npublic:\n    virtual ~<#= v.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> = 0;\n\npublic:\n<#+\n            if (v.parent()) {\n                const auto& pn(*v.parent());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\n    using <#= pqn #>::visit;\n\n<#+\n            }\n\n            bool is_first(true);\n            for (const auto& t : v.visits()) {\n                if (!is_first)\n#>\n\n<#+\n                const auto qn(ast.get_qualified_name(t));\n                const auto doc(\"Accept visits for type \" + qn);\n                ast.comment_start_method_group(doc);\n#>\n    virtual void visit(const <#= qn #>&) const { }\n    virtual void visit(const <#= qn #>&) { }\n    virtual void visit(<#= qn #>&) const { }\n    virtual void visit(<#= qn #>&) { }\n<#+\n                ast.comment_end_method_group(doc);\n                is_first = false;\n            }\n#>\n};\n\ninline <#= v.name().simple() #>::~<#= v.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> { }\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::class_implementation",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::structural::object;\n    const auto& o(assistant::as<object>(e));\n    auto builder(f.make());\n\n    const auto ch_arch(traits::class_header_archetype_qn());\n    builder.add(o.name(), ch_arch);\n    builder.add(o.opaque_associations(), ch_arch);\n\n    const auto io_arch(transforms::io::traits::class_header_archetype_qn());\n    const bool in_inheritance(o.is_parent() || o.is_child());\n    const bool io_enabled(builder.is_enabled(o.name(), io_arch));\n    const bool requires_io(io_enabled && in_inheritance);\n\n    if (!requires_io)\n        return builder.build();\n\n    const auto os(inclusion_constants::std::ostream());\n    builder.add(os);\n\n    const auto io_carch(io::traits::canonical_archetype());\n    builder.add(o.transparent_associations(), io_carch);\n    builder.add(o.opaque_associations(), io_carch);\n    builder.add(o.parents(), io_carch);\n\n    if (o.is_visitation_leaf()) {\n        /*\n         * Only leaves have a visitation implementation. Note that we\n         * don't bother including the base if we are already including\n         * the derived visitor.\n         */\n        const auto v_arch(traits::visitor_header_archetype_qn());\n        if (o.derived_visitor())\n            builder.add(*o.derived_visitor(), v_arch);\n        else\n            builder.add(*o.base_visitor(), v_arch);\n    }\n\n    return builder.build();\n}\n\nvoid class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(o.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n\n            /*\n             * Default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\n\n<#= sn #>::<#= sn #>()\n<#+\n                // FIXME: this was just too hard to hack with a sequence.\n                // FIXME: indentation is all off too.\n                std::ostringstream ss;\n                bool is_first(true);\n                bool found(false);\n                for (const auto& attr : o.local_attributes()) {\n                    if (!attr.parsed_type().is_current_simple_type())\n                        continue;\n\n                    found = true;\n                    if (!is_first)\n                        ss << \",\" << std::endl << \"      \";\n\n                    ss << attr.member_variable_name()\n                       << \"(static_cast<\" << ast.get_qualified_name(attr.parsed_type())\n                       << \">(0))\";\n\n                    is_first = false;\n                }\n                ss << \" { }\";\n                const std::string out(ss.str());\n#>\n    <#= (found ? \": \" : \"\") #><#= out #>\n<#+\n            }\n\n            /*\n             * Move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\n\n<#= sn #>::<#= sn #>(<#= sn #>&& rhs)\n<#+\n                const auto size(o.parents().size() + o.local_attributes().size());\n\n                utility::formatters::sequence_formatter sf(size);\n                sf.prefix_configuration().first(\": \").not_first(\"  \");\n                sf.postfix_configuration().last(\" { }\");\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= sf.prefix() #><#= pqn #>(\n        std::forward<<#= pqn #>>(rhs))<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= sf.prefix() #><#= attr.member_variable_name() #>(std::move(rhs.<#= attr.member_variable_name() #>))<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n            }\n\n            /*\n             * Complete constructor.\n             */\n            if (!o.all_attributes().empty()) {\n                const auto attr_count(o.all_attributes().size());\n                if (attr_count == 1) {\n                     const auto attr(*o.all_attributes().begin());\n#>\n\n<#= sn #>::<#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>)\n<#+\n                } else {\n#>\n\n<#= sn #>::<#= sn #>(\n<#+\n\n                    utility::formatters::sequence_formatter sf(attr_count);\n                    sf.postfix_configuration().last(\")\");\n                    for (const auto& attr : o.all_attributes()) {\n#>\n    const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #><#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n                }\n\n                auto sequence_size(o.local_attributes().size() + o.parents().size());\n                for (const auto& pair : o.inherited_attributes()) {\n                    const auto& pattrs(pair.second);\n                    sequence_size += (pattrs.size() > 1 ? pattrs.size() : 0);\n                }\n\n                utility::formatters::sequence_formatter sf(sequence_size);\n                sf.postfix_configuration().last(\" { }\");\n                sf.prefix_configuration().first(\": \").not_first(\"  \");\n                for (const auto& pair : o.inherited_attributes()) {\n                    const auto pqn(ast.get_qualified_name(pair.first));\n                    const auto& pattrs(pair.second);\n                    if (pattrs.size() <= 1) {\n#>\n    <#= sf.prefix() #><#= pqn #>(<#= (pattrs.empty() ? \"\" : pattrs.front().name().simple()) #>)<#= sf.postfix() #>\n<#+\n                        sf.next();\n                    } else {\n#>\n    <#= sf.prefix() #><#= pqn #>(<#= sf.postfix(true/*skip*/) #>\n<#+\n                        sf.next();\n                        utility::formatters::sequence_formatter sf2(pattrs.size());\n                        sf2.element_separator(\"\");\n\n                        sf2.prefix_configuration().first(\"  \").not_first(\"  \");\n                        sf2.postfix_configuration().last(\")\");\n                        for (const auto& attr : pattrs) {\n#>\n    <#= sf2.prefix() #><#= attr.name().simple() #><#= sf2.postfix() #><#= sf.postfix() #>\n<#+\n                            sf2.next();\n                            sf.next();\n                        }\n                    }\n                }\n\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= sf.prefix() #><#= attr.member_variable_name() #>(<#= attr.name().simple() #>)<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n            }\n\n            /*\n             * Visitation.\n             */\n            if (o.is_visitation_leaf()) {\n                std::string bvn;\n                std::string dvn;\n                std::string rpn;\n                if (o.derived_visitor()) {\n                    bvn = ast.get_qualified_name(*o.base_visitor());\n                    dvn = o.derived_visitor()->simple();\n                    rpn = ast.get_qualified_name(o.root_parents().front());\n                } else {\n                    bvn = o.base_visitor()->simple();\n                    rpn = o.root_parents().front().simple();\n                }\n#>\n\nvoid <#= sn #>::accept(const <#= bvn #>& v) const {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef const <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n}\n\nvoid <#= sn #>::accept(<#= bvn #>& v) const {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n    }\n\nvoid <#= sn #>::accept(const <#= bvn #>& v) {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef const <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n}\n\nvoid <#= sn #>::accept(<#= bvn #>& v) {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n}\n<#+\n            }\n\n            /*\n             * Streaming\n             */\n            if (ast.is_io_enabled()) {\n                if (o.in_inheritance_relationship()) {\n#>\n\nvoid <#= sn #>::to_stream(std::ostream& s) const {\n<#+\n                io::inserter_implementation_helper(ast, o, true/*inside_class*/);\n#>\n}\n<#+\n                }\n            }\n\n            /*\n             * Swap\n             */\n            if (!o.is_immutable() && (!o.all_attributes().empty() || o.is_parent())) {\n                const bool empty(o.all_attributes().empty() && o.parents().empty());\n#>\n\nvoid <#= sn #>::swap(<#= sn #>&<#= (empty ? \"\" : \" other\") #>)<#= ast.make_noexcept_keyword_text() #> {\n<#+\n               if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= pqn #>::swap(other);\n\n<#+\n\n               }\n\n               if (!o.local_attributes().empty()) {\n#>\n    using std::swap;\n<#+\n                   for (const auto& attr : o.local_attributes())\n#>\n    swap(<#= attr.member_variable_name() #>, other.<#= attr.member_variable_name() #>);\n<#+\n               }\n#>\n}\n<#+\n            }\n\n            /*\n             * Equals method\n             */\n            // FIXME: looking at root_parent as a hack due to service leafs not\n            // FIXME: being processed atm.\n            if (!o.is_parent() && !o.parents().empty() && !o.root_parents().empty()) {\n                const auto rpn(o.root_parents().front());\n#>\n\nbool <#= sn #>::equals(const <#= ast.get_qualified_name(rpn) #>& other) const {\n    const <#= sn #>* const p(dynamic_cast<const <#= sn #>* const>(&other));\n    if (!p) return false;\n    return *this == *p;\n}\n<#+\n            }\n\n            /*\n             * Equals operator\n             */\n            std::string method_name;\n            if (o.is_parent())\n                method_name = \"compare\";\n            else\n                method_name = \"operator==\";\n#>\n\nbool <#= sn #>::<#= method_name #>(const <#= sn #>& <#= (o.all_attributes().empty() ? \"/*rhs*/\" : \"rhs\") #>) const {\n<#+\n\n            if (o.all_attributes().empty())\n#>\n    return true;\n<#+\n            else {\n                utility::formatters::sequence_formatter sf(o.parents().size());\n                sf.element_separator(\"\");\n                sf.prefix_configuration().first(\"return \").not_first(\"    \");\n                sf.postfix_configuration().not_last(\" &&\");\n                if (o.local_attributes().empty())\n                    sf.postfix_configuration().last(\";\");\n                else\n                    sf.postfix_configuration().last(\" &&\");\n\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= sf.prefix() #><#= pqn #>::compare(rhs)<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n                sf.reset(o.local_attributes().size());\n                sf.element_separator(\"\");\n                if (o.parents().empty())\n                   sf.prefix_configuration().first(\"return \");\n                else\n                   sf.prefix_configuration().first(\"    \");\n                sf.prefix_configuration().not_first(\"    \");\n                sf.postfix_configuration().last(\";\").not_last(\" &&\");\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= sf.prefix() #><#= attr.member_variable_name() #> == rhs.<#= attr.member_variable_name() #><#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n            }\n#>\n}\n<#+\n\n            /*\n             * Assignment\n             */\n            if (!o.all_attributes().empty() && !o.is_parent() && !o.is_immutable()) {\n#>\n\n<#= sn #>& <#= sn #>::operator=(<#= sn #> other) {\n    using std::swap;\n    swap(*this, other);\n    return *this;\n}\n<#+\n            }\n\n            /*\n             * Getters and setters\n             */\n             for (const auto& attr : o.local_attributes()) {\n                 if (attr.parsed_type().is_current_simple_type()) {\n#>\n\n<#= ast.get_qualified_name(attr.parsed_type()) #> <#= sn #>::<#= attr.name().simple() #>() const {\n    return <#= attr.member_variable_name() #>;\n}\n<#+\n                    if (!o.is_immutable()) {\n#>\n\n<#= (attr.is_fluent() ? sn + \"&\" : \"void\") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #> v) {\n    <#= attr.member_variable_name() #> = v;\n<#+\n                        if (attr.is_fluent()) {\n#>\n    return *this;\n<#+\n                        }\n#>\n}\n<#+\n                    }\n                } else {\n#>\n\nconst <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() const {\n    return <#= attr.member_variable_name() #>;\n}\n<#+\n                    if (!o.is_immutable()) {\n#>\n\n<#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() {\n    return <#= attr.member_variable_name() #>;\n}\n\n<#= (o.is_fluent() ? sn + \"&\" : \"void\") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>& v) {\n    <#= attr.member_variable_name() #> = v;\n<#+\n                        if (o.is_fluent()) {\n#>\n    return *this;\n<#+\n                        }\n#>\n}\n<#+\n                        if (ast.supports_move_operator()) {\n#>\n\n<#= (o.is_fluent() ? sn + \"&\" : \"void\") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v) {\n    <#= attr.member_variable_name() #> = std::move(v);\n<#+\n                            if (o.is_fluent()) {\n#>\n    return *this;\n<#+\n                            }\n#>\n}\n<#+\n                        }\n                    }\n                }\n            }\n#>\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::hash::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n    builder.add(inclusion_constants::std::functional());\n    builder.add(e.name(), types::traits::enum_header_archetype_qn());\n    return builder.build();\n}\n\nvoid enum_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\n\nnamespace std {\n\ntemplate<>\nstruct hash<<#= ast.get_qualified_name(ye.name()) #>> {\npublic:\n    size_t operator()(const <#= ast.get_qualified_name(ye.name()) #>& v) const {\n        return std::hash<unsigned int>()(static_cast<unsigned int>(v));\n    }\n};\n\n}\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::io",
      "documentation": "Formatters for the io facet of the\nC++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::io::class_header",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n    builder.add(inclusion_constants::std::iosfwd());\n\n    using traits = transforms::types::traits;\n    builder.add(e.name(), traits::canonical_archetype());\n\n    return builder.build();\n}\n\nvoid class_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto qn(ast.get_qualified_name(o.name()));\n#>\n\nstd::ostream&\noperator<<(std::ostream& s,\n     const <#= qn #>& v);\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::io::class_implementation",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    const auto& o(assistant::as<logical::entities::structural::object>(e));\n    auto builder(f.make());\n    const auto ch_fn(traits::class_header_archetype_qn());\n    builder.add(o.name(), ch_fn);\n\n    builder.add(o.opaque_associations(), ch_fn);\n\n    const auto io_carch(transforms::io::traits::canonical_archetype());\n    const auto self_fn(class_implementation_transform::static_archetype().meta_name().qualified());\n    const bool io_enabled(builder.is_enabled(o.name(), self_fn));\n\n    if (!io_enabled)\n        return builder.build();\n\n    const auto os(inclusion_constants::std::ostream());\n    builder.add(os);\n    builder.add(o.transparent_associations(), io_carch);\n    builder.add(o.opaque_associations(), io_carch);\n    builder.add(o.parents(), io_carch);\n\n    return builder.build();\n}\n\nvoid class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(o.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(o.name().simple());\n            const auto qn(ast.get_qualified_name(o.name()));\n            const bool no_arg(!o.is_parent() && o.parents().empty() &&\n                o.local_attributes().empty());\n#>\n\nstd::ostream& operator<<(std::ostream& s, const <#= sn #>&<#= (no_arg ? \"\" : \" v\")  #>) {\n<#+\n            if (o.is_parent() || !o.parents().empty()) {\n#>\n    v.to_stream(s);\n    return(s);\n<#+\n            } else\n                io::inserter_implementation_helper(ast, o, false/*inside_class*/);\n#>\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::io::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n\n    builder.add(inclusion_constants::std::iosfwd());\n\n    const auto eh_fn(types::traits::enum_header_archetype_qn());\n    builder.add(e.name(), eh_fn);\n    return builder.build();\n}\n\nvoid enum_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nstd::ostream& operator<<(std::ostream& s, const <#= ye.name().simple() #>& v);\n\n<#+\n         } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::io::enum_implementation",
      "documentation": "Generates implementation files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/enum_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/enum_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n\n    builder.add(inclusion_constants::std::ostream());\n    builder.add(inclusion_constants::std::stdexcept());\n    builder.add(inclusion_constants::std::string());\n\n    const auto eh_fn(traits::enum_header_archetype_qn());\n    builder.add(e.name(), eh_fn);\n    return builder.build();\n}\n\nvoid enum_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nstd::ostream& operator<<(std::ostream& s, const <#= ye.name().simple() #>& v) {\n    s << \"{ \" << \"\\\"__type__\\\": \" << \"\\\"<#= ye.name().simple() #>\\\", \" << \"\\\"value\\\": \";\n\n    std::string attr;\n    switch (v) {\n<#+\n            for (const auto& en : ye.enumerators()) {\n                if (ast.is_cpp_standard_98())\n#>\n    case <#= en.name().simple() #>:\n<#+\n                else\n#>\n    case <#= ye.name().simple() #>::<#= en.name().simple() #>:\n        attr = \"\\\"<#= en.name().simple() #>\\\"\";\n        break;\n<#+\n            }\n#>\n    default:\n        throw std::invalid_argument(\"Invalid value for <#= ye.name().simple() #>\");\n    }\n    s << attr << \" }\";\n    return s;\n}\n\n<#+\n         } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::serialization",
      "documentation": "Formatters for the boost serialisation\nfacet of the C++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::serialization::class_header",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::object;\n    const auto& o(assistant::as<object>(e));\n    auto builder(f.make());\n    builder.add(o.name(), types::traits::class_header_archetype_qn());\n\n    using ic = inclusion_constants;\n    builder.add(ic::boost::serialization::split_free());\n\n    if (o.is_parent())\n        builder.add(ic::boost::serialization::assume_abstract());\n\n    if (!o.is_parent() && o.is_child())\n        builder.add(ic::boost::type_traits::is_virtual_base_of());\n\n    return builder.build();\n}\n\nvoid class_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n\n        if (!o.is_parent() && !o.parents().empty()) {\n            const auto& pn(o.parents().front());\n            const auto pqn(ast.get_qualified_name(pn));\n#>\nnamespace boost {\n\ntemplate<>struct\nis_virtual_base_of<\n    <#= pqn #>,\n    <#= qn #>\n> : public mpl::true_ {};\n\n}\n<#+\n        }\n#>\n\nBOOST_SERIALIZATION_SPLIT_FREE(<#= qn #>)\n<#+\n        if (o.is_parent()) {\n#>\nBOOST_SERIALIZATION_ASSUME_ABSTRACT(<#= qn #>)\n\n<#+\n        }\n#>\nnamespace boost {\nnamespace serialization {\n\ntemplate<typename Archive>\nvoid save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\ntemplate<typename Archive>\nvoid load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::serialization::class_implementation",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    const auto& o(assistant::as<logical::entities::structural::object>(e));\n    auto builder(f.make());\n\n    const auto ch_fn(traits::class_header_archetype_qn());\n    builder.add(o.name(), ch_fn);\n\n    using ic = inclusion_constants;\n    builder.add(ic::boost::archive::text_iarchive());\n    builder.add(ic::boost::archive::text_oarchive());\n    builder.add(ic::boost::archive::binary_iarchive());\n    builder.add(ic::boost::archive::binary_oarchive());\n    builder.add(ic::boost::archive::polymorphic_iarchive());\n    builder.add(ic::boost::archive::polymorphic_oarchive());\n\n    // XML serialisation\n    builder.add(ic::boost::serialization::nvp());\n    builder.add(ic::boost::archive::xml_iarchive());\n    builder.add(ic::boost::archive::xml_oarchive());\n\n    const auto carch(traits::canonical_archetype());\n    builder.add(o.transparent_associations(), carch);\n    builder.add(o.opaque_associations(), carch);\n    builder.add(o.parents(), carch);\n    builder.add(o.leaves(), carch);\n\n    return builder.build();\n}\n\nvoid class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(o.name().qualified().dot());\n\n        const auto qn(ast.get_qualified_name(o.name()));\n        const bool has_attributes(!o.local_attributes().empty());\n        const bool has_parent(!o.parents().empty());\n        const bool has_attributes_or_parent(has_attributes || has_parent);\n\n        if (o.is_parent() || !o.parents().empty()) {\n#>\n\nBOOST_CLASS_TRACKING(\n    <#= qn #>,\n    boost::serialization::track_selectively)\n<#+\n        }\n#>\n\nnamespace boost {\nnamespace serialization {\n<#+\n\n        /*\n         * Save function\n         */\n#>\n\ntemplate<typename Archive>\nvoid save(Archive& <#= (has_attributes_or_parent ? \"ar\" : \"/*ar*/\") #>,\n    const <#= qn #>& <#= (has_attributes_or_parent ? \"v\" : \"/*v*/\") #>,\n    const unsigned int /*version*/) {\n<#+\n        if (!o.parents().empty()) {\n            const auto& pn(o.parents().front());\n            const auto pqn(ast.get_qualified_name(pn));\n#>\n    ar << make_nvp(\"<#= pn.simple() #>\", base_object<<#= pqn #>>(v));\n<#+\n        }\n\n        if (has_attributes && has_parent)\n#>\n\n<#+\n        for (const auto& attr : o.local_attributes()) {\n#>\n    ar << make_nvp(\"<#= attr.name().simple() #>\", v.<#= attr.member_variable_name() #>);\n<#+\n        }\n#>\n}\n\n<#+\n        /*\n         * Load function\n         */\n#>\ntemplate<typename Archive>\nvoid load(Archive& <#= (has_attributes_or_parent ? \"ar,\" : \"/*ar*/,\") #>\n    <#= qn #>& <#= (has_attributes_or_parent ? \"v\" : \"/*v*/\") #>,\n    const unsigned int /*version*/) {\n<#+\n        if (!o.parents().empty()) {\n            const auto& pn(o.parents().front());\n            const auto pqn(ast.get_qualified_name(pn));\n#>\n    ar >> make_nvp(\"<#= pn.simple() #>\", base_object<<#= pqn #>>(v));\n<#+\n            if (has_attributes && has_parent)\n#>\n\n<#+\n        }\n\n        for (const auto& attr : o.local_attributes()) {\n#>\n    ar >> make_nvp(\"<#= attr.name().simple() #>\", v.<#= attr.member_variable_name() #>);\n<#+\n        }\n#>\n}\n\n} }\n\nnamespace boost {\nnamespace serialization {\n\ntemplate void save(archive::polymorphic_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::polymorphic_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::text_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::text_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::binary_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::binary_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::xml_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::xml_iarchive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::test_data",
      "documentation": "Formatters for the test_data facet\nof the C++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::test_data::class_header",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n    builder.add(e.name(), types::traits::class_header_archetype_qn());\n    return builder.build();\n}\n\nvoid class_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto sn(o.name().simple());\n            const auto qn(ast.get_qualified_name(o.name()));\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= sn #>_generator {\n<#+\n            if (!o.is_parent()) {\n#>\npublic:\n    <#= sn #>_generator();\n\n<#+\n            }\n#>\npublic:\n    typedef <#= qn #> result_type;\n\npublic:\n<#+\n            if (!o.is_immutable())\n#>\n    static void populate(const unsigned int position, result_type& v);\n<#+\n            if (!o.is_parent()) {\n#>\n    static result_type create(const unsigned int position);\n    result_type operator()();\n\nprivate:\n    unsigned int position_;\n<#+\n            }\n#>\npublic:\n    static result_type* create_ptr(const unsigned int position);\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::test_data::class_implementation",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    const auto& o(assistant::as<logical::entities::structural::object>(e));\n    auto builder(f.make());\n    builder.add(o.name(), traits::class_header_archetype_qn());\n\n    const auto carch(traits::canonical_archetype());\n    builder.add(o.transparent_associations(), carch);\n    builder.add(o.opaque_associations(), carch);\n    builder.add(o.parents(), carch);\n    builder.add(o.leaves(), carch);\n\n    return builder.build();\n}\n\nvoid class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        if (!o.local_attributes().empty()) {\n#>\nnamespace {\n<#+\n        ast.add_helper_methods(o.name().qualified().dot());\n#>\n\n}\n\n<#+\n        }\n\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n\n            /*\n             * Default constructor.\n             */\n            if (!o.is_parent()) {\n#>\n\n<#= sn #>_generator::<#= sn #>_generator() : position_(0) { }\n<#+\n            }\n\n            /*\n             * Populate method.\n             */\n            if (!o.is_immutable()) {\n                bool no_args(o.local_attributes().empty() && o.parents().empty());\n                if (no_args) {\n#>\n\nvoid <#= sn #>_generator::\npopulate(const unsigned int /*position*/, result_type& /*v*/) {\n<#+\n                } else {\n#>\n\nvoid <#= sn #>_generator::\npopulate(const unsigned int position, result_type& v) {\n<#+\n                }\n\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= pqn #>_generator::populate(position, v);\n<#+\n                }\n                unsigned int i(0);\n                for (const auto& attr : o.local_attributes()) {\n#>\n    v.<#= attr.name().simple() #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + <#= i #>));\n<#+\n                    ++i;\n                }\n#>\n}\n<#+\n            }\n\n            /*\n             * Create method.\n             */\n            if (!o.is_parent()) {\n                 const bool no_arg(o.all_attributes().empty());\n#>\n\n<#= sn #>_generator::result_type\n<#= sn #>_generator::create(const unsigned int<#= (no_arg ? \"/*position*/\" : \" position\") #>) {\n<#+\n                if (o.is_immutable()) {\n#>\n    return <#= sn #>(\n<#+\n                    if (o.local_attributes().empty())\n#>\n\n<#+\n                    else {\n                        utility::formatters::sequence_formatter sf(o.local_attributes().size());\n                        for (const auto& attr : o.local_attributes()) {\n#>\n        create_<#= attr.parsed_type().qualified().identifiable() #>(position + <#= sf.current_position() #>)<#= sf.postfix() #>\n<#+\n                            sf.next();\n                        }\n                    }\n#>\n        );\n<#+\n                } else {\n#>\n    <#= sn #> r;\n<#+\n                    if (!o.all_attributes().empty())\n#>\n    <#= sn #>_generator::populate(position, r);\n    return r;\n<#+\n                }\n#>\n}\n<#+\n            }\n\n            /*\n             * Create method ptr.\n             */\n#>\n\n<#= sn #>_generator::result_type*\n<#= sn #>_generator::create_ptr(const unsigned int position) {\n<#+\n            if (o.leaves().empty()) {\n                if (o.is_immutable())\n#>\n    return new <#= sn #>(create(position));\n<#+\n                else {\n#>\n    <#= sn #>* p = new <#= sn #>();\n    <#= sn #>_generator::populate(position, *p);\n    return p;\n<#+\n                }\n            } else {\n                auto leaves(o.leaves());\n                const auto front(leaves.front());\n                leaves.pop_front();\n                unsigned int i(0);\n                const auto total(static_cast<unsigned int>(leaves.size()));\n                for (const auto& l : leaves) {\n#>\n    if ((position % <#= total #>) == <#= i++ #>)\n        return <#= ast.get_qualified_name(l) #>_generator::create_ptr(position);\n<#+\n                }\n#>\n    return <#= ast.get_qualified_name(front) #>_generator::create_ptr(position);\n<#+\n            }\n#>\n}\n<#+\n            /*\n             * Function operator\n             */\n             if (!o.is_parent()) {\n#>\n\n<#= sn #>_generator::result_type\n<#= sn #>_generator::operator()() {\n    return create(position_++);\n}\n<#+\n            }\n#>\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::test_data::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n\n    builder.add(e.name(), types::traits::enum_header_archetype_qn());\n    return builder.build();\n}\n\nvoid enum_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= ye.name().simple() #>_generator {\npublic:\n    <#= ye.name().simple() #>_generator();\n\npublic:\n    typedef <#= ast.get_qualified_name(ye.name()) #> result_type;\n\npublic:\n    static void populate(const unsigned int position, result_type& v);\n    static result_type create(const unsigned int position);\n    result_type operator()();\n\nprivate:\n    unsigned int position_;\n};\n\n<#+\n         } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::test_data::enum_implementation",
      "documentation": "Generates implementation files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/enum_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/enum_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n\n    builder.add(e.name(), traits::enum_header_archetype_qn());\n    return builder.build();\n}\n\nvoid enum_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#= ye.name().simple() #>_generator::<#= ye.name().simple() #>_generator() : position_(0) { }\nvoid <#= ye.name().simple() #>_generator::\npopulate(const unsigned int position, result_type& v) {\n    v = static_cast<<#= ye.name().simple() #>>(position % <#= ye.enumerators().size() #>);\n}\n\n<#= ye.name().simple() #>_generator::result_type\n<#= ye.name().simple() #>_generator::create(const unsigned int  position) {\n    result_type r;\n    <#= ye.name().simple() #>_generator::populate(position, r);\n    return r;\n}\n\n<#= ye.name().simple() #>_generator::result_type\n<#= ye.name().simple() #>_generator::operator()() {\n    return create(position_++);\n}\n\n<#+\n         } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::odb",
      "documentation": "Formatters for the odb facet of the\nC++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::odb::class_header",
      "documentation": "Generates header files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::structural::object;\n    const auto& o(assistant::as<object>(e));\n    auto builder(f.make());\n    builder.add(o.name(), types::traits::class_header_archetype_qn());\n\n    const auto carch(traits::canonical_archetype());\n    builder.add(o.transparent_associations(), carch);\n    builder.add(o.opaque_associations(), carch);\n\n    const auto self_fn(class_header_transform::static_archetype().meta_name().qualified());\n    builder.add(o.parents(), self_fn);\n\n    return builder.build();\n}\n\nvoid class_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n\n        if (!o.orm_properties() || o.orm_properties()->odb_pragmas().empty()) {\n#>\n// class has no ODB pragmas defined.\n\n<#+\n        } else {\n            {\n                const auto ns(ast.make_namespaces(o.name()));\n                auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n#ifdef ODB_COMPILER\n\n<#+\n                for (const auto& pg : o.orm_properties()->odb_pragmas())\n#>\n<#= pg #>\n<#+\n\n                bool is_first(true);\n                for (const auto& attr : o.local_attributes()) {\n                    if (!attr.orm_properties() ||\n                        attr.orm_properties()->odb_pragmas().empty())\n                        continue;\n\n                    const auto attr_level_pragmas(attr.orm_properties()->odb_pragmas());\n                    for (const auto& pg : attr_level_pragmas) {\n                        if (is_first)\n#>\n\n<#+\n                        is_first = false;\n#>\n<#= pg #>\n<#+\n                    }\n                }\n#>\n\n#endif\n\n<#+\n            }\n#>\n\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::registrar",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::registrar_error",
      "documentation": "There was an error in the registrar.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "workflow_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::formatting_error",
      "documentation": "An error occurred whilst formatting.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::repository",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.io.enabled": "true",
        "masd.cpp.io.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stock_artefact_formatters_by_meta_name",
          "type": "std::unordered_map<std::string, std::forward_list<std::shared_ptr<transforms::model_to_text_transform>>>"
        },
        {
          "name": "stock_artefact_formatters_by_archetype",
          "type": "std::unordered_map<std::string, std::shared_ptr<transforms::model_to_text_transform>>"
        },
        {
          "name": "stock_artefact_formatters",
          "type": "std::forward_list<std::shared_ptr<transforms::model_to_text_transform>>"
        },
        {
          "name": "helper_formatters",
          "type": "std::unordered_map<std::string, std::unordered_map<std::string, std::list<std::shared_ptr<transforms::helper_transform>>>>"
        }
      ]
    },
    {
      "name": "transforms::workflow",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "registrar_",
          "type": "transforms::registrar"
        }
      ]
    },
    {
      "name": "transforms::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables",
      "documentation": "Formattables contains all types required by the formatters\nand those used to generate them.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "formattables::workflow",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::inclusion_constants",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::locator",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::dependencies_builder",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::building_error",
      "documentation": "An error occurred while the factory was building.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::artefact_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "file_path",
          "type": "boost::filesystem::path"
        },
        {
          "name": "header_guard",
          "type": "std::string"
        },
        {
          "name": "inclusion_dependencies",
          "type": "std::list<std::string>"
        }
      ]
    },
    {
      "name": "formattables::dependencies_builder_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::assistant",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stream_",
          "type": "std::ostringstream"
        }
      ]
    },
    {
      "name": "transforms::serialization::enum_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n    builder.add(e.name(), types::traits::enum_header_archetype_qn());\n    builder.add(inclusion_constants::boost::serialization::nvp());\n    return builder.build();\n}\n\nvoid enum_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\n\ntemplate<class Archive>\nvoid serialize(Archive& ar, <#= ast.get_qualified_name(ye.name()) #>& v, unsigned int /*version*/){\n    using boost::serialization::make_nvp;\n    ar & make_nvp(\"<#= ye.name().simple() #>\", v);\n}\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::odb::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n    builder.add(e.name(), types::traits::enum_header_archetype_qn());\n    return builder.build();\n}\n\nvoid enum_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n#ifdef ODB_COMPILER\n\n#endif\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::context",
      "documentation": "Supplies additional information required for formatting.\n",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "enabled_archetype_for_element",
          "type": "std::unordered_set<text::entities::element_archetype>"
        },
        {
          "name": "element_properties",
          "type": "formattables::element_properties"
        },
        {
          "name": "model",
          "type": "formattables::model"
        },
        {
          "name": "helpers",
          "type": "std::unordered_map<std::string, std::unordered_map<std::string, std::list<std::shared_ptr<transforms::helper_transform>>>>"
        },
        {
          "name": "tracer",
          "type": "boost::shared_ptr<tracing::tracer>"
        }
      ]
    },
    {
      "name": "transforms::helper_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::building_error",
      "documentation": "An error occurred whilst the factory was building.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_descriptor",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "family",
          "type": "std::string"
        },
        {
          "name": "namespaces",
          "type": "std::list<std::string>"
        },
        {
          "name": "name_identifiable",
          "type": "std::string"
        },
        {
          "name": "name_qualified",
          "type": "std::string"
        },
        {
          "name": "name_tree_qualified",
          "type": "std::string"
        },
        {
          "name": "name_tree_identifiable",
          "type": "std::string"
        },
        {
          "name": "streaming_properties",
          "type": "boost::optional<formattables::streaming_properties>"
        },
        {
          "name": "is_simple_type",
          "type": "bool"
        },
        {
          "name": "requires_hashing_helper",
          "type": "bool"
        },
        {
          "name": "is_circular_dependency",
          "type": "bool"
        },
        {
          "name": "is_pointer",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::helper_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "current",
          "type": "formattables::helper_descriptor"
        },
        {
          "name": "direct_descendants",
          "type": "std::list<formattables::helper_descriptor>"
        },
        {
          "name": "in_inheritance_relationship",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::element_properties",
      "documentation": "All of the properties associated with an element.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "aspect_properties",
          "type": "formattables::aspect_properties"
        },
        {
          "name": "artefact_properties",
          "type": "std::unordered_map<std::string, formattables::artefact_properties>"
        },
        {
          "name": "helper_properties",
          "type": "std::list<formattables::helper_properties>"
        },
        {
          "name": "canonical_archetype_to_archetype",
          "type": "std::unordered_map<std::string, std::string>"
        },
        {
          "name": "attribute_level_test_data_properties",
          "type": "std::unordered_map<std::string, test_data_properties>"
        }
      ]
    },
    {
      "name": "formattables::aspect_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "requires_manual_default_constructor",
          "type": "bool"
        },
        {
          "name": "requires_manual_move_constructor",
          "type": "bool"
        },
        {
          "name": "requires_stream_manipulators",
          "type": "bool"
        }
      ]
    },
    {
      "name": "transforms::inclusion_support_types",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "not_supported",
          "type": "",
          "documentation": "This formatter does not export an inclusion directive.\n"
        },
        {
          "name": "regular_support",
          "type": "",
          "documentation": "This formatter exports a regular inclusion directive.\n"
        },
        {
          "name": "canonical_support",
          "type": "",
          "documentation": "This formatter exports a regular inclusion directive and is the default for its facet\nand element.\n"
        }
      ]
    },
    {
      "name": "transforms::types::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> builtin_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static const std::list<std::string> r;\n    return r;\n}\n\nvoid builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    a.logical_name().simple(e.name().simple());\n    a.logical_name().qualified(e.name().qualified().dot());\n    a.origin_sha1_hash(e.origin_sha1_hash());\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::hash::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> builtin_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static const std::list<std::string> r;\n    return r;\n}\n\nvoid builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    a.logical_name().simple(e.name().simple());\n    a.logical_name().qualified(e.name().qualified().dot());\n    a.origin_sha1_hash(e.origin_sha1_hash());\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::test_data::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> builtin_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static const std::list<std::string> r;\n    return r;\n}\n\nvoid builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    a.logical_name().simple(e.name().simple());\n    a.logical_name().qualified(e.name().qualified().dot());\n    a.origin_sha1_hash(e.origin_sha1_hash());\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::io::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> builtin_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static const std::list<std::string> r;\n    return r;\n}\n\nvoid builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"FIXME\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    a.logical_name().simple(e.name().simple());\n    a.logical_name().qualified(e.name().qualified().dot());\n    a.origin_sha1_hash(e.origin_sha1_hash());\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::odb::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> builtin_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static const std::list<std::string> r;\n    return r;\n}\n\nvoid builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    a.logical_name().simple(e.name().simple());\n    a.logical_name().qualified(e.name().qualified().dot());\n    a.origin_sha1_hash(e.origin_sha1_hash());\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::serialization::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> builtin_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static const std::list<std::string> r;\n    return r;\n}\n\nvoid builtin_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    a.logical_name().simple(e.name().simple());\n    a.logical_name().qualified(e.name().qualified().dot());\n    a.origin_sha1_hash(e.origin_sha1_hash());\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "formattables::formattable",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "element",
          "type": "boost::shared_ptr<logical::entities::element>"
        },
        {
          "name": "element_properties",
          "type": "formattables::element_properties"
        },
        {
          "name": "artefacts",
          "type": "std::unordered_map<std::string, boost::shared_ptr<physical::entities::artefact>>"
        }
      ]
    },
    {
      "name": "formattables::adapter",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::inclusion_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::reducer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::model_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::file_path_and_guard_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::aspect_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::adaptation_error",
      "documentation": "An error occurred during adaptation.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::expansion_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::odb_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::model",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "name",
          "type": "logical::entities::name"
        },
        {
          "name": "streaming_properties",
          "type": "std::unordered_map<std::string, formattables::streaming_properties>"
        },
        {
          "name": "formattables",
          "type": "std::unordered_map<std::string, formattables::formattable>"
        },
        {
          "name": "facet_properties",
          "type": "std::unordered_map<std::string, formattables::facet_properties>"
        },
        {
          "name": "cpp_standard",
          "type": "formattables::cpp_standards"
        },
        {
          "name": "odb_databases",
          "type": "std::list<std::string>"
        },
        {
          "name": "odb_sql_name_case",
          "type": "std::string"
        },
        {
          "name": "project_items",
          "type": "std::list<std::string>"
        }
      ]
    },
    {
      "name": "formattables::facet_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory",
          "type": "std::string"
        },
        {
          "name": "enabled",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::facet_directory_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::canonical_archetype_resolver",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::canonical_archetype_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::resolution_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::streaming_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "requires_quoting",
          "type": "bool"
        },
        {
          "name": "string_conversion_method",
          "type": "std::string"
        },
        {
          "name": "remove_unprintable_characters",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::streaming_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::locator_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "facet_configurations",
          "type": "std::unordered_map<std::string, formattables::locator_facet_configuration>"
        },
        {
          "name": "archetype_configurations",
          "type": "std::unordered_map<std::string, formattables::locator_archetype_configuration>"
        },
        {
          "name": "include_directory_name",
          "type": "std::string"
        },
        {
          "name": "source_directory_name",
          "type": "std::string"
        },
        {
          "name": "disable_facet_directories",
          "type": "bool"
        },
        {
          "name": "header_file_extension",
          "type": "std::string"
        },
        {
          "name": "implementation_file_extension",
          "type": "std::string"
        },
        {
          "name": "backend_directory_name",
          "type": "std::string"
        },
        {
          "name": "tests_directory_name",
          "type": "std::string"
        },
        {
          "name": "templates_directory_name",
          "type": "std::string"
        },
        {
          "name": "templates_file_extension",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::locator_facet_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory",
          "type": "std::string"
        },
        {
          "name": "postfix",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::locator_archetype_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "facet_directory",
          "type": "std::string"
        },
        {
          "name": "facet_postfix",
          "type": "std::string"
        },
        {
          "name": "archetype_postfix",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "transforms::wale_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::stitch_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::smart_pointer_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::smart_pointer_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::time_duration_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::ptree_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::associative_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::date_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::optional_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::path_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::pair_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::sequence_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::ptime_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::variant_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::associative_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::smart_pointer_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::ptree_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::optional_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::pair_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::sequence_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::variant_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::string_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::path_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::associative_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::char_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::bool_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::date_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::domain_type_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::number_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::optional_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::pair_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::path_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::ptime_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::ptree_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::sequence_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::smart_pointer_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::string_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::time_duration_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::variant_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::inserter_implementation_helper",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_implementation.formatting_style": "stitch",
        "masd.cpp.types.class_implementation.overwrite": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::location_error",
      "documentation": "An error occurred while the locator was creating a path.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "helper_families",
          "type": "std::unordered_map<std::string, std::string>"
        },
        {
          "name": "streaming_properties",
          "type": "std::unordered_map<std::string, formattables::streaming_properties>"
        }
      ]
    },
    {
      "name": "transforms::types::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::primitive;\n    const auto& p(assistant::as<primitive>(e));\n    auto builder(f.make());\n\n    // algorithm: domain headers need it for the swap function.\n    builder.add(inclusion_constants::std::algorithm());\n\n    using ser = transforms::serialization::traits;\n    const auto ser_fwd_arch(ser::primitive_forward_declarations_archetype_qn());\n    builder.add(p.name(), ser_fwd_arch);\n\n    const auto carch(traits::canonical_archetype());\n    builder.add(p.value_attribute().parsed_type().current(), carch);\n\n    return builder.build();\n}\n\nvoid primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto attr(p.value_attribute());\n\n            ast.comment(p.documentation());\n#>\nclass <#= sn #> final {\npublic:\n<#+\n            /*\n             * Compiler generated constructors and destructors.\n             */\n            if (!ast.requires_manual_default_constructor())\n#>\n    <#= sn #>() = default;\n    <#= sn #>(const <#= sn #>&) = default;\n<#+\n            if (!ast.requires_manual_move_constructor())\n#>\n    <#= sn #>(<#= sn #>&&) = default;\n    ~<#= sn #>() = default;\n<#+\n            if (p.is_immutable())\n#>\n    <#= sn #>& operator=(const <#= sn #>&) = delete;\n<#+\n            /*\n             * Manually generated default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\npublic:\n    <#= sn #>();\n\n<#+\n            }\n\n            /*\n             * Manually generated move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\npublic:\n    <#= sn #>(<#= sn #>&& rhs);\n\n<#+\n            }\n\n            /*\n             * Manually generated complete constructor.\n             */\n#>\npublic:\n    explicit <#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>);\n\n<#+\n            /*\n             * Serialisaton Friends\n             */\n            if (ast.is_serialization_enabled()) {\n#>\nprivate:\n    template<typename Archive>\n    friend void boost::serialization::save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\n    template<typename Archive>\n    friend void boost::serialization::load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n<#+\n            }\n\n            /*\n             * Getters and setters.\n             */\n#>\npublic:\n<#+\n            ast.comment_start_method_group(attr.documentation(), !attr.is_immutable());\n            if (attr.parsed_type().is_current_simple_type()) {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #>() const;\n<#+\n                if (attr.is_immutable()) {\n#>\n\n<#+\n\n                } else {\n#>\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n<#+\n                }\n            } else {\n#>\n    const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= attr.name().simple() #>() const;\n<#+\n                if (attr.is_immutable()) {\n#>\n\n<#+\n                } else {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>();\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v);\n<#+\n                }\n            }\n            ast.comment_end_method_group(attr.documentation(), !attr.is_immutable());\n\n            /*\n             * Explicit cast.\n             */\n#>\n\npublic:\n    explicit operator <#= ast.get_qualified_name(attr.parsed_type()) #>() const {\n        return <#= attr.member_variable_name() #>;\n    }\n<#+\n            /*\n             * Equality.\n             */\n#>\n\npublic:\n    bool operator==(const <#= sn #>& rhs) const;\n    bool operator!=(const <#= sn #>& rhs) const {\n        return !this->operator==(rhs);\n    }\n\n<#+\n            /*\n             * Swap and assignment.\n             */\n#>\npublic:\n    void swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #>;\n<#+\n            if (!p.is_immutable()) {\n#>\n    <#= sn #>& operator=(<#= sn #> other);\n<#+\n            }\n\n            /*\n             * Member variables.\n             */\n#>\n\nprivate:\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.member_variable_name() #>;\n};\n\n<#+\n        } // snf\n\n        if (!p.is_immutable()) {\n#>\n\nnamespace std {\n\ntemplate<>\ninline void swap(\n    <#= qn #>& lhs,\n    <#= qn #>& rhs) {\n    lhs.swap(rhs);\n}\n\n}\n<#+\n        }\n#>\n\n<#+\n    } //ah  sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::hash::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    auto builder(f.make());\n    builder.add(inclusion_constants::std::functional());\n    builder.add(e.name(), types::traits::canonical_archetype());\n    return builder.build();\n}\n\nvoid primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nstruct <#= sn #>_hasher {\npublic:\n    static std::size_t hash(const <#= sn #>& v);\n};\n\n<#+\n        } // snf\n#>\n\nnamespace std {\n\ntemplate<>\nstruct hash<<#= qn #>> {\npublic:\n    size_t operator()(const <#= qn #>& v) const {\n        return <#= qn #>_hasher::hash(v);\n    }\n};\n\n}\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::io::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n    builder.add(inclusion_constants::std::iosfwd());\n\n    using traits = transforms::types::traits;\n    builder.add(e.name(), traits::canonical_archetype());\n\n    return builder.build();\n}\n\nvoid primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"FIXME\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto qn(ast.get_qualified_name(p.name()));\n#>\n\nstd::ostream&\noperator<<(std::ostream& s, const <#= qn #>& v);\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::odb::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::primitive;\n    const auto& p(assistant::as<primitive>(e));\n    auto builder(f.make());\n    builder.add(p.name(), types::traits::primitive_header_archetype_qn());\n\n    return builder.build();\n}\n\nvoid primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    {\n        const auto sn(p.name().simple());\n        const auto qn(ast.get_qualified_name(p.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        const auto attr(p.value_attribute());\n\n        if (!p.orm_properties() || p.orm_properties()->odb_pragmas().empty()) {\n#>\n// class has no ODB pragmas defined.\n\n<#+\n        } else {\n            {\n                const auto ns(ast.make_namespaces(p.name()));\n                auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n#ifdef ODB_COMPILER\n\n<#+\n                for (const auto& pg : p.orm_properties()->odb_pragmas())\n#>\n<#= pg #>\n<#+\n\n                bool is_first(true);\n                if (p.value_attribute().orm_properties() &&\n                    !p.value_attribute().orm_properties()->odb_pragmas().empty()) {\n                    for (const auto& pg : p.value_attribute().orm_properties()->odb_pragmas()) {\n                        if (is_first)\n#>\n\n<#+\n                            is_first = false;\n#>\n<#= pg #>\n<#+\n                    }\n#>\n\n#endif\n\n<#+\n                }\n            }\n#>\n\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::test_data::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n    builder.add(e.name(), types::traits::primitive_header_archetype_qn());\n    return builder.build();\n}\n\nvoid primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= sn #>_generator {\npublic:\n    <#= sn #>_generator();\n\npublic:\n    typedef <#= qn #> result_type;\n\npublic:\n<#+\n            if (!p.is_immutable())\n#>\n    static void populate(const unsigned int position, result_type& v);\n    static result_type create(const unsigned int position);\n    result_type operator()();\n\nprivate:\n    unsigned int position_;\n\npublic:\n    static result_type* create_ptr(const unsigned int position);\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::serialization::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::primitive;\n    const auto& p(assistant::as<primitive>(e));\n    auto builder(f.make());\n    builder.add(p.name(), types::traits::primitive_header_archetype_qn());\n\n    using ic = inclusion_constants;\n    builder.add(ic::boost::serialization::split_free());\n\n    return builder.build();\n}\n\nvoid primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\nBOOST_SERIALIZATION_SPLIT_FREE(<#= qn #>)\n\nnamespace boost {\nnamespace serialization {\n\ntemplate<typename Archive>\nvoid save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\ntemplate<typename Archive>\nvoid load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::primitive_implementation",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/primitive_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/primitive_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string>\nprimitive_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::structural::primitive;\n    const auto& o(assistant::as<primitive>(e));\n    auto builder(f.make());\n\n    const auto ch_arch(traits::primitive_header_archetype_qn());\n    builder.add(o.name(), ch_arch);\n    return builder.build();\n}\n\nvoid primitive_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto attr(p.value_attribute());\n\n            /*\n             * Default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\n\n<#= sn #>::<#= sn #>()\n    : <#= attr.member_variable_name() #>(static_cast<<#= ast.get_qualified_name(attr.parsed_type()) #>>(0)) { }\n<#+\n            }\n\n            /*\n             * Move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\n\n<#= sn #>::<#= sn #>(<#= sn #>&& rhs)\n    : <#= attr.member_variable_name() #>(std::move(rhs.<#= attr.member_variable_name() #>)) { }\n<#+\n            }\n\n            /*\n             * Complete constructor.\n             */\n#>\n\n<#= sn #>::<#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>)\n    : <#= attr.member_variable_name() #>(<#= attr.name().simple() #>) { }\n\n<#+\n            /*\n             * Getters and setters\n             */\n             if (attr.parsed_type().is_current_simple_type()) {\n#>\n<#= ast.get_qualified_name(attr.parsed_type()) #> <#= sn #>::<#= attr.name().simple() #>() const {\n    return <#= attr.member_variable_name() #>;\n}\n\n<#+\n                if (!p.is_immutable()) {\n#>\nvoid <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #> v) {\n    <#= attr.member_variable_name() #> = v;\n}\n\n<#+\n                }\n            } else {\n#>\nconst <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() const {\n    return <#= attr.member_variable_name() #>;\n}\n<#+\n                if (!p.is_immutable()) {\n#>\n\n<#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() {\n    return <#= attr.member_variable_name() #>;\n}\n\nvoid <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>& v) {\n    <#= attr.member_variable_name() #> = v;\n}\n\nvoid <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v) {\n    <#= attr.member_variable_name() #> = std::move(v);\n}\n\n<#+\n                }\n            }\n\n            /*\n             * Equality.\n             */\n#>\nbool <#= sn #>::operator==(const <#= sn #>& rhs) const {\n    return <#= attr.member_variable_name() #> == rhs.<#= attr.member_variable_name() #>;\n}\n\n<#+\n            /*\n             * Swap and assignment.\n             */\n            if (!p.is_immutable()) {\n#>\nvoid <#= sn #>::swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #> {\n    using std::swap;\n    swap(<#= attr.member_variable_name() #>, other.<#= attr.member_variable_name() #>);\n}\n\n<#= sn #>& <#= sn #>::operator=(<#= sn #> other) {\n    using std::swap;\n    swap(*this, other);\n    return *this;\n}\n\n<#+\n            }\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::hash::primitive_implementation",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/primitive_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/primitive_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string>\nprimitive_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::primitive;\n    const auto& p(assistant::as<primitive>(e));\n    const auto carch(traits::canonical_archetype());\n    auto builder(f.make());\n    builder.add(p.name(), carch);\n\n    return builder.build();\n}\n\nvoid primitive_implementation_transform::\napply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\n\nnamespace {\n\ntemplate <typename HashableType>\ninline void combine(std::size_t& seed, const HashableType& value) {\n    std::hash<HashableType> hasher;\n    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n<#+\n\n        ast.add_helper_methods(p.name().qualified().dot());\n#>\n\n}\n\n<#+\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(p.name().simple());\n            const auto qn(ast.get_qualified_name(p.name()));\n            const auto attr(p.value_attribute());\n#>\n\nstd::size_t <#= sn #>_hasher::hash(const <#= sn #>& v) {\n    std::size_t seed(0);\n<#+\n            if (ast.requires_hashing_helper_method(attr))\n#>\n    combine(seed, hash_<#= attr.parsed_type().qualified().identifiable() #>(v.<#= attr.name().simple() #>()));\n<#+\n            else\n#>\n    combine(seed, v.<#= attr.name().simple() #>());\n    return seed;\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::io::primitive_implementation",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/primitive_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/primitive_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string>\nprimitive_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::primitive;\n    const auto& p(assistant::as<primitive>(e));\n    auto builder(f.make());\n    const auto ph_fn(traits::primitive_header_archetype_qn());\n    builder.add(p.name(), ph_fn);\n\n    const auto io_carch(transforms::io::traits::canonical_archetype());\n    const auto self_fn(primitive_implementation_transform::static_archetype().meta_name().qualified());\n    const bool io_enabled(builder.is_enabled(p.name(), self_fn));\n\n    if (!io_enabled)\n        return builder.build();\n\n    const auto os(inclusion_constants::std::ostream());\n    builder.add(os);\n    builder.add(p.value_attribute().parsed_type().current(), io_carch);\n\n    return builder.build();\n}\n\nvoid primitive_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(p.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(p.name().simple());\n            const auto qn(ast.get_qualified_name(p.name()));\n            const auto attr(p.value_attribute());\n#>\n\nstd::ostream& operator<<(std::ostream& s, const <#= sn #>& v) {\n<#+\n            if (ast.requires_stream_manipulators()) {\n#>\n    boost::io::ios_flags_saver ifs(s);\n    s.setf(std::ios_base::boolalpha);\n    s.setf(std::ios::fixed, std::ios::floatfield);\n    s.precision(6);\n    s.setf(std::ios::showpoint);\n<#+\n            }\n\n            const std::string variable_name = \"v.\" + attr.getter_setter_name() + \"()\";\n#>\n\n    s << \" { \"\n      << \"\\\"__type__\\\": \" << \"\\\"<#= qn #>\\\"\" << \", \"\n      << \"\\\"<#= attr.name().simple() #>\\\": \" << <#= ast.streaming_for_type(attr.parsed_type().current(), variable_name) #>\n      << \" }\";\n\n    return s;\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::test_data::primitive_implementation",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/primitive_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/primitive_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    const auto& p(assistant::as<logical::entities::structural::primitive>(e));\n    auto builder(f.make());\n    builder.add(p.name(), traits::primitive_header_archetype_qn());\n\n    const auto carch(traits::canonical_archetype());\n    builder.add(p.value_attribute().parsed_type().current(), carch);\n\n    return builder.build();\n}\n\nvoid primitive_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\nnamespace {\n<#+\n        ast.add_helper_methods(p.name().qualified().dot());\n#>\n\n}\n\n<#+\n        {\n            const auto attr(p.value_attribute());\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n\n            /*\n             * Default constructor.\n             */\n#>\n\n<#= sn #>_generator::<#= sn #>_generator() : position_(0) { }\n<#+\n            /*\n             * Populate method.\n             */\n            if (!p.is_immutable()) {\n#>\n\nvoid <#= sn #>_generator::\npopulate(const unsigned int position, result_type& v) {\n    v.<#= attr.name().simple() #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + 1));\n}\n<#+\n            }\n\n            /*\n             * Create method.\n             */\n#>\n\n<#= sn #>_generator::result_type\n<#= sn #>_generator::create(const unsigned int position) {\n<#+\n            if (p.is_immutable()) {\n#>\n    return <#= sn #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + 1));\n<#+\n            } else {\n#>\n    <#= sn #> r;\n    <#= sn #>_generator::populate(position, r);\n    return r;\n<#+\n            }\n#>\n}\n<#+\n            /*\n             * Create method ptr.\n             */\n#>\n\n<#= sn #>_generator::result_type*\n<#= sn #>_generator::create_ptr(const unsigned int position) {\n<#+\n            if (p.is_immutable())\n#>\n    return new <#= sn #>(create(position));\n<#+\n            else {\n#>\n    <#= sn #>* r = new <#= sn #>();\n    <#= sn #>_generator::populate(position, *r);\n    return r;\n<#+\n            }\n#>\n}\n<#+\n            /*\n             * Function operator\n             */\n#>\n\n<#= sn #>_generator::result_type\n<#= sn #>_generator::operator()() {\n    return create(position_++);\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::serialization::primitive_implementation",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/primitive_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/primitive_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string>\nprimitive_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::structural::primitive;\n    const auto& p(assistant::as<primitive>(e));\n    auto builder(f.make());\n\n    const auto ph_fn(traits::primitive_header_archetype_qn());\n    builder.add(p.name(), ph_fn);\n\n    using ic = inclusion_constants;\n    builder.add(ic::boost::archive::text_iarchive());\n    builder.add(ic::boost::archive::text_oarchive());\n    builder.add(ic::boost::archive::binary_iarchive());\n    builder.add(ic::boost::archive::binary_oarchive());\n    builder.add(ic::boost::archive::polymorphic_iarchive());\n    builder.add(ic::boost::archive::polymorphic_oarchive());\n\n    // XML serialisation\n    builder.add(ic::boost::serialization::nvp());\n    builder.add(ic::boost::archive::xml_iarchive());\n    builder.add(ic::boost::archive::xml_oarchive());\n\n    const auto carch(traits::canonical_archetype());\n    builder.add(p.value_attribute().parsed_type().current(), carch);\n\n    return builder.build();\n}\n\nvoid primitive_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        const auto attr(p.value_attribute());\n#>\n\nnamespace boost {\nnamespace serialization {\n<#+\n\n        /*\n         * Save function\n         */\n#>\n\ntemplate<typename Archive>\nvoid save(Archive& ar, const <#= qn #>& v, const unsigned int /*version*/) {\n    ar << make_nvp(\"<#= attr.name().simple() #>\", v.<#= attr.member_variable_name() #>);\n}\n\n<#+\n        /*\n         * Load function\n         */\n#>\ntemplate<typename Archive>\nvoid load(Archive& ar, <#= qn #>& v, const unsigned int /*version*/) {\n    ar >> make_nvp(\"<#= attr.name().simple() #>\", v.<#= attr.member_variable_name() #>);\n}\n\n} }\n\nnamespace boost {\nnamespace serialization {\n\ntemplate void save(archive::polymorphic_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::polymorphic_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::text_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::text_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::binary_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::binary_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::xml_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::xml_iarchive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "formattables::directive_group_repository",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "by_id",
          "type": "std::unordered_map<std::string, std::unordered_map<std::string, formattables::directive_group>>"
        }
      ]
    },
    {
      "name": "formattables::directive_group_repository_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::directive_group",
      "documentation": "Represents the group of inclusion directives associated with a name and an archetype.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "primary",
          "type": "std::string",
          "documentation": "The main inclusion directive needed for this element.\n"
        },
        {
          "name": "secondary",
          "type": "std::list<std::string>",
          "documentation": "Any other directives that are also needed for this element.\n"
        }
      ]
    },
    {
      "name": "formattables::build_files_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::cpp_standards",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "cpp_98",
          "type": ""
        },
        {
          "name": "cpp_11",
          "type": ""
        },
        {
          "name": "cpp_14",
          "type": ""
        },
        {
          "name": "cpp_17",
          "type": ""
        }
      ]
    },
    {
      "name": "formattables::cpp_standard_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::header_guard_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::test_data_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "maximum_size",
          "type": "unsigned int"
        },
        {
          "name": "prefix",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::test_data_properties_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::repository_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests",
      "documentation": "Formatters that generate tests for generated\ncode.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::tests::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests::class_implementation",
      "documentation": "Generates tests for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::tests_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.kvp.class.simple_name": "class_implementation_transform",
        "masd.wale.kvp.archetype.simple_name": "class_implementation",
        "masd.wale.kvp.meta_element": "object",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.tests"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::tests #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::object;\n    const auto& o(assistant::as<object>(e));\n    auto builder(f.make());\n    builder.add(o.name(), types::traits::class_header_archetype_qn());\n    builder.add(o.name(), test_data::traits::class_header_archetype_qn());\n\n    using ic = inclusion_constants;\n    builder.add(ic::std::string());\n    builder.add(ic::boost::test::unit_test());\n\n    if (o.is_parent())\n        builder.add(ic::boost::shared_ptr());\n\n    const auto io_arch(io::traits::class_header_archetype_qn());\n    const bool io_enabled(builder.is_enabled(o.name(), io_arch));\n    if (io_enabled) {\n        builder.add(o.name(), io_arch);\n        builder.add(ic::std::sstream());\n        builder.add(ic::boost::property_tree::ptree());\n        builder.add(ic::boost::property_tree::json_parser());\n    }\n\n    using ser = transforms::serialization::traits;\n    const auto ser_arch(ser::class_header_archetype_qn());\n    const bool ser_enabled(builder.is_enabled(o.name(), ser_arch));\n    if (ser_enabled) {\n        builder.add(o.name(), ser_arch);\n\n        if (o.type_registrar())\n            builder.add(o.type_registrar(), ser::type_registrar_header_archetype_qn());\n\n        builder.add(ic::boost::archive::text_iarchive());\n        builder.add(ic::boost::archive::text_oarchive());\n        builder.add(ic::boost::archive::binary_iarchive());\n        builder.add(ic::boost::archive::binary_oarchive());\n        builder.add(ic::boost::archive::polymorphic_iarchive());\n        builder.add(ic::boost::archive::polymorphic_oarchive());\n        builder.add(ic::boost::serialization::nvp());\n        builder.add(ic::boost::archive::xml_iarchive());\n        builder.add(ic::boost::archive::xml_oarchive());\n\n        if (o.is_parent())\n            builder.add(ic::boost::serialization::shared_ptr());\n    }\n\n    using hash = transforms::hash::traits;\n    const auto hash_arch(hash::class_header_archetype_qn());\n    const bool hash_enabled(builder.is_enabled(o.name(), hash_arch));\n    if (hash_enabled)\n        builder.add(o.name(), hash_arch);\n\n    return builder.build();\n}\n\nvoid class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto list(e.name().location().internal_modules());\n        list.push_back(o.name().simple());\n        const std::string test_suite_name(boost::join(list, \"_\"));\n\n        std::string type_name(\"auto\");\n        if (ast.is_cpp_standard_98())\n            type_name = qn;\n\n#>\nBOOST_AUTO_TEST_SUITE(<#= test_suite_name #>_tests)\n\n<#+\n        /*\n         * If we have no attributes at all, we cannot test this\n         * type. Similarly, if test data is not enabled, none of the\n         * tests can be generated. In either case, we need to insert a\n         * fake test for now. The real solution will be to filter\n         * based on element state.\n         */\n        if (o.all_attributes().empty() || !ast.is_test_data_enabled()) {\n            /*\n             * No tests.\n             */\n#>\nBOOST_AUTO_TEST_CASE(fake_test) {\n    BOOST_CHECK(true);\n}\n\n<#+\n        } else {\n            /*\n             * Types tests. These cannot be performed to parents as\n             * they are abstract.\n             */\n            if (!o.is_parent()) {\n#>\nBOOST_AUTO_TEST_CASE(identical_objects_are_equal) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(a);\n\n    BOOST_CHECK(a == b);\n    BOOST_CHECK(b == a);\n    BOOST_CHECK(!(a != b));\n}\n\nBOOST_AUTO_TEST_CASE(an_object_is_equal_to_itself) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    BOOST_CHECK(a == a);\n    BOOST_CHECK(!(a != a));\n}\n\nBOOST_AUTO_TEST_CASE(distinct_objects_are_unequal) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(g());\n\n    BOOST_CHECK(!(a == b));\n    BOOST_CHECK(a != b);\n}\n\n<#+\n                if (!o.is_immutable()) {\n#>\nBOOST_AUTO_TEST_CASE(assigning_an_object_to_itself_results_in_the_same_object) {\n#if defined(__clang__) && !defined(__apple_build_version__)  && (__clang_major__ >= 7)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wself-assign-overloaded\"\n#endif\n    <#= qn #>_generator g;\n    <#= type_name #> a(g());\n    const <#= type_name #> b(a);\n    const <#= type_name #> c(g());\n\n    a = a;\n    BOOST_CHECK(a == b);\n    BOOST_CHECK(a != c);\n#if defined(__clang__) && !defined(__apple_build_version__)  && (__clang_major__ >= 7)\n#pragma clang diagnostic pop\n#endif\n}\n\n<#+\n                }\n\n                // FIXME: should be 11 or greater.\n                if (!ast.is_cpp_standard_98()) {\n#>\nBOOST_AUTO_TEST_CASE(moved_objects_are_equal) {\n    <#= qn #>_generator g;\n    g();\n    <#= type_name #> a(g());\n    const <#= type_name #> b = <#= qn #>();\n    const <#= type_name #> c(a);\n    BOOST_CHECK(a != b);\n    BOOST_CHECK(a == c);\n\n    const <#= type_name #> d = std::move(a);\n    BOOST_CHECK(d == c);\n    BOOST_CHECK(d != b);\n}\n\n<#+\n                }\n\n                if (!o.is_immutable()) {\n#>\nBOOST_AUTO_TEST_CASE(assigned_objects_are_equal) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    <#= qn #> b;\n    BOOST_CHECK(a != b);\n\n    b = a;\n    BOOST_CHECK(a == b);\n}\n\nBOOST_AUTO_TEST_CASE(copy_constructed_objects_are_equal) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    <#= type_name #> b(a);\n    BOOST_CHECK(a == b);\n\n    b = <#= qn #>();\n    BOOST_CHECK(a != b);\n}\n\nBOOST_AUTO_TEST_CASE(swapping_objects_results_in_the_expected_state) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(g());\n\n    <#= type_name #> c(a);\n    <#= type_name #> d(b);\n    BOOST_CHECK(c == a);\n    BOOST_CHECK(d == b);\n\n    std::swap(c, d);\n    BOOST_CHECK(c == b);\n    BOOST_CHECK(d == a);\n}\n\n<#+\n                }\n            }\n\n            if (ast.is_io_enabled()) {\n                /*\n                 * IO tests.\n                 */\n#>\nBOOST_AUTO_TEST_CASE(inserter_operator_produces_valid_json) {\n<#+\n                if (o.is_parent()) {\n#>\n    <#= qn #>_generator g;\n    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));\n    std::stringstream s;\n    s << *a;\n\n    boost::property_tree::ptree pt;\n    BOOST_REQUIRE_NO_THROW(read_json(s, pt));\n<#+\n                } else {\n#>\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n    std::stringstream s;\n    s << a;\n\n    boost::property_tree::ptree pt;\n    BOOST_REQUIRE_NO_THROW(read_json(s, pt));\n<#+\n                }\n#>\n}\n\n<#+\n            }\n\n            if (ast.is_serialization_enabled()) {\n                /*\n                 * Serialization tests.\n                 */\n                 const auto registrar_qn(o.type_registrar() ?\n                     ast.get_qualified_name(*o.type_registrar()) : std::string());\n\n                if (o.is_parent()) {\n#>\nBOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        xml_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<xml_oarchive>(oa);\n<#+\n                    }\n#>\n\n        oa << BOOST_SERIALIZATION_NVP(a);\n    }\n\n    boost::shared_ptr<<#= qn #>> b;\n    std::istringstream is(os.str());\n    {\n        xml_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<xml_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> BOOST_SERIALIZATION_NVP(b);\n    }\n\n    BOOST_REQUIRE(a);\n    BOOST_REQUIRE(b);\n    BOOST_CHECK(*a == *b);\n}\n\nBOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        text_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<text_oarchive>(oa);\n<#+\n                    }\n#>\n        oa << a;\n    }\n\n    boost::shared_ptr<<#= qn #>> b;\n    std::istringstream is(os.str());\n    {\n        text_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<text_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> b;\n    }\n\n    BOOST_REQUIRE(a);\n    BOOST_REQUIRE(b);\n    BOOST_CHECK(*a == *b);\n}\n\nBOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        binary_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<binary_oarchive>(oa);\n<#+\n                    }\n#>\n        oa << a;\n    }\n\n    boost::shared_ptr<<#= qn #>> b;\n    std::istringstream is(os.str());\n    {\n        binary_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<binary_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> b;\n    }\n\n    BOOST_REQUIRE(a);\n    BOOST_REQUIRE(b);\n    BOOST_CHECK(*a == *b);\n}\n\n<#+\n                } else {\n\n#>\nBOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        xml_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<xml_oarchive>(oa);\n<#+\n                    }\n#>\n        oa << BOOST_SERIALIZATION_NVP(a);\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        xml_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<xml_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> BOOST_SERIALIZATION_NVP(b);\n    }\n\n    BOOST_CHECK(a == b);\n}\n\nBOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        text_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<text_oarchive>(oa);\n<#+\n                    }\n#>\n        oa << a;\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        text_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<text_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> b;\n    }\n\n    BOOST_CHECK(a == b);\n}\n\nBOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        binary_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<binary_oarchive>(oa);\n<#+\n                    }\n#>\n        oa << a;\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        binary_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<binary_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> b;\n    }\n\n    BOOST_CHECK(a == b);\n}\n<#+\n                }\n            }\n\n            if (ast.is_hash_enabled() && !o.is_parent()) {\n                /*\n                 * hash tests.\n                 */\n#>\nBOOST_AUTO_TEST_CASE(equal_objects_generate_the_same_hash) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(a);\n\n    std::hash<<#= qn #>> hasher;\n    BOOST_CHECK(hasher(a) == hasher(b));\n}\n\nBOOST_AUTO_TEST_CASE(different_objects_generate_different_hashes) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(g());\n\n    std::hash<<#= qn #>> hasher;\n    BOOST_CHECK(hasher(a) != hasher(b));\n}\n\n<#+\n            }\n        }\n#>\nBOOST_AUTO_TEST_SUITE_END()\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::tests::enum_implementation",
      "documentation": "Generates tests for enumeration.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::tests_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.enumeration",
        "masd.wale.kvp.class.simple_name": "enum_implementation_transform",
        "masd.wale.kvp.archetype.simple_name": "enum_implementation",
        "masd.wale.kvp.meta_element": "enumeration",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.tests"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::tests #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/predef.h>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/lexical_cast/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/enum_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/enum_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    auto builder(f.make());\n    builder.add(e.name(), types::traits::enum_header_archetype_qn());\n    builder.add(e.name(), test_data::traits::enum_header_archetype_qn());\n\n    using ic = inclusion_constants;\n    builder.add(ic::std::string());\n    builder.add(ic::boost::test::unit_test());\n    builder.add(ic::boost::predef());\n\n    const auto io_arch(io::traits::enum_header_archetype_qn());\n    const bool io_enabled(builder.is_enabled(e.name(), io_arch));\n    if (io_enabled) {\n        builder.add(e.name(), io_arch);\n        builder.add(ic::std::sstream());\n        builder.add(ic::boost::property_tree::ptree());\n        builder.add(ic::boost::property_tree::json_parser());\n    }\n\n    const auto lc_arch(lexical_cast::traits::enum_header_archetype_qn());\n    const bool lc_enabled(builder.is_enabled(e.name(), lc_arch));\n    if (lc_enabled) {\n        builder.add(e.name(), lc_arch);\n        builder.add(ic::boost::lexical_cast());\n    }\n\n    using ser = transforms::serialization::traits;\n    const auto ser_arch(ser::enum_header_archetype_qn());\n    const bool ser_enabled(builder.is_enabled(e.name(), ser_arch));\n    if (ser_enabled) {\n        builder.add(e.name(), ser_arch);\n\n        builder.add(ic::boost::archive::text_iarchive());\n        builder.add(ic::boost::archive::text_oarchive());\n        builder.add(ic::boost::archive::binary_iarchive());\n        builder.add(ic::boost::archive::binary_oarchive());\n        builder.add(ic::boost::archive::polymorphic_iarchive());\n        builder.add(ic::boost::archive::polymorphic_oarchive());\n        builder.add(ic::boost::serialization::nvp());\n        builder.add(ic::boost::archive::xml_iarchive());\n        builder.add(ic::boost::archive::xml_oarchive());\n    }\n\n    using hash = transforms::hash::traits;\n    const auto hash_arch(hash::enum_header_archetype_qn());\n    const bool hash_enabled(builder.is_enabled(e.name(), hash_arch));\n    if (hash_enabled)\n        builder.add(e.name(), hash_arch);\n\n    return builder.build();\n}\n\nvoid enum_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& enm(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        const auto qn(ast.get_qualified_name(e.name()));\n        const auto sn(e.name().simple());\n        std::string type_name(\"auto\");\n        if (ast.is_cpp_standard_98())\n            type_name = qn;\n#>\nBOOST_AUTO_TEST_SUITE(<#= e.name().simple() #>_tests)\n\n<#+\n        /*\n         * If test data is not enabled, none of the tests can be\n         * generated. We need to insert a fake test for now. The real\n         * solution will be to filter based on element state.\n         */\n        if (!ast.is_test_data_enabled()) {\n            /*\n             * No tests.\n             */\n#>\nBOOST_AUTO_TEST_CASE(fake_test) {\n    BOOST_CHECK(true);\n}\n\n<#+\n        } else {\n            if (ast.is_io_enabled()) {\n                /*\n                 * IO tests.\n                 */\n#>\nBOOST_AUTO_TEST_CASE(inserter_operator_produces_valid_json) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n    std::stringstream s;\n    s << a;\n\n    boost::property_tree::ptree pt;\n    BOOST_REQUIRE_NO_THROW(read_json(s, pt));\n}\n\n<#+\n            }\n\n            if (ast.is_lexical_cast_enabled()) {\n                /*\n                 * Lexical cast tests.\n                 */\n#>\nBOOST_AUTO_TEST_CASE(casting_valid_strings_produces_expected_enumeration) {\n    using <#= qn #>;\n    <#= sn #> r;\n<#+\n        for (const auto& enu : enm.enumerators()) {\n            const auto enu_sn(enu.name().simple());\n            std::string enu_qn;\n            if (ast.is_cpp_standard_98())\n                enu_qn = ast.get_qualified_namespace(enm.name()) + \"::\" + enu_sn;\n            else\n                enu_qn = sn + \"::\" + enu_sn;\n#>\n\n    r = boost::lexical_cast<<#= sn #>>(std::string(\"<#= enu_sn #>\"));\n    BOOST_CHECK(r == <#= enu_qn #>);\n    r = boost::lexical_cast<<#= sn #>>(std::string(\"<#= sn + \"::\" + enu_sn #>\"));\n    BOOST_CHECK(r == <#= enu_qn #>);\n<#+\n        }\n#>\n}\n\nBOOST_AUTO_TEST_CASE(casting_invalid_string_throws) {\n    using <#= qn #>;\n    BOOST_CHECK_THROW(boost::lexical_cast<<#= sn #>>(std::string(\"DOGEN_THIS_IS_INVALID_DOGEN\")),\n        boost::bad_lexical_cast);\n}\n\nBOOST_AUTO_TEST_CASE(casting_valid_enumerations_produces_expected_strings) {\n    using <#= qn #>;\n    std::string r;\n<#+\n        for (const auto& enu : enm.enumerators()) {\n            const auto enu_sn(enu.name().simple());\n            std::string enu_qn;\n            if (ast.is_cpp_standard_98())\n                enu_qn = ast.get_qualified_namespace(enm.name()) + \"::\" + enu_sn;\n            else\n                enu_qn = sn + \"::\" + enu_sn;\n\n#>\n\n    r = boost::lexical_cast<std::string>(<#= enu_qn #>);\n    BOOST_CHECK(r == \"<#= sn + \"::\" + enu_sn #>\");\n<#+\n        }\n#>\n}\n\nBOOST_AUTO_TEST_CASE(casting_invalid_enumeration_throws) {\n#if BOOST_COMP_GNUC\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#endif\n    using <#= qn #>;\n    const <#= sn #> r(static_cast<<#= sn #>>(<#= enm.enumerators().size() + 10 #>));\n#if BOOST_COMP_GNUC\n#pragma GCC diagnostic pop\n#endif\n    BOOST_CHECK_THROW(boost::lexical_cast<std::string>(r),\n        boost::bad_lexical_cast);\n}\n\n<#+\n            }\n\n            if (ast.is_serialization_enabled()) {\n                /*\n                 * Serialization tests.\n                 */\n#>\nBOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        xml_oarchive oa(os);\n        oa << BOOST_SERIALIZATION_NVP(a);\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        xml_iarchive ia(is);\n        ia >> BOOST_SERIALIZATION_NVP(b);\n    }\n    BOOST_CHECK(a == b);\n}\n\nBOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        xml_oarchive oa(os);\n        oa << BOOST_SERIALIZATION_NVP(a);\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        xml_iarchive ia(is);\n        ia >> BOOST_SERIALIZATION_NVP(b);\n    }\n    BOOST_CHECK(a == b);\n}\n\nBOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        text_oarchive oa(os);\n        oa << a;\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        text_iarchive ia(is);\n        ia >> b;\n    }\n    BOOST_CHECK(a == b);\n}\n\n<#+\n            }\n\n             if (ast.is_hash_enabled()) {\n                 /*\n                  * hash tests.\n                  */\n#>\nBOOST_AUTO_TEST_CASE(equal_enums_generate_the_same_hash) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(a);\n\n    std::hash<<#= qn #>> hasher;\n    BOOST_CHECK(hasher(a) == hasher(b));\n}\n\nBOOST_AUTO_TEST_CASE(different_enums_generate_different_hashes) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(g());\n\n    std::hash<<#= qn #>> hasher;\n    BOOST_CHECK(hasher(a) != hasher(b));\n}\n\n<#+\n            }\n        }\n#>\nBOOST_AUTO_TEST_SUITE_END()\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::feature_template_bundle_header",
      "documentation": "Generates implementation files for feature template bundles\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_feature_template_bundle",
        "masd.wale.kvp.class.simple_name": "feature_template_bundle_header_transform",
        "masd.wale.kvp.archetype.simple_name": "feature_template_bundle_header",
        "masd.wale.kvp.meta_element": "variability_feature_template_bundle",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/string/splitter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/feature_template_bundle.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/feature_template_bundle_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/feature_template_bundle_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> feature_template_bundle_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::variability::feature_template_bundle;\n\n    const auto& fb(assistant::as<feature_template_bundle>(e));\n    auto builder(f.make());\n\n    builder.add(inclusion_constants::std::list());\n    builder.add_as_user(\"dogen.variability/types/entities/feature_template.hpp\");\n\n    if (fb.generate_static_configuration()) {\n        builder.add_as_user(\"dogen.variability/types/entities/feature_model.hpp\");\n        builder.add_as_user(\"dogen.variability/types/entities/configuration.hpp\");\n        builder.add_as_user(\"dogen.variability/types/entities/feature.hpp\");\n\n        const auto ch_arch(traits::class_header_archetype_qn());\n        builder.add(fb.transparent_associations(), ch_arch);\n\n        const auto fwd_arch(traits::class_forward_declarations_archetype_qn());\n        builder.add(fb.opaque_associations(), fwd_arch);\n    }\n\n    return builder.build();\n}\n\nvoid feature_template_bundle_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"feature template bundle header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& fb(ast.as<logical::entities::variability::feature_template_bundle>(e));\n\n    {\n        const auto sn(fb.name().simple());\n        const auto qn(ast.get_qualified_name(fb.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(fb));\n        ast.add_helper_methods(fb.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(fb.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            using utility::string::splitter;\n#>\n\n<#+\n            ast.comment(fb.documentation());\n#>\nclass <#= sn #> final {\n<#+\n            if (fb.generate_static_configuration()) {\n#>\npublic:\n    struct feature_group {\n<#+\n                for (const auto& fb_ft : fb.feature_templates()) {\n                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n#>\n        variability::entities::feature <#= simple_key #>;\n<#+\n                }\n#>\n    };\n\n    static feature_group\n    make_feature_group(const variability::entities::feature_model& fm);\n\npublic:\n    struct static_configuration {\n<#+\n                for (const auto& fb_ft : fb.feature_templates()) {\n                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n#>\n        <#= ast.get_qualified_name(fb_ft.parsed_type()) #> <#= simple_key #>;\n<#+\n                }\n\n                if (fb.requires_manual_default_constructor()) {\n                    bool is_first(true);\n                    std::ostringstream ss;\n                    for (const auto& fb_ft : fb.feature_templates()) {\n                        if (!fb_ft.parsed_type().is_current_simple_type())\n                            continue;\n\n                        const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n\n                        if (!is_first)\n                            ss << \",\" << std::endl << \"            \";\n\n                        ss << simple_key << \"()\";\n                        is_first = false;\n                    }\n#>\n\n        static_configuration() :\n            <#= ss.str() #> {}\n<#+\n                }\n#>\n    };\n\n    static static_configuration make_static_configuration(\n        const feature_group& fg,\n        const variability::entities::configuration& cfg);\n\n    template<typename Configurable>\n    static static_configuration make_static_configuration(\n        const feature_group& fg, const Configurable& c) {\n        return make_static_configuration(fg, *c.configuration());\n    }\n<#+\n            }\n\n            if (fb.generate_registration()) {\n#>\n\npublic:\n    static std::list<dogen::variability::entities::feature_template>\n    make_templates();\n<#+\n            }\n#>\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::feature_template_bundle_implementation",
      "documentation": "Generates implementation files for feature templates.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_feature_template_bundle",
        "masd.wale.kvp.class.simple_name": "feature_template_bundle_implementation_transform",
        "masd.wale.kvp.archetype.simple_name": "feature_template_bundle_implementation",
        "masd.wale.kvp.meta_element": "variability_feature_template_bundle",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/string/splitter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.variability/types/helpers/enum_mapper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/feature_template_bundle.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/feature_template_bundle_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/feature_template_bundle_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> feature_template_bundle_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::variability::feature_template_bundle;\n    const auto& fb(assistant::as<feature_template_bundle>(e));\n    auto builder(f.make());\n\n    const auto ch_arch(traits::feature_template_bundle_header_archetype_qn());\n    builder.add(fb.name(), ch_arch);\n    builder.add_as_user(\"dogen.variability/types/helpers/value_factory.hpp\");\n\n    if (fb.generate_static_configuration()) {\n        builder.add_as_user(\"dogen.variability/types/helpers/feature_selector.hpp\");\n        builder.add_as_user(\"dogen.variability/types/helpers/configuration_selector.hpp\");\n    }\n\n    return builder.build();\n}\n\nvoid feature_template_bundle_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"feature template bundle implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& ftb(ast.as<logical::entities::variability::feature_template_bundle>(e));\n\n    {\n        const auto sn(ftb.name().simple());\n        const auto qn(ast.get_qualified_name(ftb.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(ftb));\n        ast.add_helper_methods(ftb.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(ftb.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            using namespace variability::helpers;\n            using utility::string::splitter;\n\n            if (ftb.generate_registration()) {\n#>\n\nnamespace {\n<#+\n                for (const auto& ft : ftb.feature_templates()) {\n                    const auto simple_key(splitter::split_scoped(ft.key()).back());\n                    const bool has_qualified_name(simple_key != ft.key());\n#>\n\ndogen::variability::entities::feature_template\nmake_<#= ft.identifiable_key() #>() {\n    using namespace dogen::variability::entities;\n    feature_template r;\n    r.name().simple(\"<#= simple_key #>\");\n<#+\n                    if (has_qualified_name) {\n#>\n    r.name().qualified(\"<#= ft.key() #>\");\n<#+\n                    }\n#>\n    r.description(R\"(<#= ft.documentation() #>\n)\");\n    const auto vt(<#= enum_mapper::from_value_type(ft.value_type()) #>);\n    r.value_type(vt);\n    r.binding_point(<#= enum_mapper::from_binding_point(*ft.binding_point()) #>);\n    r.instantiation_domain_name(\"<#= ftb.instantiation_domain_name() #>\");\n<#+\n\n                    if (!ft.default_value().empty()) {\n#>\n    dogen::variability::helpers::value_factory f;\n    r.default_value(f.make(vt, std::list<std::string>{ <#= ft.default_value() #> }));\n<#+\n                        for (const auto& dvo : ft.default_value_overrides()) {\n#>\n    r.default_value_overrides().push_back(\n        default_value_override(\"<#= dvo.key_ends_with() #>\",\n            f.make(vt, std::list<std::string>{ <#= dvo.default_value() #> })));\n<#+\n                       }\n                   }\n#>\n    return r;\n}\n<#+\n                }\n#>\n\n}\n\n<#+\n            }\n\n            if (ftb.generate_static_configuration()) {\n#>\n<#= sn #>::feature_group\n<#= sn #>::make_feature_group(const dogen::variability::entities::feature_model& fm) {\n    feature_group r;\n    const dogen::variability::helpers::feature_selector s(fm);\n\n<#+\n                for (const auto& ft : ftb.feature_templates()) {\n                    const auto simple_key(splitter::split_scoped(ft.key()).back());\n#>\n    r.<#= simple_key #> = s.get_by_name(\"<#= ft.key() #>\");\n<#+\n                }\n#>\n\n    return r;\n}\n\n<#= sn #>::static_configuration <#= sn #>::make_static_configuration(\n    const feature_group& fg,\n    const dogen::variability::entities::configuration& cfg) {\n\n    static_configuration r;\n    const dogen::variability::helpers::configuration_selector s(cfg);\n<#+\n                for (const auto& ft : ftb.feature_templates()) {\n                    const auto simple_key(splitter::split_scoped(ft.key()).back());\n\n                    const bool has_default_value(!ft.default_value().empty());\n                    if (has_default_value) {\n#>\n    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content_or_default(fg.<#= simple_key #>);\n<#+\n                    } else if (ft.is_optional()) {\n#>\n    if (s.has_configuration_point(fg.<#= simple_key #>))\n        r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);\n<#+\n                    } else {\n#>\n    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);\n<#+\n                    }\n                }\n#>\n    return r;\n}\n<#+\n            }\n\n            if (ftb.generate_registration()) {\n\n#>\n\nstd::list<dogen::variability::entities::feature_template>\n<#= sn #>::make_templates() {\n    using namespace dogen::variability::entities;\n    std::list<dogen::variability::entities::feature_template> r;\n<#+\n\n                for (const auto& ft : ftb.feature_templates()) {\n#>\n    r.push_back(make_<#= ft.identifiable_key() #>());\n<#+\n                }\n#>\n    return r;\n}\n\n<#+\n            }\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::variability_initializer_header",
      "documentation": "Generates header files for feature bundles.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_initializer",
        "masd.wale.kvp.class.simple_name": "variability_initializer_header_transform",
        "masd.wale.kvp.archetype.simple_name": "variability_initializer_header",
        "masd.wale.kvp.meta_element": "variability_initializer",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/initializer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/variability_initializer_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/variability_initializer_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> variability_initializer_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& /*e*/) const {\n\n    using logical::entities::variability::initializer;\n    auto builder(f.make());\n    builder.add_as_user(\"dogen.variability/types/entities/feature_template.hpp\");\n    builder.add_as_user(\"dogen.variability/types/helpers/registrar.hpp\");\n\n    return builder.build();\n}\n\nvoid variability_initializer_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"variability initializer header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::variability::initializer>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Registers all of the available feature templates with registrar.\n */\nclass <#= sn #> final {\npublic:\n    static void register_entities(variability::helpers::registrar& rg);\n};\n\n<#+\n        }\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::variability_initializer_implementation",
      "documentation": "Generates header files for feature bundles.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_initializer",
        "masd.wale.kvp.class.simple_name": "variability_initializer_implementation_transform",
        "masd.wale.kvp.archetype.simple_name": "variability_initializer_implementation",
        "masd.wale.kvp.meta_element": "variability_initializer",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/initializer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/variability_initializer_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/variability_initializer_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> variability_initializer_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::variability::initializer;\n    const auto& o(assistant::as<initializer>(e));\n    auto builder(f.make());\n\n    const auto ch_arch(traits::variability_initializer_header_archetype_qn());\n    builder.add(o.name(), ch_arch);\n\n    const auto ftb_arch(traits::feature_template_bundle_header_archetype_qn());\n    builder.add(o.feature_template_bundles(), ftb_arch);\n\n    const auto fb_arch(traits::feature_bundle_header_archetype_qn());\n    builder.add(o.feature_bundles(), fb_arch);\n\n    return builder.build();\n}\n\nvoid variability_initializer_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"variability initializer implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::variability::initializer>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(o.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nvoid <#= sn #>::\nregister_entities(variability::helpers::registrar& rg) {\n<#+\n            for (const auto& n : o.feature_template_bundles())\n#>\n    rg.register_templates(<#= n.qualified().colon() #>::make_templates());\n<#+\n            if (!o.feature_bundles().empty()) {\n                for (const auto& n : o.feature_bundles())\n#>\n    rg.register_features(<#= n.qualified().colon() #>::make_features());\n<#+\n            }\n#>\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "feature_initializer",
      "stereotypes": [
        "masd::variability::initializer"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::global_features",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "tagged_values": {
        "masd.variability.generate_static_configuration": "false",
        "masd.variability.key_prefix": "masd.cpp"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "headers_output_directory",
          "type": "masd::variability::text",
          "documentation": "Override location of public c++ headers.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "directory",
          "type": "masd::variability::text",
          "value": "\"cpp\"",
          "documentation": "Directory in which to place code for the C++ backend.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "inclusion_required",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, inclusion is required for this modeling element.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "source_directory_name",
          "type": "masd::variability::text",
          "value": "\"src\"",
          "documentation": "Directory in which to place C++ source files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "include_directory_name",
          "type": "masd::variability::text",
          "value": "\"include\"",
          "documentation": "Directory in which to place include headers.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "tests_directory_name",
          "type": "masd::variability::text",
          "value": "\"generated_tests\"",
          "documentation": "Directory in which to place c++ tests.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "templates_directory_name",
          "type": "masd::variability::text",
          "value": "\"templates\"",
          "documentation": "Directory in which to place text templates.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "header_file_extension",
          "type": "masd::variability::text",
          "value": "\"hpp\"",
          "documentation": "Extension to use for C++ header files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "implementation_file_extension",
          "type": "masd::variability::text",
          "value": "\"cpp\"",
          "documentation": "Extension to use for C++ implementation files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "templates_file_extension",
          "type": "masd::variability::text",
          "value": "\"wale\"",
          "documentation": "Extension to use for text templates.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "enable_unique_file_names",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, make all file names unique within a model.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "aspect.requires_manual_default_constructor",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, the modeling element requires a manual defaul constructor.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "aspect.requires_manual_move_constructor",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, the modeling element requires a manual move constructor.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "aspect.requires_stream_manipulators",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, the modeling element requires stream manipulators.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "disable_facet_directories",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, facet directories will not be used.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "standard",
          "type": "masd::variability::text",
          "value": "\"c++-14\"",
          "documentation": "Which version of C++ to use.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "helper.family",
          "type": "masd::variability::text",
          "value": "\"Default\"",
          "documentation": "Which family of helpers to use for this modeling element.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "streaming.string_conversion_method",
          "type": "masd::variability::text",
          "value": "\"\"",
          "documentation": "Which conversion method to use to convert strings.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "streaming.requires_quoting",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, streaming this type must be preceeded by quoting.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "streaming.remove_unprintable_characters",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, streaming this type requires removing unprintable characters.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        }
      ]
    },
    {
      "name": "transforms::archetype_features",
      "stereotypes": [
        "masd::variability::feature_template_bundle"
      ],
      "tagged_values": {
        "masd.variability.default_binding_point": "element",
        "masd.variability.instantiation_domain_name": "masd.cpp.archetype"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "primary_inclusion_directive",
          "type": "masd::variability::text"
        },
        {
          "name": "secondary_inclusion_directive",
          "type": "masd::variability::text_collection"
        }
      ]
    },
    {
      "name": "transforms::lexical_cast",
      "documentation": "Formatters related to conversions from and to\nstring.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::lexical_cast::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::lexical_cast::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::lexical_cast::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.lexical_cast"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::lexical_cast #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/lexical_cast/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/lexical_cast/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/lexical_cast/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n\n    const auto eh_fn(types::traits::enum_header_archetype_qn());\n    builder.add(e.name(), eh_fn);\n    builder.add(inclusion_constants::boost::lexical_cast());\n\n    return builder.build();\n}\n\nvoid enum_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& enm(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(enm));\n        const auto qn(ast.get_qualified_name(enm.name()));\n        const auto sn(enm.name().simple());\n#>\n\nnamespace boost {\n\ntemplate<>\ninline std::string lexical_cast(const <#= qn #>& v) {\n<#+\n        if (!ast.is_cpp_standard_98()) {\n#>\n    using <#= qn #>;\n\n<#+\n        }\n#>\n    switch (v) {\n<#+\n        for (const auto& enu : enm.enumerators()) {\n            const auto enu_sn(enu.name().simple());\n            std::string enu_qn;\n            if (ast.is_cpp_standard_98())\n                enu_qn = ast.get_qualified_namespace(enm.name()) + \"::\" + enu_sn;\n            else\n                enu_qn = sn + \"::\" + enu_sn;\n#>\n    case <#= enu_qn #>:\n        return \"<#= sn + \"::\" + enu_sn #>\";\n<#+\n        }\n#>\n    default:\n        throw boost::bad_lexical_cast();\n    }\n}\n\ntemplate<>\ninline <#= qn #> lexical_cast(const std::string & s) {\n<#+\n        if (!ast.is_cpp_standard_98()) {\n#>\n    using <#= qn #>;\n\n<#+\n        }\n\n        for (const auto& enu : enm.enumerators()) {\n           const auto enu_sn(enu.name().simple());\n           std::string enu_qn;\n           if (ast.is_cpp_standard_98())\n               enu_qn = ast.get_qualified_namespace(enm.name()) + \"::\" + enu_sn;\n           else\n               enu_qn = sn + \"::\" + enu_sn;\n#>\n    if (s == \"<#= enu_sn #>\" || s == \"<#= sn + \"::\" + enu_sn #>\")\n        return <#= enu_qn #>;\n<#+\n        }\n#>\n    throw boost::bad_lexical_cast();\n}\n\n}\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "cpp_artefact_transform_header",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "class {{class.simple_name}} final : public model_to_text_transform {\npublic:\n    static physical::entities::archetype static_archetype();\n    const physical::entities::archetype& archetype() const override;\n\npublic:\n    std::list<std::string> inclusion_dependencies(\n        const formattables::dependencies_builder_factory& f,\n        const logical::entities::element& e) const override;\n\n    inclusion_support_types inclusion_support_type() const override;\n\n    boost::filesystem::path inclusion_path(\n        const formattables::locator& l,\n        const logical::entities::name& n) const override;\n\n    boost::filesystem::path full_path(\n        const formattables::locator& l,\n        const logical::entities::name& n) const override;\n\npublic:\n    void apply(const context& ctx, const logical::entities::element& e,\n        physical::entities::artefact& a) const override;\n};\n"
        }
      ]
    },
    {
      "name": "cpp_artefact_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "namespace {\n\nconst std::string transform_id(\"{{containing_namespace}}.{{class.simple_name}}\");\n\nusing namespace dogen::utility::log;\nauto lg(logger_factory(transform_id));\n\n}\n\nconst physical::entities::archetype& {{class.simple_name}}::static_archetype() {\n    static auto r({{archetype.simple_name}}_factory::make());\n    return r;\n}\n\nconst physical::entities::archetype& {{class.simple_name}}::archetype() const {\n    return static_archetype();\n}\n\ninclusion_support_types {{class.simple_name}}::inclusion_support_type() const {\n    return inclusion_support_types::not_supported;\n}\n\nboost::filesystem::path {{class.simple_name}}::inclusion_path(\n    const formattables::locator& /*l*/, const logical::entities::name& n) const {\n\n    using namespace dogen::utility::log;\n    static logger lg(logger_factory(archetype().meta_name().qualified()));\n    static const std::string not_supported(\"Inclusion path is not supported: \");\n\n    BOOST_LOG_SEV(lg, error) << not_supported << n.qualified().dot();\n    BOOST_THROW_EXCEPTION(formatting_error(not_supported + n.qualified().dot()));\n}\n\nboost::filesystem::path {{class.simple_name}}::full_path(\n    const formattables::locator& l, const logical::entities::name& n) const {\n    return l.{{locator_function}}(n, archetype().meta_name().qualified());\n}\n"
        }
      ]
    },
    {
      "name": "cpp_artefact_transform_implementation_header",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "namespace {\n\nconst std::string transform_id(\"{{containing_namespace}}.{{class.simple_name}}\");\n\nusing namespace dogen::utility::log;\nauto lg(logger_factory(transform_id));\n\n}\n\nconst physical::entities::archetype& {{class.simple_name}}::static_archetype() {\n    static auto r({{archetype.simple_name}}_factory::make());\n    return r;\n}\n\nconst physical::entities::archetype& {{class.simple_name}}::archetype() const {\n    return static_archetype();\n}\n\ninclusion_support_types {{class.simple_name}}::inclusion_support_type() const {\n    return inclusion_support_types::{{class.inclusion_support_type}};\n}\n\nboost::filesystem::path {{class.simple_name}}::inclusion_path(\n    const formattables::locator& l, const logical::entities::name& n) const {\n    return l.make_inclusion_path_for_cpp_header(n, archetype().meta_name().qualified());\n}\n\nboost::filesystem::path {{class.simple_name}}::full_path(\n    const formattables::locator& l, const logical::entities::name& n) const {\n    return l.{{locator_function}}(n, archetype().meta_name().qualified());\n}\n"
        }
      ]
    },
    {
      "name": "cpp_helper_transform_header",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "class {{class.simple_name}} : public helper_transform {\npublic:\n    std::string id() const override;\n    std::string family() const override;\n    std::list<std::string> owning_formatters() const override;\n    std::list<std::string> owning_facets() const override;\n    std::string helper_name() const override;\n    bool is_enabled(const assistant& a,\n        const formattables::helper_properties& hc) const override;\n    void apply(assistant& a,\n        const formattables::helper_properties& hc) const override;\n};\n"
        }
      ]
    },
    {
      "name": "cpp_helper_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "std::string {{class.simple_name}}::id() const {\n    static auto r(std::string(\"<\") + traits::facet_qn() + std::string(\">\") +\n        std::string(\"<\") + helper_name() + std::string(\">\"));\n    return r;\n}\n\nstd::string {{class.simple_name}}::family() const {\n    static std::string r(\"{{helper.family}}\");\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_formatters() const {\n    static auto r(std::list<std::string> {\n        io::traits::class_implementation_archetype_qn(),\n        io::traits::primitive_implementation_archetype_qn(),\n        types::traits::class_implementation_archetype_qn(),\n        types::traits::primitive_implementation_archetype_qn()\n    });\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_facets() const {\n    static auto r(std::list<std::string> {\n        io::traits::facet_qn(), types::traits::facet_qn()\n    });\n    return r;\n}\n\nstd::string {{class.simple_name}}::helper_name() const {\n    static std::string r(\"{{class.simple_name}}\");\n    return r;\n}\n\nbool {{class.simple_name}}::is_enabled(const assistant& a,\n    const formattables::helper_properties& hp) const {\n    return a.is_streaming_enabled(hp);\n}\n"
        }
      ]
    },
    {
      "name": "cpp_helper_transform_implementation_enabled",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "std::string {{class.simple_name}}::id() const {\n    static auto r(std::string(\"<\") + traits::facet_qn() + std::string(\">\") +\n        std::string(\"<\") + helper_name() + std::string(\">\"));\n    return r;\n}\n\nstd::string {{class.simple_name}}::family() const {\n    static std::string r(\"{{helper.family}}\");\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_formatters() const {\n    static auto r(std::list<std::string> {\n        traits::class_implementation_archetype_qn(),\n        traits::primitive_implementation_archetype_qn()\n    });\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_facets() const {\n    static auto r(std::list<std::string> {\n        traits::facet_qn()\n    });\n    return r;\n}\n\nstd::string {{class.simple_name}}::helper_name() const {\n    static std::string r(\"{{class.simple_name}}\");\n    return r;\n}\n\nbool {{class.simple_name}}::is_enabled(const assistant& /*a*/,\n    const formattables::helper_properties& /*hp*/) const {\n    return true;\n}\n"
        }
      ]
    },
    {
      "name": "transforms::templates",
      "documentation": "Formatters related to templating.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::templates::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::templates::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::templates::logic_less_template",
      "documentation": "Generates logic-less templates.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.templating_logic_less_templates",
        "masd.wale.kvp.class.simple_name": "logic_less_template_transform",
        "masd.wale.kvp.archetype.simple_name": "logic_less_template",
        "masd.wale.kvp.meta_element": "templating_logic_less_templates",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.templating",
        "masd.wale.kvp.locator_function": "make_full_path_for_templates",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.templates",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.referencing_status": "not_referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::templates #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/templating/logic_less_template.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/templates/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/templates/logic_less_template_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/templates/logic_less_template_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> logic_less_template_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    std::list<std::string> r;\n    return r;\n}\n\nvoid logic_less_template_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"logic less template transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    ast.update_artefact();\n    a.overwrite(false);\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::class_forward_declarations",
      "documentation": "Generates forward declarations for classes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.kvp.class.simple_name": "class_forward_declarations_transform",
        "masd.wale.kvp.archetype.simple_name": "class_forward_declarations",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.physical.referencing_status": "referable",
        "masd.wale.kvp.meta_element": "object",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/class_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/class_forward_declarations_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_forward_declarations_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid class_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class forward declarations transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= o.name().simple() #>;\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::visitor_forward_declarations",
      "documentation": "Generates forward declarations for visitors.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visitor",
        "masd.wale.kvp.class.simple_name": "visitor_forward_declarations_transform",
        "masd.wale.kvp.archetype.simple_name": "visitor_forward_declarations",
        "masd.physical.referencing_status": "referable",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.wale.kvp.meta_element": "visitor",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/visitor.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/visitor_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/visitor_forward_declarations_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> visitor_forward_declarations_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid visitor_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"visitor forward declarations transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::visitor>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= o.name().simple() #>;\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::serialization::class_forward_declarations",
      "documentation": "Generates forward declarations for classes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.kvp.class.simple_name": "class_forward_declarations_transform",
        "masd.wale.kvp.archetype.simple_name": "class_forward_declarations",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.physical.referencing_status": "referable",
        "masd.wale.kvp.meta_element": "object",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/class_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/class_forward_declarations_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_forward_declarations_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n\n    using tp = transforms::types::traits;\n    const auto tp_fn(tp::class_forward_declarations_archetype_qn());\n    builder.add(e.name(), tp_fn);\n\n    return builder.build();\n}\n\nvoid class_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class forward declarations transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        const auto qn(ast.get_qualified_name(o.name()));\n#>\n\nnamespace boost {\nnamespace serialization {\n\ntemplate<class Archive>\nvoid save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\ntemplate<class Archive>\nvoid load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::primitive_forward_declarations",
      "documentation": "Generates forward declarations for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.primitive",
        "masd.wale.kvp.class.simple_name": "primitive_forward_declarations_transform",
        "masd.wale.kvp.archetype.simple_name": "primitive_forward_declarations",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.physical.referencing_status": "referable",
        "masd.wale.kvp.meta_element": "primitive",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/primitive_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/primitive_forward_declarations_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_forward_declarations_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid primitive_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive forward declarations transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(p));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= p.name().simple() #>;\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::serialization::primitive_forward_declarations",
      "documentation": "Generates forward declarations for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.primitive",
        "masd.wale.kvp.class.simple_name": "primitive_forward_declarations_transform",
        "masd.wale.kvp.archetype.simple_name": "primitive_forward_declarations",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.physical.referencing_status": "referable",
        "masd.wale.kvp.meta_element": "primitive",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/primitive_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/primitive_forward_declarations_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_forward_declarations_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    auto builder(f.make());\n\n    using tp = transforms::types::traits;\n    const auto tp_fn(tp::primitive_forward_declarations_archetype_qn());\n    builder.add(e.name(), tp_fn);\n\n    return builder.build();\n}\n\nvoid primitive_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive forward declarations transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(p));\n        const auto qn(ast.get_qualified_name(p.name()));\n#>\n\nnamespace boost {\nnamespace serialization {\n\ntemplate<class Archive>\nvoid save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\ntemplate<class Archive>\nvoid load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::serialization::type_registrar_header",
      "documentation": "Generates header files for type registrars.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.serialization_type_registrar",
        "masd.wale.kvp.class.simple_name": "type_registrar_header_transform",
        "masd.wale.kvp.archetype.simple_name": "type_registrar_header",
        "masd.wale.kvp.meta_element": "serialization_type_registrar",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/serialization/type_registrar.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/type_registrar_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/type_registrar_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> type_registrar_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid type_registrar_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"type registrar header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& rg(ast.as<logical::entities::serialization::type_registrar>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(rg.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(e.name().simple());\n#>\n\nclass <#= sn #> {\npublic:\n\ntemplate<typename Archive>\nstatic void register_types(Archive& ar);\n\n};\n<#+\n        } // snf\n#>\n\n<#+\n\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::serialization::type_registrar_implementation",
      "documentation": "Generates header files for feature bundles.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.serialization_type_registrar",
        "masd.wale.kvp.class.simple_name": "type_registrar_implementation_transform",
        "masd.wale.kvp.archetype.simple_name": "type_registrar_implementation",
        "masd.wale.kvp.meta_element": "serialization_type_registrar",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/serialization/type_registrar.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/type_registrar_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/type_registrar_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> type_registrar_implementation_transform::\ninclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    const auto& rg(assistant::as<logical::entities::serialization::type_registrar>(e));\n    auto builder(f.make());\n\n    const auto rh_fn(traits::type_registrar_header_archetype_qn());\n    builder.add(rg.name(), rh_fn);\n\n    using ic = inclusion_constants;\n    builder.add(ic::boost::archive::text_iarchive());\n    builder.add(ic::boost::archive::text_oarchive());\n    builder.add(ic::boost::archive::binary_iarchive());\n    builder.add(ic::boost::archive::binary_oarchive());\n    builder.add(ic::boost::archive::polymorphic_iarchive());\n    builder.add(ic::boost::archive::polymorphic_oarchive());\n\n    // XML serialisation\n    builder.add(ic::boost::archive::xml_iarchive());\n    builder.add(ic::boost::archive::xml_oarchive());\n\n    const auto ch_fn(traits::class_header_archetype_qn());\n    builder.add(rg.leaves(), ch_fn);\n\n    const auto carch(traits::canonical_archetype());\n    builder.add(rg.registrar_dependencies(), carch);\n    return builder.build();\n}\n\nvoid type_registrar_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n   physical::entities::artefact& a) const {\n   tracing::scoped_transform_tracer stp(lg, \"type registrar implementationtransform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& rg(ast.as<logical::entities::serialization::type_registrar>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(rg.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto deps(rg.registrar_dependencies());\n            const auto carch(traits::canonical_archetype());\n            const auto leaves(ast.names_with_enabled_archetype(carch, rg.leaves()));\n            const bool has_types(!deps.empty() || !leaves.empty());\n            const std::string arg_name(has_types ? \" ar\" : \"\");\n            const auto sn(e.name().simple());\n#>\n\ntemplate<typename Archive>\nvoid <#= sn #>::register_types(Archive&<#= arg_name #>) {\n<#+\n            if (has_types) {\n                for (const auto& d : deps) {\n                    const auto dqn(ast.get_qualified_name(d));\n#>\n    <#= dqn #>::register_types(ar);\n<#+\n                }\n\n                if (!deps.empty() && !leaves.empty())\n#>\n\n<#+\n                for (const auto& l : leaves) {\n                    const auto lqn(ast.get_qualified_name(l));\n#>\n    ar.template register_type<<#= lqn #>>();\n<#+\n                }\n            }\n#>\n}\n\ntemplate void <#= sn #>::register_types(boost::archive::polymorphic_oarchive&<#= arg_name #>);\ntemplate void <#= sn #>::register_types(boost::archive::polymorphic_iarchive&<#= arg_name #>);\n\ntemplate void <#= sn #>::register_types(boost::archive::text_oarchive&<#= arg_name #>);\ntemplate void <#= sn #>::register_types(boost::archive::text_iarchive&<#= arg_name #>);\n\ntemplate void <#= sn #>::register_types(boost::archive::binary_oarchive&<#= arg_name #>);\ntemplate void <#= sn #>::register_types(boost::archive::binary_iarchive&<#= arg_name #>);\n\ntemplate void <#= sn #>::register_types(boost::archive::xml_oarchive&<#= arg_name #>);\ntemplate void <#= sn #>::register_types(boost::archive::xml_iarchive&<#= arg_name #>);\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "registrar",
      "stereotypes": [
        "masd::serialization::type_registrar"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio",
      "documentation": "Formatters related to Visual Studio support.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::visual_studio::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::project",
      "documentation": "Generates visual studio project.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visual_studio_project",
        "masd.wale.kvp.class.simple_name": "project_transform",
        "masd.wale.kvp.archetype.simple_name": "project",
        "masd.wale.kvp.meta_element": "visual_studio_project",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.project",
        "masd.wale.kvp.locator_function": "make_full_path_for_visual_studio_project",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.visual_studio",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.referencing_status": "not_referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::visual_studio #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/visual_studio/project.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/visual_studio/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/visual_studio/project_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/visual_studio/project_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> project_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid project_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"project transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    using logical::entities::visual_studio::project;\n    const auto& proj(ast.as<project>(e));\n\n#>\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProjectGuid>{<#= proj.guid() #>}</ProjectGuid>\n    <OutputType>Library</OutputType>\n    <RootNamespace><#= proj.project_name() #></RootNamespace>\n    <AssemblyName><#= proj.project_name() #></AssemblyName>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug</OutputPath>\n    <DefineConstants>DEBUG;</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <ConsolePause>false</ConsolePause>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <DebugType>full</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release</OutputPath>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <ConsolePause>false</ConsolePause>\n  </PropertyGroup>\n  <ItemGroup>\n    <Reference Include=\"System\" />\n  </ItemGroup>\n<#+\n        for (const auto& ig : proj.item_groups()) {\n#>\n  <ItemGroup>\n<#+\n            for (const auto& i : ig.items())\n#>\n    <<#= i.name() #> Include=\"<#= i.include() #>\" />\n  </ItemGroup>\n<#+\n        }\n#>\n  <Import Project=\"$(MSBuildBinPath)\\Microsoft.Cpp.targets\" />\n</Project>\n<#+\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::visual_studio::solution",
      "documentation": "Generates visual studio solutions.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visual_studio_solution",
        "masd.wale.kvp.class.simple_name": "solution_transform",
        "masd.wale.kvp.archetype.simple_name": "solution",
        "masd.wale.kvp.meta_element": "visual_studio_solution",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.project",
        "masd.wale.kvp.locator_function": "make_full_path_for_visual_studio_solution",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.visual_studio",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.referencing_status": "not_referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::visual_studio #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/visual_studio/solution.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/visual_studio/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/visual_studio/solution_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/visual_studio/solution_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> solution_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid solution_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"solution transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    using logical::entities::visual_studio::solution;\n    const auto& sln(ast.as<solution>(e));\n#>\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 2012\n<#+\n    for (const auto& ppb : sln.project_persistence_blocks()) {\n#>\nProject(\"{<#= ppb.type_guid() #>}\") = \"<#= ppb.name() #>\", \"<#= ppb.name() #>.csproj\", \"{<#= ppb.guid() #>}\"\nEndProject\n<#+\n    }\n#>\nGlobal\n    GlobalSection(SolutionConfigurationPlatforms) = preSolution\n        Debug|Any CPU = Debug|Any CPU\n        Release|Any CPU = Release|Any CPU\n    EndGlobalSection\n    GlobalSection(ProjectConfigurationPlatforms) = postSolution\n<#+\n    for (const auto& ppb : sln.project_persistence_blocks()) {\n#>\n        {<#= ppb.guid() #>}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n        {<#= ppb.guid() #>}.Debug|Any CPU.Build.0 = Debug|Any CPU\n        {<#= ppb.guid() #>}.Release|Any CPU.ActiveCfg = Release|Any CPU\n        {<#= ppb.guid() #>}.Release|Any CPU.Build.0 = Release|Any CPU\n<#+\n    }\n#>\n    EndGlobalSection\n    GlobalSection(MonoDevelopProperties) = preSolution\n        StartupItem = CppModel.vcxroj\n    EndGlobalSection\nEndGlobal\n<#+\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::tests::main",
      "documentation": "Generates entry point for tests.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::tests_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.entry_point",
        "masd.wale.kvp.class.simple_name": "main_transform",
        "masd.wale.kvp.archetype.simple_name": "main",
        "masd.wale.kvp.meta_element": "entry_point",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.tests"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::tests #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/entry_point.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/main_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/main_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> main_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& /*e*/) const {\n\n    using logical::entities::structural::object;\n    auto builder(f.make());\n\n    using ic = inclusion_constants;\n    builder.add(ic::boost::test::unit_test());\n    builder.add(ic::boost::test::unit_test_monitor());\n    builder.add(ic::boost::exception::info());\n    builder.add(ic::std::iostream());\n    builder.add(ic::boost::exception::diagnostic_information());\n\n    return builder.build();\n}\n\nvoid main_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"main transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    using logical::entities::structural::entry_point;\n    const auto& ep(ast.as<entry_point>(e));\n    const auto qn(ast.get_qualified_name(ep.name()));\n#>\n#define BOOST_TEST_MODULE <#= qn #>\n\n<#+\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(ep));\n#>\n\nnamespace  {\n\nconst std::string error_msg(\"Error during test.\");\n\ninline void translate(const boost::exception& e) {\n    std::cerr << std::endl << boost::diagnostic_information(e);\n    throw std::runtime_error(error_msg);\n}\n\nstruct exception_fixture {\n    exception_fixture() {\n        using boost::exception;\n        using boost::unit_test::unit_test_monitor;\n        unit_test_monitor.register_exception_translator<exception>(&translate);\n    }\n};\n\n}\n\nBOOST_GLOBAL_FIXTURE(exception_fixture);\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::odb::object_odb_options",
      "documentation": "Generates object options for odb.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.kvp.class.simple_name": "object_odb_options_transform",
        "masd.wale.kvp.archetype.simple_name": "object_odb_options",
        "masd.wale.kvp.meta_element": "object",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.implementation",
        "masd.wale.kvp.locator_function": "make_full_path_for_odb_options",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.odb",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.referencing_status": "not_referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/object_odb_options_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/object_odb_options_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> object_odb_options_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid object_odb_options_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"object odb options transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto ts(logical::entities::technical_space::odb);\n        ast.make_decoration_preamble(e, ts);\n\n        if (!o.orm_properties()) {\n#>\n\n#\n# class has no ODB options defined.\n#\n<#+\n        } else {\n            const auto ooo(o.orm_properties()->odb_options());\n#>\n# epilogue\n--odb-epilogue <#= ooo.epilogue() #>\n\n<#+\n            if (!ooo.include_regexes().empty()) {\n#>\n# regexes\n<#+\n                for (const auto& regex : ooo.include_regexes())\n#>\n--include-regex <#= regex #>\n\n# debug regexes\n# --include-regex-trace\n\n# make the header guards similar to dogen ones\n--guard-prefix <#= ooo.header_guard_prefix() #>\n<#+\n            }\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::odb::primitive_odb_options",
      "documentation": "Generates object options for odb.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.primitive",
        "masd.wale.kvp.class.simple_name": "primitive_odb_options_transform",
        "masd.wale.kvp.archetype.simple_name": "primitive_odb_options",
        "masd.wale.kvp.meta_element": "primitive",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.implementation",
        "masd.wale.kvp.locator_function": "make_full_path_for_odb_options",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.odb",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.referencing_status": "not_referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/primitive_odb_options_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/primitive_odb_options_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_odb_options_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid primitive_odb_options_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive odb options transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    {\n        const auto ts(logical::entities::technical_space::odb);\n        ast.make_decoration_preamble(e, ts);\n\n        if (!p.orm_properties()) {\n#>\n\n#\n# class has no ODB options defined.\n#\n<#+\n        } else {\n            const auto ooo(p.orm_properties()->odb_options());\n#>\n# epilogue\n--odb-epilogue <#= ooo.epilogue() #>\n\n<#+\n            if (!ooo.include_regexes().empty()) {\n#>\n# regexes\n<#+\n                for (const auto& regex : ooo.include_regexes())\n#>\n--include-regex <#= regex #>\n\n# debug regexes\n# --include-regex-trace\n\n# make the header guards similar to dogen ones\n--guard-prefix <#= ooo.header_guard_prefix() #>\n<#+\n            }\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::main",
      "documentation": "Generates implementation file for entry point.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.entry_point",
        "masd.wale.kvp.class.simple_name": "main_transform",
        "masd.wale.kvp.archetype.simple_name": "main",
        "masd.wale.kvp.meta_element": "entry_point",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/entry_point.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/main_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/main_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> main_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid main_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"main transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::entry_point>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nint main(int /*argc*/, char* /*argv*/[]) {\n    return 0;\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "main",
      "stereotypes": [
        "masd::entry_point",
        "dogen::untypable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::common_odb_options",
      "documentation": "Generates object options for odb.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.orm_common_odb_options",
        "masd.wale.kvp.class.simple_name": "common_odb_options_transform",
        "masd.wale.kvp.archetype.simple_name": "common_odb_options",
        "masd.wale.kvp.meta_element": "orm_common_odb_options",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.implementation",
        "masd.wale.kvp.locator_function": "make_full_path_for_odb_options",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.odb",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.referencing_status": "not_referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/orm/common_odb_options.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/common_odb_options_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/odb/common_odb_options_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> common_odb_options_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid common_odb_options_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"common odb options transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    using logical::entities::orm::common_odb_options;\n    const auto& o(ast.as<common_odb_options>(e));\n\n    {\n        const auto ts(logical::entities::technical_space::odb);\n        ast.make_decoration_preamble(e, ts);\n\n        if (!ast.is_cpp_standard_98()) {\n#>\n# enable C++11\n--std c++11\n\n<#+\n        }\n\n        if (!o.sql_name_case().empty()) {\n#>\n# casing\n--sql-name-case <#= o.sql_name_case() #>\n\n<#+\n        }\n\n        if (o.databases().size() > 1) {\n#>\n# enable multi-database support\n--multi-database static\n\n<#+\n        }\n\n        if (!o.databases().empty()) {\n#>\n# target databases\n<#+\n\n            for (const auto& d : o.databases())\n#>\n--database <#= d #>\n\n<#+\n        }\n#>\n# use the boost profile\n--profile boost\n\n# generate queries and embedded schemas\n--generate-query\n--generate-schema\n--schema-format embedded\n\n# force odb extensions to be different from dogen ones just in case.\n--ixx-suffix .ixx\n--hxx-suffix .hxx\n--cxx-suffix .cxx\n\n# debug regexes\n# --include-regex-trace\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::visual_studio::msbuild_targets",
      "documentation": "Generates msbuild targets.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visual_studio_msbuild_targets",
        "masd.wale.kvp.class.simple_name": "msbuild_targets_transform",
        "masd.wale.kvp.archetype.simple_name": "msbuild_targets",
        "masd.wale.kvp.meta_element": "visual_studio_msbuild_targets",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.project",
        "masd.wale.kvp.locator_function": "make_full_path_for_msbuild_targets",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.visual_studio",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.referencing_status": "not_referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::visual_studio #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/visual_studio/msbuild_targets.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/visual_studio/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/visual_studio/msbuild_targets_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/visual_studio/msbuild_targets_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> msbuild_targets_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid msbuild_targets_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"msbuild targets transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    using logical::entities::visual_studio::msbuild_targets;\n    const auto& c(ast.as<msbuild_targets>(e));\n\n    {\n        const auto ts(logical::entities::technical_space::xml);\n        ast.make_decoration_preamble(e, ts);\n        const auto model_name(ast.get_identifiable_model_name(c.name()));\n        const auto product_name(ast.get_product_name(c.name()));\n        const auto targets(c.odb_targets());\n#>\n<Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" ToolsVersion=\"4.0\">\n\n    <!--[\n        .NAME: odb.targets\n\n        .SYNOPSIS:\n            Generates all of the ODB files for this project.\n\n        .DESCRIPTION:\n            Calls the ODB compiler against each of the files in this Dogen model that require\n            ODB compilation. Also moves the generated files to their correct location.\n\n        .INPUTS:\n\n        .OUTPUTS:\n    ]-->\n    <Target Name=\"<#= targets.main_target_name() #>\"\n<#+\n            utility::formatters::sequence_formatter sf(targets.targets().size());\n            sf.prefix_configuration().first(\"          DependsOnTargets=\\\"\")\n                                     .not_first(\"                            \");\n            sf.postfix_configuration().last(\"\\\">\");\n            sf.element_separator(\";\");\n            for (const auto& target : targets.targets()) {\n#>\n<#= sf.prefix() #><#= target.name() #><#= sf.postfix() #>\n<#+\n                sf.next();\n            }\n#>\n        <Message Importance=\"high\" Text=\"ODB <#= model_name #> \"/>\n    </Target>\n\n<#+\n            for (const auto& target : targets.targets()) {\n#>\n    <Target Name=\"<#= target.name() #>\">\n        <Message Importance=\"high\" Text=\"<#= target.comment() #>\"/>\n        <Exec WorkingDirectory=\"$(OutputDirectory)\" Command=\"&quot;$(OdbPath)&quot; -D_SECURE_SCL=0 $(OdbIncludeDirectories) --options-file $(MSBuildThisFileDirectory)<#= targets.common_odb_options() #> --options-file $(MSBuildThisFileDirectory)<#= target.object_odb_options() #> --output-dir $(MSBuildThisFileDirectory)<#= target.output_directory() #> $(MSBuildThisFileDirectory)<#= target.types_file() #>\" />\n<#+\n                for (const auto& pair : target.move_parameters()) {\n#>\n        <Move\n            SourceFiles=\"$(MSBuildThisFileDirectory)<#= pair.first #>\"\n            DestinationFolder=\"$(MSBuildThisFileDirectory)<#= pair.second #>\" />\n<#+\n                }\n#>\n    </Target>\n<#+\n            }\n#>\n</Project>\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::build",
      "documentation": "Formatters related to build files.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::build::source_cmakelists",
      "documentation": "Generates cmakelists for tests.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.build_cmakelists",
        "masd.wale.kvp.class.simple_name": "source_cmakelists_transform",
        "masd.wale.kvp.archetype.simple_name": "source_cmakelists",
        "masd.wale.kvp.meta_element": "build_cmakelists",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.project",
        "masd.wale.kvp.locator_function": "make_full_path_for_source_cmakelists",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.build",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.referencing_status": "not_referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::build #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/build/cmakelists.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/build/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/build/source_cmakelists_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/build/source_cmakelists_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> source_cmakelists_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid source_cmakelists_transform::apply(const context& ctx,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"source cmakelists transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    using logical::entities::build::cmakelists;\n    const auto& c(ast.as<cmakelists>(e));\n\n    {\n        const auto ts(logical::entities::technical_space::cmake);\n        ast.make_decoration_preamble(e, ts);\n        const auto model_name(ast.get_dot_separated_model_name(c.name()));\n        const auto product_name(ast.get_product_name(c.name()));\n#>\nset(name \"<#= model_name #>\")\nset(lib_binary_name ${name})\nset(lib_target_name ${name}.lib)\n\nset(files \"\")\nfile(GLOB_RECURSE files RELATIVE\n    \"${CMAKE_CURRENT_SOURCE_DIR}/\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/*.<#= c.implementation_file_extension() #>\")\n\n<#+\n        if (ast.is_odb_facet_enabled() && !c.odb_targets().targets().empty()) {\n#>\nset(odb_files \"\")\nfile(GLOB_RECURSE odb_files RELATIVE\n   \"${CMAKE_CURRENT_SOURCE_DIR}/\"\n   \"${CMAKE_CURRENT_SOURCE_DIR}/*.cxx\")\nset(files ${files} ${odb_files})\n\n<#+\n        }\n#>\nset(lib_files ${files})\nadd_library(${lib_target_name} ${lib_files})\nset_target_properties(${lib_target_name} PROPERTIES\n<#+\n        if (ast.is_cpp_standard_98()) {\n#>\n    CXX_STANDARD 98\n<#+\n        }\n#>\n    OUTPUT_NAME ${lib_binary_name})\n\ninstall(TARGETS ${lib_target_name}\n    ARCHIVE DESTINATION lib\n    LIBRARY DESTINATION lib\n    COMPONENT libraries)\n<#+\n        if (ast.is_odb_facet_enabled() && !c.odb_targets().targets().empty()) {\n            const auto targets(c.odb_targets());\n#>\n\n#\n# ODB Executable Targets\n#\nif (ODB_EXECUTABLE)\n    # Top-level targets\n    add_custom_target(<#= targets.main_target_name() #>)\n    add_dependencies(odb_all <#= targets.main_target_name() #>)\n\n    if (NOT ODB_EXECUTABLE_GLOBAL_ARGS)\n        message(WARNING \"ODB_EXECUTABLE_GLOBAL_ARGS not defined. Inclusion errors likely when running ODB targets.\")\n    endif()\n\n<#+\n            for (const auto& target : targets.targets()) {\n#>\n\n    add_custom_target(<#= target.name() #>\n        COMMENT \"<#= target.comment() #>\"\n        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n        COMMAND ${ODB_EXECUTABLE}\n            --options-file ${CMAKE_CURRENT_SOURCE_DIR}/<#= targets.common_odb_options() #>\n            --options-file ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.object_odb_options() #>\n            --output-dir ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.output_directory() #>\n            ${ODB_EXECUTABLE_GLOBAL_ARGS}\n            ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.types_file() #>\n<#+\n                for (const auto& pair : target.move_parameters())\n#>\n        COMMAND mv ${CMAKE_CURRENT_SOURCE_DIR}/<#= pair.first #> ${CMAKE_CURRENT_SOURCE_DIR}/<#= pair.second #>\n        VERBATIM\n    )\n    add_dependencies(<#= targets.main_target_name() #> <#= target.name() #>)\n<#+\n            }\n#>\nendif()\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::build::include_cmakelists",
      "documentation": "Generates cmakelists for tests.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.build_cmakelists",
        "masd.wale.kvp.class.simple_name": "include_cmakelists_transform",
        "masd.wale.kvp.archetype.simple_name": "include_cmakelists",
        "masd.wale.kvp.meta_element": "build_cmakelists",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.project",
        "masd.wale.kvp.locator_function": "make_full_path_for_include_cmakelists",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.build",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.referencing_status": "not_referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::build #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/build/cmakelists.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/build/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/build/include_cmakelists_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/build/include_cmakelists_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> include_cmakelists_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid include_cmakelists_transform::apply(const context& ctx,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"include cmakelists transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    using logical::entities::build::cmakelists;\n    const auto& c(ast.as<cmakelists>(e));\n\n    {\n        const auto ts(logical::entities::technical_space::cmake);\n        ast.make_decoration_preamble(e, ts);\n#>\nadd_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/<#= c.source_directory_name() #>)\n<#+\n       if (ast.is_tests_enabled()) {\n#>\nadd_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/<#= c.tests_directory_name() #>)\n<#+\n       }\n#>\n\ninstall(\n    DIRECTORY <#= c.include_directory_path() #>/\n    DESTINATION <#= c.include_directory_path() #>/\n    COMPONENT headers\n    FILES_MATCHING PATTERN \"*.<#= c.header_file_extension() #>\")\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::build::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::build::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests::cmakelists",
      "documentation": "Generates cmakelists for tests.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.build_cmakelists",
        "masd.wale.kvp.class.simple_name": "cmakelists_transform",
        "masd.wale.kvp.archetype.simple_name": "cmakelists",
        "masd.wale.kvp.meta_element": "build_cmakelists",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.testing",
        "masd.wale.kvp.locator_function": "make_full_path_for_tests_cmakelists",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.tests",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.referencing_status": "not_referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::tests #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/build/cmakelists.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/cmakelists_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/tests/cmakelists_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> cmakelists_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid cmakelists_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"cmakelists transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    using logical::entities::build::cmakelists;\n    const auto& c(ast.as<cmakelists>(e));\n\n    {\n\n        const auto ts(logical::entities::technical_space::cmake);\n        ast.make_decoration_preamble(e, ts);\n        const auto model_name(ast.get_dot_separated_model_name(c.name()));\n        const auto product_name(ast.get_product_name(c.name()));\n#>\nset(name \"<#= model_name #>\")\nset(lib_target_name ${name}.lib)\nset(tests_binary_name ${name}.<#= c.tests_directory_name() #>)\nset(tests_target_name ${name}.<#= c.tests_directory_name() #>)\n\nset(files \"\")\nfile(GLOB_RECURSE files RELATIVE\n    \"${CMAKE_CURRENT_SOURCE_DIR}/\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/*.<#= c.implementation_file_extension() #>\")\n\nadd_executable(${tests_target_name} ${files})\n\nset_target_properties(${tests_target_name} PROPERTIES\n<#+\n        if (ast.is_cpp_standard_98()) {\n#>\n    CXX_STANDARD 98\n<#+\n        }\n#>\n    OUTPUT_NAME ${tests_binary_name})\n\n<#+\n        if (ast.is_cpp_standard_98()) {\n#>\ntarget_compile_options(${tests_target_name} PRIVATE\n    $<$<OR:$<CXX_COMPILER_ID:Clang>,$<CXX_COMPILER_ID:AppleClang>,$<CXX_COMPILER_ID:GNU>>:\n    -Wno-c99-extensions>)\n<#+\n        }\n#>\n\ntarget_link_libraries(${tests_target_name}\n    ${lib_target_name}\n    ${CMAKE_REQUIRED_LIBRARIES}\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${Boost_LIBRARIES})\n\nset(command $<TARGET_FILE:${tests_target_name}> ${boost_test_parameters})\n\nadd_custom_target(run_${tests_target_name}\n    COMMENT \"Running ${tests_target_name}\" VERBATIM\n    COMMAND ${command}\n    WORKING_DIRECTORY ${stage_bin_dir}\n    DEPENDS ${tests_target_name})\n\nadd_dependencies(run_all_tests run_${tests_target_name})\n\nif(WITH_BENCHMARKS)\n    set(benchmark_file\n        ${benchmark_directory}/${benchmark_prefix}${tests_target_name}.csv)\n    add_custom_target(benchmark_${tests_target_name}\n        COMMENT \"Benchmarking testing ${tests_target_name}\" VERBATIM\n        COMMAND ${benchmark_command} ${benchmark_repeats} ${benchmark_file}\n        ${command}\n        WORKING_DIRECTORY ${stage_bin_dir}\n        DEPENDS ${tests_target_name})\n\n    add_dependencies(benchmark_all benchmark_${tests_target_name})\nendif()\n\nadd_boost_tests(${tests_binary_name} ${files})\n\ninstall(TARGETS ${tests_target_name} RUNTIME DESTINATION bin COMPONENT tests)\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "CMakeLists",
      "stereotypes": [
        "masd::build::cmakelists",
        "dogen::handcrafted::cmake"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::feature_bundle_header",
      "documentation": "Generates header files for feature bundles.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_feature_bundle",
        "masd.wale.kvp.class.simple_name": "feature_bundle_header_transform",
        "masd.wale.kvp.archetype.simple_name": "feature_bundle_header",
        "masd.wale.kvp.meta_element": "variability_feature_bundle",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/string/splitter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/feature_bundle.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/feature_bundle_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/feature_bundle_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> feature_bundle_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::variability::feature_bundle;\n\n    const auto& fb(assistant::as<feature_bundle>(e));\n    auto builder(f.make());\n\n    builder.add(inclusion_constants::std::list());\n    builder.add_as_user(\"dogen.variability/types/entities/feature.hpp\");\n\n    if (fb.generate_static_configuration()) {\n        builder.add_as_user(\"dogen.variability/types/entities/feature_model.hpp\");\n        builder.add_as_user(\"dogen.variability/types/entities/configuration.hpp\");\n\n        const auto ch_arch(traits::class_header_archetype_qn());\n        builder.add(fb.transparent_associations(), ch_arch);\n\n        const auto fwd_arch(traits::class_forward_declarations_archetype_qn());\n        builder.add(fb.opaque_associations(), fwd_arch);\n    }\n\n    return builder.build();\n}\n\nvoid feature_bundle_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"feature bundle header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& fb(ast.as<logical::entities::variability::feature_bundle>(e));\n\n    {\n        const auto sn(fb.name().simple());\n        const auto qn(ast.get_qualified_name(fb.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(fb));\n        ast.add_helper_methods(fb.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(fb.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            using utility::string::splitter;\n#>\n\n<#+\n            ast.comment(fb.documentation());\n#>\nclass <#= sn #> final {\n<#+\n            if (fb.generate_static_configuration()) {\n#>\npublic:\n    struct feature_group {\n<#+\n                for (const auto& fb_ft : fb.features()) {\n                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n#>\n        variability::entities::feature <#= simple_key #>;\n<#+\n                }\n#>\n    };\n\n    static feature_group\n    make_feature_group(const variability::entities::feature_model& fm);\n\npublic:\n    struct static_configuration {\n<#+\n                for (const auto& fb_ft : fb.features()) {\n                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n#>\n        <#= ast.get_qualified_name(fb_ft.parsed_type()) #> <#= simple_key #>;\n<#+\n                }\n\n                if (fb.requires_manual_default_constructor()) {\n                    bool is_first(true);\n                    std::ostringstream ss;\n                    for (const auto& fb_ft : fb.features()) {\n                        if (!fb_ft.parsed_type().is_current_simple_type())\n                            continue;\n\n                        const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n\n                        if (!is_first)\n                            ss << \",\" << std::endl << \"            \";\n\n                        ss << simple_key << \"()\";\n                        is_first = false;\n                    }\n#>\n\n        static_configuration() :\n            <#= ss.str() #> {}\n<#+\n                }\n#>\n    };\n\n    static static_configuration make_static_configuration(\n        const feature_group& fg,\n        const variability::entities::configuration& cfg);\n\n    template<typename Configurable>\n    static static_configuration make_static_configuration(\n        const feature_group& fg, const Configurable& c) {\n        return make_static_configuration(fg, *c.configuration());\n    }\n<#+\n            }\n#>\n\n<#+\n            if (fb.generate_registration()) {\n#>\npublic:\n    static std::list<dogen::variability::entities::feature>\n    make_features();\n<#+\n            }\n#>\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::feature_bundle_implementation",
      "documentation": "Generates implementation files for feature bundles.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_feature_bundle",
        "masd.wale.kvp.class.simple_name": "feature_bundle_implementation_transform",
        "masd.wale.kvp.archetype.simple_name": "feature_bundle_implementation",
        "masd.wale.kvp.meta_element": "variability_feature_bundle",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/string/splitter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.variability/types/helpers/enum_mapper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/feature_bundle.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/feature_bundle_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/feature_bundle_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> feature_bundle_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::variability::feature_bundle;\n    const auto& fb(assistant::as<feature_bundle>(e));\n    auto builder(f.make());\n\n    const auto ch_arch(traits::feature_bundle_header_archetype_qn());\n    builder.add(fb.name(), ch_arch);\n    builder.add_as_user(\"dogen.variability/types/helpers/value_factory.hpp\");\n\n    if (fb.generate_static_configuration()) {\n        builder.add_as_user(\"dogen.variability/types/helpers/feature_selector.hpp\");\n        builder.add_as_user(\"dogen.variability/types/helpers/configuration_selector.hpp\");\n    }\n\n    return builder.build();\n}\n\nvoid feature_bundle_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"feature bundle implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& fb(ast.as<logical::entities::variability::feature_bundle>(e));\n\n    {\n        const auto sn(fb.name().simple());\n        const auto qn(ast.get_qualified_name(fb.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(fb));\n        ast.add_helper_methods(fb.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(fb.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            using namespace variability::helpers;\n            using utility::string::splitter;\n\n            if (fb.generate_registration()) {\n#>\n\nnamespace {\n<#+\n                for (const auto& f : fb.features()) {\n                    const auto simple_key(splitter::split_scoped(f.key()).back());\n                    const bool has_qualified_name(simple_key != f.key());\n#>\n\ndogen::variability::entities::feature\nmake_<#= f.identifiable_key() #>() {\n    using namespace dogen::variability::entities;\n    feature r;\n    r.name().simple(\"<#= simple_key #>\");\n<#+\n                   if (has_qualified_name) {\n#>\n    r.name().qualified(\"<#= f.key() #>\");\n<#+\n                   }\n#>\n    r.description(R\"(<#= f.documentation() #>\n)\");\n    const auto vt(<#= enum_mapper::from_value_type(f.value_type()) #>);\n    r.value_type(vt);\n<#+\n                   if (f.unparsed_type() == \"masd::variability::key_value_pair\") {\n#>\n    r.is_partially_matchable(true);\n<#+\n                   }\n#>\n    r.binding_point(<#= enum_mapper::from_binding_point(*f.binding_point()) #>);\n<#+\n                   if (!f.default_value().empty()) {\n#>\n    dogen::variability::helpers::value_factory f;\n    r.default_value(f.make(vt, std::list<std::string>{ <#= f.default_value() #> }));\n<#+\n                   }\n#>\n    return r;\n}\n<#+\n                }\n#>\n\n}\n\n<#+\n            }\n\n            if (fb.generate_static_configuration()) {\n#>\n<#= sn #>::feature_group\n<#= sn #>::make_feature_group(const dogen::variability::entities::feature_model& fm) {\n    feature_group r;\n    const dogen::variability::helpers::feature_selector s(fm);\n\n<#+\n                for (const auto& f : fb.features()) {\n                    const auto simple_key(splitter::split_scoped(f.key()).back());\n#>\n    r.<#= simple_key #> = s.get_by_name(\"<#= f.key() #>\");\n<#+\n                }\n#>\n\n    return r;\n}\n\n<#= sn #>::static_configuration <#= sn #>::make_static_configuration(\n    const feature_group& fg,\n    const dogen::variability::entities::configuration& cfg) {\n\n    static_configuration r;\n    const dogen::variability::helpers::configuration_selector s(cfg);\n<#+\n                for (const auto& f : fb.features()) {\n                    const auto simple_key(splitter::split_scoped(f.key()).back());\n\n                    const bool has_default_value(!f.default_value().empty());\n                    if (has_default_value) {\n#>\n    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content_or_default(fg.<#= simple_key #>);\n<#+\n                    } else if (f.is_optional()) {\n#>\n    if (s.has_configuration_point(fg.<#= simple_key #>))\n        r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);\n<#+\n                    } else {\n#>\n    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);\n<#+\n                    }\n                }\n#>\n    return r;\n}\n<#+\n            }\n\n            if (fb.generate_registration()) {\n#>\n\nstd::list<dogen::variability::entities::feature>\n<#= sn #>::make_features() {\n    using namespace dogen::variability::entities;\n    std::list<dogen::variability::entities::feature> r;\n<#+\n\n                for (const auto& f : fb.features()) {\n#>\n    r.push_back(make_<#= f.identifiable_key() #>());\n<#+\n                }\n#>\n    return r;\n}\n\n<#+\n            }\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::archetype_class_header_transform",
      "documentation": "Generates header files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype",
        "masd.wale.kvp.class.simple_name": "archetype_class_header_transform_transform",
        "masd.wale.kvp.archetype.simple_name": "archetype_class_header_transform",
        "masd.wale.kvp.meta_element": "physical_archetype",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types",
        "masd.label.a_labelz": "a,b,c"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_class_header_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_class_header_transform_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> archetype_class_header_transform_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    const auto& arch(assistant::as<logical::entities::physical::archetype>(e));\n\n    auto builder(f.make());\n    using logical::entities::technical_space;\n    if (arch.major_technical_space() == technical_space::cpp) {\n        builder.add_as_user(\n            \"dogen.text.cpp/types/transforms/model_to_text_transform.hpp\");\n    } else if (arch.major_technical_space() == technical_space::csharp) {\n        builder.add_as_user(\n            \"dogen.text.csharp/types/transforms/model_to_text_transform.hpp\");\n    }\n\n    return builder.build();\n}\n\nvoid archetype_class_header_transform_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"types archetype class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::physical::archetype>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(o.name().simple() + \"_transform\");\n#>\n\nclass <#= sn #> final : public model_to_text_transform {\npublic:\n    static const physical::entities::archetype& static_archetype();\n    const physical::entities::archetype& archetype() const override;\n\npublic:\n<#+\n            using logical::entities::technical_space;\n            if (o.major_technical_space() == technical_space::cpp) {\n#>\n    std::list<std::string> inclusion_dependencies(\n        const formattables::dependencies_builder_factory& f,\n        const logical::entities::element& e) const override;\n\n    inclusion_support_types inclusion_support_type() const override;\n\n    boost::filesystem::path inclusion_path(\n        const formattables::locator& l,\n        const logical::entities::name& n) const override;\n\n    boost::filesystem::path full_path(\n        const formattables::locator& l,\n        const logical::entities::name& n) const override;\n<#+\n            } else if (o.major_technical_space() == technical_space::csharp) {\n#>\n    std::list<std::string> inclusion_dependencies(\n        const logical::entities::element& e) const override;\n\n    boost::filesystem::path full_path(\n        const formattables::locator& l, const logical::entities::name& n) const override;\n<#+\n            }\n#>\n\npublic:\n    void apply(const context& ctx, const logical::entities::element& e,\n        physical::entities::artefact& a) const override;\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::public_headers",
      "documentation": "Contains the header files that are publicly visible.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "internal_modules_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "true"
        }
      ]
    },
    {
      "name": "transforms::standard_header_file",
      "documentation": "Header file generated by Dogen.\n",
      "stereotypes": [
        "masd::physical::archetype_kind"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "file_extension",
          "type": "",
          "value": "hpp"
        }
      ]
    },
    {
      "name": "transforms::types::archetype_class_implementation_transform",
      "documentation": "Generates implementation files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype",
        "masd.wale.kvp.class.simple_name": "archetype_class_implementation_transform_transform",
        "masd.wale.kvp.archetype.simple_name": "archetype_class_implementation_transform",
        "masd.wale.kvp.meta_element": "physical_archetype",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_class_implementation_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_class_implementation_transform_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> archetype_class_implementation_transform_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid archetype_class_implementation_transform_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"archetype class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& arch(ast.as<logical::entities::physical::archetype>(e));\n    ast.update_artefact();\n    a.content(arch.rendered_stitch_template());\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::implementation",
      "documentation": "Contains the implementation files.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        }
      ]
    },
    {
      "name": "transforms::testing",
      "documentation": "Contains the test files.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        }
      ]
    },
    {
      "name": "transforms::base_archetype_configuration",
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests_configuration",
      "parents": [
        "transforms::base_archetype_configuration"
      ],
      "documentation": "Contains the configuration common to most archetypes in tests.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::tests_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.part_id",
          "type": "",
          "value": "masd.cpp.testing"
        },
        {
          "name": "masd.wale.kvp.locator_function",
          "type": "",
          "value": "make_full_path_for_tests_cpp_implementation"
        },
        {
          "name": "masd.physical.wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation"
        },
        {
          "name": "masd.physical.referencing_status",
          "type": "",
          "value": "not_referable"
        }
      ]
    },
    {
      "name": "transforms::header_configuration",
      "parents": [
        "transforms::base_archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all c++ header archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::header_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.part_id",
          "type": "",
          "value": "masd.cpp.public_headers"
        },
        {
          "name": "masd.wale.kvp.locator_function",
          "type": "",
          "value": "make_full_path_for_cpp_header"
        },
        {
          "name": "masd.physical.wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation_header"
        }
      ]
    },
    {
      "name": "transforms::header_facet_default_configuration",
      "parents": [
        "transforms::header_configuration"
      ],
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::header_facet_default_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.wale.kvp.class.inclusion_support_type",
          "type": "",
          "value": "canonical_support"
        },
        {
          "name": "masd.physical.referencing_status",
          "type": "",
          "value": "facet_default"
        }
      ]
    },
    {
      "name": "transforms::object_header_configuration",
      "parents": [
        "transforms::header_facet_default_configuration"
      ],
      "documentation": "Contains the configuration common to all object header archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::object_header_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.object"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "class_header_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "class_header"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "object"
        }
      ]
    },
    {
      "name": "transforms::enumeration_header_configuration",
      "parents": [
        "transforms::header_facet_default_configuration"
      ],
      "documentation": "Contains the configuration common to all enumeration header archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::enumeration_header_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.enumeration"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "enum_header_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "enum_header"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "enumeration"
        }
      ]
    },
    {
      "name": "transforms::implementation_configuration",
      "parents": [
        "transforms::base_archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all c++ implementation archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::implementation_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.part_id",
          "type": "",
          "value": "masd.cpp.implementation"
        },
        {
          "name": "masd.wale.kvp.locator_function",
          "type": "",
          "value": "make_full_path_for_cpp_implementation"
        },
        {
          "name": "masd.physical.wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation"
        },
        {
          "name": "masd.physical.referencing_status",
          "type": "",
          "value": "not_referable"
        }
      ]
    },
    {
      "name": "transforms::object_implementation_configuration",
      "parents": [
        "transforms::implementation_configuration"
      ],
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::object_implementation_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.object"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "class_implementation_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "class_implementation"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "object"
        }
      ]
    },
    {
      "name": "transforms::builtin_header_configuration",
      "parents": [
        "transforms::header_facet_default_configuration"
      ],
      "documentation": "Contains the configuration common to all built header archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::builtin_header_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.builtin"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "builtin_header_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "builtin_header"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "builtin"
        }
      ]
    },
    {
      "name": "transforms::primitive_header_configuration",
      "parents": [
        "transforms::header_facet_default_configuration"
      ],
      "documentation": "Contains the configuration common to all built header archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::primitive_header_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.primitive"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "primitive_header_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "primitive_header"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "primitive"
        }
      ]
    },
    {
      "name": "transforms::primitive_implementation_configuration",
      "parents": [
        "transforms::implementation_configuration"
      ],
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::primitive_implementation_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.primitive"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "primitive_implementation_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "primitive_implementation"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "primitive"
        }
      ]
    },
    {
      "name": "transforms::project",
      "documentation": "Top-level project part.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        }
      ]
    },
    {
      "name": "transforms::enumeration_implementation_configuration",
      "parents": [
        "transforms::implementation_configuration"
      ],
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::enumeration_implementation_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.enumeration"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "enum_implementation_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "enum_implementation"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "enumeration"
        }
      ]
    },
    {
      "name": "transforms::templating",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        }
      ]
    },
    {
      "name": "transforms::types::facet_class_header_transform",
      "documentation": "Generates header files for facet transforms.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_facet",
        "masd.wale.kvp.class.simple_name": "facet_class_header_transform_transform",
        "masd.wale.kvp.archetype.simple_name": "facet_class_header_transform",
        "masd.wale.kvp.meta_element": "physical_facet",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/facet_class_header_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/facet_class_header_transform_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> facet_class_header_transform_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    const auto& fct(assistant::as<logical::entities::physical::facet>(e));\n\n    auto builder(f.make());\n    builder.add_as_user(\"dogen.physical/types/entities/facet.hpp\");\n    using logical::entities::technical_space;\n    if (fct.major_technical_space() == technical_space::cpp) {\n        builder.add_as_user(\n            \"dogen.text.cpp/types/transforms/registrar.hpp\");\n    } else if (fct.major_technical_space() == technical_space::csharp) {\n        builder.add_as_user(\n            \"dogen.text.csharp/types/transforms/registrar.hpp\");\n    }\n    const auto ch_arch(traits::class_header_archetype_qn());\n    return builder.build();\n}\n\nvoid facet_class_header_transform_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"facet class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& fct(ast.as<logical::entities::physical::facet>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(fct));\n        {\n            const auto ns(ast.make_namespaces(e.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(fct.documentation());\n#>\nclass <#= fct.name().simple() #>_facet_chain final {\npublic:\n    static const physical::entities::facet& static_facet();\n    const physical::entities::facet& facet() const;\n\npublic:\n    static void initialise(registrar& r);\n};\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::facet_class_implementation_transform",
      "documentation": "Generates implementation files for facet transforms.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_facet",
        "masd.wale.kvp.class.simple_name": "facet_class_implementation_transform_transform",
        "masd.wale.kvp.archetype.simple_name": "facet_class_implementation_transform",
        "masd.wale.kvp.meta_element": "physical_facet",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/entities/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/facet_class_implementation_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/facet_class_implementation_transform_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> facet_class_implementation_transform_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    const auto& fct(assistant::as<logical::entities::physical::facet>(e));\n    auto builder(f.make());\n    const auto ch_arch(traits::canonical_archetype());\n    builder.add(fct.name(), ch_arch);\n    builder.add(fct.archetypes(), ch_arch);\n    builder.add_as_user(\"dogen.physical/types/helpers/meta_name_builder.hpp\");\n    builder.add_as_user(\"dogen.utility/types/log/logger.hpp\");\n    builder.add_as_user(\"dogen.text/types/transforms/transformation_error.hpp\");\n\n    return builder.build();\n}\n\nvoid facet_class_implementation_transform_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"facet class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& fct(ast.as<logical::entities::physical::facet>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(fct));\n        {\n            const auto ns(ast.make_namespaces(fct.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(fct.name().simple() + \"_facet_chain\");\n#>\nnamespace {\n\nusing namespace dogen::utility::log;\nstatic logger lg(logger_factory(\"<#= fct.name().qualified().dot() #>\"));\n\nphysical::entities::facet make_facet() {\n    physical::helpers::meta_name_builder b;\n    b.meta_model(\"<#= fct.meta_model_name() #>\");\n    b.backend(\"<#= fct.backend_name() #>\");\n    b.facet(\"<#= fct.name().simple() #>\");\n\n    physical::entities::facet r;\n    r.meta_name(b.build());\n    return r;\n}\n\n}\n\nconst physical::entities::facet& <#= sn #>::static_facet() {\n    static const auto r(make_facet());\n    return r;\n}\n\nconst physical::entities::facet& <#= sn #>::facet() const {\n    return static_facet();\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::backend_class_header_transform",
      "documentation": "Generates header files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_backend",
        "masd.wale.kvp.class.simple_name": "backend_class_header_transform_transform",
        "masd.wale.kvp.archetype.simple_name": "backend_class_header_transform",
        "masd.wale.kvp.meta_element": "physical_backend",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/backend.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/backend_class_header_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/backend_class_header_transform_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> backend_class_header_transform_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    const auto& be(assistant::as<logical::entities::physical::backend>(e));\n\n    auto builder(f.make());\n    builder.add_as_user(\"dogen.physical/types/entities/backend.hpp\");\n    using logical::entities::technical_space;\n    if (be.major_technical_space() == technical_space::cpp) {\n        builder.add_as_user(\n            \"dogen.text.cpp/types/transforms/registrar.hpp\");\n    } else if (be.major_technical_space() == technical_space::csharp) {\n        builder.add_as_user(\n            \"dogen.text.csharp/types/transforms/registrar.hpp\");\n    }\n    const auto ch_arch(traits::class_header_archetype_qn());\n    return builder.build();\n}\n\nvoid backend_class_header_transform_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"backend class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& be(ast.as<logical::entities::physical::backend>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(be));\n        {\n            const auto ns(ast.make_namespaces(be.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(be.documentation());\n#>\nclass <#= be.name().simple() #>_backend_chain final {\npublic:\n    static const physical::entities::backend& static_backend();\n    const physical::entities::backend& backend() const;\n\npublic:\n    static void initialise(transforms::registrar& r);\n};\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::backend_class_implementation_transform",
      "documentation": "Generates implementation files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_backend",
        "masd.wale.kvp.class.simple_name": "backend_class_implementation_transform_transform",
        "masd.wale.kvp.archetype.simple_name": "backend_class_implementation_transform",
        "masd.wale.kvp.meta_element": "physical_backend",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/backend.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/backend_class_implementation_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/backend_class_implementation_transform_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> backend_class_implementation_transform_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    auto builder(f.make());\n    const auto ch_arch(traits::canonical_archetype());\n    const auto& be(assistant::as<logical::entities::physical::backend>(e));\n\n    builder.add(be.name(), ch_arch);\n    builder.add(be.facets(), ch_arch);\n    builder.add_as_user(\"dogen.physical/types/helpers/meta_name_builder.hpp\");\n    builder.add_as_user(\"dogen.utility/types/log/logger.hpp\");\n    builder.add_as_user(\"dogen.text/types/transforms/transformation_error.hpp\");\n\n    return builder.build();\n}\n\nvoid backend_class_implementation_transform_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"backend class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& be(ast.as<logical::entities::physical::backend>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(be));\n        {\n            const auto ns(ast.make_namespaces(be.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(be.name().simple() + \"_backend_chain\");\n#>\nnamespace {\n\nusing namespace dogen::utility::log;\nstatic logger lg(logger_factory(\"<#= be.name().qualified().dot() #>\"));\n\nphysical::entities::backend make_backend() {\n    physical::helpers::meta_name_builder b;\n    b.meta_model(\"<#= be.meta_model_name() #>\");\n    b.backend(\"<#= be.backend_name() #>\");\n\n    physical::entities::backend r;\n    r.meta_name(b.build());\n\n    const auto lambda([&](const auto& fct) {\n        const auto id(fct.meta_name().qualified());\n        const auto pair(std::make_pair(id, fct));\n        const auto inserted(r.facets().insert(pair).second);\n        if (!inserted) {\n            using text::transforms::transformation_error;\n            const std::string duplicate_facet(\"Duplicate facet: \");\n            BOOST_LOG_SEV(lg, error) << duplicate_facet << id;\n            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + id));\n        }\n    });\n\n<#+\n            for (const auto& n : be.facets()) {\n#>\n    lambda(<#= n.simple() #>::<#= n.simple() #>_facet_chain::static_facet());\n<#+\n            }\n#>\n    return r;\n}\n\n}\n\nconst physical::entities::backend& <#= sn #>::static_backend() {\n    static const auto r(make_backend());\n    return r;\n}\n\nconst physical::entities::backend& <#= sn #>::backend() const {\n    return static_backend();\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::part_class_header_transform",
      "documentation": "Generates header files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_part",
        "masd.wale.kvp.class.simple_name": "part_class_header_transform_transform",
        "masd.wale.kvp.archetype.simple_name": "part_class_header_transform",
        "masd.wale.kvp.meta_element": "physical_part",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/part.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/part_class_header_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/part_class_header_transform_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> part_class_header_transform_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid part_class_header_transform_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"part class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::physical::part>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= o.name().simple() #> final : public model_to_text_transform {\npublic:\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::part_class_implementation_transform",
      "documentation": "Generates implementation files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_part",
        "masd.wale.kvp.class.simple_name": "part_class_implementation_transform_transform",
        "masd.wale.kvp.archetype.simple_name": "part_class_implementation_transform",
        "masd.wale.kvp.meta_element": "physical_part",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/part.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/part_class_implementation_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/part_class_implementation_transform_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> part_class_implementation_transform_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid part_class_implementation_transform_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"part class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::archetype_kind_class_header_transform",
      "documentation": "Generates header files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype_kind",
        "masd.wale.kvp.class.simple_name": "archetype_kind_class_header_transform_transform",
        "masd.wale.kvp.archetype.simple_name": "archetype_kind_class_header_transform",
        "masd.wale.kvp.meta_element": "physical_archetype_kind",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype_kind.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_kind_class_header_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_kind_class_header_transform_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> archetype_kind_class_header_transform_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid archetype_kind_class_header_transform_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"archetype kind class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::physical::archetype_kind>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= o.name().simple() #> final : public model_to_text_transform {\npublic:\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::archetype_kind_class_implementation_transform",
      "documentation": "Generates implementation files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype_kind",
        "masd.wale.kvp.class.simple_name": "archetype_kind_class_implementation_transform_transform",
        "masd.wale.kvp.archetype.simple_name": "archetype_kind_class_implementation_transform",
        "masd.wale.kvp.meta_element": "physical_archetype_kind",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype_kind.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_kind_class_implementation_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_kind_class_implementation_transform_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> archetype_kind_class_implementation_transform_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid archetype_kind_class_implementation_transform_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"archetype kind class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::transformation_error",
      "documentation": "An error occurred whilst applying a transform.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::archetype_class_header_factory",
      "documentation": "Generates header files for archetype factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype",
        "masd.wale.kvp.class.simple_name": "archetype_class_header_factory_transform",
        "masd.wale.kvp.archetype.simple_name": "archetype_class_header_factory",
        "masd.wale.kvp.meta_element": "physical_archetype",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.physical.referencing_status": "referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_class_header_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_class_header_factory_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> archetype_class_header_factory_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& /*e*/) const {\n    auto builder(f.make());\n    builder.add_as_user(\"dogen.physical/types/entities/archetype.hpp\");\n    return builder.build();\n}\n\nvoid archetype_class_header_factory_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"types archetype class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::physical::archetype>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Creates a physical representation for the archetype\n * <#= o.name().simple() #>.\n *\n * Archetype documentation: <#= o.documentation() #>\n */\nclass <#= o.name().simple() #>_factory final {\npublic:\n    /**\n     * @brief Makes the archetype.\n     */\n    static physical::entities::archetype make();\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::archetype_class_implementation_factory",
      "documentation": "Generates implementation files for archetype factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype",
        "masd.wale.kvp.class.simple_name": "archetype_class_implementation_factory_transform",
        "masd.wale.kvp.archetype.simple_name": "archetype_class_implementation_factory",
        "masd.wale.kvp.meta_element": "physical_archetype",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_class_implementation_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_class_implementation_factory_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> archetype_class_implementation_factory_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    const auto& arch(assistant::as<logical::entities::physical::archetype>(e));\n    auto builder(f.make());\n    const auto ch_arch(traits::archetype_class_header_factory_archetype_qn());\n    builder.add(arch.name(), ch_arch);\n    builder.add_as_user(\"dogen.physical/types/helpers/meta_name_factory.hpp\");\n    return builder.build();\n}\n\nvoid archetype_class_implementation_factory_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"archetype class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& arch(ast.as<logical::entities::physical::archetype>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(arch));\n        {\n            const auto ns(ast.make_namespaces(arch.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(arch.name().simple() + \"_factory\");\n#>\n\nphysical::entities::archetype <#= sn #>::make() {\n    physical::entities::archetype r;\n    using pmnf = physical::helpers::meta_name_factory;\n    r.meta_name(pmnf::make(\"<#= arch.backend_name() #>\", \"<#= arch.facet_name() #>\", \"<#= arch.name().simple() #>\"));\n    r.logical_meta_element_id(\"<#= arch.logical_meta_element_id() #>\");\n    r.referencing_status(physical::entities::referencing_status::<#= arch.referencing_status() #>);\n<#+\n            for(const auto& l : arch.labels()) {\n#>\n     r.labels().push_back(physical::entities::label(\"<#= l.key() #>\", \"<#= l.value() #>\"));\n<#+\n            }\n#>\n    return r;\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::facet_class_header_factory",
      "documentation": "Generates header files for facet factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_facet",
        "masd.wale.kvp.class.simple_name": "facet_class_header_factory_transform",
        "masd.wale.kvp.archetype.simple_name": "facet_class_header_factory",
        "masd.wale.kvp.meta_element": "physical_facet",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.physical.referencing_status": "referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/facet_class_header_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/facet_class_header_factory_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> facet_class_header_factory_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& /*e*/) const {\n    auto builder(f.make());\n    builder.add_as_user(\"dogen.physical/types/entities/facet.hpp\");\n    return builder.build();\n}\n\nvoid facet_class_header_factory_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"facet class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& fct(ast.as<logical::entities::physical::facet>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(fct));\n        {\n            const auto ns(ast.make_namespaces(e.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Creates a physical representation for the facet\n * <#= fct.name().simple() #>.\n *\n * Facet documentation: <#= fct.documentation() #>\n */\nclass <#= fct.name().simple() #>_factory final {\npublic:\n    static physical::entities::facet make();\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::facet_class_implementation_factory",
      "documentation": "Generates implementation files for facet factory.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_facet",
        "masd.wale.kvp.class.simple_name": "facet_class_implementation_factory_transform",
        "masd.wale.kvp.archetype.simple_name": "facet_class_implementation_factory",
        "masd.wale.kvp.meta_element": "physical_facet",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/entities/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/facet_class_implementation_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/facet_class_implementation_factory_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> facet_class_implementation_factory_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    const auto& fct(assistant::as<logical::entities::physical::facet>(e));\n    auto builder(f.make());\n    const auto fct_ch_arch(traits::facet_class_header_factory_archetype_qn());\n    builder.add(fct.name(), fct_ch_arch);\n\n    const auto ch_arch(traits::archetype_class_header_factory_archetype_qn());\n    builder.add(fct.archetypes(), ch_arch);\n    builder.add_as_user(\"dogen.utility/types/log/logger.hpp\");\n    builder.add_as_user(\"dogen.text/types/transforms/transformation_error.hpp\");\n    builder.add_as_user(\"dogen.physical/types/helpers/meta_name_builder.hpp\");\n\n    return builder.build();\n}\n\nvoid facet_class_implementation_factory_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"facet class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& fct(ast.as<logical::entities::physical::facet>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(fct));\n        {\n            const auto ns(ast.make_namespaces(fct.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(fct.name().simple() + \"_factory\");\n#>\nnamespace {\n\nusing namespace dogen::utility::log;\nstatic logger lg(logger_factory(\"<#= fct.name().qualified().dot() #>\"));\n\n}\n\nphysical::entities::facet <#= sn #>::make() {\n    physical::helpers::meta_name_builder b;\n    b.meta_model(\"<#= fct.meta_model_name() #>\");\n    b.backend(\"<#= fct.backend_name() #>\");\n    b.facet(\"<#= fct.name().simple() #>\");\n\n    physical::entities::facet r;\n    r.meta_name(b.build());\n<#+\n            for(const auto& l : fct.labels()) {\n#>\n    r.labels().push_back(physical::entities::label(\"<#= l.key() #>\", \"<#= l.value() #>\"));\n<#+\n            }\n#>\n\n    const auto lambda([&](const auto& arch) {\n        const auto id(arch.meta_name().qualified());\n        const auto pair(std::make_pair(id, arch));\n        const auto inserted(r.archetypes().insert(pair).second);\n        if (!inserted) {\n            using text::transforms::transformation_error;\n            const std::string duplicate_archetype(\"Duplicate archetype: \");\n            BOOST_LOG_SEV(lg, error) << duplicate_archetype << id;\n            BOOST_THROW_EXCEPTION(transformation_error(duplicate_archetype + id));\n        }\n    });\n\n<#+\n            for (const auto& n : fct.archetypes()) {\n#>\n    lambda(<#= n.simple() #>_factory::make());\n<#+\n            }\n#>\n    return r;\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::backend_class_header_factory",
      "documentation": "Generates header files for backend factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_backend",
        "masd.wale.kvp.class.simple_name": "backend_class_header_factory_transform",
        "masd.wale.kvp.archetype.simple_name": "backend_class_header_factory",
        "masd.wale.kvp.meta_element": "physical_backend",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.physical.referencing_status": "referable"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/backend.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/backend_class_header_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/backend_class_header_factory_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> backend_class_header_factory_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& /*e*/) const {\n    auto builder(f.make());\n    builder.add_as_user(\"dogen.physical/types/entities/backend.hpp\");\n    const auto ch_arch(traits::class_header_archetype_qn());\n    return builder.build();\n}\n\nvoid backend_class_header_factory_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"backend class header transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& be(ast.as<logical::entities::physical::backend>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(be));\n        {\n            const auto ns(ast.make_namespaces(be.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Creates a physical representation for the backend\n * <#= be.name().simple() #>.\n *\n * Backend documentation: <#= be.documentation() #>\n */\nclass <#= be.name().simple() #>_factory final {\npublic:\n    static physical::entities::backend make();\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::types::backend_class_implementation_factory",
      "documentation": "Generates implementation files for backend factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_backend",
        "masd.wale.kvp.class.simple_name": "backend_class_implementation_factory_transform",
        "masd.wale.kvp.archetype.simple_name": "backend_class_implementation_factory",
        "masd.wale.kvp.meta_element": "physical_backend",
        "masd.wale.kvp.containing_namespace": "text.cpp.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/backend.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/backend_class_implementation_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/backend_class_implementation_factory_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> backend_class_implementation_factory_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    auto builder(f.make());\n    const auto& be(assistant::as<logical::entities::physical::backend>(e));\n    const auto be_ch_arch(traits::backend_class_header_factory_archetype_qn());\n    builder.add(be.name(), be_ch_arch);\n\n    const auto ch_arch(traits::facet_class_header_factory_archetype_qn());\n    builder.add(be.facets(), ch_arch);\n\n    builder.add_as_user(\"dogen.physical/types/helpers/meta_name_builder.hpp\");\n    builder.add_as_user(\"dogen.utility/types/log/logger.hpp\");\n    builder.add_as_user(\"dogen.text/types/transforms/transformation_error.hpp\");\n\n    return builder.build();\n}\n\nvoid backend_class_implementation_factory_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"backend class implementation transform\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& be(ast.as<logical::entities::physical::backend>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(be));\n        {\n            const auto ns(ast.make_namespaces(be.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(be.name().simple() + \"_factory\");\n#>\nnamespace {\n\nusing namespace dogen::utility::log;\nstatic logger lg(logger_factory(\"<#= be.name().qualified().dot() #>\"));\n\n}\n\nphysical::entities::backend <#= sn #>::make() {\n    physical::helpers::meta_name_builder b;\n    b.meta_model(\"<#= be.meta_model_name() #>\");\n    b.backend(\"<#= be.backend_name() #>\");\n\n    physical::entities::backend r;\n    r.meta_name(b.build());\n<#+\n            for(const auto& l : be.labels()) {\n#>\n    r.labels().push_back(physical::entities::label(\"<#= l.key() #>\", \"<#= l.value() #>\"));\n<#+\n            }\n#>\n\n    const auto lambda([&](const auto& fct) {\n        const auto id(fct.meta_name().qualified());\n        const auto pair(std::make_pair(id, fct));\n        const auto inserted(r.facets().insert(pair).second);\n        if (!inserted) {\n            using text::transforms::transformation_error;\n            const std::string duplicate_facet(\"Duplicate facet: \");\n            BOOST_LOG_SEV(lg, error) << duplicate_facet << id;\n            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + id));\n        }\n    });\n\n<#+\n            for (const auto& n : be.facets()) {\n#>\n    lambda(<#= n.simple() #>::<#= n.simple() #>_factory::make());\n<#+\n            }\n#>\n    return r;\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n#>\n"
        }
      ]
    }
  ]
}
