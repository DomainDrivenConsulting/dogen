{
  "documentation": "CPP is the C++ backend in the default generation kernel.\n",
  "tagged_values": {
    "masd.injection.dia.comment": "true",
    "masd.injection.model_modules": "dogen.text.cpp",
    "masd.injection.reference": "cpp.builtins",
    "masd.injection.reference": "cpp.boost",
    "masd.injection.reference": "cpp.std",
    "masd.injection.reference": "dogen",
    "masd.injection.reference": "dogen.variability",
    "masd.injection.reference": "dogen.tracing",
    "masd.injection.reference": "dogen.logical",
    "masd.injection.reference": "dogen.text",
    "masd.injection.reference": "masd",
    "masd.injection.reference": "masd.variability",
    "masd.injection.reference": "dogen.profiles",
    "masd.injection.input_technical_space": "cpp",
    "masd.physical.ignore_files_matching_regex": ".*/test/.*",
    "masd.physical.ignore_files_matching_regex": ".*/tests/.*",
    "masd.variability.profile": "dogen.profiles.base.default_profile"
  },
  "elements": [
    {
      "name": "transforms",
      "documentation": "Formatters for the C++ model.\n\nTakes types in the C++ model and creates a file\nrepresentation of these types according to the\ngrammar of the C++ technical space.\n",
      "stereotypes": [
        "masd::physical::backend"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true",
        "masd.physical.backend_name": "cpp"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::types",
      "documentation": "Formatters for the types facet of the\nC++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::types::class_header_transform",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.public_headers",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.kvp.class.simple_name": "class_header_transform",
        "masd.wale.kvp.archetype.simple_name": "class_header",
        "masd.wale.kvp.class.inclusion_support_type": "canonical_support",
        "masd.wale.kvp.meta_element": "object",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/class_header_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::object;\n    const auto& o(assistant::as<object>(e));\n    auto builder(f.make());\n\n    // algorithm: domain headers need it for the swap function.\n    builder.add(inclusion_constants::std::algorithm());\n\n    const auto io_arch(transforms::io::traits::class_header_archetype_qn());\n    const bool in_inheritance(o.is_parent() || o.is_child());\n    const bool io_enabled(builder.is_enabled(o.name(), io_arch));\n    const bool requires_io(io_enabled && in_inheritance);\n\n    const auto ios(inclusion_constants::std::iosfwd());\n    if (requires_io)\n        builder.add(ios);\n\n    using ser = transforms::serialization::traits;\n    const auto ser_fwd_arch(ser::class_forward_declarations_archetype_qn());\n    builder.add(o.name(), ser_fwd_arch);\n\n    const auto carch(traits::canonical_archetype());\n    builder.add(o.transparent_associations(), carch);\n\n    const auto fwd_arch(traits::class_forward_declarations_archetype_qn());\n    builder.add(o.opaque_associations(), fwd_arch);\n\n    const auto self_arch(class_header_transform::static_archetype().meta_name().qualified());\n    builder.add(o.parents(), self_arch);\n\n    using hash = transforms::hash::traits;\n    const auto hash_carch(hash::traits::canonical_archetype());\n    builder.add(o.associative_container_keys(), hash_carch);\n\n    if (o.is_visitation_root()) {\n        /*\n         * On the header files of the visitation root we only care\n         * about the base visitor; as such we can get away with a\n         * forward declaration. For the visitation leaves, since we\n         * must include the parent we do not need any additional\n         * includes.\n         */\n        builder.add(o.opaque_associations(), fwd_arch);\n\n        const auto visitor_fwd_arch(traits::visitor_forward_declarations_archetype_qn());\n        builder.add(*o.base_visitor(), visitor_fwd_arch);\n    }\n    return builder.build();\n}\n\nvoid class_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(o.documentation());\n            if (o.parents().empty()) {\n#>\nclass <#= sn #> <#= ast.make_final_keyword_text(o) #>{\n<#+\n            } else {\n                const auto& pn(o.parents().front());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\nclass <#= sn #> <#= ast.make_final_keyword_text(o) #>: public <#= pqn #> {\n<#+\n            }\n\n            /*\n             * Compiler generated constructors and destructors.\n             */\n            if (ast.supports_defaulted_functions()) {\n#>\npublic:\n<#+\n                if (!ast.requires_manual_default_constructor())\n#>\n    <#= sn #>() = default;\n    <#= sn #>(const <#= sn #>&) = default;\n<#+\n                if (!ast.requires_manual_move_constructor())\n#>\n    <#= sn #>(<#= sn #>&&) = default;\n<#+\n                if (!o.in_inheritance_relationship())\n#>\n    ~<#= sn #>() = default;\n<#+\n                if (o.is_immutable())\n#>\n    <#= sn #>& operator=(const <#= sn #>&) = delete;\n<#+\n                else if (o.all_attributes().empty())\n#>\n    <#= sn #>& operator=(const <#= sn #>&) = default;\n\n<#+\n            }\n\n            /*\n             * Manually generated default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\npublic:\n    <#= sn #>();\n\n<#+\n            }\n\n            /*\n             * Manually generated destructor.\n             *\n             * according to MEC++, item 33, base classes should always be\n             * abstract. this avoids all sorts of tricky problems with\n             * assignment and swap.\n             *\n             * incidentally, this also fixes some strange clang errors:\n             * undefined reference to `vtable.\n             */\n            if (o.is_parent()) {\n#>\n    virtual ~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> = 0;\n\n<#+\n            } else if (o.is_child() != 0) {\n#>\n    virtual ~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> { }\n\n<#+\n            }\n\n            /*\n             * Manually generated move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\npublic:\n    <#= sn #>(<#= sn #>&& rhs);\n\n<#+\n            }\n\n            /*\n             * Manually generated complete constructor.\n             */\n            if (!o.all_attributes().empty()) {\n#>\npublic:\n<#+\n                const auto attr_count(o.all_attributes().size());\n                if (attr_count == 1) {\n                    const auto attr(*o.all_attributes().begin());\n#>\n    explicit <#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>);\n<#+\n                } else {\n#>\n    <#= sn #>(\n<#+\n                    utility::formatters::sequence_formatter sf(attr_count);\n                    sf.postfix_configuration().last(\");\");\n                    for (const auto& attr : o.all_attributes()) {\n#>\n        const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #><#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n                }\n#>\n\n<#+\n            }\n\n            /*\n             * Serialisaton Friends\n             */\n            if (ast.is_serialization_enabled()) {\n#>\nprivate:\n    template<typename Archive>\n    friend void boost::serialization::save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\n    template<typename Archive>\n    friend void boost::serialization::load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n<#+\n            }\n\n            /*\n             * Visitation.\n             */\n            if (o.is_visitation_root()) {\n                const auto vsn(o.base_visitor()->simple());\n#>\npublic:\n    virtual void accept(const <#= vsn #>& v) const = 0;\n    virtual void accept(<#= vsn #>& v) const = 0;\n    virtual void accept(const <#= vsn #>& v) = 0;\n    virtual void accept(<#= vsn #>& v) = 0;\n\n<#+\n            } else if (o.is_visitation_leaf()) {\n                std::string bvn;\n                std::string rpn;\n                if (o.derived_visitor()) {\n                    bvn = ast.get_qualified_name(*o.base_visitor());\n                    rpn = ast.get_qualified_name(o.root_parents().front());\n                } else {\n                    bvn = o.base_visitor()->simple();\n                    rpn = o.root_parents().front().simple();\n                }\n#>\npublic:\n    using <#= rpn #>::accept;\n\n    virtual void accept(const <#= bvn #>& v) const<#= ast.make_override_keyword_text() #>;\n    virtual void accept(<#= bvn #>& v) const<#= ast.make_override_keyword_text() #>;\n    virtual void accept(const <#= bvn #>& v)<#= ast.make_override_keyword_text() #>;\n    virtual void accept(<#= bvn #>& v)<#= ast.make_override_keyword_text() #>;\n<#+\n            }\n\n            /*\n             * Streaming\n             */\n            if (ast.is_io_enabled()) {\n                if (o.is_parent()) {\n#>\npublic:\n    virtual void to_stream(std::ostream& s) const;\n\n<#+\n                } else if (!o.parents().empty()) {\n#>\npublic:\n    void to_stream(std::ostream& s) const<#= ast.make_override_keyword_text() #>;\n\n<#+\n                }\n            }\n\n            /*\n             * Getters and setters.\n             */\n            if (!o.local_attributes().empty()) {\n#>\npublic:\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    ast.comment_start_method_group(attr.documentation(), !attr.is_immutable());\n\n                    if (attr.parsed_type().is_current_simple_type()) {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #>() const;\n<#+\n                        if (attr.is_immutable()) {\n#>\n\n<#+\n                            continue;\n                        }\n#>\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n<#+\n                    } else {\n#>\n    const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= attr.name().simple() #>() const;\n<#+\n                        if (attr.is_immutable()) {\n#>\n\n<#+\n                            continue;\n                        }\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>();\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n<#+\n                        if (ast.supports_move_operator()) {\n#>\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v);\n<#+\n                        }\n                    }\n                    ast.comment_end_method_group(attr.documentation(), !attr.is_immutable());\n#>\n\n<#+\n                }\n            }\n\n            /*\n             * Equality.\n             *\n             * Equality is only public in leaf classes - MEC++-33.\n             */\n            if (o.is_parent()) {\n#>\nprotected:\n    bool compare(const <#= sn #>& rhs) const;\n<#+\n            } else {\n#>\npublic:\n    bool operator==(const <#= sn #>& rhs) const;\n    bool operator!=(const <#= sn #>& rhs) const {\n        return !this->operator==(rhs);\n    }\n\n<#+\n            }\n\n            if (o.in_inheritance_relationship()) {\n#>\npublic:\n<#+\n                if (o.is_parent() && !o.is_child()) {\n#>\n    virtual bool equals(const <#= sn #>& other) const = 0;\n<#+\n                } else if (o.is_parent()) {\n                    const auto rpn(o.root_parents().front());\n#>\n    virtual bool equals(const <#= ast.get_qualified_name(rpn) #>& other) const = 0;\n<#+\n                } else if (!o.root_parents().empty()) {\n                    const auto rpn(o.root_parents().front());\n#>\n    bool equals(const <#= ast.get_qualified_name(rpn) #>& other) const<#= ast.make_override_keyword_text() #>;\n<#+\n                }\n#>\n\n<#+\n             }\n\n            /*\n             * Swap and assignment.\n             *\n             * Swap and assignment are only public in leaf classes - MEC++-33\n             */\n            if ((!o.all_attributes().empty() || o.is_parent()) && !o.is_immutable()) {\n                if (o.is_parent()) {\n#>\nprotected:\n<#+\n                } else {\n#>\npublic:\n<#+\n                }\n#>\n    void swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #>;\n<#+\n                if (!o.is_parent() && !o.is_immutable()) {\n#>\n    <#= sn #>& operator=(<#= sn #> other);\n<#+\n                }\n#>\n\n<#+\n            }\n\n            /*\n             * Member variables.\n             */\n            if (!o.local_attributes().empty()) {\n#>\nprivate:\n<#+\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.member_variable_name() #>;\n<#+\n                }\n            }\n#>\n};\n\n<#+\n            /*\n             * Destructor implementation.\n             */\n            if (o.is_parent()) {\n#>\ninline <#= sn #>::~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> { }\n\n<#+\n            }\n\n            /*\n             * Global equality operator implementation.\n             */\n            if (o.is_parent()) {\n#>\ninline bool operator==(const <#= sn #>& lhs, const <#= sn #>& rhs) {\n    return lhs.equals(rhs);\n}\n\n<#+\n            }\n        }\n\n        if (!o.all_attributes().empty() && !o.is_parent() && !o.is_immutable()) {\n#>\n\nnamespace std {\n\ntemplate<>\ninline void swap(\n    <#= qn #>& lhs,\n    <#= qn #>& rhs) {\n    lhs.swap(rhs);\n}\n\n}\n<#+\n        }\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation_header"
        }
      ]
    },
    {
      "name": "transforms::model_to_text_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable::header_only"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "model_to_text_cpp_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash",
      "documentation": "Formatters for the hash facet of the\nC++ technical space.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::hash::class_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::class_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::exception_header_transform",
      "documentation": "Generates header files for exceptions.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.public_headers",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.exception",
        "masd.wale.text_template": "cpp_artefact_transform_implementation_header.wale",
        "masd.wale.kvp.class.simple_name": "exception_header_transform",
        "masd.wale.kvp.archetype.simple_name": "exception_header",
        "masd.wale.kvp.class.inclusion_support_type": "canonical_support",
        "masd.wale.kvp.meta_element": "exception",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.wale.kvp.text_to_text_transform": "\"\" #>"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/exception.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/exception_header_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> exception_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& /*e*/) const {\n    auto builder(f.make());\n    builder.add(inclusion_constants::std::string());\n    builder.add(inclusion_constants::boost::exception::info());\n    return builder.build();\n}\n\nvoid exception_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::exception>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(ye.documentation());\n#>\nclass <#= ye.name().simple() #> : public virtual std::exception, public virtual boost::exception {\npublic:\n<#+\n            if (ast.is_cpp_standard_98()) {\n#>\n    <#= ye.name().simple() #>() {}\n    ~<#= ye.name().simple() #>() {}\n<#+\n            } else {\n#>\n    <#= ye.name().simple() #>() = default;\n    ~<#= ye.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> = default;\n<#+\n            }\n#>\n\npublic:\n    explicit <#= ye.name().simple() #>(const std::string& message) : message_(message) { }\n\npublic:\n<#+\n            if (ast.is_cpp_standard_98()) {\n                // Note: we are using BOOST_NOEXCEPT here by design. The problem is\n                // users may include this header in a C++ 98 project or in a C++ > 11 project;\n                // and we need to have different behaviours. Depending on this inclusion.\n                // If we do not, we will cause compilation errors when including C++ 98 code\n                // on a C++ 11 project. This is because the standard library will have noexcept\n                // but we won't (as we were generated for C++ 98), so we'd be weakening the exception\n                // guarantees. By using the boost macro we will do the right thing hopefully.\n                // And since we already need boost for exception, we should be ok.\n#>\n    const char* what() const BOOST_NOEXCEPT { return(message_.c_str()); }\n<#+\n            } else {\n#>\n    const char* what() const<#= ast.make_noexcept_keyword_text() #> { return(message_.c_str()); }\n<#+\n            }\n#>\n\nprivate:\n    const std::string message_;\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation_header"
        }
      ]
    },
    {
      "name": "transforms::types::enum_header_transform",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.public_headers",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.enumeration",
        "masd.wale.text_template": "cpp_artefact_transform_implementation_header.wale",
        "masd.wale.kvp.class.simple_name": "enum_header_transform",
        "masd.wale.kvp.archetype.simple_name": "enum_header",
        "masd.wale.kvp.class.inclusion_support_type": "canonical_support",
        "masd.wale.kvp.meta_element": "enumeration",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/enum_header_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> enum_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::enumeration;\n    const auto& en(assistant::as<enumeration>(e));\n    auto builder(f.make());\n    const auto arch(traits::canonical_archetype());\n    builder.add(en.underlying_element(), arch);\n    return builder.build();\n}\n\nvoid enum_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(e.documentation());\n            if (ast.is_cpp_standard_98()) {\n#>\nenum <#= ye.name().simple() #> {\n<#+\n            } else {\n                if (ye.use_implementation_defined_underlying_element())\n#>\nenum class <#= ye.name().simple() #> {\n<#+\n                else\n#>\nenum class <#= ye.name().simple() #> : <#= ast.get_qualified_name(ye.underlying_element()) #> {\n<#+\n            }\n\n            utility::formatters::sequence_formatter sf(ye.enumerators().size());\n            for (const auto& en : ye.enumerators()) {\n                if (ye.use_implementation_defined_enumerator_values())\n#>\n    <#= en.name().simple() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                else\n#>\n    <#= en.name().simple() #> = <#= en.value() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                sf.next();\n            }\n#>\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation_header"
        }
      ]
    },
    {
      "name": "transforms::types::namespace_header_transform",
      "documentation": "Generates header files for namespaces.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.public_headers",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.module",
        "masd.wale.text_template": "cpp_artefact_transform_implementation_header.wale",
        "masd.wale.kvp.class.simple_name": "namespace_header_transform",
        "masd.wale.kvp.archetype.simple_name": "namespace_header",
        "masd.wale.kvp.class.inclusion_support_type": "canonical_support",
        "masd.wale.kvp.meta_element": "module",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/module.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/namespace_header_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> namespace_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid namespace_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& m(ast.as<logical::entities::structural::module>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            if (ast.requires_nested_namespaces()) {\n                ast.comment(m.documentation());\n                const auto ns(ast.make_namespaces(e.name(),\n                        false/*detect_model_name*/));\n                auto snf(ast.make_scoped_namespace_formatter(ns));\n            } else {\n                const auto ns(ast.make_namespaces(m.name()));\n                auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n                ast.comment(m.documentation());\n#>\nnamespace <#= m.name().simple() #> {\n}\n\n<#+\n            }\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation_header"
        }
      ]
    },
    {
      "name": "transforms::types::visitor_header_transform",
      "documentation": "Generates header files for visitors.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.public_headers",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visitor",
        "masd.wale.text_template": "cpp_artefact_transform_implementation_header.wale",
        "masd.wale.kvp.class.simple_name": "visitor_header_transform",
        "masd.wale.kvp.archetype.simple_name": "visitor_header",
        "masd.wale.kvp.class.inclusion_support_type": "canonical_support",
        "masd.wale.kvp.meta_element": "visitor",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/visitor.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/hash/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/visitor_header_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> visitor_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::structural::visitor;\n    const auto& v(assistant::as<visitor>(e));\n    auto builder(f.make());\n    builder.add(v.visits(), traits::class_forward_declarations_archetype_qn());\n\n    if (v.parent())\n        builder.add(*v.parent(), traits::visitor_header_archetype_qn());\n\n    return builder.build();\n}\n\nvoid visitor_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& v(ast.as<logical::entities::structural::visitor>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(v.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(v.documentation());\n            if (!v.parent())\n#>\nclass <#= v.name().simple() #> {\n<#+\n            else {\n                const auto& pn(*v.parent());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\nclass <#= v.name().simple() #> : public <#= pqn #> {\n<#+\n            }\n#>\npublic:\n    virtual ~<#= v.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> = 0;\n\npublic:\n<#+\n            if (v.parent()) {\n                const auto& pn(*v.parent());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\n    using <#= pqn #>::visit;\n\n<#+\n            }\n\n            bool is_first(true);\n            for (const auto& t : v.visits()) {\n                if (!is_first)\n#>\n\n<#+\n                const auto qn(ast.get_qualified_name(t));\n                const auto doc(\"Accept visits for type \" + qn);\n                ast.comment_start_method_group(doc);\n#>\n    virtual void visit(const <#= qn #>&) const { }\n    virtual void visit(const <#= qn #>&) { }\n    virtual void visit(<#= qn #>&) const { }\n    virtual void visit(<#= qn #>&) { }\n<#+\n                ast.comment_end_method_group(doc);\n                is_first = false;\n            }\n#>\n};\n\ninline <#= v.name().simple() #>::~<#= v.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> { }\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation_header"
        }
      ]
    },
    {
      "name": "transforms::types::class_implementation_transform",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.implementation",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.text_template": "cpp_artefact_transform_implementation.wale",
        "masd.wale.kvp.class.simple_name": "class_implementation_transform",
        "masd.wale.kvp.archetype.simple_name": "class_implementation",
        "masd.wale.kvp.meta_element": "object",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/class_implementation_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n    using logical::entities::structural::object;\n    const auto& o(assistant::as<object>(e));\n    auto builder(f.make());\n\n    const auto ch_arch(traits::class_header_archetype_qn());\n    builder.add(o.name(), ch_arch);\n    builder.add(o.opaque_associations(), ch_arch);\n\n    const auto io_arch(transforms::io::traits::class_header_archetype_qn());\n    const bool in_inheritance(o.is_parent() || o.is_child());\n    const bool io_enabled(builder.is_enabled(o.name(), io_arch));\n    const bool requires_io(io_enabled && in_inheritance);\n\n    if (!requires_io)\n        return builder.build();\n\n    const auto os(inclusion_constants::std::ostream());\n    builder.add(os);\n\n    const auto io_carch(io::traits::canonical_archetype());\n    builder.add(o.transparent_associations(), io_carch);\n    builder.add(o.opaque_associations(), io_carch);\n    builder.add(o.parents(), io_carch);\n\n    if (o.is_visitation_leaf()) {\n        /*\n         * Only leaves have a visitation implementation. Note that we\n         * don't bother including the base if we are already including\n         * the derived visitor.\n         */\n        const auto v_arch(traits::visitor_header_archetype_qn());\n        if (o.derived_visitor())\n            builder.add(*o.derived_visitor(), v_arch);\n        else\n            builder.add(*o.base_visitor(), v_arch);\n    }\n\n    return builder.build();\n}\n\nvoid class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(o.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n\n            /*\n             * Default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\n\n<#= sn #>::<#= sn #>()\n<#+\n                // FIXME: this was just too hard to hack with a sequence.\n                // FIXME: indentation is all off too.\n                std::ostringstream ss;\n                bool is_first(true);\n                bool found(false);\n                for (const auto& attr : o.local_attributes()) {\n                    if (!attr.parsed_type().is_current_simple_type())\n                        continue;\n\n                    found = true;\n                    if (!is_first)\n                        ss << \",\" << std::endl << \"      \";\n\n                    ss << attr.member_variable_name()\n                       << \"(static_cast<\" << ast.get_qualified_name(attr.parsed_type())\n                       << \">(0))\";\n\n                    is_first = false;\n                }\n                ss << \" { }\";\n                const std::string out(ss.str());\n#>\n    <#= (found ? \": \" : \"\") #><#= out #>\n<#+\n            }\n\n            /*\n             * Move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\n\n<#= sn #>::<#= sn #>(<#= sn #>&& rhs)\n<#+\n                const auto size(o.parents().size() + o.local_attributes().size());\n\n                utility::formatters::sequence_formatter sf(size);\n                sf.prefix_configuration().first(\": \").not_first(\"  \");\n                sf.postfix_configuration().last(\" { }\");\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= sf.prefix() #><#= pqn #>(\n        std::forward<<#= pqn #>>(rhs))<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= sf.prefix() #><#= attr.member_variable_name() #>(std::move(rhs.<#= attr.member_variable_name() #>))<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n            }\n\n            /*\n             * Complete constructor.\n             */\n            if (!o.all_attributes().empty()) {\n                const auto attr_count(o.all_attributes().size());\n                if (attr_count == 1) {\n                     const auto attr(*o.all_attributes().begin());\n#>\n\n<#= sn #>::<#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>)\n<#+\n                } else {\n#>\n\n<#= sn #>::<#= sn #>(\n<#+\n\n                    utility::formatters::sequence_formatter sf(attr_count);\n                    sf.postfix_configuration().last(\")\");\n                    for (const auto& attr : o.all_attributes()) {\n#>\n    const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #><#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n                }\n\n                auto sequence_size(o.local_attributes().size() + o.parents().size());\n                for (const auto& pair : o.inherited_attributes()) {\n                    const auto& pattrs(pair.second);\n                    sequence_size += (pattrs.size() > 1 ? pattrs.size() : 0);\n                }\n\n                utility::formatters::sequence_formatter sf(sequence_size);\n                sf.postfix_configuration().last(\" { }\");\n                sf.prefix_configuration().first(\": \").not_first(\"  \");\n                for (const auto& pair : o.inherited_attributes()) {\n                    const auto pqn(ast.get_qualified_name(pair.first));\n                    const auto& pattrs(pair.second);\n                    if (pattrs.size() <= 1) {\n#>\n    <#= sf.prefix() #><#= pqn #>(<#= (pattrs.empty() ? \"\" : pattrs.front().name().simple()) #>)<#= sf.postfix() #>\n<#+\n                        sf.next();\n                    } else {\n#>\n    <#= sf.prefix() #><#= pqn #>(<#= sf.postfix(true/*skip*/) #>\n<#+\n                        sf.next();\n                        utility::formatters::sequence_formatter sf2(pattrs.size());\n                        sf2.element_separator(\"\");\n\n                        sf2.prefix_configuration().first(\"  \").not_first(\"  \");\n                        sf2.postfix_configuration().last(\")\");\n                        for (const auto& attr : pattrs) {\n#>\n    <#= sf2.prefix() #><#= attr.name().simple() #><#= sf2.postfix() #><#= sf.postfix() #>\n<#+\n                            sf2.next();\n                            sf.next();\n                        }\n                    }\n                }\n\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= sf.prefix() #><#= attr.member_variable_name() #>(<#= attr.name().simple() #>)<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n            }\n\n            /*\n             * Visitation.\n             */\n            if (o.is_visitation_leaf()) {\n                std::string bvn;\n                std::string dvn;\n                std::string rpn;\n                if (o.derived_visitor()) {\n                    bvn = ast.get_qualified_name(*o.base_visitor());\n                    dvn = o.derived_visitor()->simple();\n                    rpn = ast.get_qualified_name(o.root_parents().front());\n                } else {\n                    bvn = o.base_visitor()->simple();\n                    rpn = o.root_parents().front().simple();\n                }\n#>\n\nvoid <#= sn #>::accept(const <#= bvn #>& v) const {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef const <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n}\n\nvoid <#= sn #>::accept(<#= bvn #>& v) const {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n    }\n\nvoid <#= sn #>::accept(const <#= bvn #>& v) {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef const <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n}\n\nvoid <#= sn #>::accept(<#= bvn #>& v) {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n}\n<#+\n            }\n\n            /*\n             * Streaming\n             */\n            if (ast.is_io_enabled()) {\n                if (o.in_inheritance_relationship()) {\n#>\n\nvoid <#= sn #>::to_stream(std::ostream& s) const {\n<#+\n                io::inserter_implementation_helper(ast, o, true/*inside_class*/);\n#>\n}\n<#+\n                }\n            }\n\n            /*\n             * Swap\n             */\n            if (!o.is_immutable() && (!o.all_attributes().empty() || o.is_parent())) {\n                const bool empty(o.all_attributes().empty() && o.parents().empty());\n#>\n\nvoid <#= sn #>::swap(<#= sn #>&<#= (empty ? \"\" : \" other\") #>)<#= ast.make_noexcept_keyword_text() #> {\n<#+\n               if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= pqn #>::swap(other);\n\n<#+\n\n               }\n\n               if (!o.local_attributes().empty()) {\n#>\n    using std::swap;\n<#+\n                   for (const auto& attr : o.local_attributes())\n#>\n    swap(<#= attr.member_variable_name() #>, other.<#= attr.member_variable_name() #>);\n<#+\n               }\n#>\n}\n<#+\n            }\n\n            /*\n             * Equals method\n             */\n            // FIXME: looking at root_parent as a hack due to service leafs not\n            // FIXME: being processed atm.\n            if (!o.is_parent() && !o.parents().empty() && !o.root_parents().empty()) {\n                const auto rpn(o.root_parents().front());\n#>\n\nbool <#= sn #>::equals(const <#= ast.get_qualified_name(rpn) #>& other) const {\n    const <#= sn #>* const p(dynamic_cast<const <#= sn #>* const>(&other));\n    if (!p) return false;\n    return *this == *p;\n}\n<#+\n            }\n\n            /*\n             * Equals operator\n             */\n            std::string method_name;\n            if (o.is_parent())\n                method_name = \"compare\";\n            else\n                method_name = \"operator==\";\n#>\n\nbool <#= sn #>::<#= method_name #>(const <#= sn #>& <#= (o.all_attributes().empty() ? \"/*rhs*/\" : \"rhs\") #>) const {\n<#+\n\n            if (o.all_attributes().empty())\n#>\n    return true;\n<#+\n            else {\n                utility::formatters::sequence_formatter sf(o.parents().size());\n                sf.element_separator(\"\");\n                sf.prefix_configuration().first(\"return \").not_first(\"    \");\n                sf.postfix_configuration().not_last(\" &&\");\n                if (o.local_attributes().empty())\n                    sf.postfix_configuration().last(\";\");\n                else\n                    sf.postfix_configuration().last(\" &&\");\n\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= sf.prefix() #><#= pqn #>::compare(rhs)<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n                sf.reset(o.local_attributes().size());\n                sf.element_separator(\"\");\n                if (o.parents().empty())\n                   sf.prefix_configuration().first(\"return \");\n                else\n                   sf.prefix_configuration().first(\"    \");\n                sf.prefix_configuration().not_first(\"    \");\n                sf.postfix_configuration().last(\";\").not_last(\" &&\");\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= sf.prefix() #><#= attr.member_variable_name() #> == rhs.<#= attr.member_variable_name() #><#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n            }\n#>\n}\n<#+\n\n            /*\n             * Assignment\n             */\n            if (!o.all_attributes().empty() && !o.is_parent() && !o.is_immutable()) {\n#>\n\n<#= sn #>& <#= sn #>::operator=(<#= sn #> other) {\n    using std::swap;\n    swap(*this, other);\n    return *this;\n}\n<#+\n            }\n\n            /*\n             * Getters and setters\n             */\n             for (const auto& attr : o.local_attributes()) {\n                 if (attr.parsed_type().is_current_simple_type()) {\n#>\n\n<#= ast.get_qualified_name(attr.parsed_type()) #> <#= sn #>::<#= attr.name().simple() #>() const {\n    return <#= attr.member_variable_name() #>;\n}\n<#+\n                    if (!o.is_immutable()) {\n#>\n\n<#= (attr.is_fluent() ? sn + \"&\" : \"void\") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #> v) {\n    <#= attr.member_variable_name() #> = v;\n<#+\n                        if (attr.is_fluent()) {\n#>\n    return *this;\n<#+\n                        }\n#>\n}\n<#+\n                    }\n                } else {\n#>\n\nconst <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() const {\n    return <#= attr.member_variable_name() #>;\n}\n<#+\n                    if (!o.is_immutable()) {\n#>\n\n<#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() {\n    return <#= attr.member_variable_name() #>;\n}\n\n<#= (o.is_fluent() ? sn + \"&\" : \"void\") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>& v) {\n    <#= attr.member_variable_name() #> = v;\n<#+\n                        if (o.is_fluent()) {\n#>\n    return *this;\n<#+\n                        }\n#>\n}\n<#+\n                        if (ast.supports_move_operator()) {\n#>\n\n<#= (o.is_fluent() ? sn + \"&\" : \"void\") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v) {\n    <#= attr.member_variable_name() #> = std::move(v);\n<#+\n                            if (o.is_fluent()) {\n#>\n    return *this;\n<#+\n                            }\n#>\n}\n<#+\n                        }\n                    }\n                }\n            }\n#>\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::hash::enum_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io",
      "documentation": "Formatters for the io facet of the\nC++ technical space.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::io::class_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::class_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::enum_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::enum_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization",
      "documentation": "Formatters for the boost serialisation\nfacet of the C++ technical space.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::serialization::class_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::class_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data",
      "documentation": "Formatters for the test_data facet\nof the C++ technical space.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::test_data::class_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::class_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::enum_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::enum_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb",
      "documentation": "Formatters for the odb facet of the\nC++ technical space.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::odb::class_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::registrar",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::registrar_error",
      "documentation": "There was an error in the registrar.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "workflow_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::formatting_error",
      "documentation": "An error occurred whilst formatting.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::repository",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.io.enabled": "true",
        "masd.cpp.io.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stock_artefact_formatters_by_meta_name",
          "type": "std::unordered_map<std::string, std::forward_list<std::shared_ptr<transforms::model_to_text_transform>>>"
        },
        {
          "name": "stock_artefact_formatters_by_archetype",
          "type": "std::unordered_map<std::string, std::shared_ptr<transforms::model_to_text_transform>>"
        },
        {
          "name": "stock_artefact_formatters",
          "type": "std::forward_list<std::shared_ptr<transforms::model_to_text_transform>>"
        },
        {
          "name": "helper_formatters",
          "type": "std::unordered_map<std::string, std::unordered_map<std::string, std::list<std::shared_ptr<transforms::helper_transform>>>>"
        }
      ]
    },
    {
      "name": "transforms::workflow",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "registrar_",
          "type": "transforms::registrar"
        }
      ]
    },
    {
      "name": "transforms::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables",
      "documentation": "Formattables contains all types required by the formatters\nand those used to generate them.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "formattables::workflow",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::inclusion_constants",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::locator",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::dependencies_builder",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::building_error",
      "documentation": "An error occurred while the factory was building.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::artefact_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "file_path",
          "type": "boost::filesystem::path"
        },
        {
          "name": "header_guard",
          "type": "std::string"
        },
        {
          "name": "inclusion_dependencies",
          "type": "std::list<std::string>"
        }
      ]
    },
    {
      "name": "formattables::dependencies_builder_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::assistant",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stream_",
          "type": "std::ostringstream"
        }
      ]
    },
    {
      "name": "transforms::serialization::enum_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::enum_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::context",
      "documentation": "Supplies additional information required for formatting.\n",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "model",
          "type": "formattables::model"
        },
        {
          "name": "element_properties",
          "type": "formattables::element_properties"
        },
        {
          "name": "helpers",
          "type": "std::unordered_map<std::string, std::unordered_map<std::string, std::list<std::shared_ptr<transforms::helper_transform>>>>"
        }
      ]
    },
    {
      "name": "transforms::helper_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::building_error",
      "documentation": "An error occurred whilst the factory was building.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_descriptor",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "family",
          "type": "std::string"
        },
        {
          "name": "namespaces",
          "type": "std::list<std::string>"
        },
        {
          "name": "name_identifiable",
          "type": "std::string"
        },
        {
          "name": "name_qualified",
          "type": "std::string"
        },
        {
          "name": "name_tree_qualified",
          "type": "std::string"
        },
        {
          "name": "name_tree_identifiable",
          "type": "std::string"
        },
        {
          "name": "streaming_properties",
          "type": "boost::optional<formattables::streaming_properties>"
        },
        {
          "name": "is_simple_type",
          "type": "bool"
        },
        {
          "name": "requires_hashing_helper",
          "type": "bool"
        },
        {
          "name": "is_circular_dependency",
          "type": "bool"
        },
        {
          "name": "is_pointer",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::helper_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "current",
          "type": "formattables::helper_descriptor"
        },
        {
          "name": "direct_descendants",
          "type": "std::list<formattables::helper_descriptor>"
        },
        {
          "name": "in_inheritance_relationship",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::element_properties",
      "documentation": "All of the properties associated with an element.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "aspect_properties",
          "type": "formattables::aspect_properties"
        },
        {
          "name": "artefact_properties",
          "type": "std::unordered_map<std::string, formattables::artefact_properties>"
        },
        {
          "name": "helper_properties",
          "type": "std::list<formattables::helper_properties>"
        },
        {
          "name": "canonical_archetype_to_archetype",
          "type": "std::unordered_map<std::string, std::string>"
        },
        {
          "name": "attribute_level_test_data_properties",
          "type": "std::unordered_map<std::string, test_data_properties>"
        }
      ]
    },
    {
      "name": "formattables::aspect_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "requires_manual_default_constructor",
          "type": "bool"
        },
        {
          "name": "requires_manual_move_constructor",
          "type": "bool"
        },
        {
          "name": "requires_stream_manipulators",
          "type": "bool"
        }
      ]
    },
    {
      "name": "transforms::inclusion_support_types",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "not_supported",
          "type": "",
          "documentation": "This formatter does not export an inclusion directive.\n"
        },
        {
          "name": "regular_support",
          "type": "",
          "documentation": "This formatter exports a regular inclusion directive.\n"
        },
        {
          "name": "canonical_support",
          "type": "",
          "documentation": "This formatter exports a regular inclusion directive and is the default for its facet\nand element.\n"
        }
      ]
    },
    {
      "name": "transforms::types::builtin_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::builtin_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::builtin_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::builtin_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::builtin_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::builtin_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::formattable",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "element",
          "type": "boost::shared_ptr<logical::entities::element>"
        },
        {
          "name": "element_properties",
          "type": "formattables::element_properties"
        },
        {
          "name": "artefacts",
          "type": "std::unordered_map<std::string, boost::shared_ptr<physical::entities::artefact>>"
        }
      ]
    },
    {
      "name": "formattables::adapter",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::inclusion_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::reducer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::model_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::file_path_and_guard_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::aspect_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::adaptation_error",
      "documentation": "An error occurred during adaptation.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::expansion_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::odb_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::model",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "name",
          "type": "logical::entities::name"
        },
        {
          "name": "streaming_properties",
          "type": "std::unordered_map<std::string, formattables::streaming_properties>"
        },
        {
          "name": "formattables",
          "type": "std::unordered_map<std::string, formattables::formattable>"
        },
        {
          "name": "facet_properties",
          "type": "std::unordered_map<std::string, formattables::facet_properties>"
        },
        {
          "name": "cpp_standard",
          "type": "formattables::cpp_standards"
        },
        {
          "name": "odb_databases",
          "type": "std::list<std::string>"
        },
        {
          "name": "odb_sql_name_case",
          "type": "std::string"
        },
        {
          "name": "project_items",
          "type": "std::list<std::string>"
        }
      ]
    },
    {
      "name": "formattables::facet_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory",
          "type": "std::string"
        },
        {
          "name": "enabled",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::facet_directory_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::canonical_archetype_resolver",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::canonical_archetype_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::resolution_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::streaming_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "requires_quoting",
          "type": "bool"
        },
        {
          "name": "string_conversion_method",
          "type": "std::string"
        },
        {
          "name": "remove_unprintable_characters",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::streaming_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::locator_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "facet_configurations",
          "type": "std::unordered_map<std::string, formattables::locator_facet_configuration>"
        },
        {
          "name": "archetype_configurations",
          "type": "std::unordered_map<std::string, formattables::locator_archetype_configuration>"
        },
        {
          "name": "include_directory_name",
          "type": "std::string"
        },
        {
          "name": "source_directory_name",
          "type": "std::string"
        },
        {
          "name": "disable_facet_directories",
          "type": "bool"
        },
        {
          "name": "header_file_extension",
          "type": "std::string"
        },
        {
          "name": "implementation_file_extension",
          "type": "std::string"
        },
        {
          "name": "backend_directory_name",
          "type": "std::string"
        },
        {
          "name": "tests_directory_name",
          "type": "std::string"
        },
        {
          "name": "templates_directory_name",
          "type": "std::string"
        },
        {
          "name": "templates_file_extension",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::locator_facet_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory",
          "type": "std::string"
        },
        {
          "name": "postfix",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::locator_archetype_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "facet_directory",
          "type": "std::string"
        },
        {
          "name": "facet_postfix",
          "type": "std::string"
        },
        {
          "name": "archetype_postfix",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "transforms::wale_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::stitch_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::smart_pointer_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::smart_pointer_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::time_duration_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::ptree_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::associative_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::date_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::optional_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::path_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::pair_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::sequence_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::ptime_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::variant_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::associative_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::smart_pointer_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::ptree_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::optional_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::pair_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::sequence_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::variant_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::string_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::path_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::associative_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::char_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::bool_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::date_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::domain_type_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::number_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::optional_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::pair_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::path_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::ptime_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::ptree_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::sequence_container_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::smart_pointer_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::string_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::time_duration_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::variant_helper",
      "stereotypes": [
        "dogen::cpp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::inserter_implementation_helper",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_implementation.formatting_style": "stitch",
        "masd.cpp.types.class_implementation.overwrite": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::location_error",
      "documentation": "An error occurred while the locator was creating a path.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "helper_families",
          "type": "std::unordered_map<std::string, std::string>"
        },
        {
          "name": "streaming_properties",
          "type": "std::unordered_map<std::string, formattables::streaming_properties>"
        }
      ]
    },
    {
      "name": "transforms::types::primitive_header_transform",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.public_headers",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.primitive",
        "masd.wale.text_template": "cpp_artefact_transform_implementation_header.wale",
        "masd.wale.kvp.class.simple_name": "primitive_header_transform",
        "masd.wale.kvp.archetype.simple_name": "primitive_header",
        "masd.wale.kvp.class.inclusion_support_type": "canonical_support",
        "masd.wale.kvp.meta_element": "primitive",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/serialization/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/inclusion_constants.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/primitive_header_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> primitive_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& e) const {\n\n    using logical::entities::structural::primitive;\n    const auto& p(assistant::as<primitive>(e));\n    auto builder(f.make());\n\n    // algorithm: domain headers need it for the swap function.\n    builder.add(inclusion_constants::std::algorithm());\n\n    using ser = transforms::serialization::traits;\n    const auto ser_fwd_arch(ser::primitive_forward_declarations_archetype_qn());\n    builder.add(p.name(), ser_fwd_arch);\n\n    const auto carch(traits::canonical_archetype());\n    builder.add(p.value_attribute().parsed_type().current(), carch);\n\n    return builder.build();\n}\n\nvoid primitive_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto attr(p.value_attribute());\n\n            ast.comment(p.documentation());\n#>\nclass <#= sn #> final {\npublic:\n<#+\n            /*\n             * Compiler generated constructors and destructors.\n             */\n            if (!ast.requires_manual_default_constructor())\n#>\n    <#= sn #>() = default;\n    <#= sn #>(const <#= sn #>&) = default;\n<#+\n            if (!ast.requires_manual_move_constructor())\n#>\n    <#= sn #>(<#= sn #>&&) = default;\n    ~<#= sn #>() = default;\n<#+\n            if (p.is_immutable())\n#>\n    <#= sn #>& operator=(const <#= sn #>&) = delete;\n<#+\n            /*\n             * Manually generated default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\npublic:\n    <#= sn #>();\n\n<#+\n            }\n\n            /*\n             * Manually generated move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\npublic:\n    <#= sn #>(<#= sn #>&& rhs);\n\n<#+\n            }\n\n            /*\n             * Manually generated complete constructor.\n             */\n#>\npublic:\n    explicit <#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>);\n\n<#+\n            /*\n             * Serialisaton Friends\n             */\n            if (ast.is_serialization_enabled()) {\n#>\nprivate:\n    template<typename Archive>\n    friend void boost::serialization::save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\n    template<typename Archive>\n    friend void boost::serialization::load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n<#+\n            }\n\n            /*\n             * Getters and setters.\n             */\n#>\npublic:\n<#+\n            ast.comment_start_method_group(attr.documentation(), !attr.is_immutable());\n            if (attr.parsed_type().is_current_simple_type()) {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #>() const;\n<#+\n                if (attr.is_immutable()) {\n#>\n\n<#+\n\n                } else {\n#>\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n<#+\n                }\n            } else {\n#>\n    const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= attr.name().simple() #>() const;\n<#+\n                if (attr.is_immutable()) {\n#>\n\n<#+\n                } else {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>();\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v);\n<#+\n                }\n            }\n            ast.comment_end_method_group(attr.documentation(), !attr.is_immutable());\n\n            /*\n             * Explicit cast.\n             */\n#>\n\npublic:\n    explicit operator <#= ast.get_qualified_name(attr.parsed_type()) #>() const {\n        return <#= attr.member_variable_name() #>;\n    }\n<#+\n            /*\n             * Equality.\n             */\n#>\n\npublic:\n    bool operator==(const <#= sn #>& rhs) const;\n    bool operator!=(const <#= sn #>& rhs) const {\n        return !this->operator==(rhs);\n    }\n\n<#+\n            /*\n             * Swap and assignment.\n             */\n#>\npublic:\n    void swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #>;\n<#+\n            if (!p.is_immutable()) {\n#>\n    <#= sn #>& operator=(<#= sn #> other);\n<#+\n            }\n\n            /*\n             * Member variables.\n             */\n#>\n\nprivate:\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.member_variable_name() #>;\n};\n\n<#+\n        } // snf\n\n        if (!p.is_immutable()) {\n#>\n\nnamespace std {\n\ntemplate<>\ninline void swap(\n    <#= qn #>& lhs,\n    <#= qn #>& rhs) {\n    lhs.swap(rhs);\n}\n\n}\n<#+\n        }\n#>\n\n<#+\n    } //ah  sbf\n    ast.update_artefact();\n}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation_header"
        }
      ]
    },
    {
      "name": "transforms::hash::primitive_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::primitive_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::primitive_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::primitive_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::primitive_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::primitive_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::hash::primitive_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::primitive_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::primitive_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::primitive_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::directive_group_repository",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "by_id",
          "type": "std::unordered_map<std::string, std::unordered_map<std::string, formattables::directive_group>>"
        }
      ]
    },
    {
      "name": "formattables::directive_group_repository_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::directive_group",
      "documentation": "Represents the group of inclusion directives associated with a name and an archetype.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "primary",
          "type": "std::string",
          "documentation": "The main inclusion directive needed for this element.\n"
        },
        {
          "name": "secondary",
          "type": "std::list<std::string>",
          "documentation": "Any other directives that are also needed for this element.\n"
        }
      ]
    },
    {
      "name": "formattables::build_files_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::cpp_standards",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "cpp_98",
          "type": ""
        },
        {
          "name": "cpp_11",
          "type": ""
        },
        {
          "name": "cpp_14",
          "type": ""
        },
        {
          "name": "cpp_17",
          "type": ""
        }
      ]
    },
    {
      "name": "formattables::cpp_standard_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::header_guard_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::test_data_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "maximum_size",
          "type": "unsigned int"
        },
        {
          "name": "prefix",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::test_data_properties_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::repository_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests",
      "documentation": "Formatters that generate tests for generated\ncode.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::tests::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests::class_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests::enum_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::feature_template_bundle_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::feature_template_bundle_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::variability_initializer_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::variability_initializer_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "feature_initializer",
      "stereotypes": [
        "masd::variability::initializer"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::global_features",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "tagged_values": {
        "masd.variability.generate_static_configuration": "false",
        "masd.variability.key_prefix": "masd.cpp"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "headers_output_directory",
          "type": "masd::variability::text",
          "documentation": "Override location of public c++ headers.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "directory",
          "type": "masd::variability::text",
          "value": "\"cpp\"",
          "documentation": "Directory in which to place code for the C++ backend.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "inclusion_required",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, inclusion is required for this modeling element.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "source_directory_name",
          "type": "masd::variability::text",
          "value": "\"src\"",
          "documentation": "Directory in which to place C++ source files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "include_directory_name",
          "type": "masd::variability::text",
          "value": "\"include\"",
          "documentation": "Directory in which to place include headers.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "tests_directory_name",
          "type": "masd::variability::text",
          "value": "\"generated_tests\"",
          "documentation": "Directory in which to place c++ tests.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "templates_directory_name",
          "type": "masd::variability::text",
          "value": "\"templates\"",
          "documentation": "Directory in which to place text templates.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "header_file_extension",
          "type": "masd::variability::text",
          "value": "\"hpp\"",
          "documentation": "Extension to use for C++ header files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "implementation_file_extension",
          "type": "masd::variability::text",
          "value": "\"cpp\"",
          "documentation": "Extension to use for C++ implementation files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "templates_file_extension",
          "type": "masd::variability::text",
          "value": "\"wale\"",
          "documentation": "Extension to use for text templates.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "enable_unique_file_names",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, make all file names unique within a model.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "aspect.requires_manual_default_constructor",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, the modeling element requires a manual defaul constructor.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "aspect.requires_manual_move_constructor",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, the modeling element requires a manual move constructor.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "aspect.requires_stream_manipulators",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, the modeling element requires stream manipulators.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "disable_facet_directories",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, facet directories will not be used.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "standard",
          "type": "masd::variability::text",
          "value": "\"c++-14\"",
          "documentation": "Which version of C++ to use.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "helper.family",
          "type": "masd::variability::text",
          "value": "\"Default\"",
          "documentation": "Which family of helpers to use for this modeling element.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "streaming.string_conversion_method",
          "type": "masd::variability::text",
          "value": "\"\"",
          "documentation": "Which conversion method to use to convert strings.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "streaming.requires_quoting",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, streaming this type must be preceeded by quoting.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "streaming.remove_unprintable_characters",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, streaming this type requires removing unprintable characters.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        }
      ]
    },
    {
      "name": "transforms::archetype_features",
      "stereotypes": [
        "masd::variability::feature_template_bundle"
      ],
      "tagged_values": {
        "masd.variability.default_binding_point": "element",
        "masd.variability.instantiation_domain_name": "masd.cpp.archetype"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "primary_inclusion_directive",
          "type": "masd::variability::text"
        },
        {
          "name": "secondary_inclusion_directive",
          "type": "masd::variability::text_collection"
        }
      ]
    },
    {
      "name": "transforms::lexical_cast",
      "documentation": "Formatters related to conversions from and to\nstring.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::lexical_cast::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::lexical_cast::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::lexical_cast::enum_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "cpp_artefact_transform_header",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "class {{class.simple_name}} final : public model_to_text_transform {\npublic:\n    physical::entities::archetype static_archetype() const;\n    physical::entities::archetype archetype() const override;\n\npublic:\n    std::list<std::string> inclusion_dependencies(\n        const formattables::dependencies_builder_factory& f,\n        const logical::entities::element& e) const override;\n\n    inclusion_support_types inclusion_support_type() const override;\n\n    boost::filesystem::path inclusion_path(\n        const formattables::locator& l,\n        const logical::entities::name& n) const override;\n\n    boost::filesystem::path full_path(\n        const formattables::locator& l,\n        const logical::entities::name& n) const override;\n\npublic:\n    void apply(const context& ctx, const logical::entities::element& e,\n        physical::entities::artefact& a) const override;\n};\n"
        }
      ]
    },
    {
      "name": "cpp_artefact_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "physical::entities::archetype {{class.simple_name}}::static_archetype() const {\n    static physical::entities::archetype r([]() {\n        physical::entities::archetype r;\n        using pmnf = physical::helpers::meta_name_factory;\n        r.meta_name(pmnf::make(cpp::traits::backend_sn(),\n            traits::facet_sn(), traits::{{archetype.simple_name}}_archetype_sn()));\n        using lmnf = {{meta_name_factory}};\n        r.logical_meta_element_id(lmnf::make_{{meta_element}}_name().qualified().dot());\n        return r;\n    }());\n    return r;\n}\n\nphysical::entities::archetype {{class.simple_name}}::archetype() const {\n    return static_archetype();\n}\n\ninclusion_support_types {{class.simple_name}}::inclusion_support_type() const {\n    return inclusion_support_types::not_supported;\n}\n\nboost::filesystem::path {{class.simple_name}}::inclusion_path(\n    const formattables::locator& /*l*/, const logical::entities::name& n) const {\n\n    using namespace dogen::utility::log;\n    static logger lg(logger_factory(archetype().meta_name().qualified()));\n    static const std::string not_supported(\"Inclusion path is not supported: \");\n\n    BOOST_LOG_SEV(lg, error) << not_supported << n.qualified().dot();\n    BOOST_THROW_EXCEPTION(formatting_error(not_supported + n.qualified().dot()));\n}\n\nboost::filesystem::path {{class.simple_name}}::full_path(\n    const formattables::locator& l, const logical::entities::name& n) const {\n    return l.make_full_path_for_cpp_implementation(n, archetype().meta_name().qualified());\n}\n"
        }
      ]
    },
    {
      "name": "cpp_artefact_transform_implementation_header",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "physical::entities::archetype {{class.simple_name}}::static_archetype() const {\n    static physical::entities::archetype r([]() {\n        physical::entities::archetype r;\n        using pmnf = physical::helpers::meta_name_factory;\n        r.meta_name(pmnf::make(cpp::traits::backend_sn(),\n            traits::facet_sn(), traits::{{archetype.simple_name}}_archetype_sn()));\n        using lmnf = {{meta_name_factory}};\n        r.logical_meta_element_id(lmnf::make_{{meta_element}}_name().qualified().dot());\n        return r;\n    }());\n    return r;\n}\n\nphysical::entities::archetype {{class.simple_name}}::archetype() const {\n    return static_archetype();\n}\n\ninclusion_support_types {{class.simple_name}}::inclusion_support_type() const {\n    return inclusion_support_types::{{class.inclusion_support_type}};\n}\n\nboost::filesystem::path {{class.simple_name}}::inclusion_path(\n    const formattables::locator& l, const logical::entities::name& n) const {\n    return l.make_inclusion_path_for_cpp_header(n, archetype().meta_name().qualified());\n}\n\nboost::filesystem::path {{class.simple_name}}::full_path(\n    const formattables::locator& l, const logical::entities::name& n) const {\n    return l.make_full_path_for_cpp_header(n, archetype().meta_name().qualified());\n}\n"
        }
      ]
    },
    {
      "name": "cpp_helper_transform_header",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "class {{class.simple_name}} : public helper_transform {\npublic:\n    std::string id() const override;\n    std::string family() const override;\n    std::list<std::string> owning_formatters() const override;\n    std::list<std::string> owning_facets() const override;\n    std::string helper_name() const override;\n    bool is_enabled(const assistant& a,\n        const formattables::helper_properties& hc) const override;\n    void apply(assistant& a,\n        const formattables::helper_properties& hc) const override;\n};\n"
        }
      ]
    },
    {
      "name": "cpp_helper_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "std::string {{class.simple_name}}::id() const {\n    static auto r(std::string(\"<\") + traits::facet_qn() + std::string(\">\") +\n        std::string(\"<\") + helper_name() + std::string(\">\"));\n    return r;\n}\n\nstd::string {{class.simple_name}}::family() const {\n    static std::string r(\"{{helper.family}}\");\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_formatters() const {\n    static auto r(std::list<std::string> {\n        io::traits::class_implementation_archetype_qn(),\n        io::traits::primitive_implementation_archetype_qn(),\n        types::traits::class_implementation_archetype_qn(),\n        types::traits::primitive_implementation_archetype_qn()\n    });\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_facets() const {\n    static auto r(std::list<std::string> {\n        io::traits::facet_qn(), types::traits::facet_qn()\n    });\n    return r;\n}\n\nstd::string {{class.simple_name}}::helper_name() const {\n    static std::string r(\"{{class.simple_name}}\");\n    return r;\n}\n\nbool {{class.simple_name}}::is_enabled(const assistant& a,\n    const formattables::helper_properties& hp) const {\n    return a.is_streaming_enabled(hp);\n}\n"
        }
      ]
    },
    {
      "name": "cpp_helper_transform_implementation_enabled",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "std::string {{class.simple_name}}::id() const {\n    static auto r(std::string(\"<\") + traits::facet_qn() + std::string(\">\") +\n        std::string(\"<\") + helper_name() + std::string(\">\"));\n    return r;\n}\n\nstd::string {{class.simple_name}}::family() const {\n    static std::string r(\"{{helper.family}}\");\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_formatters() const {\n    static auto r(std::list<std::string> {\n        traits::class_implementation_archetype_qn(),\n        traits::primitive_implementation_archetype_qn()\n    });\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_facets() const {\n    static auto r(std::list<std::string> {\n        traits::facet_qn()\n    });\n    return r;\n}\n\nstd::string {{class.simple_name}}::helper_name() const {\n    static std::string r(\"{{class.simple_name}}\");\n    return r;\n}\n\nbool {{class.simple_name}}::is_enabled(const assistant& /*a*/,\n    const formattables::helper_properties& /*hp*/) const {\n    return true;\n}\n"
        }
      ]
    },
    {
      "name": "transforms::templates",
      "documentation": "Formatters related to templating.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::templates::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::templates::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::templates::logic_less_template_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::class_forward_declarations_transform",
      "documentation": "Generates forward declarations for classes.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.public_headers",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.kvp.class.simple_name": "class_forward_declarations_transform",
        "masd.wale.kvp.archetype.simple_name": "class_forward_declarations",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.wale.kvp.meta_element": "object",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/class_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> class_forward_declarations_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid class_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= o.name().simple() #>;\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation_header"
        }
      ]
    },
    {
      "name": "transforms::types::visitor_forward_declarations_transform",
      "documentation": "Generates forward declarations for visitors.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.public_headers",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visitor",
        "masd.wale.kvp.class.simple_name": "visitor_forward_declarations_transform",
        "masd.wale.kvp.archetype.simple_name": "visitor_forward_declarations",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.wale.kvp.meta_element": "visitor",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/visitor.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/visitor_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> visitor_forward_declarations_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid visitor_forward_declarations_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::structural::visitor>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= o.name().simple() #>;\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation_header"
        }
      ]
    },
    {
      "name": "transforms::serialization::class_forward_declarations_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::primitive_forward_declarations_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::primitive_forward_declarations_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::type_registrar_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::serialization::type_registrar_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "registrar",
      "stereotypes": [
        "masd::serialization::type_registrar"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio",
      "documentation": "Formatters related to Visual Studio support.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::visual_studio::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::project_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::solution_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests::main_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::object_odb_options_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::primitive_odb_options_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::main_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "main",
      "stereotypes": [
        "masd::entry_point",
        "dogen::untypable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::odb::common_odb_options_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::msbuild_targets_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::build",
      "documentation": "Formatters related to build files.\n",
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::build::source_cmakelists_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::build::include_cmakelists_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::build::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::build::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::tests::cmakelists_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "CMakeLists",
      "stereotypes": [
        "masd::build::cmakelists",
        "dogen::handcrafted::cmake"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::feature_bundle_header_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::feature_bundle_implementation_transform",
      "stereotypes": [
        "dogen::cpp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::archetype_class_header_transform",
      "documentation": "A comment.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.public_headers",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype",
        "masd.wale.kvp.class.simple_name": "archetype_class_header_transform",
        "masd.wale.kvp.archetype.simple_name": "archetype_class_header",
        "masd.wale.kvp.class.inclusion_support_type": "regular_support",
        "masd.wale.kvp.meta_element": "physical_archetype",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> archetype_class_header_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& f,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n\n    auto builder(f.make());\n    builder.add_as_user(\"dogen.text.cpp/types/transforms/model_to_text_transform.hpp\");\n\n    return builder.build();\n}\n\nvoid archetype_class_header_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), true/*requires_header_guard*/, a);\n    const auto& o(ast.as<logical::entities::physical::archetype>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= o.name().simple() #> final : public model_to_text_transform {\npublic:\n    physical::entities::archetype static_archetype() const;\n    physical::entities::archetype archetype() const override;\n\npublic:\n    std::list<std::string> inclusion_dependencies(\n        const formattables::dependencies_builder_factory& f,\n        const logical::entities::element& e) const override;\n\n    inclusion_support_types inclusion_support_type() const override;\n\n    boost::filesystem::path inclusion_path(\n        const formattables::locator& l,\n        const logical::entities::name& n) const override;\n\n    boost::filesystem::path full_path(\n        const formattables::locator& l,\n        const logical::entities::name& n) const override;\n\npublic:\n    void apply(const context& ctx, const logical::entities::element& e,\n        physical::entities::artefact& a) const override;\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation_header"
        }
      ]
    },
    {
      "name": "transforms::public_headers",
      "documentation": "Contains the header files that are publicly visible.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "internal_modules_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "true"
        }
      ]
    },
    {
      "name": "transforms::standard_header_file",
      "documentation": "Header file generated by Dogen.\n",
      "stereotypes": [
        "masd::physical::archetype_kind"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "file_extension",
          "type": "",
          "value": "hpp"
        }
      ]
    },
    {
      "name": "transforms::types::archetype_class_implementation_transform",
      "documentation": "A comment.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.part_id": "masd.cpp.public_headers",
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype",
        "masd.wale.kvp.class.simple_name": "archetype_class_implementation_transform",
        "masd.wale.kvp.archetype.simple_name": "archetype_class_implementation",
        "masd.wale.kvp.meta_element": "physical_archetype",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/formatting_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/archetype_class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.cpp/types/transforms/types/traits.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nstd::list<std::string> archetype_class_implementation_transform::inclusion_dependencies(\n    const formattables::dependencies_builder_factory& /*f*/,\n    const logical::entities::element& /*e*/) const {\n    static std::list<std::string> r;\n    return r;\n}\n\nvoid archetype_class_implementation_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), false/*requires_header_guard*/, a);\n    const auto& arch(ast.as<logical::entities::physical::archetype>(e));\n    a.overwrite(true);\n    ast.update_artefact();\n    a.content(arch.rendered_stitch_template());\n}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::implementation",
      "documentation": "Contains the implementation files.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        }
      ]
    }
  ]
}
