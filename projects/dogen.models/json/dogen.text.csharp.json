{
  "documentation": "CSharp is the c# model in the default generation kernel.\n",
  "tagged_values": {
    "masd.injection.dia.comment": "true",
    "masd.injection.model_modules": "dogen.text.csharp",
    "masd.injection.reference": "cpp.builtins",
    "masd.injection.reference": "cpp.boost",
    "masd.injection.reference": "cpp.std",
    "masd.injection.reference": "dogen",
    "masd.injection.reference": "dogen.variability",
    "masd.injection.reference": "dogen.tracing",
    "masd.injection.reference": "dogen.logical",
    "masd.injection.reference": "masd",
    "masd.injection.reference": "masd.variability",
    "masd.injection.reference": "dogen.profiles",
    "masd.injection.input_technical_space": "cpp",
    "masd.variability.profile": "dogen.profiles.base.default_profile"
  },
  "elements": [
    {
      "name": "model_to_text_csharp_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "workflow_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms",
      "documentation": "M2T transforms for the C# Technical Space.\n\nTakes types in the logical model and creates text\nrepresentations of these types according to the grammar\nof the C# Technical Space.\n",
      "stereotypes": [
        "masd::physical::backend"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true",
        "masd.physical.backend_name": "csharp",
        "masd.physical.major_technical_space": "csharp"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::workflow",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "registrar_",
          "type": "transforms::registrar"
        }
      ]
    },
    {
      "name": "transforms::registrar",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "formatter_repository_",
          "type": "transforms::repository"
        }
      ]
    },
    {
      "name": "transforms::model_to_text_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable::header_only"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::repository",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.io.enabled": "true",
        "masd.cpp.io.overwrite": "false",
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stock_artefact_formatters_by_meta_name",
          "type": "std::unordered_map<std::string, std::forward_list<std::shared_ptr<transforms::model_to_text_transform>>>"
        },
        {
          "name": "stock_artefact_formatters",
          "type": "std::forward_list<std::shared_ptr<transforms::model_to_text_transform>>"
        },
        {
          "name": "stock_artefact_formatters_by_archetype",
          "type": "std::unordered_map<std::string, std::shared_ptr<transforms::model_to_text_transform>>"
        }
      ]
    },
    {
      "name": "transforms::types",
      "documentation": "M2T transforms for the types facet of\nthe C# Technical Space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::types::class_transform",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/class_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    const auto id(e.name().qualified().dot());\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& o(ast.as<logical::entities::structural::object>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n            if (!o.in_inheritance_relationship() || !o.is_child()) {\n#>\n    public <#= ast.make_inheritance_keyword_text(o) #>class <#= sn #>\n<#+\n            } else {\n                const auto& pn(o.parents().front());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\n    public <#= ast.make_inheritance_keyword_text(o) #>class <#= sn #> : <#= pqn #>\n<#+\n            }\n#>\n    {\n<#+\n            if (!o.local_attributes().empty()) {\n                if (!ctx.element_properties().helper_properties().empty())\n                    ast.add_helper_methods(id);\n\n                /*\n                * Properties\n                */\n#>\n        #region Properties\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    ast.comment(attr.documentation(), 2/*indent*/);\n#>\n        public <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #> { get; <#= (o.is_immutable() ? \"internal \" : \"\") #>set; }\n<#+\n                }\n#>\n        #endregion\n\n<#+\n            }\n\n            /*\n             * Constructors.\n             */\n#>\n        #region Constructors\n        public <#= sn #>() { }\n<#+\n            if (!o.all_attributes().empty()) {\n                const auto attr_count(o.all_attributes().size());\n                if (attr_count == 1) {\n                     const auto attr(*o.all_attributes().begin());\n#>\n        public <#= sn #>(<#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #>)\n<#+\n                } else {\n#>\n\n        public <#= sn #>(\n<#+\n                    utility::formatters::sequence_formatter sf(attr_count);\n                    sf.postfix_configuration().last(\")\");\n                    for (const auto& attr : o.all_attributes()) {\n#>\n            <#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #><#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n                }\n\n                if (!o.parents().empty()) {\n                    const auto& pair(*o.inherited_attributes().begin());\n                    const auto& pattrs(pair.second);\n                    const auto size(pattrs.size());\n\n                    if (size == 0) {\n#>\n            : base()\n<#+\n                    } else if (size == 1) {\n#>\n            : base(<#= ast.make_argument_name(pattrs.front()) #>)\n<#+\n                    } else {\n                        utility::formatters::sequence_formatter sf(size);\n                        sf.postfix_configuration().last(\")\");\n                        sf.prefix_configuration().first(\",\").not_first(\",\");\n#>\n            : base(\n<#+\n                        for (const auto& pattr : pattrs) {\n#>\n                <#= ast.make_argument_name(pattr) #><#= sf.postfix() #>\n<#+\n                            sf.next();\n                        }\n                    }\n                }\n#>\n        {\n<#+\n                if (o.local_attributes().empty()) {\n#>\n            // no properties\n<#+\n                } else {\n                    for (const auto& attr : o.local_attributes()) {\n#>\n            <#= attr.name().simple() #> = <#= ast.make_argument_name(attr) #>;\n<#+\n                    }\n                }\n#>\n        }\n<#+\n            }\n#>\n        #endregion\n\n<#+\n            /*\n             * Equals\n             */\n#>\n        #region Equality\n        public override bool Equals(object obj)\n        {\n            if (ReferenceEquals(null, obj)) return false;\n            if (ReferenceEquals(this, obj)) return true;\n            if (obj.GetType() != GetType()) return false;\n\n            var value = obj as <#= sn #>;\n<#+\n            if (o.local_attributes().empty()) {\n                if (!o.parents().empty()) {\n#>\n            return (value != null && base.Equals(value));\n<#+\n                } else {\n#>\n            return value != null;\n<#+\n                }\n            } else {\n                if (!o.parents().empty()) {\n#>\n            if (value == null || !base.Equals(value)) return false;\n<#+\n                } else {\n#>\n            if (value == null) return false;\n<#+\n                }\n#>\n\n            return\n<#+\n                utility::formatters::sequence_formatter sf(o.local_attributes().size());\n                sf.element_separator(\"\");\n                sf.postfix_configuration().not_last(\" &&\");\n                sf.postfix_configuration().last(\";\");\n                for (const auto& attr : o.local_attributes()) {\n                    if (attr.parsed_type().is_current_simple_type()) {\n                        if (attr.parsed_type().is_floating_point()) {\n#>\n                NearlyEqual(<#= attr.name().simple() #>, value.<#= attr.name().simple() #>)<#= sf.postfix() #>\n<#+\n                        } else {\n#>\n                <#= attr.name().simple() #> == value.<#= attr.name().simple() #><#= sf.postfix() #>\n<#+\n                        }\n                    } else {\n#>\n                <#= attr.name().simple() #> != null && value.<#= attr.name().simple() #> != null &&\n                <#= attr.name().simple() #>.Equals(value.<#= attr.name().simple() #>)<#= sf.postfix() #>\n<#+\n                    }\n                    sf.next();\n                }\n            }\n#>\n        }\n\n        public static bool operator ==(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            if (Object.ReferenceEquals(lhs, rhs))\n                return true;\n\n            return !Object.ReferenceEquals(null, lhs) && lhs.Equals(rhs);\n        }\n\n        public static bool operator !=(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            return !(lhs == rhs);\n        }\n\n        public override int GetHashCode()\n        {\n<#+\n            if (o.local_attributes().empty()) {\n#>\n            return 0;\n<#+\n            } else {\n#>\n            unchecked\n            {\n                // Choose large primes to avoid hashing collisions\n                const int HashingBase = (int) 2166136261;\n                const int HashingMultiplier = 16777619;\n\n                int hash = HashingBase;\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    if (attr.parsed_type().is_current_simple_type()) {\n#>\n                hash = (hash * HashingMultiplier) ^ <#= attr.name().simple() #>.GetHashCode();\n<#+\n                    } else {\n#>\n                hash = (hash * HashingMultiplier) ^\n                    (!<#= ast.reference_equals(attr) #>.ReferenceEquals(null, <#= attr.name().simple() #>) ? <#= attr.name().simple() #>.GetHashCode() : 0);\n<#+\n                    }\n                }\n#>\n                return hash;\n            }\n<#+\n            }\n#>\n        }\n        #endregion\n<#+\n            if (o.in_inheritance_relationship())\n            {\n#>\n\n        #region Dumpers\n<#+\n                if (o.is_parent() && !o.is_child()) {\n#>\n        internal abstract string Dump();\n<#+\n                } else if (o.is_leaf()) {\n#>\n        internal override string Dump()\n        {\n            return <#= sn #>Dumper.Dump(this);\n        }\n<#+\n                }\n#>\n        #endregion\n<#+\n        }\n#>\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::types::enum_transform",
      "documentation": "Generates implementation files for enums.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/enum_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n            if (ye.use_implementation_defined_underlying_element())\n#>\n    public enum <#= sn #>\n<#+\n            else\n#>\n    public enum <#= sn #> : <#= ast.get_qualified_name(ye.underlying_element()) #>\n    {\n<#+\n            utility::formatters::sequence_formatter sf(ye.enumerators().size());\n            for (const auto& en : ye.enumerators()) {\n                if (ye.use_implementation_defined_enumerator_values())\n#>\n        <#= en.name().simple() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                else\n#>\n        <#= en.name().simple() #> = <#= en.value() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                sf.next();\n            }\n#>\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::io",
      "documentation": "M2T transforms for the io facet of\nthe C# Technical Space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::io::class_transform",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/class_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& o(ast.as<logical::entities::structural::object>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const bool has_attributes(!o.local_attributes().empty());\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>Dumper\n    {\n        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)\n        {\n            assistant.IncrementDepth();\n            if (assistant.MaximumDepthExceeded())\n                return;\n\n            assistant.AddStartObject();\n            assistant.AddType(\"<#= qn #>\", true/*withSeparator*/);\n            if (value == null)\n            {\n                assistant.Add(\"data\", \"<null>\");\n                assistant.AddEndObject();\n                return;\n            }\n\n            assistant.AddKey(\"data\");\n            assistant.AddPairSeparator();\n            assistant.AddStartObject();\n<#+\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n            assistant.AddKey(\"__parent_0__\");\n            assistant.AddPairSeparator();\n            <#= pqn #>Dumper.Dump(assistant, value<#= (has_attributes ? \", true/*withSeparator*/\" : \"\") #>);\n<#+\n                }\n\n                utility::formatters::sequence_formatter sf(o.local_attributes().size());\n                sf.element_separator(\"\");\n                sf.postfix_configuration().not_last(\", true/*withSeparator*/\");\n                sf.postfix_configuration().last(\"\");\n\n                for (const auto& attr : o.local_attributes()) {\n                    const auto oap(ast.get_assistant_properties(attr));\n                    if (oap && oap->requires_assistance()) {\n#>\n            assistant.Add(\"<#= attr.name().simple() #>\", value.<#= attr.name().simple() #><#= sf.postfix() #>);\n<#+\n                    } else {\n                        const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));\n#>\n            assistant.AddKey(\"<#= attr.name().simple() #>\");\n            assistant.AddPairSeparator();\n            <#= attr_qn #>Dumper.Dump(assistant, value.<#= attr.name().simple() #><#= sf.postfix() #>);\n<#+\n                    }\n\n                    sf.next();\n                }\n#>\n            assistant.AddEndObject(); // data\n            assistant.AddEndObject(); // main object\n            assistant.HandleMemberSeparator(withSeparator);\n\n            assistant.DecrementDepth();\n        }\n\n        public static string Dump(<#= sn #> value)\n        {\n<#+\n                if (o.is_parent()) {\n#>\n            return value.Dump();\n<#+\n                } else {\n#>\n            var assistant = new AssistantDumper();\n            Dump(assistant, value);\n            return assistant.ToString();\n<#+\n                }\n#>\n        }\n    }\n<#+\n        }\n    } // sbf\n\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::io::enum_transform",
      "documentation": "Generates implementation files for enums.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/enum_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_transform::apply(const context& ctx, const logical::entities::element& e,\n   physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>Dumper\n    {\n        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)\n        {\n            assistant.IncrementDepth();\n            if (assistant.MaximumDepthExceeded())\n                return;\n\n            assistant.AddStartObject();\n            assistant.AddType(\"<#= qn #>\", true/*withSeparator*/);\n            string valueAsString = \"Unsupported Value\";\n            switch (value)\n            {\n<#+\n            for (const auto& en : ye.enumerators()) {\n#>\n                case <#= ye.name().simple() #>.<#= en.name().simple() #>:\n                    valueAsString = \"<#= en.name().simple() #>\";\n                    break;\n<#+\n            }\n#>\n            }\n\n            assistant.Add(\"value\", valueAsString);\n            assistant.AddEndObject();\n\n            assistant.DecrementDepth();\n        }\n\n        public static string Dump(<#= sn #> value)\n        {\n            var assistant = new AssistantDumper();\n            Dump(assistant, value);\n            return assistant.ToString();\n        }\n    }\n<#+\n        }\n    } // sbf\n\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::test_data",
      "documentation": "M2T transforms for the test data\nfacet of the C# Technical Space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::test_data::class_transform",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/test_data/class_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& o(ast.as<logical::entities::structural::object>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const bool has_attributes(!o.all_attributes().empty());\n            const bool is_parent_or_has_attributes(\n                !o.parents().empty() || has_attributes);\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>SequenceGenerator\n    {\n        static internal void Populate(<#= sn #> value, uint position)\n        {\n<#+\n                if (!is_parent_or_has_attributes) {\n#>\n            // nothing to populate\n<#+\n                } else {\n                    unsigned int count(0);\n                    if (!o.parents().empty()) {\n                        const auto& pn(o.parents().front());\n                        const auto pqn(ast.get_qualified_name(pn));\n#>\n            <#= pqn #>SequenceGenerator.Populate(value, position);\n<#+\n                    }\n\n                    for (const auto& attr : o.local_attributes()) {\n                        const auto oap(ast.get_assistant_properties(attr));\n                        if (oap && oap->requires_assistance()) {\n#>\n            value.<#= attr.name().simple() #> = AssistantSequenceGenerator.Create<#= oap->method_postfix() #>(position + <#= count++ #>);\n<#+\n                        } else {\n                            const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));\n#>\n            value.<#= attr.name().simple() #> = <#= attr_qn #>SequenceGenerator.Create(position + <#= count++ #>);\n<#+\n                        }\n                    }\n                }\n#>\n        }\n\n        static internal <#= sn #> Create(uint position)\n        {\n<#+\n            if (!o.is_parent()) {\n#>\n            var result = new <#= sn #>();\n<#+\n                if (has_attributes) {\n#>\n            Populate(result, position);\n<#+\n                }\n#>\n            return result;\n<#+\n            } else {\n                auto leaves(o.leaves());\n                const auto front(leaves.front());\n                leaves.pop_front();\n                unsigned int i(0);\n                const auto total(static_cast<unsigned int>(leaves.size()));\n                for (const auto& l : leaves) {\n#>\n            if ((position % <#= total #>) == <#= i++ #>)\n                return <#= ast.get_qualified_name(l) #>SequenceGenerator.Create(position);\n<#+\n                }\n#>\n            return <#= ast.get_qualified_name(front) #>SequenceGenerator.Create(position);\n<#+\n            }\n#>\n        }\n\n        #region Enumerator\n        private class <#= sn #>Enumerator : IEnumerator, IEnumerator<<#= sn #>>, IDisposable\n        {\n            #region Properties\n            private uint _position;\n            private <#= sn #> _current;\n            #endregion\n\n            private void PopulateCurrent()\n            {\n                _current = <#= sn #>SequenceGenerator.Create(_position);\n            }\n\n            #region IDisposable\n            public void Dispose()\n            {\n            }\n            #endregion\n\n            #region IEnumerator implementation\n            public bool MoveNext()\n            {\n                ++_position;\n                PopulateCurrent();\n                return true;\n            }\n\n            public void Reset()\n            {\n                _position = 0;\n                PopulateCurrent();\n            }\n\n            public object Current {\n                get\n                {\n                    return _current;\n                }\n            }\n\n            <#= sn #> IEnumerator<<#= sn #>>.Current\n            {\n                get\n                {\n                    return _current;\n                }\n            }\n            #endregion\n\n            public <#= sn #>Enumerator()\n            {\n                PopulateCurrent();\n            }\n        }\n        #endregion\n\n        #region Enumerable\n        private class <#= sn #>Enumerable : IEnumerable, IEnumerable<<#= sn #>>\n        {\n            #region IEnumerable implementation\n            public IEnumerator GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n\n            IEnumerator<<#= sn #>> IEnumerable<<#= sn #>>.GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n            #endregion\n        }\n        #endregion\n\n        static public IEnumerable<<#= sn #>> Sequence()\n        {\n            return new <#= sn #>Enumerable();\n        }\n    }\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::test_data::enum_transform",
      "documentation": "Generates implementation files for enums.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/test_data/enum_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>SequenceGenerator\n    {\n        static internal <#= sn #> Create(uint position)\n        {\n            var result = (<#= sn #>)(position % <#= ye.enumerators().size() #>);\n            return result;\n        }\n\n        #region Enumerator\n        private class <#= sn #>Enumerator : IEnumerator, IEnumerator<<#= sn #>>, IDisposable\n        {\n            #region Properties\n            private uint _position;\n            private <#= sn #> _current;\n            #endregion\n\n            private void PopulateCurrent()\n            {\n                _current = <#= sn #>SequenceGenerator.Create(_position);\n            }\n\n            #region IDisposable\n            public void Dispose()\n            {\n            }\n            #endregion\n\n            #region IEnumerator implementation\n            public bool MoveNext()\n            {\n                ++_position;\n                PopulateCurrent();\n                return true;\n            }\n\n            public void Reset()\n            {\n                _position = 0;\n                PopulateCurrent();\n            }\n\n            public object Current {\n                get\n                {\n                    return _current;\n                }\n            }\n\n            <#= sn #> IEnumerator<<#= sn #>>.Current\n            {\n                get\n                {\n                    return _current;\n                }\n            }\n            #endregion\n\n            public <#= sn #>Enumerator()\n            {\n                PopulateCurrent();\n            }\n        }\n        #endregion\n\n        #region Enumerable\n        private class <#= sn #>Enumerable : IEnumerable, IEnumerable<<#= sn #>>\n        {\n            #region IEnumerable implementation\n            public IEnumerator GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n\n            IEnumerator<<#= sn #>> IEnumerable<<#= sn #>>.GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n            #endregion\n        }\n        #endregion\n\n        static public IEnumerable<<#= sn #>> Sequence()\n        {\n            return new <#= sn #>Enumerable();\n        }\n    }\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::types::exception_transform",
      "documentation": "Generates implementation files for exceptions.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::exception_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/exception.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/exception_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid exception_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n#>\n    public class <#= sn #>  : Exception\n    {\n        public <#= sn #>() { }\n        public <#= sn #>(string message) : base(message) { }\n        public <#= sn #>(string message, Exception inner) : base(message, inner) { }\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::types::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::registrar_error",
      "documentation": "There was an error in the registrar.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::assistant",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables",
      "fallback_element_type": "masd::module"
    },
    {
      "name": "formattables::model",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "name",
          "type": "logical::entities::name"
        },
        {
          "name": "formattables",
          "type": "std::unordered_map<std::string, formattables::formattable>"
        },
        {
          "name": "project_items",
          "type": "std::list<std::string>"
        },
        {
          "name": "aspect_properties",
          "type": "std::unordered_map<std::string, formattables::aspect_properties>"
        },
        {
          "name": "assistant_properties",
          "type": "std::unordered_map<std::string, formattables::assistant_properties>"
        }
      ]
    },
    {
      "name": "formattables::formattable",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "element_properties",
          "type": "formattables::element_properties"
        },
        {
          "name": "element",
          "type": "boost::shared_ptr<logical::entities::element>"
        },
        {
          "name": "artefacts",
          "type": "std::unordered_map<std::string, boost::shared_ptr<physical::entities::artefact>>"
        }
      ]
    },
    {
      "name": "formattables::element_properties",
      "documentation": "All of the properties associated with an element.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "artefact_properties",
          "type": "std::unordered_map<std::string, formattables::artefact_properties>"
        },
        {
          "name": "helper_properties",
          "type": "std::list<formattables::helper_properties>"
        },
        {
          "name": "attribute_properties",
          "type": "std::unordered_map<std::string, formattables::attribute_properties>"
        }
      ]
    },
    {
      "name": "formattables::locator",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::locator_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "facet_configurations",
          "type": "std::unordered_map<std::string, formattables::locator_facet_configuration>"
        },
        {
          "name": "archetype_configurations",
          "type": "std::unordered_map<std::string, formattables::locator_archetype_configuration>"
        },
        {
          "name": "disable_facet_directories",
          "type": "bool"
        },
        {
          "name": "backend_directory_name",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::adapter",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::adaptation_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::workflow",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::artefact_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "enabled",
          "type": "bool"
        },
        {
          "name": "overwrite",
          "type": "bool"
        },
        {
          "name": "file_path",
          "type": "boost::filesystem::path"
        },
        {
          "name": "relative_path",
          "type": "boost::filesystem::path"
        },
        {
          "name": "using_dependencies",
          "type": "std::list<std::string>"
        }
      ]
    },
    {
      "name": "formattables::model_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::file_path_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::reducer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::expansion_error",
      "documentation": "An error occurred whilst performing model expansion.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::using_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::context",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "element_properties",
          "type": "formattables::element_properties"
        },
        {
          "name": "model",
          "type": "formattables::model"
        },
        {
          "name": "helpers",
          "type": "std::unordered_map<std::string, std::unordered_map<std::string, std::list<std::shared_ptr<transforms::helper_transform>>>>"
        }
      ]
    },
    {
      "name": "transforms::formatting_error",
      "documentation": "An error occurred whilst formatting.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::project_items_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::locator_archetype_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "facet_directory",
          "type": "std::string"
        },
        {
          "name": "facet_postfix",
          "type": "std::string"
        },
        {
          "name": "archetype_postfix",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::locator_facet_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory",
          "type": "std::string"
        },
        {
          "name": "postfix",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::location_error",
      "documentation": "An error occurred while the locator was creating a path.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::aspect_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "is_floating_point",
          "type": "bool"
        },
        {
          "name": "requires_static_reference_equals",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::aspect_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "current",
          "type": "formattables::helper_descriptor"
        },
        {
          "name": "direct_descendants",
          "type": "std::list<formattables::helper_descriptor>"
        },
        {
          "name": "in_inheritance_relationship",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::helper_descriptor",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "family",
          "type": "std::string"
        },
        {
          "name": "namespaces",
          "type": "std::list<std::string>"
        },
        {
          "name": "name_identifiable",
          "type": "std::string"
        },
        {
          "name": "name_qualified",
          "type": "std::string"
        },
        {
          "name": "name_tree_qualified",
          "type": "std::string"
        },
        {
          "name": "name_tree_identifiable",
          "type": "std::string"
        },
        {
          "name": "is_simple_type",
          "type": "bool"
        },
        {
          "name": "is_circular_dependency",
          "type": "bool"
        }
      ]
    },
    {
      "name": "transforms::helper_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::floating_point_number_helper",
      "stereotypes": [
        "dogen::csharp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "helper_families",
          "type": "std::unordered_map<std::string, std::string>"
        }
      ]
    },
    {
      "name": "transforms::types::builtin_transform",
      "documentation": "Generates implementation files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/builtin_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid builtin_transform::apply(const context& /*ctx*/, const logical::entities::element& /*e*/,\n    physical::entities::artefact& /*a*/) const {}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "formattables::assistant_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "requires_assistance",
          "type": "bool",
          "documentation": "If true, the type needs help of an assistant.\n"
        },
        {
          "name": "method_postfix",
          "type": "std::string",
          "documentation": "Postfix to use to call the appropriate assistant method, if required.\n"
        }
      ]
    },
    {
      "name": "formattables::assistant_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::enumerable_helper",
      "stereotypes": [
        "dogen::csharp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::attribute_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "auxiliary_function_properties",
          "type": "std::unordered_map<std::string, formattables::auxiliary_function_properties>"
        }
      ]
    },
    {
      "name": "formattables::auxiliary_function_types",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "assistant",
          "type": "",
          "documentation": "The auxiliary function is supplied by an assistant.\n"
        },
        {
          "name": "helper",
          "type": "",
          "documentation": "The auxiliary function is supplied by a helper.\n"
        }
      ]
    },
    {
      "name": "formattables::auxiliary_function_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "type",
          "type": "formattables::auxiliary_function_types"
        },
        {
          "name": "name",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "transforms::types::primitive_transform",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=<iostream> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/primitive_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    const auto id(e.name().qualified().dot());\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n#>\n    public sealed class <#= sn #>\n    {\n<#+\n            if (!ctx.element_properties().helper_properties().empty())\n                ast.add_helper_methods(id);\n\n            /*\n             * Properties\n             */\n#>\n        #region Properties\n<#+\n            const auto& attr(p.value_attribute());\n            ast.comment(attr.documentation(), 2/*indent*/);\n#>\n        public <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #> { get; <#= (p.is_immutable() ? \"internal \" : \"\") #>set; }\n        #endregion\n\n<#+\n            /*\n             * Constructors.\n             */\n#>\n        #region Constructors\n        public <#= sn #>() { }\n        public <#= sn #>(<#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #>)\n        {\n            <#= attr.name().simple() #> = <#= ast.make_argument_name(attr) #>;\n        }\n        #endregion\n\n<#+\n            /*\n             * Equals\n             */\n#>\n        #region Equality\n        public override bool Equals(object obj)\n        {\n            if (ReferenceEquals(null, obj)) return false;\n            if (ReferenceEquals(this, obj)) return true;\n            if (obj.GetType() != GetType()) return false;\n\n            var value = obj as <#= sn #>;\n            if (value == null) return false;\n            return\n<#+\n             if (attr.parsed_type().is_current_simple_type()) {\n                if (attr.parsed_type().is_floating_point()) {\n#>\n                NearlyEqual(<#= attr.name().simple() #>, value.<#= attr.name().simple() #>);\n<#+\n                } else {\n#>\n                <#= attr.name().simple() #> == value.<#= attr.name().simple() #>;\n<#+\n                }\n           } else {\n#>\n                <#= attr.name().simple() #> != null && value.<#= attr.name().simple() #> != null &&\n                <#= attr.name().simple() #>.Equals(value.<#= attr.name().simple() #>);\n<#+\n            }\n#>\n        }\n\n        public static bool operator ==(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            if (Object.ReferenceEquals(lhs, rhs))\n                return true;\n\n            return !Object.ReferenceEquals(null, lhs) && lhs.Equals(rhs);\n        }\n\n        public static bool operator !=(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            return !(lhs == rhs);\n        }\n\n        public override int GetHashCode()\n        {\n            unchecked\n            {\n                // Choose large primes to avoid hashing collisions\n                const int HashingBase = (int) 2166136261;\n                const int HashingMultiplier = 16777619;\n\n                int hash = HashingBase;\n<#+\n                if (attr.parsed_type().is_current_simple_type()) {\n#>\n                hash = (hash * HashingMultiplier) ^ <#= attr.name().simple() #>.GetHashCode();\n<#+\n                } else {\n#>\n                hash = (hash * HashingMultiplier) ^\n                    (!<#= ast.reference_equals(attr) #>.ReferenceEquals(null, <#= attr.name().simple() #>) ? <#= attr.name().simple() #>.GetHashCode() : 0);\n<#+\n                }\n#>\n                return hash;\n            }\n        }\n        #endregion\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::test_data::primitive_transform",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/test_data/primitive_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>SequenceGenerator\n    {\n        static internal void Populate(<#= sn #> value, uint position)\n        {\n<#+\n            const auto attr(p.value_attribute());\n            const auto oap(ast.get_assistant_properties(attr));\n            if (oap && oap->requires_assistance()) {\n#>\n            value.<#= attr.name().simple() #> = AssistantSequenceGenerator.Create<#= oap->method_postfix() #>(position);\n<#+\n            } else {\n                const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));\n#>\n            value.<#= attr.name().simple() #> = <#= attr_qn #>SequenceGenerator.Create(position);\n<#+\n            }\n#>\n        }\n\n        static internal <#= sn #> Create(uint position)\n        {\n            var result = new <#= sn #>();\n            Populate(result, position);\n            return result;\n        }\n\n        #region Enumerator\n        private class <#= sn #>Enumerator : IEnumerator, IEnumerator<<#= sn #>>, IDisposable\n        {\n            #region Properties\n            private uint _position;\n            private <#= sn #> _current;\n            #endregion\n\n            private void PopulateCurrent()\n            {\n                _current = <#= sn #>SequenceGenerator.Create(_position);\n            }\n\n            #region IDisposable\n            public void Dispose()\n            {\n            }\n            #endregion\n\n            #region IEnumerator implementation\n            public bool MoveNext()\n            {\n                ++_position;\n                PopulateCurrent();\n                return true;\n            }\n\n            public void Reset()\n            {\n                _position = 0;\n                PopulateCurrent();\n            }\n\n            public object Current {\n                get\n                {\n                    return _current;\n                }\n            }\n\n            <#= sn #> IEnumerator<<#= sn #>>.Current\n            {\n                get\n                {\n                    return _current;\n                }\n            }\n            #endregion\n\n            public <#= sn #>Enumerator()\n            {\n                PopulateCurrent();\n            }\n        }\n        #endregion\n\n        #region Enumerable\n        private class <#= sn #>Enumerable : IEnumerable, IEnumerable<<#= sn #>>\n        {\n            #region IEnumerable implementation\n            public IEnumerator GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n\n            IEnumerator<<#= sn #>> IEnumerable<<#= sn #>>.GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n            #endregion\n        }\n        #endregion\n\n        static public IEnumerable<<#= sn #>> Sequence()\n        {\n            return new <#= sn #>Enumerable();\n        }\n    }\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::io::primitive_transform",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/primitive_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>Dumper\n    {\n        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)\n        {\n            assistant.IncrementDepth();\n            if (assistant.MaximumDepthExceeded())\n                return;\n\n            assistant.AddStartObject();\n            assistant.AddType(\"<#= qn #>\", true/*withSeparator*/);\n            if (value == null)\n            {\n                assistant.Add(\"data\", \"<null>\");\n                assistant.AddEndObject();\n                return;\n            }\n\n            assistant.AddKey(\"data\");\n            assistant.AddPairSeparator();\n            assistant.AddStartObject();\n<#+\n            const auto attr(p.value_attribute());\n            const auto oap(ast.get_assistant_properties(attr));\n            if (oap && oap->requires_assistance()) {\n#>\n            assistant.Add(\"<#= attr.name().simple() #>\", value.<#= attr.name().simple() #>);\n<#+\n            } else {\n                const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));\n#>\n            assistant.AddKey(\"<#= attr.name().simple() #>\");\n            assistant.AddPairSeparator();\n            <#= attr_qn #>Dumper.Dump(assistant, value.<#= attr.name().simple() #>;\n<#+\n            }\n#>\n            assistant.AddEndObject(); // data\n            assistant.AddEndObject(); // main object\n            assistant.HandleMemberSeparator(withSeparator);\n\n            assistant.DecrementDepth();\n        }\n\n        public static string Dump(<#= sn #> value)\n        {\n            var assistant = new AssistantDumper();\n            Dump(assistant, value);\n            return assistant.ToString();\n        }\n    }\n<#+\n        }\n    } // sbf\n\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "feature_initializer",
      "stereotypes": [
        "masd::variability::initializer"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::global_features",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "tagged_values": {
        "masd.variability.generate_static_configuration": "false",
        "masd.variability.key_prefix": "masd.csharp"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory",
          "type": "masd::variability::text",
          "value": "\"cs\"",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "aspect.requires_static_reference_equals",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "helper.family",
          "type": "masd::variability::text",
          "value": "\"Default\"",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "assistant.requires_assistance",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "assistant.method_postfix",
          "type": "masd::variability::text",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        }
      ]
    },
    {
      "name": "csharp_artefact_transform_header",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "class {{class.simple_name}} final : public model_to_text_transform {\npublic:\n    physical::entities::archetype static_archetype() const;\n    physical::entities::archetype archetype() const override;\n\npublic:\n    std::list<std::string> inclusion_dependencies(\n        const logical::entities::element& e) const override;\n\n    boost::filesystem::path full_path(\n        const formattables::locator& l, const logical::entities::name& n) const override;\n\npublic:\n    void apply(const context& ctx, const logical::entities::element& e,\n        physical::entities::artefact& a) const override;\n};\n"
        }
      ]
    },
    {
      "name": "csharp_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "physical::entities::archetype {{class.simple_name}}::static_archetype() const {\n    static physical::entities::archetype r([]() {\n        physical::entities::archetype r;\n        using pmnf = physical::helpers::meta_name_factory;\n        r.meta_name(pmnf::make(csharp::traits::backend_sn(),\n            traits::facet_sn(), traits::{{archetype.simple_name}}_archetype_sn()));\n        using lmnf = {{meta_name_factory}};\n        r.logical_meta_element_id(lmnf::make_{{meta_element}}_name().qualified().dot());\n        return r;\n    }());\n    return r;\n}\n\nphysical::entities::archetype {{class.simple_name}}::archetype() const {\n    return static_archetype();\n}\n\nboost::filesystem::path {{class.simple_name}}::full_path(\n    const formattables::locator& l, const logical::entities::name& n) const {\n    return l.{{locator_function}}(n, archetype().meta_name().qualified());\n}\n\nstd::list<std::string> {{class.simple_name}}::\ninclusion_dependencies(const logical::entities::element& /*e*/) const {\n    std::list<std::string> r;\n    return r;\n}\n"
        }
      ]
    },
    {
      "name": "csharp_helper_transform_header",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "class {{class.simple_name}} : public helper_transform {\npublic:\n    std::string id() const override;\n    std::string family() const override;\n    std::list<std::string> owning_formatters() const override;\n    std::list<std::string> owning_facets() const override;\n    std::string helper_name() const override;\n    void apply(assistant& ast, const formattables::helper_properties& hc) const override;\n};\n"
        }
      ]
    },
    {
      "name": "csharp_helper_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "std::string {{class.simple_name}}::id() const {\n    static auto r(std::string(\"<\") + traits::facet_qn() + std::string(\">\") +\n        std::string(\"<\") + helper_name() + std::string(\">\"));\n    return r;\n}\n\nstd::string {{class.simple_name}}::family() const {\n    static std::string r(\"{{helper.family}}\");\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_formatters() const {\n    static auto r(std::list<std::string> {\n        traits::class_archetype_qn(),\n        traits::primitive_archetype_qn()\n    });\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_facets() const {\n    static auto r(std::list<std::string> {\n        traits::facet_qn()\n    });\n    return r;\n}\n\nstd::string {{class.simple_name}}::helper_name() const {\n    static std::string r(\"{{class.simple_name}}\");\n    return r;\n}\n"
        }
      ]
    },
    {
      "name": "registrar",
      "stereotypes": [
        "masd::serialization::type_registrar"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio",
      "documentation": "M2T transforms for the visual studio\nfacet of the C# Technical Space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::visual_studio::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::project_transform",
      "documentation": "Generates visual studio project.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visual_studio_project",
        "masd.wale.kvp.class.simple_name": "project_transform",
        "masd.wale.kvp.archetype.simple_name": "project",
        "masd.wale.kvp.meta_element": "visual_studio_project",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.csharp.implementation",
        "masd.wale.kvp.locator_function": "make_full_path_for_visual_studio_project"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::visual_studio #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/visual_studio/project.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/visual_studio/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/visual_studio/project_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid project_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    using logical::entities::visual_studio::project;\n    const auto& proj(ast.as<project>(archetype().meta_name().qualified(), e));\n\n#>\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProjectGuid>{<#= proj.guid() #>}</ProjectGuid>\n    <OutputType>Library</OutputType>\n    <RootNamespace><#= proj.project_name() #></RootNamespace>\n    <AssemblyName><#= proj.project_name() #></AssemblyName>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug</OutputPath>\n    <DefineConstants>DEBUG;</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <ConsolePause>false</ConsolePause>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <DebugType>full</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release</OutputPath>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <ConsolePause>false</ConsolePause>\n  </PropertyGroup>\n  <ItemGroup>\n    <Reference Include=\"System\" />\n  </ItemGroup>\n<#+\n        for (const auto& ig : proj.item_groups()) {\n#>\n  <ItemGroup>\n<#+\n            for (const auto& i : ig.items())\n#>\n    <<#= i.name() #> Include=\"<#= i.include() #>\" />\n  </ItemGroup>\n<#+\n        }\n#>\n  <Import Project=\"$(MSBuildBinPath)\\Microsoft.CSharp.targets\" />\n</Project>\n<#+\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::visual_studio::solution_transform",
      "stereotypes": [
        "dogen::csharp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "main",
      "stereotypes": [
        "masd::entry_point",
        "dogen::untypable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::assistant_transform",
      "documentation": "Generates implementation files for assistants.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::archetype_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.assistant",
        "masd.wale.kvp.class.simple_name": "assistant_transform",
        "masd.wale.kvp.archetype.simple_name": "assistant",
        "masd.wale.kvp.meta_element": "assistant"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/assistant_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid assistant_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\nusing System.Text;\nusing System.Collections;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    class <#= sn #>Dumper\n    {\n        #region Properties\n        private readonly StringBuilder _stringBuilder;\n        private int _currentDepth;\n\n        private const uint MaxDepth = 1000;\n        private const string HashCode = \"HashCode\";\n        private const string Type = \"__type__\";\n        private const string StringType = \"string\";\n        private const string ByteType = \"byte\";\n        private const string SByteType = \"sbyte\";\n        private const string IntType = \"int\";\n        private const string UIntType = \"uint\";\n        private const string LongType = \"long\";\n        private const string ULongType = \"ulong\";\n        private const string FloatType = \"float\";\n        private const string DoubleType = \"double\";\n        private const string CharType = \"char\";\n        private const string DecimalType = \"decimal\";\n        private const string BoolType = \"bool\";\n        private const string NullValue = \"<null>\";\n        private const string SystemObjectType = \"System.Object\";\n        private const string KeyType = \"key\";\n        private const string ValueType = \"value\";\n        private const string DataKey = \"data\";\n        #endregion\n\n        #region Depth management\n        public void IncrementDepth()\n        {\n            ++_currentDepth;\n        }\n\n        public void DecrementDepth()\n        {\n            ++_currentDepth;\n        }\n\n        public bool MaximumDepthExceeded()\n        {\n            return _currentDepth > MaxDepth;\n        }\n        #endregion\n\n        #region Adds for JSON syntax\n        public void AddStartObject()\n        {\n            _stringBuilder.Append(\"{ \");\n        }\n\n        public void AddEndObject()\n        {\n            _stringBuilder.Append(\" }\");\n        }\n\n        public void AddStartArray()\n        {\n            _stringBuilder.Append(\"[ \");\n        }\n\n        public void AddEndArray()\n        {\n            _stringBuilder.Append(\" ]\");\n        }\n\n        public void AddPairSeparator()\n        {\n            _stringBuilder.Append(\" : \");\n        }\n\n        public void AddMemberSeparator()\n        {\n            _stringBuilder.Append(\", \");\n        }\n\n        public void AddQuoted(string value)\n        {\n            if (value == null)\n                _stringBuilder.Append(\"\\\"<null>\\\"\");\n            else\n                _stringBuilder.Append(\"\\\"\" + value + \"\\\"\");\n        }\n\n        public void AddNonQuoted(int value)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n        }\n\n        public void AddKey(string k)\n        {\n            AddQuoted(k);\n        }\n\n        public void AddType(string typeName, bool withSeparator = false)\n        {\n            AddKey(Type);\n            AddPairSeparator();\n            AddQuoted(typeName);\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddKeyWithSeparator(string key)\n        {\n            AddKey(key);\n            AddPairSeparator();\n        }\n\n        public void HandleMemberSeparator(bool withSeparator)\n        {\n            if (withSeparator)\n                AddMemberSeparator();\n        }\n        #endregion\n\n        #region Add value for well known types\n        private bool HandleBoxedPrimitives(object value)\n        {\n            var type = value.GetType();\n            if (type == typeof(string))\n            {\n                AddStartObject();\n                AddType(StringType, true/*withSeparator*/);\n                Add(DataKey, value as string);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(byte))\n            {\n                AddStartObject();\n                AddType(ByteType, true/*withSeparator*/);\n                Add(DataKey, (byte)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(sbyte))\n            {\n                AddStartObject();\n                AddType(SByteType, true/*withSeparator*/);\n                Add(DataKey, (sbyte)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(int))\n            {\n                AddStartObject();\n                AddType(IntType, true/*withSeparator*/);\n                Add(DataKey, (int)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(uint))\n            {\n                AddStartObject();\n                AddType(UIntType, true/*withSeparator*/);\n                Add(DataKey, (uint)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(long))\n            {\n                AddStartObject();\n                AddType(LongType, true/*withSeparator*/);\n                Add(DataKey, (long)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(ulong))\n            {\n                AddStartObject();\n                AddType(ULongType, true/*withSeparator*/);\n                Add(DataKey, (ulong)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(float))\n            {\n                AddStartObject();\n                AddType(FloatType, true/*withSeparator*/);\n                Add(DataKey, (float)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(double))\n            {\n                AddStartObject();\n                AddType(DoubleType, true/*withSeparator*/);\n                Add(DataKey, (double)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(char))\n            {\n                AddStartObject();\n                AddType(CharType, true/*withSeparator*/);\n                Add(DataKey, (char)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(decimal))\n            {\n                AddStartObject();\n                AddType(DecimalType, true/*withSeparator*/);\n                Add(DataKey, (decimal)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(bool))\n            {\n                AddStartObject();\n                AddType(BoolType, true/*withSeparator*/);\n                Add(DataKey, (bool)value);\n                AddEndObject();\n                return true;\n            }\n\n            return false;\n        }\n\n        private void AddValue(object value, bool withSeparator = false)\n        {\n            AddStartObject();\n            AddType(SystemObjectType, true/*withSeparator*/);\n\n            if (value == null)\n            {\n                Add(DataKey, NullValue);\n                AddEndObject();\n                HandleMemberSeparator(withSeparator);\n                return;\n            }\n\n            AddKey(DataKey);\n            AddPairSeparator();\n            if (HandleBoxedPrimitives(value))\n            {\n                AddEndObject();\n                HandleMemberSeparator(withSeparator);\n                return;\n            }\n\n            AddStartObject();\n            AddKey(HashCode);\n            AddPairSeparator();\n            AddNonQuoted(value.GetHashCode());\n\n            AddEndObject(); // data\n            AddEndObject();\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(string value, bool withSeparator = false)\n        {\n            AddQuoted(value);\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(byte value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(sbyte value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(int value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(uint value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(long value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(ulong value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(float value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(double value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(char value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(Convert.ToInt16(value)));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(decimal value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(bool value, bool withSeparator = false)\n        {\n            if (value)\n                _stringBuilder.Append(\"true\");\n            else\n                _stringBuilder.Append(\"false\");\n\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(IEnumerable value, bool withSeparator = false)\n        {\n            AddStartArray();\n            bool isFirst = true;\n            foreach (var item in value)\n            {\n                if (!isFirst)\n                    AddMemberSeparator();\n\n                AddValue(item);\n                isFirst = false;\n            }\n            AddEndArray();\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(IDictionary value, bool withSeparator = false)\n        {\n            AddStartArray();\n            bool isFirst = true;\n            foreach (DictionaryEntry item in value)\n            {\n                if (!isFirst)\n                    AddMemberSeparator();\n\n                AddStartArray();\n\n                AddStartObject();\n                AddType(KeyType, true/*withSeparator*/);\n                Add(DataKey, item.Key);\n                AddEndObject();\n\n                AddMemberSeparator();\n\n                AddStartObject();\n                AddType(ValueType, true/*withSeparator*/);\n                Add(DataKey, item.Value);\n                AddEndObject();\n\n                AddEndArray();\n                isFirst = false;\n            }\n            AddEndArray();\n            HandleMemberSeparator(withSeparator);\n        }\n        #endregion\n\n        #region Add for well known types\n        public void Add(string key, object value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, string value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, byte value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, sbyte value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, int value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, uint value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, long value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, ulong value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, float value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, double value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, char value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, decimal value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, bool value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, IEnumerable value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, IDictionary value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n        #endregion\n\n        public AssistantDumper()\n        {\n            _stringBuilder = new StringBuilder();\n        }\n\n        public override string ToString()\n        {\n            return _stringBuilder.ToString();\n        }\n    }\n<#+\n        }\n    } // sbf\n\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::test_data::assistant_transform",
      "documentation": "Generates implementation files for assistants.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::archetype_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.assistant",
        "masd.wale.kvp.class.simple_name": "assistant_transform",
        "masd.wale.kvp.archetype.simple_name": "assistant",
        "masd.wale.kvp.meta_element": "assistant"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/test_data/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/test_data/assistant_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid assistant_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    {\n        const auto sn(e.name().simple());\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\nusing System.Collections;\nusing System.Collections.Specialized;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    /// <summary>\n    /// Provides helper methods for the sequence generators.\n    /// </summary>\n    static class <#= sn #>SequenceGenerator\n    {\n        private const int SequenceSize = 10;\n\n        public static object CreateObject(uint position)\n        {\n            return \"this is an object: \" + Convert.ToString(position);\n        }\n\n        public static string CreateString(uint position)\n        {\n            return \"this is a string: \" + Convert.ToString(position);\n        }\n\n        public static byte CreateByte(uint position)\n        {\n            return Convert.ToByte(position);\n        }\n\n        public static sbyte CreateShortByte(uint position)\n        {\n            return Convert.ToSByte(position);\n        }\n\n        public static int CreateInt(uint position)\n        {\n            return Convert.ToInt32(position);\n        }\n\n        public static uint CreateUInt(uint position)\n        {\n            return position;\n        }\n\n        public static short CreateShort(uint position)\n        {\n            return Convert.ToInt16(position);\n        }\n\n        public static ushort CreateUShort(uint position)\n        {\n            return Convert.ToUInt16(position);\n        }\n\n        public static long CreateLong(uint position)\n        {\n            return Convert.ToInt64(position);\n        }\n\n        public static ulong CreateULong(uint position)\n        {\n            return Convert.ToUInt64(position);\n        }\n\n        public static float CreateFloat(uint position)\n        {\n            return Convert.ToSingle(position);\n        }\n\n        public static double CreateDouble(uint position)\n        {\n            return Convert.ToDouble(position);\n        }\n\n        public static char CreateChar(uint position)\n        {\n            return Convert.ToChar(position);\n        }\n\n        public static bool CreateBool(uint position)\n        {\n            return position % 2 == 0;\n        }\n\n        public static decimal CreateDecimal(uint position)\n        {\n            return Convert.ToDecimal(position);\n        }\n\n        public static IEnumerable CreateIEnumerable(uint position)\n        {\n            return CreateArrayList(position);\n        }\n\n        public static ICollection CreateICollection(uint position)\n        {\n            return CreateArrayList(position);\n        }\n\n        public static IList CreateIList(uint position)\n        {\n            return CreateArrayList(position);\n        }\n\n        public static ArrayList CreateArrayList(uint position)\n        {\n            var result = new ArrayList();\n            for (uint i = 0; i < SequenceSize; i++)\n            {\n                switch((position + i) % 5)\n                {\n                case 0: result.Add(CreateString(position + i)); break;\n                case 1: result.Add(CreateByte(position + i)); break;\n                case 2: result.Add(CreateInt(position + i)); break;\n                case 3: result.Add(CreateLong(position + i)); break;\n                case 4: result.Add(CreateFloat(position + i)); break;\n                case 5: result.Add(CreateDecimal(position + i)); break;\n                default: result.Add(CreateBool(position + i)); break;\n                }\n            }\n            return result;\n        }\n\n        public static IDictionary CreateIDictionary(uint position)\n        {\n            return CreateHashtable(position);\n        }\n\n        public static Hashtable CreateHashtable(uint position)\n        {\n            var result = new Hashtable();\n            for (uint i = 0; i < SequenceSize; i++)\n            {\n                result.Add(\"key_\" + position + i, \"value_\" + position + i);\n            }\n            return result;\n        }\n\n        public static HybridDictionary CreateHybridDictionary(uint position)\n        {\n            var result = new HybridDictionary();\n            for (uint i = 0; i < SequenceSize; i++)\n            {\n                result.Add(\"key_\" + position + i, \"value_\" + position + i);\n            }\n            return result;\n        }\n\n        public static NameValueCollection CreateNameValueCollection(uint position)\n        {\n            var result = new NameValueCollection();\n            for (uint i = 0; i < SequenceSize; i++)\n            {\n                result.Add(\"key_\" + position + i, \"value_\" + position + i);\n            }\n            return result;\n        }\n\n        public static BitArray CreateBitArray(uint position)\n        {\n            var result = new BitArray(SequenceSize);\n            for (int i = 0; i < SequenceSize; i++)\n            {\n                result[i] = position % 2 == 0;\n            }\n            return result;\n        }\n\n        public static Queue CreateQueue(uint position)\n        {\n            var result = new Queue();\n            for (int i = 0; i < SequenceSize; i++)\n            {\n                result.Enqueue(\"value_\" + position + i);\n            }\n            return result;\n        }\n\n        public static Stack CreateStack(uint position)\n        {\n            var result = new Stack();\n            for (int i = 0; i < SequenceSize; i++)\n            {\n                result.Push(\"value_\" + position + i);\n            }\n            return result;\n        }\n\n        public static SortedList CreateSortedList(uint position)\n        {\n            var result = new SortedList();\n            for (int i = 0; i < SequenceSize; i++)\n            {\n                result.Add(\"key_\" + position + i, \"value_\" + position + i);\n            }\n            return result;\n        }\n    }\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "CMakeLists",
      "stereotypes": [
        "masd::build::cmakelists",
        "dogen::handcrafted::cmake"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::archetype_configuration",
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::archetype_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.wale.kvp.meta_name_factory",
          "type": "",
          "value": "logical::helpers::meta_name_factory"
        },
        {
          "name": "masd.physical.part_id",
          "type": "",
          "value": "masd.csharp.implementation"
        },
        {
          "name": "masd.wale.kvp.locator_function",
          "type": "",
          "value": "make_full_path"
        }
      ]
    },
    {
      "name": "transforms::object_configuration",
      "parents": [
        "transforms::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::object_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.object"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "class_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "class"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "object"
        }
      ]
    },
    {
      "name": "transforms::implementation",
      "documentation": "Contains the implementation files.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        }
      ]
    },
    {
      "name": "transforms::enumeration_configuration",
      "parents": [
        "transforms::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::enumeration_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.enumeration"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "enum_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "enum"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "enumeration"
        }
      ]
    },
    {
      "name": "transforms::exception_configuration",
      "parents": [
        "transforms::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::exception_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.exception"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "exception_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "exception"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "exception"
        }
      ]
    },
    {
      "name": "transforms::primitive_configuration",
      "parents": [
        "transforms::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::primitive_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.primitive"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "primitive_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "primitive"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "primitive"
        }
      ]
    },
    {
      "name": "transforms::builtin_configuration",
      "parents": [
        "transforms::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::builtin_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.builtin"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "builtin_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "builtin"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "builtin"
        }
      ]
    }
  ]
}
