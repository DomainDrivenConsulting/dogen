{
  "documentation": "CSharp is the c# model in the default generation kernel.\n",
  "tagged_values": {
    "masd.injection.dia.comment": "true",
    "masd.injection.model_modules": "dogen.text.csharp",
    "masd.injection.reference": "cpp.builtins",
    "masd.injection.reference": "cpp.boost",
    "masd.injection.reference": "cpp.std",
    "masd.injection.reference": "dogen",
    "masd.injection.reference": "dogen.variability",
    "masd.injection.reference": "dogen.tracing",
    "masd.injection.reference": "dogen.logical",
    "masd.injection.reference": "masd",
    "masd.injection.reference": "masd.variability",
    "masd.injection.reference": "dogen.profiles",
    "masd.injection.input_technical_space": "cpp",
    "masd.variability.profile": "dogen.profiles.base.default_profile"
  },
  "elements": [
    {
      "name": "model_to_text_csharp_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "workflow_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms",
      "documentation": "M2T transforms for the C# Technical Space.\n\nTakes types in the logical model and creates text\nrepresentations of these types according to the grammar\nof the C# Technical Space.\n",
      "stereotypes": [
        "masd::physical::backend"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true",
        "masd.physical.backend_name": "csharp",
        "masd.physical.major_technical_space": "csharp"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::workflow",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "registrar_",
          "type": "transforms::registrar"
        }
      ]
    },
    {
      "name": "transforms::registrar",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "formatter_repository_",
          "type": "transforms::repository"
        }
      ]
    },
    {
      "name": "transforms::model_to_text_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable::header_only"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::repository",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.io.enabled": "true",
        "masd.cpp.io.overwrite": "false",
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stock_artefact_formatters_by_meta_name",
          "type": "std::unordered_map<std::string, std::forward_list<std::shared_ptr<transforms::model_to_text_transform>>>"
        },
        {
          "name": "stock_artefact_formatters",
          "type": "std::forward_list<std::shared_ptr<transforms::model_to_text_transform>>"
        },
        {
          "name": "stock_artefact_formatters_by_archetype",
          "type": "std::unordered_map<std::string, std::shared_ptr<transforms::model_to_text_transform>>"
        }
      ]
    },
    {
      "name": "transforms::types",
      "documentation": "M2T transforms for the types facet of\nthe C# Technical Space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::types::class_transform",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/class_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    const auto id(e.name().qualified().dot());\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& o(ast.as<logical::entities::structural::object>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n            if (!o.in_inheritance_relationship() || !o.is_child()) {\n#>\n    public <#= ast.make_inheritance_keyword_text(o) #>class <#= sn #>\n<#+\n            } else {\n                const auto& pn(o.parents().front());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\n    public <#= ast.make_inheritance_keyword_text(o) #>class <#= sn #> : <#= pqn #>\n<#+\n            }\n#>\n    {\n<#+\n            if (!o.local_attributes().empty()) {\n                if (!ctx.element_properties().helper_properties().empty())\n                    ast.add_helper_methods(id);\n\n                /*\n                * Properties\n                */\n#>\n        #region Properties\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    ast.comment(attr.documentation(), 2/*indent*/);\n#>\n        public <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #> { get; <#= (o.is_immutable() ? \"internal \" : \"\") #>set; }\n<#+\n                }\n#>\n        #endregion\n\n<#+\n            }\n\n            /*\n             * Constructors.\n             */\n#>\n        #region Constructors\n        public <#= sn #>() { }\n<#+\n            if (!o.all_attributes().empty()) {\n                const auto attr_count(o.all_attributes().size());\n                if (attr_count == 1) {\n                     const auto attr(*o.all_attributes().begin());\n#>\n        public <#= sn #>(<#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #>)\n<#+\n                } else {\n#>\n\n        public <#= sn #>(\n<#+\n                    utility::formatters::sequence_formatter sf(attr_count);\n                    sf.postfix_configuration().last(\")\");\n                    for (const auto& attr : o.all_attributes()) {\n#>\n            <#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #><#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n                }\n\n                if (!o.parents().empty()) {\n                    const auto& pair(*o.inherited_attributes().begin());\n                    const auto& pattrs(pair.second);\n                    const auto size(pattrs.size());\n\n                    if (size == 0) {\n#>\n            : base()\n<#+\n                    } else if (size == 1) {\n#>\n            : base(<#= ast.make_argument_name(pattrs.front()) #>)\n<#+\n                    } else {\n                        utility::formatters::sequence_formatter sf(size);\n                        sf.postfix_configuration().last(\")\");\n                        sf.prefix_configuration().first(\",\").not_first(\",\");\n#>\n            : base(\n<#+\n                        for (const auto& pattr : pattrs) {\n#>\n                <#= ast.make_argument_name(pattr) #><#= sf.postfix() #>\n<#+\n                            sf.next();\n                        }\n                    }\n                }\n#>\n        {\n<#+\n                if (o.local_attributes().empty()) {\n#>\n            // no properties\n<#+\n                } else {\n                    for (const auto& attr : o.local_attributes()) {\n#>\n            <#= attr.name().simple() #> = <#= ast.make_argument_name(attr) #>;\n<#+\n                    }\n                }\n#>\n        }\n<#+\n            }\n#>\n        #endregion\n\n<#+\n            /*\n             * Equals\n             */\n#>\n        #region Equality\n        public override bool Equals(object obj)\n        {\n            if (ReferenceEquals(null, obj)) return false;\n            if (ReferenceEquals(this, obj)) return true;\n            if (obj.GetType() != GetType()) return false;\n\n            var value = obj as <#= sn #>;\n<#+\n            if (o.local_attributes().empty()) {\n                if (!o.parents().empty()) {\n#>\n            return (value != null && base.Equals(value));\n<#+\n                } else {\n#>\n            return value != null;\n<#+\n                }\n            } else {\n                if (!o.parents().empty()) {\n#>\n            if (value == null || !base.Equals(value)) return false;\n<#+\n                } else {\n#>\n            if (value == null) return false;\n<#+\n                }\n#>\n\n            return\n<#+\n                utility::formatters::sequence_formatter sf(o.local_attributes().size());\n                sf.element_separator(\"\");\n                sf.postfix_configuration().not_last(\" &&\");\n                sf.postfix_configuration().last(\";\");\n                for (const auto& attr : o.local_attributes()) {\n                    if (attr.parsed_type().is_current_simple_type()) {\n                        if (attr.parsed_type().is_floating_point()) {\n#>\n                NearlyEqual(<#= attr.name().simple() #>, value.<#= attr.name().simple() #>)<#= sf.postfix() #>\n<#+\n                        } else {\n#>\n                <#= attr.name().simple() #> == value.<#= attr.name().simple() #><#= sf.postfix() #>\n<#+\n                        }\n                    } else {\n#>\n                <#= attr.name().simple() #> != null && value.<#= attr.name().simple() #> != null &&\n                <#= attr.name().simple() #>.Equals(value.<#= attr.name().simple() #>)<#= sf.postfix() #>\n<#+\n                    }\n                    sf.next();\n                }\n            }\n#>\n        }\n\n        public static bool operator ==(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            if (Object.ReferenceEquals(lhs, rhs))\n                return true;\n\n            return !Object.ReferenceEquals(null, lhs) && lhs.Equals(rhs);\n        }\n\n        public static bool operator !=(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            return !(lhs == rhs);\n        }\n\n        public override int GetHashCode()\n        {\n<#+\n            if (o.local_attributes().empty()) {\n#>\n            return 0;\n<#+\n            } else {\n#>\n            unchecked\n            {\n                // Choose large primes to avoid hashing collisions\n                const int HashingBase = (int) 2166136261;\n                const int HashingMultiplier = 16777619;\n\n                int hash = HashingBase;\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    if (attr.parsed_type().is_current_simple_type()) {\n#>\n                hash = (hash * HashingMultiplier) ^ <#= attr.name().simple() #>.GetHashCode();\n<#+\n                    } else {\n#>\n                hash = (hash * HashingMultiplier) ^\n                    (!<#= ast.reference_equals(attr) #>.ReferenceEquals(null, <#= attr.name().simple() #>) ? <#= attr.name().simple() #>.GetHashCode() : 0);\n<#+\n                    }\n                }\n#>\n                return hash;\n            }\n<#+\n            }\n#>\n        }\n        #endregion\n<#+\n            if (o.in_inheritance_relationship())\n            {\n#>\n\n        #region Dumpers\n<#+\n                if (o.is_parent() && !o.is_child()) {\n#>\n        internal abstract string Dump();\n<#+\n                } else if (o.is_leaf()) {\n#>\n        internal override string Dump()\n        {\n            return <#= sn #>Dumper.Dump(this);\n        }\n<#+\n                }\n#>\n        #endregion\n<#+\n        }\n#>\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::types::enum_transform",
      "documentation": "Generates implementation files for enums.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/enum_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n            if (ye.use_implementation_defined_underlying_element())\n#>\n    public enum <#= sn #>\n<#+\n            else\n#>\n    public enum <#= sn #> : <#= ast.get_qualified_name(ye.underlying_element()) #>\n    {\n<#+\n            utility::formatters::sequence_formatter sf(ye.enumerators().size());\n            for (const auto& en : ye.enumerators()) {\n                if (ye.use_implementation_defined_enumerator_values())\n#>\n        <#= en.name().simple() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                else\n#>\n        <#= en.name().simple() #> = <#= en.value() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                sf.next();\n            }\n#>\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::io",
      "documentation": "M2T transforms for the io facet of\nthe C# Technical Space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.injection.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::io::class_transform",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/class_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& o(ast.as<logical::entities::structural::object>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const bool has_attributes(!o.local_attributes().empty());\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>Dumper\n    {\n        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)\n        {\n            assistant.IncrementDepth();\n            if (assistant.MaximumDepthExceeded())\n                return;\n\n            assistant.AddStartObject();\n            assistant.AddType(\"<#= qn #>\", true/*withSeparator*/);\n            if (value == null)\n            {\n                assistant.Add(\"data\", \"<null>\");\n                assistant.AddEndObject();\n                return;\n            }\n\n            assistant.AddKey(\"data\");\n            assistant.AddPairSeparator();\n            assistant.AddStartObject();\n<#+\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n            assistant.AddKey(\"__parent_0__\");\n            assistant.AddPairSeparator();\n            <#= pqn #>Dumper.Dump(assistant, value<#= (has_attributes ? \", true/*withSeparator*/\" : \"\") #>);\n<#+\n                }\n\n                utility::formatters::sequence_formatter sf(o.local_attributes().size());\n                sf.element_separator(\"\");\n                sf.postfix_configuration().not_last(\", true/*withSeparator*/\");\n                sf.postfix_configuration().last(\"\");\n\n                for (const auto& attr : o.local_attributes()) {\n                    const auto oap(ast.get_assistant_properties(attr));\n                    if (oap && oap->requires_assistance()) {\n#>\n            assistant.Add(\"<#= attr.name().simple() #>\", value.<#= attr.name().simple() #><#= sf.postfix() #>);\n<#+\n                    } else {\n                        const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));\n#>\n            assistant.AddKey(\"<#= attr.name().simple() #>\");\n            assistant.AddPairSeparator();\n            <#= attr_qn #>Dumper.Dump(assistant, value.<#= attr.name().simple() #><#= sf.postfix() #>);\n<#+\n                    }\n\n                    sf.next();\n                }\n#>\n            assistant.AddEndObject(); // data\n            assistant.AddEndObject(); // main object\n            assistant.HandleMemberSeparator(withSeparator);\n\n            assistant.DecrementDepth();\n        }\n\n        public static string Dump(<#= sn #> value)\n        {\n<#+\n                if (o.is_parent()) {\n#>\n            return value.Dump();\n<#+\n                } else {\n#>\n            var assistant = new AssistantDumper();\n            Dump(assistant, value);\n            return assistant.ToString();\n<#+\n                }\n#>\n        }\n    }\n<#+\n        }\n    } // sbf\n\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::io::enum_transform",
      "documentation": "Generates implementation files for enums.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/io/enum_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_transform::apply(const context& ctx, const logical::entities::element& e,\n   physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>Dumper\n    {\n        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)\n        {\n            assistant.IncrementDepth();\n            if (assistant.MaximumDepthExceeded())\n                return;\n\n            assistant.AddStartObject();\n            assistant.AddType(\"<#= qn #>\", true/*withSeparator*/);\n            string valueAsString = \"Unsupported Value\";\n            switch (value)\n            {\n<#+\n            for (const auto& en : ye.enumerators()) {\n#>\n                case <#= ye.name().simple() #>.<#= en.name().simple() #>:\n                    valueAsString = \"<#= en.name().simple() #>\";\n                    break;\n<#+\n            }\n#>\n            }\n\n            assistant.Add(\"value\", valueAsString);\n            assistant.AddEndObject();\n\n            assistant.DecrementDepth();\n        }\n\n        public static string Dump(<#= sn #> value)\n        {\n            var assistant = new AssistantDumper();\n            Dump(assistant, value);\n            return assistant.ToString();\n        }\n    }\n<#+\n        }\n    } // sbf\n\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::test_data",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::test_data::class_transform",
      "stereotypes": [
        "dogen::csharp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::enum_transform",
      "stereotypes": [
        "dogen::csharp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::exception_transform",
      "documentation": "Generates implementation files for exceptions.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::exception_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/exception.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/exception_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid exception_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n#>\n    public class <#= sn #>  : Exception\n    {\n        public <#= sn #>() { }\n        public <#= sn #>(string message) : base(message) { }\n        public <#= sn #>(string message, Exception inner) : base(message, inner) { }\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::types::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::registrar_error",
      "documentation": "There was an error in the registrar.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::assistant",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables",
      "fallback_element_type": "masd::module"
    },
    {
      "name": "formattables::model",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "name",
          "type": "logical::entities::name"
        },
        {
          "name": "formattables",
          "type": "std::unordered_map<std::string, formattables::formattable>"
        },
        {
          "name": "project_items",
          "type": "std::list<std::string>"
        },
        {
          "name": "aspect_properties",
          "type": "std::unordered_map<std::string, formattables::aspect_properties>"
        },
        {
          "name": "assistant_properties",
          "type": "std::unordered_map<std::string, formattables::assistant_properties>"
        }
      ]
    },
    {
      "name": "formattables::formattable",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "element_properties",
          "type": "formattables::element_properties"
        },
        {
          "name": "element",
          "type": "boost::shared_ptr<logical::entities::element>"
        },
        {
          "name": "artefacts",
          "type": "std::unordered_map<std::string, boost::shared_ptr<physical::entities::artefact>>"
        }
      ]
    },
    {
      "name": "formattables::element_properties",
      "documentation": "All of the properties associated with an element.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "artefact_properties",
          "type": "std::unordered_map<std::string, formattables::artefact_properties>"
        },
        {
          "name": "helper_properties",
          "type": "std::list<formattables::helper_properties>"
        },
        {
          "name": "attribute_properties",
          "type": "std::unordered_map<std::string, formattables::attribute_properties>"
        }
      ]
    },
    {
      "name": "formattables::locator",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::locator_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "facet_configurations",
          "type": "std::unordered_map<std::string, formattables::locator_facet_configuration>"
        },
        {
          "name": "archetype_configurations",
          "type": "std::unordered_map<std::string, formattables::locator_archetype_configuration>"
        },
        {
          "name": "disable_facet_directories",
          "type": "bool"
        },
        {
          "name": "backend_directory_name",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::adapter",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::adaptation_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::workflow",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::artefact_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "enabled",
          "type": "bool"
        },
        {
          "name": "overwrite",
          "type": "bool"
        },
        {
          "name": "file_path",
          "type": "boost::filesystem::path"
        },
        {
          "name": "relative_path",
          "type": "boost::filesystem::path"
        },
        {
          "name": "using_dependencies",
          "type": "std::list<std::string>"
        }
      ]
    },
    {
      "name": "formattables::model_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::file_path_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::reducer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::expansion_error",
      "documentation": "An error occurred whilst performing model expansion.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::using_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::context",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "element_properties",
          "type": "formattables::element_properties"
        },
        {
          "name": "model",
          "type": "formattables::model"
        },
        {
          "name": "helpers",
          "type": "std::unordered_map<std::string, std::unordered_map<std::string, std::list<std::shared_ptr<transforms::helper_transform>>>>"
        }
      ]
    },
    {
      "name": "transforms::formatting_error",
      "documentation": "An error occurred whilst formatting.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::project_items_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::locator_archetype_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "facet_directory",
          "type": "std::string"
        },
        {
          "name": "facet_postfix",
          "type": "std::string"
        },
        {
          "name": "archetype_postfix",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::locator_facet_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory",
          "type": "std::string"
        },
        {
          "name": "postfix",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "formattables::location_error",
      "documentation": "An error occurred while the locator was creating a path.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::aspect_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "is_floating_point",
          "type": "bool"
        },
        {
          "name": "requires_static_reference_equals",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::aspect_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "current",
          "type": "formattables::helper_descriptor"
        },
        {
          "name": "direct_descendants",
          "type": "std::list<formattables::helper_descriptor>"
        },
        {
          "name": "in_inheritance_relationship",
          "type": "bool"
        }
      ]
    },
    {
      "name": "formattables::helper_descriptor",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "family",
          "type": "std::string"
        },
        {
          "name": "namespaces",
          "type": "std::list<std::string>"
        },
        {
          "name": "name_identifiable",
          "type": "std::string"
        },
        {
          "name": "name_qualified",
          "type": "std::string"
        },
        {
          "name": "name_tree_qualified",
          "type": "std::string"
        },
        {
          "name": "name_tree_identifiable",
          "type": "std::string"
        },
        {
          "name": "is_simple_type",
          "type": "bool"
        },
        {
          "name": "is_circular_dependency",
          "type": "bool"
        }
      ]
    },
    {
      "name": "transforms::helper_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::types::floating_point_number_helper",
      "stereotypes": [
        "dogen::csharp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::helper_configuration",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "helper_families",
          "type": "std::unordered_map<std::string, std::string>"
        }
      ]
    },
    {
      "name": "transforms::types::builtin_transform",
      "documentation": "Generates implementation files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/builtin_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid builtin_transform::apply(const context& /*ctx*/, const logical::entities::element& /*e*/,\n    physical::entities::artefact& /*a*/) const {}\n\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::test_data::builtin_transform",
      "stereotypes": [
        "dogen::csharp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::assistant_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "requires_assistance",
          "type": "bool",
          "documentation": "If true, the type needs help of an assistant.\n"
        },
        {
          "name": "method_postfix",
          "type": "std::string",
          "documentation": "Postfix to use to call the appropriate assistant method, if required.\n"
        }
      ]
    },
    {
      "name": "formattables::assistant_expander",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::enumerable_helper",
      "stereotypes": [
        "dogen::csharp::helper_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formattables::attribute_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "auxiliary_function_properties",
          "type": "std::unordered_map<std::string, formattables::auxiliary_function_properties>"
        }
      ]
    },
    {
      "name": "formattables::auxiliary_function_types",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "assistant",
          "type": "",
          "documentation": "The auxiliary function is supplied by an assistant.\n"
        },
        {
          "name": "helper",
          "type": "",
          "documentation": "The auxiliary function is supplied by a helper.\n"
        }
      ]
    },
    {
      "name": "formattables::auxiliary_function_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "type",
          "type": "formattables::auxiliary_function_types"
        },
        {
          "name": "name",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "transforms::types::primitive_transform",
      "documentation": "Generates implementation files for exceptions.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_configuration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::csharp::transforms::types #>\n<#@ masd.stitch.inclusion_dependency=<iostream> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/helpers/meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/traits.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text.csharp/types/transforms/types/primitive_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_transform::apply(const context& ctx, const logical::entities::element& e,\n    physical::entities::artefact& a) const {\n    const auto id(e.name().qualified().dot());\n    assistant ast(ctx, e, archetype().meta_name(), a);\n    const auto& p(ast.as<logical::entities::structural::primitive>(archetype().meta_name().qualified(), e));\n    {\n        const auto sn(e.name().simple());\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n#>\n    public sealed class <#= sn #>\n    {\n<#+\n            if (!ctx.element_properties().helper_properties().empty())\n                ast.add_helper_methods(id);\n\n            /*\n             * Properties\n             */\n#>\n        #region Properties\n<#+\n            const auto& attr(p.value_attribute());\n            ast.comment(attr.documentation(), 2/*indent*/);\n#>\n        public <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #> { get; <#= (p.is_immutable() ? \"internal \" : \"\") #>set; }\n        #endregion\n\n<#+\n            /*\n             * Constructors.\n             */\n#>\n        #region Constructors\n        public <#= sn #>() { }\n        public <#= sn #>(<#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #>)\n        {\n            <#= attr.name().simple() #> = <#= ast.make_argument_name(attr) #>;\n        }\n        #endregion\n\n<#+\n            /*\n             * Equals\n             */\n#>\n        #region Equality\n        public override bool Equals(object obj)\n        {\n            if (ReferenceEquals(null, obj)) return false;\n            if (ReferenceEquals(this, obj)) return true;\n            if (obj.GetType() != GetType()) return false;\n\n            var value = obj as <#= sn #>;\n            if (value == null) return false;\n            return\n<#+\n             if (attr.parsed_type().is_current_simple_type()) {\n                if (attr.parsed_type().is_floating_point()) {\n#>\n                NearlyEqual(<#= attr.name().simple() #>, value.<#= attr.name().simple() #>);\n<#+\n                } else {\n#>\n                <#= attr.name().simple() #> == value.<#= attr.name().simple() #>;\n<#+\n                }\n           } else {\n#>\n                <#= attr.name().simple() #> != null && value.<#= attr.name().simple() #> != null &&\n                <#= attr.name().simple() #>.Equals(value.<#= attr.name().simple() #>);\n<#+\n            }\n#>\n        }\n\n        public static bool operator ==(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            if (Object.ReferenceEquals(lhs, rhs))\n                return true;\n\n            return !Object.ReferenceEquals(null, lhs) && lhs.Equals(rhs);\n        }\n\n        public static bool operator !=(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            return !(lhs == rhs);\n        }\n\n        public override int GetHashCode()\n        {\n            unchecked\n            {\n                // Choose large primes to avoid hashing collisions\n                const int HashingBase = (int) 2166136261;\n                const int HashingMultiplier = 16777619;\n\n                int hash = HashingBase;\n<#+\n                if (attr.parsed_type().is_current_simple_type()) {\n#>\n                hash = (hash * HashingMultiplier) ^ <#= attr.name().simple() #>.GetHashCode();\n<#+\n                } else {\n#>\n                hash = (hash * HashingMultiplier) ^\n                    (!<#= ast.reference_equals(attr) #>.ReferenceEquals(null, <#= attr.name().simple() #>) ? <#= attr.name().simple() #>.GetHashCode() : 0);\n<#+\n                }\n#>\n                return hash;\n            }\n        }\n        #endregion\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n}\n#>\n"
        },
        {
          "name": "wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::test_data::primitive_transform",
      "stereotypes": [
        "dogen::csharp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::primitive_transform",
      "stereotypes": [
        "dogen::csharp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "feature_initializer",
      "stereotypes": [
        "masd::variability::initializer"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::global_features",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "tagged_values": {
        "masd.variability.generate_static_configuration": "false",
        "masd.variability.key_prefix": "masd.csharp"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory",
          "type": "masd::variability::text",
          "value": "\"cs\"",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "aspect.requires_static_reference_equals",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "helper.family",
          "type": "masd::variability::text",
          "value": "\"Default\"",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "assistant.requires_assistance",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        },
        {
          "name": "assistant.method_postfix",
          "type": "masd::variability::text",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        }
      ]
    },
    {
      "name": "csharp_artefact_transform_header",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "class {{class.simple_name}} final : public model_to_text_transform {\npublic:\n    physical::entities::archetype static_archetype() const;\n    physical::entities::archetype archetype() const override;\n\npublic:\n    std::list<std::string> inclusion_dependencies(\n        const logical::entities::element& e) const override;\n\n    boost::filesystem::path full_path(\n        const formattables::locator& l, const logical::entities::name& n) const override;\n\npublic:\n    void apply(const context& ctx, const logical::entities::element& e,\n        physical::entities::artefact& a) const override;\n};\n"
        }
      ]
    },
    {
      "name": "csharp_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "physical::entities::archetype {{class.simple_name}}::static_archetype() const {\n    static physical::entities::archetype r([]() {\n        physical::entities::archetype r;\n        using pmnf = physical::helpers::meta_name_factory;\n        r.meta_name(pmnf::make(csharp::traits::backend_sn(),\n            traits::facet_sn(), traits::{{archetype.simple_name}}_archetype_sn()));\n        using lmnf = {{meta_name_factory}};\n        r.logical_meta_element_id(lmnf::make_{{meta_element}}_name().qualified().dot());\n        return r;\n    }());\n    return r;\n}\n\nphysical::entities::archetype {{class.simple_name}}::archetype() const {\n    return static_archetype();\n}\n\nboost::filesystem::path {{class.simple_name}}::full_path(\n    const formattables::locator& l, const logical::entities::name& n) const {\n    return l.make_full_path(n, archetype().meta_name().qualified());\n}\n\nstd::list<std::string> {{class.simple_name}}::\ninclusion_dependencies(const logical::entities::element& /*e*/) const {\n    std::list<std::string> r;\n    return r;\n}\n"
        }
      ]
    },
    {
      "name": "csharp_helper_transform_header",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "class {{class.simple_name}} : public helper_transform {\npublic:\n    std::string id() const override;\n    std::string family() const override;\n    std::list<std::string> owning_formatters() const override;\n    std::list<std::string> owning_facets() const override;\n    std::string helper_name() const override;\n    void apply(assistant& ast, const formattables::helper_properties& hc) const override;\n};\n"
        }
      ]
    },
    {
      "name": "csharp_helper_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "tagged_values": {
        "masd.cpp.templates.logic_less_template.overwrite": "false"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "std::string {{class.simple_name}}::id() const {\n    static auto r(std::string(\"<\") + traits::facet_qn() + std::string(\">\") +\n        std::string(\"<\") + helper_name() + std::string(\">\"));\n    return r;\n}\n\nstd::string {{class.simple_name}}::family() const {\n    static std::string r(\"{{helper.family}}\");\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_formatters() const {\n    static auto r(std::list<std::string> {\n        traits::class_archetype_qn(),\n        traits::primitive_archetype_qn()\n    });\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_facets() const {\n    static auto r(std::list<std::string> {\n        traits::facet_qn()\n    });\n    return r;\n}\n\nstd::string {{class.simple_name}}::helper_name() const {\n    static std::string r(\"{{class.simple_name}}\");\n    return r;\n}\n"
        }
      ]
    },
    {
      "name": "registrar",
      "stereotypes": [
        "masd::serialization::type_registrar"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::visual_studio::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::traits",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::project_transform",
      "stereotypes": [
        "dogen::csharp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::visual_studio::solution_transform",
      "stereotypes": [
        "dogen::csharp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "main",
      "stereotypes": [
        "masd::entry_point",
        "dogen::untypable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::io::assistant_transform",
      "stereotypes": [
        "dogen::csharp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::test_data::assistant_transform",
      "stereotypes": [
        "dogen::csharp::artefact_transform"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "CMakeLists",
      "stereotypes": [
        "masd::build::cmakelists",
        "dogen::handcrafted::cmake"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::archetype_configuration",
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.wale.kvp.meta_name_factory",
          "type": "",
          "value": "logical::helpers::meta_name_factory"
        },
        {
          "name": "masd.physical.part_id",
          "type": "",
          "value": "masd.csharp.implementation"
        },
        {
          "name": "masd.wale.kvp.locator_function",
          "type": "",
          "value": "make_full_path_for_cpp_header"
        }
      ]
    },
    {
      "name": "transforms::object_configuration",
      "parents": [
        "transforms::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::object_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.object"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "class_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "class"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "object"
        }
      ]
    },
    {
      "name": "transforms::implementation",
      "documentation": "Contains the implementation files.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        }
      ]
    },
    {
      "name": "transforms::enumeration_configuration",
      "parents": [
        "transforms::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::enumeration_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.enumeration"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "enum_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "enum"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "enumeration"
        }
      ]
    },
    {
      "name": "transforms::exception_configuration",
      "parents": [
        "transforms::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::exception_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.exception"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "exception_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "exception"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "exception"
        }
      ]
    },
    {
      "name": "transforms::primitive_configuration",
      "parents": [
        "transforms::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::primitive_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.primitive"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "primitive_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "primitive"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "primitive"
        }
      ]
    },
    {
      "name": "transforms::builtin_configuration",
      "parents": [
        "transforms::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::builtin_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.builtin"
        },
        {
          "name": "masd.wale.kvp.class.simple_name",
          "type": "",
          "value": "builtin_transform"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "builtin"
        },
        {
          "name": "masd.wale.kvp.meta_element",
          "type": "",
          "value": "builtin"
        }
      ]
    }
  ]
}
