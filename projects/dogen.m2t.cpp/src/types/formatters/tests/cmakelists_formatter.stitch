<#@ masd.stitch.stream_variable_name=a.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::m2t::cpp::formatters::tests #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.m2t/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.m2t.cpp/types/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.m2t.cpp/types/formatters/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/build/cmakelists.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.m2t.cpp/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.m2t.cpp/types/formatters/tests/traits.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.m2t.cpp/types/formatters/formatting_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.m2t.cpp/types/formatters/tests/cmakelists_formatter.hpp" #>
<#+

std::string cmakelists_formatter::static_id() {
    return tests::traits::cmakelists_archetype();
}

std::string cmakelists_formatter::id() const {
    return static_id();
}

physical::entities::location cmakelists_formatter::
archetype_location() const {
    static physical::entities::location
        r(cpp::traits::kernel(), cpp::traits::backend(),
          traits::facet(),
          cmakelists_formatter::static_id());
    return r;
}

const logical::entities::name& cmakelists_formatter::meta_name() const {
    using logical::helpers::meta_name_factory;
    static auto r(meta_name_factory::make_build_cmakelists_name());
    return r;
}

std::string cmakelists_formatter::family() const {
    return cpp::traits::cmake_family();
}

inclusion_support_types cmakelists_formatter::
inclusion_support_type() const {
    return inclusion_support_types::not_supported;
}

boost::filesystem::path cmakelists_formatter::inclusion_path(
    const formattables::locator& /*l*/, const logical::entities::name& n) const {

    using namespace dogen::utility::log;
    using namespace dogen::m2t::cpp::formatters;
    static logger lg(logger_factory(cmakelists_formatter::static_id()));

    static const std::string not_supported("Inclusion path is not supported: ");

    BOOST_LOG_SEV(lg, error) << not_supported << n.qualified().dot();
    BOOST_THROW_EXCEPTION(formatting_error(not_supported + n.qualified().dot()));
}

boost::filesystem::path cmakelists_formatter::full_path(
    const formattables::locator& l, const logical::entities::name& n) const {
    return l.make_full_path_for_tests_cmakelists(n, static_id());
}

std::list<std::string> cmakelists_formatter::inclusion_dependencies(
    const formattables::dependencies_builder_factory& /*f*/,
    const logical::entities::element& /*e*/) const {
    static std::list<std::string> r;
    return r;
}

physical::entities::artefact cmakelists_formatter::
format(const context& ctx, const logical::entities::element& e) const {
    assistant a(ctx, e, archetype_location(), false/*requires_header_guard*/);
    using logical::entities::build::cmakelists;
    const auto& c(a.as<cmakelists>(e));

    {

        const auto ts(logical::entities::technical_space::cmake);
        a.make_decoration_preamble(e, ts);
        const auto model_name(a.get_dot_separated_model_name(c.name()));
        const auto product_name(a.get_product_name(c.name()));
#>
set(name "<#= model_name #>")
set(lib_target_name ${name}.lib)
set(tests_binary_name ${name}.<#= c.tests_directory_name() #>)
set(tests_target_name ${name}.<#= c.tests_directory_name() #>)

set(files "")
file(GLOB_RECURSE files RELATIVE
    "${CMAKE_CURRENT_SOURCE_DIR}/"
    "${CMAKE_CURRENT_SOURCE_DIR}/*.<#= c.implementation_file_extension() #>")

add_executable(${tests_target_name} ${files})

set_target_properties(${tests_target_name} PROPERTIES
<#+
        if (a.is_cpp_standard_98()) {
#>
    CXX_STANDARD 98
<#+
        }
#>
    OUTPUT_NAME ${tests_binary_name})

<#+
        if (a.is_cpp_standard_98()) {
#>
target_compile_options(${tests_target_name} PRIVATE
    $<$<OR:$<CXX_COMPILER_ID:Clang>,$<CXX_COMPILER_ID:AppleClang>,$<CXX_COMPILER_ID:GNU>>:
    -Wno-c99-extensions>)
<#+
        }
#>

target_link_libraries(${tests_target_name}
    ${lib_target_name}
    ${CMAKE_REQUIRED_LIBRARIES}
    ${CMAKE_THREAD_LIBS_INIT}
    ${Boost_LIBRARIES})

set(command $<TARGET_FILE:${tests_target_name}> ${boost_test_parameters})

add_custom_target(run_${tests_target_name}
    COMMENT "Running ${tests_target_name}" VERBATIM
    COMMAND ${command}
    WORKING_DIRECTORY ${stage_bin_dir}
    DEPENDS ${tests_target_name})

add_dependencies(run_all_tests run_${tests_target_name})

if(WITH_BENCHMARKS)
    set(benchmark_file
        ${benchmark_directory}/${benchmark_prefix}${tests_target_name}.csv)
    add_custom_target(benchmark_${tests_target_name}
        COMMENT "Benchmarking testing ${tests_target_name}" VERBATIM
        COMMAND ${benchmark_command} ${benchmark_repeats} ${benchmark_file}
        ${command}
        WORKING_DIRECTORY ${stage_bin_dir}
        DEPENDS ${tests_target_name})

    add_dependencies(benchmark_all benchmark_${tests_target_name})
endif()

add_boost_tests(${tests_binary_name} ${files})

install(TARGETS ${tests_target_name} RUNTIME DESTINATION bin COMPONENT tests)
<#+
    } // sbf
        return a.make_artefact();
}
#>
