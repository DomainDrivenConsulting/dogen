* Overview

Motto 1: Le mieux est l'ennemi du bien. -- Voltaire

Motto 2: First write the code generator; don't worry about the code, it
will write itself.

Motto 3: Malembe, Malembe. -- Angolan proverb

** What is Dogen

*Dogen* is a code generator designed to target domain models, inspired
by the [[http://en.wikipedia.org/wiki/Domain-driven_design][domain driven design]] methodology. Our main objective was to
automate the modeling process as much as possible: the user creates
domain models using a supported UML tool and respecting a set of
predefined restrictions; Dogen then uses the tool's diagram files to
generate the source code representation. The generated code contains
most of the services required from a typical C++ domain object such as
serialisation, hashing, streaming and so on.

Please note that *the code generated by Dogen is C++-11 only.*

** Why do we need Dogen

The main objective of creating a domain generator is to avoid having
to maintain manually a significant amount of trivial code; this not
only speeds up the development process but it also improves code
quality as programmers do not tend to perform repetitive tasks
terribly well.

We developed our own domain generator because we could not find one
that fitted our requirements - open source or otherwise. You can see
the results of our research [[https://github.com/kitanda/dogen#related-work][below]].

Note that Dogen is specifically tailored for our needs and as such it
is not a general purpose domain generator. We are, however, wiling to
accept any patches for functionality not directly required by us.

* Obtaining Dogen

There are two ways of obtaining Dogen: you can either install one of
the available binary packages or compile it yourself from source.

** Binary Packages

Dogen uses Continuous Integration (CI) and Trunk Development. We use
CDash for CI. In practice, this means that it should always be safe
(and preferable) to install the most recent packages available.

You can monitor the build status [[http://hedgr.co.uk/cdash/index.php?project%3Ddogen][here]]. When the build is green, latest
is always greatest; when the build is not green, it is our top
priority to make it green again.

We have build agents for the following Operative Systems:

- Linux: 32-bit and 64-bit with Clang and GCC.
- Mac OS X: 64-bit with GCC.
- Windows: 32-bit using MinGW (GCC for Windows).

The generated packages are named after the build agents, and contain
the Operative System name and bitness (e.g. 64-bit or 32-bit) in their
names.

#begin_quote
IMPORTANT: Installable packages generated off of CI used to be available at
github [[https://github.com/kitanda/dogen/downloads][here]], but since they decommissioned the downloads section, we
found no place to upload them to. So, at present, there is no way of
downloading the packages generated by the build agents. We are trying
to find a new location to upload the packages to.
#end_quote

** Building from Source

We officially support Linux, Mac OS X and Win32 since we have build
agents for these platforms. However, any platform that meets the
dependencies [[https://github.com/kitanda/dogen#dependencies][below]] should be able to build Dogen.

*** Dependencies

In order to compile Dogen you need:

- a fairly recent version of [[http://gcc.gnu.org/][GCC]] (> [[http://gcc.gnu.org/gcc-4.7/][4.7]]) or [[http://clang.llvm.org/index.html][Clang]] (> [[http://llvm.org/releases/3.0/docs/ClangReleaseNotes.html][3.0]]) or any
  compiler with good C++-11 support;
- [[http://www.cmake.org/][CMake]] [[http://www.kitware.com/news/home/browse/CMake?2013_05_22&CMake%2B2.8.11%2BNow%2BAvailable][2.8]] or later;
- Boost [[http://www.boost.org/users/history/version_1_55_0.html][1.55]];
- for portable serialisation, you need [[http://epa.codeplex.com/][EOS]] support (optional);
- for relational database support you need [[http://www.codesynthesis.com/products/odb/][ODB]] support (optional);

*** Building Instructions

Once all dependencies have been installed, and placed in the
appropriate =INCLUDE= and =LIB= paths (or the equivalent for your
operative system), follow the following steps:

: git clone git://github.com/kitanda/dogen.git
: mkdir output
: cd output
: cmake ../dogen -G "Unix Makefiles"
: make -j5 # number of cores available

The dogen binary will be in =output/stage/bin/dogen_driver=.

If you are on a non-Unix platform you need to use the appropriate
CMake generator (the =-G= parameter above). At present the Ninja
generator is known not to work. No other generator has been used by
the Dogen team.

Once the build has completed successfully, you should [[https://github.com/kitanda/dogen#running-unit-tests][run the unit
tests]] to make sure your system is fully supported.

*** Running Unit Tests

In order to ensure your platform is properly supported by Dogen, you
should run the test suite and ensure that all tests pass.

If you have setup ODB support, you will need to do the following steps
first:

- install and configure [[http://www.postgresql.org/][PostgreSQL]];
- [[https://kb.mediatemple.net/questions/1237/How%2Bdo%2BI%2Benable%2Bremote%2Baccess%2Bto%2Bmy%2BPostgreSQL%2Bserver%253F#dv][configure]] access to local and remote users;
- create a database called =musseque= and a user called =build= with a
  password of your choice;
- setup the environment variable =PGPASSWORD= to match the password
  you have chosen for this user (see [[http://www.postgresql.org/docs/9.1/static/libpq-envars.html][Environment Variables]]).

Finally, run:

: make run_all_specs

If there are no failures, you are good to go. If there are failures,
please [[https://github.com/kitanda/dogen#submitting-bug-reports][see below]].

*** Submitting bug reports

If you have a failure building Dogen or running its unit tests, please
submit a bug report that includes:

- the error messages;
- the compiler version;
- the Operative System.

If you find a bug whilst using Dogen, please send the log file as
well; it is located under the directory where you executed Dogen and
named =dogen.log=.

Bugs can be submitted using [[https://github.com/kitanda/dogen/issues][github Issues]].

* Related Work

This section is a bit of a general research bucket. It contains a set
of links to the C++ code generators we have found on our wanderings on
the internet, as well as other interesting projects in this space -
including those in other programming languages. It also contains books
and papers on the subject we have read, or intend to read.

- [[http://www.amazon.co.uk/Domain-Driven-Design-Tackling-Complexity-ebook/dp/B00794TAUG/ref%3Dsr_1_2?ie%3DUTF8&qid%3D1368380797&sr%3D8-2&keywords%3Dmodel%2Bdriven%2Bdesign][Domain-Driven Design: Tackling Complexity in the Heart of Software]]:
  The Eric Evans book from which we tried to steal most concepts in
  Dogen. A must read for any developer.
- [[http://www.amazon.co.uk/EMF-Eclipse-Modeling-Framework-ebook/dp/B0013TPYVW/ref%3Dsr_1_2?s%3Dbooks&ie%3DUTF8&qid%3D1368380262&sr%3D1-2&keywords%3DEclipse%2BModeling%2BFramework%2B%255BPaperback%255D][EMF: Eclipse Modeling Framework]]: The original EMF book. Useful read
  for anyone interested in code generation.
- [[http://www.scribd.com/doc/78264699/Model-Driven-Architecture-for-Reverse-Engineering-Technologies-Strategic-Directions-and-System-Evolution-Premier-Reference-Source][Model Driven Architecture for Reverse Engineering Technologies]]:
  Preview of a potentially interesting MDA book.
- [[http://www2.informatik.hu-berlin.de/~piefel/Documents/06CITSA-CMMCG.pdf][A Common Metamodel for Code Generation]]: This paper will be of
  interest if we decide to support multiple languages.
- [[http://www.vollmann.com/pubs/meta/meta/meta.html][Metaclasses and Reflection in C++]]: Some (early) ideas on
  implementing a MOP (Meta Object Protocol) in C++.
- [[https://code.google.com/a/eclipselabs.org/p/cppgenmodel/][cppgenmodel - A model driven C++ code generator]]: This seems more
  like a run time / reflection based generator.
- [[https://code.google.com/p/emf4cpp/][EMF4CPP - Eclipse Modeling Framework]]: C++ port of the EMF/eCore
  eclipse framework. As with Java it includes run time support. There
  is also [[http://apps.nabbel.es/dsdm2010/download_files/dsdm2010_senac.pdf][a paper]] on it.
- [[http://www2.informatik.hu-berlin.de/~piefel/Documents/06CITSA-CMMCG.pdf][A Common Metamodel for Code Generation]]: Describes a meta-model
  designed to model Java and C++.
- [[http://marofra.com/oldhomepage/MetaCPlusPlusDoc/metacplusplus-1.html][The Meta-C++ User Manual]]: Another early C++ meta-modeling
  tool. Contains interesting ideas around C++ meta-models.
- The Columbus C++ Schema: Useful tool for re-engineering large C++
  code bases. Contains a meta-model for C++. A number of papers have
  been written about it:
  - [[http://www.inf.u-szeged.hu/~beszedes/research/tech27_ferenc_r.pdf][Columbus â€“ Reverse Engineering Tool and Schema for C++]]
  - [[http://journal.ub.tu-berlin.de/eceasst/article/download/10/19][Third Workshop on Software Evolution through Transformations]]:
    Embracing the Change
  - [[http://www.inf.u-szeged.hu/~ferenc/research/ferencr_schema.ppt.pdf][Towards a Standard Schema for C/C++]]
  - [[http://www.inf.u-szeged.hu/~ferenc/research/ferencr_columbus_schema_cpp.pdf][Data Exchange with the Columbus Schema for C++]]
- [[http://www.cpgf.org/][CPGF]]: An open source C++ library for reflection, script binding,
  serialisation and callbacks.
- [[http://www.artima.com/articles/dci_vision.html][DCI]]: The DCI Architecture: A New Vision of Object-Oriented
  Programming. Some fundamental insights on the nature of OO.
