* Overview

Motto 1: Le mieux est l'ennemi du bien. -- Voltaire

Motto 2: First write the code generator; don't worry about the code, it
will write itself.

** What is Dogen

*Dogen* is a code generator designed to target domain models, inspired
by the [[http://en.wikipedia.org/wiki/Domain-driven_design][domain driven design]] methodology. Our main objective was to
automate the modeling process as much as possible: the user creates
domain models using a supported UML tool and respecting a set of
predefined restrictions; Dogen then uses the tool's diagram files to
generate the source code representation. The generated code contains
most of the services required from a typical C++ domain object such as
serialisation, hashing, streaming and so on.

Please note that *the code generated by Dogen is C++-11 only.*

** Why do we need Dogen

The main objective of creating a domain generator is to avoid having
to maintain manually a significant amount of trivial code; this not
only speeds up the development process but it also improves code
quality as programmers do not tend to perform repetitive tasks
terribly well.

We developed our own domain generator because we could not find one
that fitted our requirements - open source or otherwise.  Note that
Dogen is specifically tailored for our needs and as such it is not a
general purpose domain generator. We are, however, wiling to accept
any patches for functionality not directly required by us.

* Obtaining Dogen

There are two ways of obtaining Dogen: you can either install one of
the available binary packages or compile it yourself from source.

** Binary Packages

Dogen uses Continuous Integration (CI) and Trunk Development. In
practice, this means that it should always be safe (and preferable) to
run the latest packages available. We use CDash for CI. You can
monitor the build status [[http://hedgr.co.uk/cdash/index.php?project%3Ddogen][here]]. When the build is green, latest is
always greatest; when the build is not green, it is our top priority
to make it green again.

We have build agents for the following Operative Systems:

- Linux: 32-bit and 64-bit;
- Mac OS X: 32-bit and 64-bit;
- Windows: 32-bit using MinGW. 64-bit using Ming64 should work but we
  do not have a build agent to prove it.

Installable packages generated off of CI are available at github
[[https://github.com/kitanda/dogen/downloads][here]]. They are named after our build agents, but the key thing is to
make sure the Operative System and bitness (e.g. 64-bit or 32-bit)
matches your setup.

** Building from Source

If for some reason you can't or do not wish to use the [[*Binary%20Packages][Binary Packages]]
above, you can always build Dogen from source.

*** Supported Operative Systems

As per [[*Binary%20Packages][Binary Packages]] above, we officially support Linux, Mac OS X
and Win32. However, any platform that meets the dependencies [[*Dependencies][below]]
should be able to build Dogen.

*** Dependencies

In order to compile Dogen you need:

- a fairly recent version of GCC (> 4.7) or Clang (> 3.0) or any
  compiler with good C++-11 support;
- CMake 2.8 or later;
- a patched version of boost which we call [[https://github.com/kitanda/turbo][turbo]]. This is largely
  boost 1.52 a few out-of-tree libraries such as boost log and EOS
  portable serialisation support.
- The include files and libraries for ODB. This should really be
  optional as its only required if you are building the database test
  model.

*** Building Instructions

Once all dependencies are available, follow the following steps:

: git clone git://github.com/kitanda/dogen.git
: mkdir output
: cd output
: cmake ../dogen
: make -j5 # number of cores available

The dogen binary will be in =output/stage/bin/dogen_driver=. You
should also run the unit tests to make sure your system is fully
supported:

: make run_all_specs

Four failures are expected as a PostgreSQL database has not
been configured for the ODB tests.

FIXME: this is not ideal.

*** Submitting bug reports

If you have a failure building Dogen, please submit a bug report that
includes:

- your compiler version;
- your Operative System.

If you find a bug whilst using Dogen, please send the log file as
well, located under the directory where you executed Dogen and named
=dogen.log=.

Bugs can be submitted using [[https://github.com/kitanda/dogen/issues][github Issues]].

* Related Work

Here we collect links to other C++ code generators, as well as
interesting projects in this space on other languages, books and
papers we have read (or intend to read) on the subject, etc.

- [[http://www.amazon.co.uk/Domain-Driven-Design-Tackling-Complexity-ebook/dp/B00794TAUG/ref%3Dsr_1_2?ie%3DUTF8&qid%3D1368380797&sr%3D8-2&keywords%3Dmodel%2Bdriven%2Bdesign][Domain-Driven Design: Tackling Complexity in the Heart of Software]]:
  The Eric Evans book from which we tried to steal most concepts in
  Dogen. A must read for any developer.
- [[http://www.amazon.co.uk/EMF-Eclipse-Modeling-Framework-ebook/dp/B0013TPYVW/ref%3Dsr_1_2?s%3Dbooks&ie%3DUTF8&qid%3D1368380262&sr%3D1-2&keywords%3DEclipse%2BModeling%2BFramework%2B%255BPaperback%255D][EMF: Eclipse Modeling Framework]]: The original EMF book. Useful read
  for anyone interested in code generation.
- [[http://www.scribd.com/doc/78264699/Model-Driven-Architecture-for-Reverse-Engineering-Technologies-Strategic-Directions-and-System-Evolution-Premier-Reference-Source][Model Driven Architecture for Reverse Engineering Technologies]]:
  Preview of a potentially interesting MDA book.
- [[http://www2.informatik.hu-berlin.de/~piefel/Documents/06CITSA-CMMCG.pdf][A Common Metamodel for Code Generation]]: This paper will be of
  interest if we decide to support multiple languages.
- [[http://www.vollmann.com/pubs/meta/meta/meta.html][Metaclasses and Reflection in C++]]: Some (early) ideas on
  implementing a MOP (Meta Object Protocol) in C++.
- [[https://code.google.com/a/eclipselabs.org/p/cppgenmodel/][cppgenmodel - A model driven C++ code generator]]: This seems more
  like a run time / reflection based generator.
- [[https://code.google.com/p/emf4cpp/][EMF4CPP - Eclipse Modeling Framework]]: C++ port of the EMF/eCore
  eclipse framework. As with Java it includes run time support. There
  is also [[http://apps.nabbel.es/dsdm2010/download_files/dsdm2010_senac.pdf][a paper]] on it.
- [[http://www2.informatik.hu-berlin.de/~piefel/Documents/06CITSA-CMMCG.pdf][A Common Metamodel for Code Generation]]: Describes a meta-model
  designed to model Java and C++.
- [[http://marofra.com/oldhomepage/MetaCPlusPlusDoc/metacplusplus-1.html][The Meta-C++ User Manual]]: Another early C++ meta-modeling
  tool. Contains interesting ideas around C++ meta-models.
- The Columbus C++ Schema: Useful tool for re-engineering large C++
  code bases. Contains a meta-model for C++. A number of papers have
  been written about it:
  - [[http://www.inf.u-szeged.hu/~beszedes/research/tech27_ferenc_r.pdf][Columbus â€“ Reverse Engineering Tool and Schema for C++]]
  - [[http://journal.ub.tu-berlin.de/eceasst/article/download/10/19][Third Workshop on Software Evolution through Transformations]]:
    Embracing the Change
  - [[www.inf.u-szeged.hu/~ferenc/research/ferencr_schema.ppt.pdf][Towards a Standard Schema for C/C++]]
  - [[http://www.inf.u-szeged.hu/~ferenc/research/ferencr_columbus_schema_cpp.pdf][Data Exchange with the Columbus Schema for C++]]
